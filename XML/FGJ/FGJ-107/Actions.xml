<Action id="71724" issue="46801" author="bestbeforetoday" type="comment" created="2021-04-27 12:51:55.0" updateauthor="bestbeforetoday" updated="2021-04-27 12:51:55.0"> <body><! CDATA Record of prior conversation by email...  The main branch is the ongoing development branch so its content is more current than the release-2.2 branch. This is true for both fabric-sdk-java and fabric-gateway-java. The release-2.2 branch may contain more recent commits, such as release commits when a new release is published from that branch.  The main branch is where new function should be delivered and then cherry-picked back to release branches as appropriate. In general we don't want to regress functionality in later releases compared to older releases so to add new functionality to release-1.4 we would want to deliver it first in main, then cherry-pick back to both release-2.2 and release-1.4.  On the implementation, ideally it should be the choice of the client application whether they want to receive filtered or full (or with private data) block events so the Network.addBlockListener() method would either have an overload that allowed the event type to be specified, or there would be a parallel Network.addFilteredBlockListener() method to receive filtered rather than full blocks. This would provide a similar API to the Node SDK where listener options provided to Network.addBlockListener() allow the block type to be specified:   https://hyperledger.github.io/fabric-sdk-node/release-2.2/module-fabric-network.Network.html#addBlockListener   Unfortunately, as you've probably noticed, the low-level fabric-sdk-java eventing implementation has a one-to-one relationship between a Peer and a PeerEventServiceClient, and the PeerEventServiceClient receives either filtered or full blocks based on the PeerOptions. The API described above would make it possible for a client to simultaneously attach listeners for both filtered and full blocks, but the low-level implementation currently allows only one. This could be solved in a few different ways, although all of them are probably quite a bit of work.  The low-level eventing could be reworked to provide a cleaner mechanism for registering listeners for different event types. This would allow the event type to be specified on the call to Channel.registerBlockListener() and probably changing the one-to-one relationship between Peer and PeerEventServiceClient for the cleanest implementation.  You could do some trickery in the higher-level code to create a second version of the Peer configured for filtered eventing, similar to how event replay is handled by ReplayListenerSession, although this is really just a work-around to the limitations of the low-level eventing:   https://github.com/hyperledger/fabric-gateway-java/blob/8e8c2a8d34aca5357119caf5fea47088f5e203ca/src/main/java/org/hyperledger/fabric/gateway/impl/event/ReplayListenerSession.java#L37   I think that, while changing the NetworkConfig implementation and having a global flag in the high level API to toggle filtered and full blocks is a simpler approach, this is definitely not the ideal solution. Remember also that the NetworkConfig often only populates a subset of the network nodes as typically the connection profile will only contain a "bootstrap" set of network nodes and then service discovery is used at runtime to locate all nodes.  ></body> </Action>
