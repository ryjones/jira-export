<Action id="55746" issue="36828" author="gennadyl" type="comment" created="2019-01-17 09:14:41.0" updateauthor="gennadyl" updated="2019-01-17 09:16:26.0"> <body><! CDATA We can look into Spring Data implementation of java client side: https://github.com/IBM-Blockchain/fabric-spring-sdk/ It takes little bit different approach, but both can be integrated together.    ></body> </Action>
<Action id="55918" issue="36828" author="rickr" type="comment" created="2019-01-21 14:31:18.0" updateauthor="rickr" updated="2019-01-21 14:31:18.0"> <body><! CDATA Please open a separate project both in gerrit and in Jira for this work.  Thanks   ></body> </Action>
<Action id="56759" issue="36828" author="bestbeforetoday" type="comment" created="2019-02-07 15:41:52.0" updateauthor="bestbeforetoday" updated="2019-02-07 15:41:52.0"> <body><! CDATA I caught a few key comments during the playback, listed below with my personal thoughts on each for discussion (in {color:#00875a}green{color}): # {color:#0747a6}Not keen on providing wallets. Prefer to let application code decide how to manage their credentials rather than take on burden of maintaining our own wallet code.{color} ** {color:#00875a}Fair concern. As I understand it, the aim is to provide some out-of-the-box implementations to accelerate adoption while still allowing application code to manage credentials themselves if they prefer. I am not hearing any argument against this.{color} # {color:#0747a6}Prefer to have submitTransaction() return a Future that the caller can decide to wait for or use later. Easier for application to work in a non-blocking mode if required.{color} ** {color:#00875a}Fair comment, and either could work. submitTransaction() encapsulates both Channel.sendProposal() and Channel.sendTransaction(). The former is a synchronous blocking call in the existing API, so there is not consistency of sync vs. async there today. It should be relatively straightforward for client code to invoke submitTransaction() asynchronously using CompletableFuture.supplyAsync(), and this also allows the client to control thread management if they desire. So having submitTransaction() as a blocking call may provide a simpler starting point (no need to worry about futures) while also allowing greater control if needed. What do you think?{color} # {color:#0747a6}Want new API in a separate JAR from low-level API. Concern about overhead of additional code and dependencies for users of only the low-level API.{color} ** {color:#00875a}A few KB of additional class files will live in the JAR on disk, but will not be loaded unless the application code makes use of them. Any dependencies (of which there are currently none) would never live in the same JAR and would not even need to be present unless the application code made use of capabilities that required them. Having multiple JARs that need to be kept in version sync certainly makes the user's life more complex. I do not understand this concern.{color}  ></body> </Action>
