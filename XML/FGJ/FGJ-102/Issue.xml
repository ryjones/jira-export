<Issue id="46520" key="FGJ-102" number="102" project="11000" reporter="conanoc" creator="conanoc" type="10004" summary="Contract.submitTransaction() does not wait for commit" priority="3" resolution="10203" status="6" created="2021-01-28 09:08:04.0" updated="2021-02-10 02:22:00.0" resolutiondate="2021-02-09 10:16:36.0" votes="0" watches="2" workflowId="60463" archived="N"> <description><! CDATA Test env:  fabric-gateway-java version: 1.4.5  chaincode: Fabcar  submitTransaction() usually wait for commit and it took about 2s in my test env.    {code:java} contract.submitTransaction("createCar", carNumber, "VW", "Polo", "Grey", randomOwner) {code}       Problem:  Create 10 thread and call submitTransaction() on each thread, then it does not wait for commit.  It took only 200ms for submitTransaction() return.  9 thread does not show this behavior. It start after 10 thread. Is there any magic number for the concurrent call of submitTransaction() ?     Test code snippet:    {code:java} Gateway.Builder builder = Gateway.createBuilder(); builder.identity(wallet, userId).networkConfig(networkConfigPath).discovery(true);  // create a gateway connection Gateway gateway = builder.connect();  // get the network and contract Network network = gateway.getNetwork("defaultchannel"); Contract contract = network.getContract("fabcar");  ExecutorService executor = Executors.newFixedThreadPool(threadCount); List<Callable<Object>> transactions = new ArrayList<>(); for (int i = 0; i < threadCount; i++) { transactions.add(new WriteTx(i * requestCount, contract)); }  System.out.println("Start write tx ..."); long start = System.currentTimeMillis(); executor.invokeAll(transactions); long end = System.currentTimeMillis(); System.out.println("Write tx finished."); System.out.println(threadCount * requestCount + " tx in " + (end - start) + "ms"); {code}      {code:java} public static class WriteTx implements Callable<Object> { int startIndex; Contract contract;  public WriteTx(int startIndex, Contract contract) { this.startIndex = startIndex; this.contract = contract; }  @Override public Object call() { String randomOwner = "Owner" + new Random().nextInt(1000); for (int i=0; i < requestCount; i++) { String carNumber = "CAR" + (startIndex + i); try { byte    result = contract.submitTransaction("createCar", carNumber, "VW", "Polo", "Grey", randomOwner); String(result)); } catch(Exception e) { System.out.println(carNumber + " failed with error: " + e.getMessage()); } }  return null; } } {code}       ></description> </Issue>
