<Action id="72005" issue="46868" author="davidkhala" type="comment" created="2021-07-28 12:36:21.0" updateauthor="davidkhala" updated="2021-07-28 12:36:21.0"> <body><! CDATA Dear Mark,   For gateway, is it limited to ChaincodeListener? Do we also count tx listener or block listener in?   ></body> </Action>
<Action id="72007" issue="46868" author="bestbeforetoday" type="comment" created="2021-07-29 09:01:19.0" updateauthor="bestbeforetoday" updated="2021-07-29 09:01:19.0"> <body><! CDATA Hi  ~davidkhala ,  This story is certainly only dealing with chaincode event listening, and the implementation that has been added today I would definitely view as beta, so feedback from the community on how the API currently looks and how it should evolve would be very welcome. Two things I have particularly been trying to consider are:  1. Offloading work in retrieving the required events to the Fabric Gateway server, and having only those events returned rather than the client always having to receive and process entire block events. 2. Giving the client more control of the rate they receive (and if/how they parallelise) events, to avoid issues that can occur with some of the existing SDKs where it is possible for the client to be overwhelmed by the volume of events received, using excessive memory and/or filling buffers and potentially causing client crashes.  Right now the API looks like: {code:go} // ChaincodeEvents returns a channel from which chaincode events emitted by transaction functions in the specified // chaincode can be read. func (network *Network) ChaincodeEvents(ctx context.Context, chaincodeID string) (<-chan *ChaincodeEvent, error) {code} {code:javascript} /** * Get chaincode events emitted by transaction functions of a specific chaincode. * @param chaincodeId - A chaincode ID. * @param callback - Event callback function. */ onChaincodeEvent(chaincodeId: string, callback: ChaincodeEventCallback): Promise<void>;  /** * Get chaincode events emitted by transaction functions of a specific chaincode. * @param chaincodeId - A chaincode ID. * @returns Chaincode events. * @example * ``` * const events = await network.getChaincodeEvents(chaincodeId); * for async (const event of events) { *     // Process event * } * ``` */ getChaincodeEvents(chaincodeId: string): Promise<AsyncIterable<ChaincodeEvent>> {code} {code:java} /** * Get events emitted by transaction functions of a specific chaincode. Note that the returned {@link Iterator} may * throw {@link io.grpc.StatusRuntimeException} during iteration if a gRPC connection error occurs. * @param chaincodeId A chaincode ID. * @return Ordered sequence of events. */ Iterator<ChaincodeEvent> getChaincodeEvents(String chaincodeId); {code} There has been a requirement mentioned to support listening for all transaction commits directly, without the overhead of having to receive full block events, so I expect this will appear at some point once chaincode event listening is more complete.  There is certainly no technical reason why we couldnâ€™t also implement block listening. I am just trying to get to capabilities that support application business logic first, like chaincode event listening, whereas block listening typically seems to have more technical uses or just supports capabilities like chaincode event listening which we are now providing directly.  It would be good to understand key use cases you see for block listening outside of supporting transaction and chaincode event listening.  ></body> </Action>
