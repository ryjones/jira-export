<Issue id="22484" key="FABC-91" number="91" project="10607" reporter="smithbk" creator="smithbk" type="10002" summary="Support Role-Based Access Control (RBAC)" priority="3" status="3" created="2017-10-18 15:34:57.0" updated="2019-07-27 14:59:56.0" votes="3" watches="6" workflowId="32271"> <description><! CDATA Role-Based Access Control, or RBAC for short, must work with multiple types of identities: 1) x509 certificates issued by fabric CA and based on attributes 2) x509 certificates issued by a 3rd party CA 3) idemix credentials 4) others in the future  For both chaincode, we need a flexible and extensible mechanism which allows a single role to be defined which includes identities from multiple categories. For example, suppose we want to define an admin role which includes all of the following identities: 1) x509 certificates issued by a fabric-ca-server CA with an attribute named "admin" and a value of "true" 2) x509 certificates issued by a 3rd party CA with an OU hierarchy of "OU=adwin,OU=finance,O=org1" 3) idemix credentials with an attribute named "admin" and a value of "true"  From a configuration perspective, this is represented as a boolean expression similar to the following: {code:java} "attr('admin') == 'true' || dn =~ '.*,OU=admin,OU=finance,O=org1,.*" {code} which reads as "attribute 'admin' equals 'true' OR distinquished name matches the regular expression pattern denoting OU=admin,OU=finance,O=org1. The 'attr' function knows how to retrieve an attribute from identities of type #1 and #3 above. The part of the expression after the OR includes identities of type #2.  The mapping of a role name to a boolean expression may be assigned to a deployer, while the decision of which roles are needed and where to check these roles is a developer's job. This is helpful and allows the same code to be deployed multiple times with different role semantics, depending on the needs.  The boolean expression language is built on top of govaluate to prevent from having to reinvent the wheel.  A RBAC library API is as follows, where *expression* is an expression of the form described above. {code:java} // Mgr is an RBAC manager type Mgr interface {  	// AddRole adds a role to the RBAC manager 	AddRole(roleName, expression string) error  	// HasRole determines if 'identity' has role 'roleName' 	HasRole(identity *langid.Identity, roleName string) (bool, error) }  // Identity represents an arbitrary identity type Identity struct { 	// MSPType is the MSP type associated with this identity 	MSPType string 	// MSPID is the MSP ID associated with this identity. 	MSPID string 	// Object is an object that is specific to the MSP type. 	// If MSPType is X509, this is of type *x509.Certificate. 	Object interface{} } {code} ----------------- Some additional thoughts ------------- Roles may not be the correct way to view this from a chaincode API perspective. For example, the well-known idemix example is that chaincode may want to verify that the user is >= 21 years old. The current mechanism proposed above would require that the actual age be put in the ecert as an attribute and the chaincode would manually verify that it is >= 21, thus revealing the actual age to chaincode. However, it would be possible for the user to send an expression similar to: {code:java} attr('age') >= 21 {code} in an enrollment request. The expression is evaluated by fabric-ca-server, and the expression and result are placed in the ecert, thus not revealing the actual age. The chaincode then accesses the key being the expression, and verifies that the value is true.  Looking at this another way, there are 3 actors to consider in the flow: the CA (fabric-ca-server), the user (e.g. an SDK), and chaincode. The question is, where do we create the boolean expression which is to be evaluated by chaincode. 1) Create the expression in chaincode. This is fine, but it reveals the actual attribute values to chaincode. 2) The user creates the expression. This is what idemix does (the expression is called "presentation policy"), and binds it to the CA by creating a zero-knowledge proof which chaincode can verify. 3) The user requests the CA to create the expression and put it into the certificate before signing. This is what I mentioned above that could be done.  In both cases 2 and 3, it seems that rather than having an RBAC API for chaincode as presented above, we should have one in which the key for chaincode is an expression rather than a role name. Maybe we could call this EBAC (Expression-Based Access Control). So basically, the chaincode would call this API similar to: {code:java} if ebac.Satisfies("attr('age') >= 21") { } {code} This does mean that either the user needs to be aware of which expressions/conditions the chaincode will require so that it could include it in its certificate or credential. Or it would be better if there is some recommended best practice so that this prior knowledge is not required. Two options are:  a) Expose an API on the chaincode to return all expressions/conditions requested by the chaincode. The advantage of this is that multiple conditions could be discovered all at once and put into a single certificate/credential. The disadvantage is that you may not need all (or any) of them, depending on which operation and code path is taken through the chaincode.  b) Another option is to have a standard error format which includes the expression/condition which was not found in the certificate/credential. The user application could capture this error and then reissue the request with a new certificate/credential which includes the expression/condition. For example, an application invokes chaincode which returns an error including the "attr('age') >= 21" condition which failed. The user application captures this error and automatically gets another certificate with this condition and its result (assuming it is true) ... or generates a new idemix proof for the condition ... and then reissues the request to chaincode.  ></description> </Issue>
