<Action id="20195" issue="13779" author="ashutosh_kumar" type="comment" body="FAB 1478 blocks this FAB , which cannot be contained in Sprint 8 , hence moving it to Sprint 9." created="2016-12-23 21:22:50.0" updateauthor="ashutosh_kumar" updated="2016-12-23 21:22:50.0"/>
<Action id="20234" issue="13779" author="ashutosh_kumar" type="comment" created="2016-12-30 20:47:38.0" updateauthor="ashutosh_kumar" updated="2017-01-05 16:00:59.0"> <body><! CDATA TCert option 1 is what has been done on Fabric 0.6. The API name in GetBatch. Hardware HSM does not support this mechanism and hence Zuric Research team came up with another mechanism where key derivation is not required.   To circumvent Hardware HSM support limitation with option 1 , different TCert generation mechanisms has been proposed as described in the attached document. Option 1 in the attached document is what has been implemented in Fabric 0.6.  CoP , aka , Membership Services team has decided to support option 1 (carrying it over from Fab 0.6) and option 2. This FAB is an attempt to implement option 2.  In option 1 , TCerts are being computed from ECERT and ECert has to be ECDSA based.  In option 2 , TCerts has no dependency on ECerts. Following is the flow :   *Client side* :  1) Client generates batch of private/public Key key pair. These public key represents public keys for TCerts.The batch of public generated will sent to CoP to obtain CoP signed certififcate.  2) Client signs the request with all private key for corresponding Public Key that was generated in step 1. Client must also specify the hash algorithm that has been used to compute signature. So , if client wants 2 tcerts , it'll generate 2 key pair and sign the same request message twice with two different keys. It keeps public key and signature in a struct , so that those can be associated. 3) Client then creates token and signs it using private key corresponding to ECert.  CoP Server Side :  It is assumed that BCCSP has been instantiated on CoP Server prior to CoP Server producing TCerts. This is applicable to TCert option #1 as well as option #2. 1) CoP server validate the token using ECert.  2) TCert processor of CoP validates each signauture block using CoP Server BCCSP instance and reading hash algorithm from the request. 3) If any of the signature validation fails , it send error back to client , otherwise , it moves to step 4 4) CoP TCert processor signs the certificate using the CoP CA key and cert and sets the certificate validity period based on user supplied value. If the user requested validity period in the request , it'll be compared against server's default Certificate Validity period. If user supplied validity period is smaller the server default value , the Certificate validity period is set to user requested validity period. Optionally TCert can contain user attributes which optionally can be encrypted.  User have choice to either choose between GetBatch() and GetBatchForGeneratedKey() for TCert option 1 and option 2 respectively. He/she does not have influence on how these APIs are implemented. This fab implements GetBatchForGeneratedKey().  EnrollenmentId computed out of ECERT subject name was used as certificate extension in FAB 0.6 for TCert #1 implementation for linkability perspective , AFAIK. For TCert option #2 , we are not planning on doing that and hence toggle is being set for generating extension for TCert option 1 or option 2.     ></body> </Action>
<Action id="42325" issue="13779" author="skarim" type="comment" body="Closing out, TCerts will no longer be implemented" created="2018-03-29 15:08:01.0" updateauthor="skarim" updated="2018-03-29 15:08:01.0"/>
