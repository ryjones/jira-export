<Action id="21719" issue="15496" author="rennman" type="comment" body="Note that I acknowledge that there may be other solutions; I&apos;m not lobbying for any fix in particular, just registering my observations about the most expedient." created="2017-03-29 14:18:40.0" updateauthor="rennman" updated="2017-03-29 14:18:40.0"/>
<Action id="23328" issue="15496" author="smithbk" type="comment" body="From reading https://tschottdorf.github.io/golang-static-linking-bug, I didn&apos;t see any other solution.  Did I miss it?  In particular, they said the underlying problem in glibc was unlikely to ever be fixed and should not use static linking." created="2017-05-03 11:59:52.0" updateauthor="smithbk" updated="2017-05-03 11:59:52.0"/>
<Action id="23338" issue="15496" author="rennman" type="comment" body="I don&apos;t know if there are any *existing* solutions, I&apos;m just guessing there may be other *potential* solutions.  I had a brief chat with Jonathan around the time I opened this, and he did not agree with using dynamic linking, so ... ? I&apos;m not sure where that leaves us." created="2017-05-03 14:46:36.0" updateauthor="rennman" updated="2017-05-03 14:46:36.0"/>
<Action id="23378" issue="15496" author="smithbk" type="comment" created="2017-05-04 15:17:04.0" updateauthor="smithbk" updated="2017-05-04 15:17:37.0"> <body><! CDATA From reading https://tschottdorf.github.io/golang-static-linking-bug, I only see two solutions: 1) musl libc which would be risky given that it is at version 1.0.0.   See http://www.musl-libc.org/manual.html 2) dynamic linking  See this section in particular at the end of the article  {code} Summing up a comment by Carlos O’Donell, the bug is likely to live forever and hard to fix; while you can link statically against glibc, it’s really nothing you should ever find yourself doing. At least not if you’re using threads. Conclusion  Linking statically against glibc has proven to be an insane idea, but it’s surprising that this was apparently news for everyone up to (but not including) the glibc bug tracker.  We figured out that we can get a less obviously ludicrous static build by substituting glibc for musl-libc, but that needs careful benchmarking and testing (in particular, we instantly had issues with the DNS resolver).  At the end of the day, we decided that there were only diminishing returns to be had by linking a completely static binary. What really matters to us is not having non-standard dependencies - having glibc available is a bit of a drag when deploying on minimal systems (think containers) but is otherwise standard. So, at least for the time being, we’ll distributed an image that only links against glibc dynamically.  In a recent post about the cost and complexity of cgo we warned that cgo comes with a more intricate build process and the occasional need to take debugging beyond the realms Go. This bug sure goes out of its way to prove these points. {code}  ></body> </Action>
<Action id="23438" issue="15496" author="mastersingh24" type="comment" created="2017-05-06 10:46:32.0" updateauthor="mastersingh24" updated="2017-05-06 10:46:32.0"> <body><! CDATA Does this only happen with Postgres? The static binaries are also a problem when doing PKCS11 according to some work  ~vpaprots@ca.ibm.com  has done as well.   ~greg.haskins  preference has been to continue publishing static binaries as the default and then require people to build dynamically linked binaries / images themselves for a variety of reasons but mainly to ensure we can decouple the binaries from the underlying baseos used in our images.  I tend to agree that the default should continue to build with the -static flag (minimally to stay consistent with the core fabric images).  The in between solution would be to add support for an environment variable in the Makefile to allow building non-static binaries but may want to hold off on that for now and just document what is needed for Postgres TLS support    ></body> </Action>
<Action id="23500" issue="15496" author="greg.haskins" type="comment" created="2017-05-07 02:31:46.0" updateauthor="greg.haskins" updated="2017-05-07 02:31:46.0"> <body><! CDATA A few points of clarity on my position.    1) -static is currently a critical component of our two-phased docker build because we build the binary in one container and inject the result into another (minimal) container.  Doing this with -dynamic _may_ work today because of a design decision we made, but it's not always guaranteed to work because doing so makes assumptions about the minimal runtime environment that may or may not be true in the future.  For instance, if someone were to re-add rocksdb, only -static would include rocksdb in the ELF without carefully coordinating the runtime container.  If we are facing an insurmountable issue because of -static, we will need to revisit this design, but we will need to do so in the context of the full stack impact w.r.t. two-phasing the build.  2) It's not that I think people should build -dynamic binaries themselves.  Merely, I think docker containers are a poor fit for the PKCS11/HSM conversation.  Since I think they are a poor fit, I didn't want to see -static turned off for that reason alone (due to point (1)).  What I was suggesting is that a better fit for HSM is native packaging (RPM/DEB/BREW), which incidentally is also a better fit for -dynamic.  In that model, I can, for example, foresee an RPM spec file that pulls in libtool, turns on pkcs11 support, and links dynamically in a manner that is not just compatible with PKCS11, it's how it was precisely designed to work.   ></body> </Action>
<Action id="23501" issue="15496" author="greg.haskins" type="comment" body="I should also add, my preference here would be to run the entire container chain on &quot;FROM alpine&quot;, which would imply musl and thus not glibc, thereby eliminating the problems noted.  However, the challenge there is that we also need to support the ppc64le/s390x architectures.  Therefore, the current implementation uses ubuntu/deb and the default glibc, apparent warts and all.  Alternatives to finding a multi-arch Alpine could include linking against the musl-dev packages available on those platforms, dropping two-phased build, or just coordinating the baseos with all needs going forward (note that it&apos;s consumed in multiple projects at this point, so it needs to be a super-set or made more granular)." created="2017-05-07 02:42:56.0" updateauthor="greg.haskins" updated="2017-05-07 02:42:56.0"/>
<Action id="23539" issue="15496" author="smithbk" type="comment" created="2017-05-08 15:40:32.0" updateauthor="smithbk" updated="2017-05-08 15:40:32.0"> <body><! CDATA Greg, do you know that musl is stable?  I see that it is only at version 1.0.0. Is there no way to dynamically link only libc with go, but continue to statically link everything else? I see the -static-libgo option to statically link the go packages.  Assuming this is the only granularity of control over linking that we get with go, then what about using -static-libgo and then your last option for non-go dependencies ("coordinating the baseos will all needs going forward)?  Or as Gari said, just add a build option.  ></body> </Action>
<Action id="24312" issue="15496" author="smithbk" type="comment" body="Unless I hear otherwise, for v1 I&apos;m going to pursue the Makefile option which Gari suggested, and then document how to build for Postgres with TLS support.   Pls speak up if you disagree." created="2017-05-25 13:02:34.0" updateauthor="smithbk" updated="2017-05-25 13:02:34.0"/>
<Action id="24315" issue="15496" author="greg.haskins" type="comment" body="Hi Keith, That&apos;s probably fine. I can review the CR once it is complete." created="2017-05-25 13:05:33.0" updateauthor="greg.haskins" updated="2017-05-25 13:05:33.0"/>
<Action id="24345" issue="15496" author="smithbk" type="comment" body="See http://gerrit.hyperledger.org/r/9805" created="2017-05-25 16:04:44.0" updateauthor="smithbk" updated="2017-05-25 16:04:44.0"/>
<Action id="30462" issue="15496" author="rennman" type="comment" created="2017-09-01 18:21:07.0" updateauthor="rennman" updated="2017-09-01 18:48:39.0"> <body><! CDATA Firstly, the recommended fix to "set the FABRIC_CA_DYNAMIC_LINK environment variable" isn't working. This is because the hyperledger/fabric-baseos image is missing some libraries.  Secondly, although this is definitely related to the postgres driver, it is not exclusively a problem with TLS, in which case the doc _could_ be updated to reflect this. The affected code comes from the pq driver in  ./vendor/github.com/lib/pq/conn.go, which calls user.Current(), which ultimately calls  lookupUnixUid(syscall.Getuid()) -->    return syscall.Errno(C.mygetpwuid_r(C.int(uid), &pwd, (*C.char)(buf.ptr), C.size_t(buf.size), &result))  which is the call that precedes the panic.  There are two places where user.Current() is called in ./vendor/github.com/lib/pq/conn.go: 1) attempting to set the auth credentials for the postgress db in handlePgpass()  2) setting up TLS in setupSSLClientCertificates()     To recreate the problem:  1) unset FABRIC_CA_DYNAMIC_LINK  2) make docker-clean  3) make docker  4) Delete the database: {code:java}     /usr/bin/dropdb "fabric_ca" -U postgres -h localhost -w{code} 5) Start the server: {code:java} docker run -e PGUSER=postgres \    -ti hyperledger/fabric-ca:x86_64-1.0.1-snapshot-5a5b061 \ /usr/local/bin/fabric-ca-server start b admin:adminpw -d \ --db.datasource "dbname=fabric_ca host=172.17.0.1 port=5432" \ --db.type postgres ... fatal error: unexpected signal during runtime execution  signal SIGSEGV: segmentation violation code=0x1 addr=0xe5 pc=0x7f2b54b883f8   runtime stack: runtime.throw(0xbd3feb, 0x2a) /opt/go/src/runtime/panic.go:566 +0x95 runtime.sigpanic() /opt/go/src/runtime/sigpanic_unix.go:12 +0x2cc  goroutine 1  syscall, locked to thread : runtime.cgocall(0x9c5920, 0xc4203b89c0, 0x0) /opt/go/src/runtime/cgocall.go:131 +0x110 fp=0xc4203b8970 sp=0xc4203b8930 os/user._Cfunc_mygetpwuid_r(0x0, 0xc42039b020, 0x7f2b480008c0, 0x400, 0xc42018e350, 0x0) ??:0 +0x4d fp=0xc4203b89c0 sp=0xc4203b8970 os/user.lookupUnixUid.func1(0x42eb52) /opt/go/src/os/user/lookup_unix.go:103 +0x1f7 fp=0xc4203b8a50 sp=0xc4203b89c0  {code}    After implementing the solution:  export FABRIC_CA_DYNAMIC_LINK=true  make docker {code:java} docker run -e PGUSER=postgres -ti hyperledger/fabric-ca:x86_64-1.0.1-snapshot-5a5b061 /usr/local/bin/fabric-ca-server start --db.datasource "dbname=fabric_ca host=172.17.0.1 port=5432" --db.type postgres -b admin:adminpw -d /usr/local/bin/fabric-ca-server: error while loading shared libraries: libltdl.so.7: cannot open shared object file: No such file or directory{code}    ></body> </Action>
<Action id="30463" issue="15496" author="rennman" type="comment" created="2017-09-01 19:39:13.0" updateauthor="rennman" updated="2017-09-01 19:58:41.0"> <body><! CDATA In the meantime, after looking at the conn.co code, it appears that there may be a much simpler work-around for now:  #1 do not rely on the ~/.pgpass mechanism. Either     a )always set the user:password in the connection string, or    b )set *both* the PGUSER and PGPASSWORD environment variables #2) alway set the PGSSLCERT and PGSSLKEY environment variables, even if they are not used, e.g. {code:java}     PGSSLCERT=dummy     PGSSLKEY=dummy{code} will work, as long are they are *not null*. The code in setupSSLClientCertificates() in ./vendor/github.com/lib/pq/conn.go does not call user.Current() if these are set. Of course if TLS is _actually_ being used, then the files pointed to by PGSSLCERT and PGSSLKEY *must* exist.      This solution does not require the exec to be re-built.  ></body> </Action>
