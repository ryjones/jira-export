<Action id="71187" issue="46438" author="JIRAUSER21282" type="comment" created="2021-01-11 16:27:50.0" updateauthor="JIRAUSER21282" updated="2021-01-11 16:41:59.0"> <body><! CDATA When I use the Java wrapper ( <version>1.15.0</version> ), I get the same error on Ubuntu 20.04 when I call proverCreateProof . This always happens when I use the schemaId, schemaJson and CredDefId, credDefJson from the ledger (i.e. Ledger.signAndSubmitRequest and then do get request and subsequently do a "parseGetSchemaResponse" and do a get request and do a "parseGetCredDefResponse").  org.hyperledger.indy.sdk.InvalidStructureException: A value being processed is not valid  One observation I had was that in the credDef Json the "schemaId" has the schema "seqNo" and not the actual "schemaId" (if this info. helps)     ></body> </Action>
<Action id="71205" issue="46438" author="JIRAUSER21212" type="comment" body="I had indeed noticed the presence of the NoSeq in the Json credDef. I tried to replace it just before the call to  indy_prover_create_proof with the right schemaId to do a test but without success. Personally, I was wondering if the bug was present just when checking a connectionless proof (this is my case). But I don&apos;t know if this is also the test you did? Will this bug be looked at by someone?" created="2021-01-12 12:54:02.0" updateauthor="JIRAUSER21212" updated="2021-01-12 12:54:02.0"/>
<Action id="71267" issue="46438" author="JIRAUSER21282" type="comment" body="I too tried the same but without success. I guess we will have to wait for someone from the development team to comment if they would be looking at it." created="2021-01-13 11:44:39.0" updateauthor="JIRAUSER21282" updated="2021-01-13 11:45:39.0"/>
<Action id="71275" issue="46438" author="JIRAUSER21212" type="comment" created="2021-01-14 13:20:30.0" updateauthor="JIRAUSER21212" updated="2021-01-14 13:20:30.0"> <body><! CDATA I discovered that I could activate the logging of the libindy. Here are the last traces just before the crash:  ...  TRACE|indy::services::anoncreds::prover| src\services\anoncreds\prover.rs:212 | _prepare_credentials_for_proving >>> requested_credentials: RequestedCredentials \{ self_attested_attributes: {}, requested_attributes: \{"email": RequestedAttribute { cred_id: "d3ca7e99-0ff8-4d72-967a-821dd0e14d7e", timestamp: None, revealed: true }, "first_name": RequestedAttribute \{ cred_id: "d3ca7e99-0ff8-4d72-967a-821dd0e14d7e", timestamp: None, revealed: true }, "username": RequestedAttribute \{ cred_id: "d3ca7e99-0ff8-4d72-967a-821dd0e14d7e", timestamp: None, revealed: true }, "last_name": RequestedAttribute \{ cred_id: "d3ca7e99-0ff8-4d72-967a-821dd0e14d7e", timestamp: None, revealed: true }}, requested_predicates: {} }, proof_req: ProofRequestPayload \{ nonce: BigNumber { openssl_bn: 960840690959336350186628 }, name: "Basic Proof", version: "1.0", requested_attributes: \{"a7ef4839-04f7-4525-92e0-79354cb30eee": AttributeInfo { name: Some("last_name"), names: None, restrictions: Some(Or( Eq("cred_def_id", "XpHQgyg7Dd4WerGtGCL3KN:3:CL:1614:vc-authn-oidc") )), non_revoked: None }, "a67d9ec5-c421-414e-8129-fdf09befb61d": AttributeInfo \{ name: Some("first_name"), names: None, restrictions: Some(Or( Eq("cred_def_id", "XpHQgyg7Dd4WerGtGCL3KN:3:CL:1614:vc-authn-oidc") )), non_revoked: None }, "f1c2c233-1785-410e-96b3-6c826df1ce94": AttributeInfo \{ name: Some("email"), names: None, restrictions: Some(Or( Eq("cred_def_id", "XpHQgyg7Dd4WerGtGCL3KN:3:CL:1614:vc-authn-oidc") )), non_revoked: None }, "aed1e027-67dd-466a-85ef-d8fdf1b2fa93": AttributeInfo \{ name: Some("username"), names: None, restrictions: Some(Or( Eq("cred_def_id", "XpHQgyg7Dd4WerGtGCL3KN:3:CL:1614:vc-authn-oidc") )), non_revoked: None }}, requested_predicates: {}, non_revoked: None }  TRACE|indy::api::anoncreds | src\api\anoncreds.rs:2056| prepare_result_1: >>> Err(IndyError \{ inner:AttributeInfo not found in ProofRequest for referent "email" Invalid structure })   TRACE|indy::api::anoncreds | src\api\anoncreds.rs:2056| indy_prover_create_proof: result: ""     In the libindy source code, prover.rs:  pub fn _prepare_credentials_for_proving(requested_credentials: &RequestedCredentials, proof_req: &ProofRequestPayload) -> IndyResult<HashMap<ProvingCredentialKey, (Vec<RequestedAttributeInfo>, Vec<RequestedPredicateInfo>)>> { trace!("_prepare_credentials_for_proving >>> requested_credentials: \{:?}, proof_req: \{:?}", requested_credentials, proof_req);  let mut credentials_for_proving: HashMap<ProvingCredentialKey, (Vec<RequestedAttributeInfo>, Vec<RequestedPredicateInfo>)> = HashMap::new();  for (attr_referent, requested_attr) in requested_credentials.requested_attributes.iter() { let attr_info = proof_req.requested_attributes .get(attr_referent.as_str()) .ok_or_else(|| err_msg(IndyErrorKind::InvalidStructure, format!("AttributeInfo not found in ProofRequest for referent \"{}\"", attr_referent.as_str())))?;  ></body> </Action>
