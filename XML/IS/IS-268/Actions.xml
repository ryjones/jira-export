<Action id="29721" issue="20030" author="douglaswightman" type="comment" body=" ~gudkov  would love comments on this approach.  If done this way I think we can avoid changes to any of the wrappers.  Do you agree?" created="2017-08-11 14:00:56.0" updateauthor="douglaswightman" updated="2017-08-11 14:00:56.0"/>
<Action id="29803" issue="20030" author="gudkov" type="comment" created="2017-08-14 12:30:43.0" updateauthor="gudkov" updated="2017-08-14 12:30:43.0"> <body><! CDATA  ~DouglasWightman   Thank you, we will review your proposal ASAP.  ></body> </Action>
<Action id="29882" issue="20030" author="douglaswightman" type="comment" created="2017-08-16 01:41:19.0" updateauthor="douglaswightman" updated="2017-08-16 01:41:19.0"> <body><! CDATA As I understand it, the long term goal is to have agents communicating using a REST API rather than CurveZMQ.  Using a REST API would allow easier integration with other systems and faster approvals in mobile app stores.  This, however, would require certificates chained to a root CA.  To get around this, and to create a truly self-sovereign, verifiable and secure communication mechanism we want to begin implementation of DID-TLS (as opposed to SSL-TLS).  Ideally we could enhance openssl to use DIDs from the sovrin network but that work is long-term and out of scope for the delivery of the enterprise agent.  So the short-term goal is to begin extending libindy in this direction, in phases that keeps things functional while moving towards the ultimate goal.  The work outlined in this ticket steps us away from CurveZMQ towards a more standard SSL implementation (over raw sockets).  The next phase would be to add a REST API on top of this work.  Eventually, when DID-TLS is part of openssl, we simply remove our custom code and use that.  ></body> </Action>
<Action id="29887" issue="20030" author="gudkov" type="comment" created="2017-08-16 06:01:26.0" updateauthor="gudkov" updated="2017-08-16 06:32:10.0"> <body><! CDATA  ~DouglasWightman   ~danielhardman   ~nage   I suggest defining what problem we want to solve more precisely. Not sure we have "short-term" and "long-term" plans. Also, the idea of deprecation previous phases doesn't look great for me. In my opinion, we need the following:  1. Sovrin requires communication infrastructure that will allow applications to find, authorize and communicate each other with using of Sovrin identities. This infrastructure should provide the following services: - Endpoint resolving (some kind of DNS) - Client authorization by Server - Server authorization by Client - Encryption - Integrity  2. It must be relatively easy to integrate this communication infrastructure to the most of the existing network applications and create new applications based on modern frameworks and approaches.  3. The solution must be practical. We plan to release first set applications in a couple of months. So solutions like waiting of including of our proposal to new TLS standard and all popular TLS implementations can't be accepted.  4. The solution must be flexible. Indy projects are under active development and communication must be under our control as much as possible and ready to integrate any crypto or workflow changes. For example, current CureveZMQ based communication relies on the transport level a lot and we see potential problem that introducing of additional encryption (HDKeys) will break this communication  5. One ip:port combination should allow handling of endpoints for multiple identities.  We can consider the following use case as a short-term example: 1. We have JVM/Scala/Akka/Akka-http application that implements agency-like scenario. it already implements some custom REST interface. This application should communicate with other agencies and end-user mobile apps. 2. We have a mobile app based on a hybrid framework. It already communicates with the agency by using custom REST interface through javascript http API.  So we need to switch this apps to use our generic communication infrastructure in a few month.  ></body> </Action>
<Action id="29888" issue="20030" author="gudkov" type="comment" created="2017-08-16 07:03:20.0" updateauthor="gudkov" updated="2017-08-16 07:03:20.0"> <body><! CDATA I suggest defining the scope of our first phase as solving of this akka-http/hybrid mobile app communication use case. I am a bit afraid that this transport level encryption proposal can solve this communication problem at all:  1. Java and iOS/Android web/network frameworks use native platform TLS implementation and just availability of custom/updated libssl doesn't provide the easy way to integrate it. 2. Dynamic management of certificates is tricky. On the most of the client platforms, there is no adequate way to manage client certificates. 3. Sovrin way of names resolving seems hard to be implemented on the transport layer.  I start thinking about implementing this security on application level. it can be shorter way to solve our problems.  ></body> </Action>
<Action id="30148" issue="20030" author="gudkov" type="comment" created="2017-08-24 11:33:55.0" updateauthor="gudkov" updated="2017-08-24 11:33:55.0"> <body><! CDATA If we decide that DID-TLS way is too risky. We can try to move the following way:  1. Use TLS or CurveCP (not CurveCP-PW) protocols on transport layer the way they were designed without any modifications. It will allow to get authenticate endpoint (not identity) and be sure about security and integrity. 2. Define DID Protocol that will allow Client and Server DIDs authentication and nonce exchange as simple well-defined messages exchange in Req/Resp style that will be performed after handshake on sockets or http layer.  3. After DID Protocol messages exchange is finished agents will exchange ed25519-encrypted messages. Encryption can be optional. For some use cases client and server can agree to use only transport layer encryption.  I created diagram that illustrates protocol that i imagine and attached it. Note that it illustrates CurveCP on protocol layer and socket-level communication, but this idea is compatible with TLS and http too (see notes).  ></body> </Action>
