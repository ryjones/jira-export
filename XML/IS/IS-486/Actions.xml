<Action id="37092" issue="25718" author="danielhardman" type="comment" created="2017-12-14 14:09:59.0" updateauthor="danielhardman" updated="2017-12-14 14:09:59.0"> <body><! CDATA Stephen: This is a great line of thinking. I love it.  I have recently been thinking about a proof constraint language. I imagined this is how a verifier would filter, and I've been thinking of it like SQL WHERE clauses: Prove street_address as sa WHERE sa.claimdef.issuer in  a, b, c  AND sa.issue_date > 2015-01-01 AND...  I'm not especially advocating for what I was imagining–just noting an intriguing overlap.  ></body> </Action>
<Action id="37115" issue="25718" author="theruss" type="comment" body="How are claims &quot;physically&quot; stored in a wallet? Could storage be (re) implemented as SQLLite (for example) thus making it queryable in exactly the manner  ~danielhardman  suggest? Just an idea.." created="2017-12-14 22:25:08.0" updateauthor="theruss" updated="2017-12-14 22:25:08.0"/>
<Action id="37697" issue="25718" author="swcurran" type="comment" created="2017-12-21 00:38:26.0" updateauthor="swcurran" updated="2017-12-21 00:38:26.0"> <body><! CDATA  ~theruss  - libindy has a default wallet implementation using an encrypted version of SQLLite (SQLCipher), but the expectation is that one can provide an implementation to suit ones needs. For example, we're planning on using Postgres for one of our projects.  The filtering in this case needs to be specified at a higher level and then passed in to the implementation. It would have to be defined by the Verifier when they create the Proof Request (likely in JSON) and then passed to the Holder (Prover) who would pass that into their wallet implementation.   ></body> </Action>
<Action id="37824" issue="25718" author="ashcherbakov" type="comment" created="2017-12-28 14:22:26.0" updateauthor="ashcherbakov" updated="2017-12-28 14:29:23.0"> <body><! CDATA  ~swcurran   ~gudkov   ~nage  Are all claims in this huge wallet issued by the same Issuer? So, all claims belong to the same (schema, issuer) pair? If so, then probably you can just use different issuers (different issuer DIDs) for issuing claims, and it will be the same as filtering against organization field value in claims. Proof request supports filtering against any number of schemas and/or issuer DIDs (independently). So, you can specify a list of Issuers and Schemas, and all claims matching at least one of them will be returned.   ></body> </Action>
<Action id="37826" issue="25718" author="ashcherbakov" type="comment" body="But in general I like the idea of more sophisticated proof requests and filters as well as DSL or any syntax for constraints and filtering in proof requests." created="2017-12-28 14:34:56.0" updateauthor="ashcherbakov" updated="2017-12-28 14:34:56.0"/>
<Action id="37863" issue="25718" author="swcurran" type="comment" created="2017-12-29 20:47:46.0" updateauthor="swcurran" updated="2017-12-29 20:47:46.0"> <body><! CDATA  ~ashcherbakov  - hmm...not really liking the idea of the issuer creating a unique DID per claim. That means two extra ledger transactions per claim - creating a DID and a Claim Def, which adds time (not that big a deal) and ledger transactions (which seems wrong).  We propose using the same syntax for "claim_filter" as is used for the existing "requested_predicate", with attributes f_type, attr_name and value.  For example, see gist:  https://gist.github.com/swcurran/ae844f6d49b132a58aafaba32c6a1dcc   There are some implied rules by the format: # The claim_filter attr_name must be within the same claim as the (parent) filtered attr (see additional note below) # Multiple claim_filters with the same attr are OR'd together. # Multiple claim_filters with different attr's are AND'd together. # Data formats must be standardized (e.g. dates must be a known format - ISO...). I assume these are defined in "requested_predicate".  The claim filter in the example would be executed as: {quote}((legal_entity_id = "862..." OR legal_entity_id = "3124...") AND effective_date > "1987-01-01") {quote} Thus, claim_filters cannot use arbitrary logic, but are powerful enough for many use cases. I'm sure a majority of cases would be an attr equaling a value.  We'd have to define the behaviour if the claim_filter references attrs not in matching claims.  I'm not sure what is best - undefined (probably not the best choice - predictable is nice), always return TRUE (all claims are matched) or always return FALSE (no claims are matched).  ></body> </Action>
<Action id="39478" issue="25718" author="gudkov" type="comment" created="2018-02-01 09:22:27.0" updateauthor="gudkov" updated="2018-02-01 09:22:27.0"> <body><! CDATA  ~ashcherbakov   ~danielhardman   ~sergey.minaev   ~SeanBohan_Sovrin   ~nage   Proposed solution is a bit contradicts with our current Wallet vision. Wallet now is a key/value storage and internal filtering is possible only by key part.   In proposed solution there is a suggestion to perform filtering on claim attributes values. I see the following problems:  1. It over-complicates the wallet. To achieve this wallet should be complex database and format of claim should be well defined. 2. It forces specific format of claim attributes. For current moment values of claim attributes are just BigNums and it is application specific logic how to conver numbers to domain entities and units like time or string.  My current vision is that filtering like this is a bit out of libindy scope.  ></body> </Action>
<Action id="39479" issue="25718" author="gudkov" type="comment" body="I suggest to postpone this at least until we define requirements for the wallet." created="2018-02-01 09:29:07.0" updateauthor="gudkov" updated="2018-02-01 09:29:07.0"/>
<Action id="39600" issue="25718" author="swcurran" type="comment" created="2018-02-02 17:58:42.0" updateauthor="swcurran" updated="2018-02-02 17:58:42.0"> <body><! CDATA  ~gudkov  and team - we'd definitely like to have further discussion on this. This feature we think is crucial for our use case, so the first thing to do is figure out if that is the case. If it is indeed required, we should look at what is the easiest way to achieve our use case without over-complicating the wallet.  That might be a simpler (less capable) version of this, or perhaps an TheOrgBook-specific hack to achieve our goal for our specific wallet implementation. Ugly, but I think doable.  We have acquired resources to implement what we are calling an "enterprise wallet" that we'd obviously like to be compatible with the HL-Indy API, so at minimum, I'm hoping we can get some time with the HL-Indy team to figure out the best path forward from a community perspective. We don't want to build things on our own that will potentially be useful to the community.  We're just starting on this effort and will stay in touch on our progress.   ~nage   ~SeanBohan_Sovrin   ~jljordan42   ></body> </Action>
<Action id="39729" issue="25718" author="swcurran" type="comment" created="2018-02-06 16:32:06.0" updateauthor="swcurran" updated="2018-02-06 16:32:06.0"> <body><! CDATA Some added thoughts on this after a bit more thought and looking around.  I agree on not over complicating the wallet, but I don't see how the feature requires a transition to either a complex database or any more structure in storing credentials.  The current claim data in an HL-Indy wallet includes both the BigNums and text representations so little/no change needed there.  Further, from my brief exploration of the tools available, most modern databases include support for JSON path-based querying and the claims structure is sufficiently constrained for that approach.  As I see it, worst case the wallet interface supports the requested feature and a specific implementation filters the data between pulling it out of the database and returning it to the caller.  So there is not really even a need for any specific database support for the feature. Even happy if, like in the case of predicates, the initial functionality is very limited (e.g. "equal").  ></body> </Action>
<Action id="40397" issue="25718" author="ianco" type="comment" created="2018-02-19 19:47:45.0" updateauthor="ianco" updated="2018-02-19 19:47:45.0"> <body><! CDATA A few of us just had a discussion on this issue and there was some confusion around where the filtering was being performed in the wallet.  My understanding is: # The caller calls "prover_get_claims_for_proof_req()" in anoncreds.py # Internally, anoncreds calls wallet.list() to get all the claims from the wallet # anoncreds iterates through all the claims to determine claims that satisfy the proof (this is in "src/services/anoncreds/prover.rs get_claims_for_proof_req()")  My understanding of the purpose of this ticket was to add the filtering capability to step 2 above, i.e. to build some kind of filtering "smarts" into the wallet.  anoncreds would then be responsible for converting the proof request into a filtered query against the wallet, to manage the quantity of data being returned to and processed by anoncreds.  The initial solution I recommended was a "virtual wallet" approach, where an enterprise wallet could store claims for different subjects in different "virtual wallets" (within the same physical database), however from our discussion today we're not sure that will be sufficient.  Subjects could potentially have hundreds of claims, and processing all claims for every proof request could have performance implications.  So we believe the wallet API requires an additional method, like the existing "list(&self, key_prefix: &str)", but with an additional parameter to specify additional filter criteria.     ></body> </Action>
<Action id="40412" issue="25718" author="gudkov" type="comment" created="2018-02-20 13:28:13.0" updateauthor="gudkov" updated="2018-02-20 13:28:13.0"> <body><! CDATA  ~ianco   ~ashcherbakov   ~danielhardman   As i already said:  > Proposed solution is a bit contradicts with our current Wallet vision. Wallet now is a key/value storage and internal filtering is possible only by key part.  Now you just met this problem. Current solution allows to efficiently filter claims by issuer and schema (they are present in the key), but filtering by value is complicated. Value in the wallet in most cases is some complex json. I don't know the effective solution that will allow to index schema less jsons by field values. Also it contradicts the idea to store all wallet values encrypted on indy-sdk level and just plug different storages. Also it will be really hard to implement this filtering over hardware key chain that iOS wrapper uses.  Possible solutions: 1. Iterate over all claims without db-level indexing. It is acceptable for small wallets of one Identity Owner, but seems too slow for your use case. 2. Index claims on application level. Just put all claim attributes and corresponded values you interested in to database you like and perform filtering on this database level. Each claim has uuid in the wallet and you can simple map the clam in the wallet to record in your database.  ></body> </Action>
<Action id="40413" issue="25718" author="gudkov" type="comment" created="2018-02-20 13:35:11.0" updateauthor="gudkov" updated="2018-02-20 13:35:11.0"> <body><! CDATA  ~ianco   ~ashcherbakov   ~danielhardman   As additional option we can extend the wallet type interface with extended version of "wallet::list" callback with optional json-filter param (need check if some RFC already provides the query language for json filtering)  1. If wallet implementation supports values filtering than indy-sdk will use enhanced version of "wallet::list" callback 2. If no than indy-sdk will just read all claims from the wallet and apply filter on sdk side  This option still contradicts the idea of storing all wallet values encrypted.  ></body> </Action>
<Action id="40415" issue="25718" author="gudkov" type="comment" created="2018-02-20 13:51:49.0" updateauthor="gudkov" updated="2018-02-20 13:51:49.0"> <body><! CDATA Indexing of jsons can be performed in the following way:  1. Get all possible "root" to "leaf" paths. For example, for json:  \{   "data": \{      "a": "a_value",     "b": "b_value"  } }  it will be:  data.a data.b  We can make table for indexing with 3 fields (key, path, path_value). For this json we will get the following records:  "key_value", "data.a", "a_value" "key_value", "data.b", "b_value"  and compound index will allow to filter jsons, but this approach seems too complex for default wallet.  ></body> </Action>
<Action id="40427" issue="25718" author="ianco" type="comment" created="2018-02-20 16:21:48.0" updateauthor="ianco" updated="2018-02-20 16:21:48.0"> <body><! CDATA  ~gudkov  thanks for your comments.  I like your idea of an optional interface that supports filtering - providers can choose to implement it if it fits their use case.  I think Sqlite, PostgreSQL and others support indexing of Json, or alternately the wallet could use a document store like CouchDB or MongoDB.  I'll look into this and see what kind of query parameters could support this.     ></body> </Action>
<Action id="40520" issue="25718" author="ianco" type="comment" created="2018-02-21 16:40:15.0" updateauthor="ianco" updated="2018-02-21 16:40:15.0"> <body><! CDATA  ~gudkov  the reason we are running into this issue is that anoncreds internally, within the "prover_get_claims_for_proof_req()" method, is calling wallet.list() and retrieving a list of all claims in the wallet.  If we implement filtering on the wallet's "list()" method then that will require changes to the anoncreds code as well.  One other option I'd like to throw out - can we add an additional parameter to the "prover_get_claims_for_proof_req()" method, which is a list of claim id's?  Then the calling application has the option to do a "pre search", determine in advance the set of claims that *might* be applicable for the proof, and then anoncreds can build the proof with this filtered list.     ></body> </Action>
<Action id="40535" issue="25718" author="swcurran" type="comment" created="2018-02-21 19:55:19.0" updateauthor="swcurran" updated="2018-02-21 19:55:19.0"> <body><! CDATA I agree that the solution is way to include a mechanism to pass into the wallet information on the credentials of interest, and leave it to the wallet to implement that efficiently. Using the current "wallet.list()" call that returns all the credentials in the wallet and have code that filters the list to those of interest is not going to scale - even, I would argue, for a personal wallet. There has to be a way in the Indy-SDK to pass filter criteria into the wallet so the filtering can be done at the DB level.  The wallet implementation can ignore the filter criteria and continue to pass back to anoncreds everything from the wallet (e.g. retain current behaviour), but at least it gives us wallet implementers a fighting chance of providing decent performance.  anoncred can continue to iterate on a further filter the list - which could be a NoOp action as the wallet has already done that.  This ticket suggested using the format of the Proof Request to provide the filter criteria.  We still think that is a good idea (possibly necessary since that is how the Verifier tells the Holder what it wants), but given that the Proof Request is NOT given to the wallet (we thought it was), perhaps the wallet filter criteria could be derived from the Proof Request to prevent the wallet knowing too much about the Proof Request process.  ></body> </Action>
<Action id="41274" issue="25718" author="gudkov" type="comment" body="Proposal for wallet interface changes that can help in this problem https://github.com/hyperledger/indy-sdk/pull/564/files" created="2018-03-06 23:58:20.0" updateauthor="gudkov" updated="2018-03-06 23:58:20.0"/>
<Action id="41369" issue="25718" author="ianco" type="comment" created="2018-03-08 15:43:57.0" updateauthor="ianco" updated="2018-03-08 15:43:57.0"> <body><! CDATA  ~gudkov  thanks for the design doc.  I'm still digesting it, but a few quick comments:  I like the separation of wallet and storage, although would still like the option of whether to encrypt data in storage or not.  Specifically entity values and metadata - for our use case the data is not private, so encryption is an unnecessary overhead.     Does the WalletStorage implementer have to implement a WalletSearch?  It looks like an internal SDK class, but the wallet_storage_search_entities needs to return this class (or (preferably) a json structure that this class will interpret)?  I'll probably have more feedback/questions as I dig into it more ...  ></body> </Action>
<Action id="41397" issue="25718" author="ianco" type="comment" created="2018-03-09 07:11:12.0" updateauthor="ianco" updated="2018-03-09 07:11:12.0"> <body><! CDATA The other question I have is how can I help?  I'd love to be able to contribute to this solution.     ></body> </Action>
<Action id="47892" issue="25718" author="gudkov" type="comment" body="We can consider this as done.  ~swcurran  If you still need something i suggest to re-open." created="2018-07-26 11:52:17.0" updateauthor="gudkov" updated="2018-07-26 11:52:17.0"/>
<Action id="48655" issue="25718" author="swcurran" type="comment" created="2018-08-09 16:57:54.0" updateauthor="swcurran" updated="2018-08-09 16:57:54.0"> <body><! CDATA  ~gudkov  - agreed, I think this is done.  We've got what we need.  There may be a future piece where the Proof Request is extended to allow the Verifier to request specific attributes of credentials be used, but that is a separate issue that needs more experience.  Thanks!  ></body> </Action>
