<Action id="46189" issue="31159" author="gudkov" type="comment" created="2018-06-19 11:27:45.0" updateauthor="gudkov" updated="2018-06-19 11:27:45.0"> <body><! CDATA  ~danielhardman   ~nage   ~esplinr  As i understand we plan to support this in the future, but it will require introduction of more complex schemas infrastructure that will define measurement units and encryption rules.   Without enhancement of schemas infrastructure this request look hard to design as encryption can be different for different use cases.  ></body> </Action>
<Action id="46206" issue="31159" author="swcurran" type="comment" created="2018-06-19 15:04:27.0" updateauthor="swcurran" updated="2018-06-19 15:04:27.0"> <body><! CDATA That's more complicated than I expected. I was thinking that the caller might have to pass in a datatype for the handling, but not much more than that. Not sure where encryption comes into it at this level.  If such complexity is required, the need for it to be in Indy-SDK is higher.  Perhaps the approach is to add a call now with a versioning mechanism and a simple implementation so that the implementation can be evolved in the future.  ></body> </Action>
<Action id="48443" issue="31159" author="ignisvulpis" type="comment" created="2018-08-06 13:51:54.0" updateauthor="ignisvulpis" updated="2018-08-06 13:51:54.0"> <body><! CDATA This topic is coming up in rocket chat again and again. Developers are confused.  In Indy we even have the same value encoded as different values: # "Alex" 12345  https://github.com/hyperledger/indy-sdk/blob/master/libindy/src/services/anoncreds/prover.rs#L468"|https://github.com/hyperledger/indy-sdk/blob/master/libindy/src/services/anoncreds/prover.rs#L468  # "Alex" 1139481716457488690172217916278103335  https://github.com/hyperledger/indy-sdk/blob/master/libindy/tests/utils/anoncreds.rs#L525  # "Alex" 1139481716457488690172217916278103335  https://github.com/hyperledger/indy-sdk/blob/master/libindy/tests/demo.rs#L220   I don't think that measurement units are that important. If a schema defines something to be a number in one measurement unit than that is it. I see no need to introduce the possibility that a claim value is in seconds and the prove request requests that value in milliseconds. The schema defines exactly the measurement unit and the values in claims and proves are number in that one unit.  The most important requirement seems to be that integers are encoded as, well, integers. (Although von_agent restricts this to -2^32 to 2^32)  The only thing implemented in indy-crypto is "GE". So another requirement on encode is that if v1 > v2 ("Alexander" > "Alex") then encoded("Alexander") > encoded("Alex")  What is the downside to put the von_agent::encode/decode into Rust and expose the two in the api?        ></body> </Action>
<Action id="48606" issue="31159" author="sklump" type="comment" body=" ~ignisvulpis , GE predicate only works on (signed) 32-bit integers, because it requires that the encoded value be the same as the raw. There is no ordering for any other data type, as far as I know." created="2018-08-09 10:39:48.0" updateauthor="sklump" updated="2018-08-09 10:39:48.0"/>
<Action id="48638" issue="31159" author="ignisvulpis" type="comment" body=" ~sklump  true, although it probably does not hurt to implement a &apos;reference&apos; encoding with this ordering requirement. Seems easy for BigIntegers if we remove the CODE for them and is probably useful for Strings as well (later). Anyway, I would rather have one reference implementation without this requirement than none." created="2018-08-09 14:45:17.0" updateauthor="ignisvulpis" updated="2018-08-09 14:45:17.0"/>
<Action id="48639" issue="31159" author="sklump" type="comment" body="It is not at all clear to me how to guarantee ordering on string encoding. Remember, &quot;9&quot; &gt; &quot;10&quot;. Do not become hypnotized by the notation; &apos;&gt;&apos; lexicographically is not the same thing as numerically. Similarly for float encoding; e.g., -2147483648.000000000000000000...1f is going encode to something bigger than 0.0f or else the encoded ordering principle will break elsewhere." created="2018-08-09 15:03:08.0" updateauthor="sklump" updated="2018-08-09 15:03:08.0"/>
<Action id="48648" issue="31159" author="ignisvulpis" type="comment" created="2018-08-09 16:04:04.0" updateauthor="ignisvulpis" updated="2018-08-09 16:04:04.0"> <body><! CDATA I don't see the "9">"10" as a problem because then the type should have been int anyway. The problem with string sorting is different in different cultures and languages but I would (arrogantly) not care about it now and go for the utf-8 (ISO-Latin) sorting  https://en.wikipedia.org/wiki/Alphabetical_order       2018-08-09 17:04 GMT+02:00 Stephen Klump (JIRA) < jira@hyperledger.org|mailto:jira@hyperledger.org >:  ></body> </Action>
<Action id="48650" issue="31159" author="sklump" type="comment" created="2018-08-09 16:14:12.0" updateauthor="sklump" updated="2018-08-09 16:28:27.0"> <body><! CDATA There is no 'should'. E.g., attribute nickname values "41" and "43" for ex-US presidents Bush Sr. and Jr., or civic numbers from street addresses "1", "2", ... they must be strings or else they could not accommodate "1A" or "2 1/2".  Once we go into encoded space, the only ordering that applies is the ordering for trivial encodings; i.e., those that match their decoded values. It's like ordering the complex numbers - works fine for the subset where the _i_ coefficient is zero.  I have been assuming UTF-8 throughout too.  ></body> </Action>
<Action id="48793" issue="31159" author="swcurran" type="comment" created="2018-08-13 15:17:44.0" updateauthor="swcurran" updated="2018-08-13 15:17:44.0"> <body><! CDATA  ~gudkov   ~esplinr  - we now have two implementations of encode/decode - one in Java in the Indy-SDK wrapper (by  ~ignisvulpis ) and one on top of the Python wrapper in VON_Anchor (by  ~sklump   https://github.com/PSPC-SPAC-buyandsell/von_anchor/blob/master/von_anchor/codec.py ). Axel and Stephen have been working together on the implementations to try to align them.  There are complexities in this :).  My question is what's next? Should a rust developer take the python/Java implementations and create a rust implementation?  Another option is putting the python implementation into the python wrapper.  Should someone in the node world look at the two implementations and start one there?  What do you think is the best approach?     Thanks!  ></body> </Action>
<Action id="50928" issue="31159" author="gudkov" type="comment" body="PoC from community: PR is here: https://github.com/hyperledger/indy-sdk/pull/1048" created="2018-09-21 11:17:24.0" updateauthor="gudkov" updated="2018-09-21 11:17:24.0"/>
<Action id="50938" issue="31159" author="sklump" type="comment" created="2018-09-21 12:39:07.0" updateauthor="sklump" updated="2018-09-21 12:39:07.0"> <body><! CDATA A brief history follows, for posterity.  In the beginning, there was the requirement to encode all strings as numeric strings, but outside the range of int32. To allow for predicates in the indy-sdk, 32-bit integers had to encode to themselves and so the whole int32 space was reserved for 32-bit integers.  Then because of python, null values encoded to the 'None' string, so decoding the encoded value produced a string that could also have been literally the 'None': not great for ORM-like processing that took values from a proof on one cred def and applied it to attributes for another. The system needed a sentinel to mark the null value.  Similarly, sentinels for True and False disambiguated booleans from their stringified (python) equivalents, and then floats came along.  If I were doing it from first principles, I would have just implemented, where 'raw' and 'encoded' have their indy-sdk meaning and 'orig' means the typed value in the data model: orig -> raw: * 1: The raw value is the stringified orig value (exception: empty string '' for null).  orig -> encoded: * 1: Is orig an int32? If so, stringify it and return the result. * 2: JSON-dump orig to string (on utf-8 encoding), build an int from the bytes, add maxint32 and return.  encoded -> orig: * 1: is encoded a string with numeric value in int32? If so, return its int value. * 2: Subtract maxint32, build a string (on utf-8 encoding) corresponding to its bytes, JSON-load and return.  By the time this simpler approach dawned on me, unfortunately Mr. Axel Nennker had already invested his sweat and tears into reproducing the original algorithm to match encoded values across the Python/Java divide (floats were evil). And modern JSON tools may not be available, or may be overly heavy, for the micro-platforms to which Mr. Nennker is porting. So this approach may not be as universal as it appears at first glance.  ></body> </Action>
<Action id="52861" issue="31159" author="mikelodder" type="comment" created="2018-10-31 20:42:59.0" updateauthor="mikelodder" updated="2018-10-31 20:42:59.0"> <body><! CDATA I reported this over a year ago. I can't find the issue so I wonder if it was closed. I recommended that it be fixed in indy-crypto so all the library callers have to pass is the revealed attribute values and the proof to the verification logic and it would check it. During issuance the issuer should just pass in the string values and indy-crypto would handle mapping them to numbers.  What I'm curious about is why I can't find my original issue and where did it go? I labeled it as high priority because this attack allows any prover to lie about their non-numeric attributes.  ></body> </Action>
<Action id="52934" issue="31159" author="swcurran" type="comment" created="2018-11-02 00:47:59.0" updateauthor="swcurran" updated="2018-11-02 00:49:21.0"> <body><! CDATA  ~MikeLodder  -  ~sklump  has put in a HIPE and has code for this.  It would be really nice to get some ideas on direction about this.   ~danielhardman  commented on the HIPE to say it is insufficient because of the lack of potential ZKP support.  What flexibility should be added so that we can go further than this?  Have others thought of what can/should be done?  The answer to Daniel's question on the HIPE is that we have nothing now so we have no chance at interoperability - every Dev is making up their own solution (as Stephen and Axel have both done). Using Stephen's solution would give Devs an appropriate API (encode with only raw data input, and decode) to use going forward, and we can add what's needed to make the encoding ZKP-friendlier in the future.  I think (not certain) Stephen put in a "version" mechanism in the encode so that we should be able to improve the capability later.  I'm guessing the more useful capabilities would require enhancements to the schema object - adding in claim metadata to make improved ZKP opportunities possible.  Those I've talked to in the Dev community to see this and pack/unpack as two of the most glaring omissions from the current SDK.  Progress on this would be really helpful.   ></body> </Action>
<Action id="52960" issue="31159" author="sklump" type="comment" created="2018-11-02 12:17:23.0" updateauthor="sklump" updated="2018-11-02 12:55:48.0"> <body><! CDATA My current partial implementation includes a version prefix. However, I had never realized the 256-bit limit for encodings. As it stands my current approach has a flaw in that it exposes an overload attack.  Some have proposed using a straight SHA-256 encoding on raw input (excluding 32-bit ints), and that would work, but preclude a version prefix.  A fundamental question is: is encoding a one-way function or is it intended to be reversible? Is it a requirement to be able to recover the raw or the original* from the encoding? If not, I would lean toward stringify-and-SHA-256, with the method for stringification being in the schema metadata (e.g., how to stringify a quaternion, complex number, RGB value, currency value "$0.05" Ontario vs. "0,05$" Québec).  \* I've used terms: - the _original_ as the input, before any contact with indy, potentially having any type - the _raw_ as indy-sdk terms it, necessarily stringified (indy-sdk raises exceptions for anything but a string for a raw value in the attribute value JSON encoding)  ></body> </Action>
<Action id="64532" issue="31159" author="esplinr" type="comment" body="This will be addressed as we implement Rich Schemas as part of the W3C Verifiable Credentials. Most of this work will likely be done on the Aries Tier." created="2019-10-10 11:56:34.0" updateauthor="esplinr" updated="2019-10-10 11:56:34.0"/>
