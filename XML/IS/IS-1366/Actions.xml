<Action id="63486" issue="42136" author="sergey.minaev" type="comment" created="2019-09-02 14:09:58.0" updateauthor="sergey.minaev" updated="2019-09-02 14:09:58.0"> <body><! CDATA Optiions by  ~KitHat  which was discussed while IS-1358  Right now in credentials we save credential definition and schema ids in unqualified form. As long as we introduce fully-qualified dids we need to support it in credential exchange somehow.      *Option 1*: Credential exchange works WITHOUT fully-qualified prefixes  _Needed changes_: We need to cut off prefixes on every stage of credential exchange including proof request handling (in restrictions). In details -- we need to cut it off in   _Problems_: Fully-qualified DID support has arguable value in that case. We can only create it in wallet and nothing else.     *Option 2:* Credential exchange can work with fully-qualified prefixes but it is enabled with a flag.  _Needed Changes:_  * We just need to introduce a flag and change some places where we operate with ids -- mostly proof request handling and credential storage. * We need to make credential definition id and schema id fully-qualified as well  _Problems:_  * Credential from new and old version will be incompatible between each other -- we will need migration. * We will need to work out the version from internal data -- that may be tricky.     *Option 3:* Credential exchange use versioning that specifies how to treat that credential exchange message  _Needed Changes_: We introduce a new field “version” and work only if this field and libindy internal version is matching. Then we will work according to the version.  _Problems:_  * The problem here is the same as in the previous version -- we will surely need migration of credentials.  * Applications will need to specify the version in some structures (like proof requests) by themselves -- we do not have any builders for them.  ></body> </Action>
<Action id="63487" issue="42136" author="sergey.minaev" type="comment" body="As VCX has some real adoption we have to implement the 3rd approach" created="2019-09-02 14:10:41.0" updateauthor="sergey.minaev" updated="2019-09-02 14:10:41.0"/>
<Action id="63725" issue="42136" author="artemkaaas" type="comment" created="2019-09-12 15:11:07.0" updateauthor="artemkaaas" updated="2019-09-27 09:54:51.0"> <body><! CDATA Minimal Support of Fully-Qualified identifiers. General format of fully-qualified identifier is `<prefix>:<method>:<value>`.   Changes: * Libindy * extended `did_info` parameter of `indy_create_and_store_my_did` function to accepts optional `method_name` filed. This field should be used to create fully qualified DID. If this field is skipped the usual unqualified form will be created.  * all functions can work with fully-qualified identifiers (new way) as well as with unqualified.   Pay attention that all functions from Ledger API can accept fully-qualified identifiers but always return results in the unqualified form (requests/responses).   * added a new function -- `indy_to_unqualified` -- that gets unqualified form of a fully-qualified identifier. this function can accept the folowwing entities: Did, SchemaId, CredentialDefinitionId, RevocationRegistryId, CredentialOffer, ProofRequest.  * proof requests now support versioning (`ver` field) -- now it specifies whether restrictions are full qualified or not.  - omit or set "1.0" to use unqualified identifiers.  - set "2.0" to use fully qualified identifiers.   Pay attention that the same format of identifiers will be used in generated proof and must be used for proof verification as keys of maps(`schemas_json`, `credential_defs_json`, `rev_reg_defs_json`, `rev_regs_json`).   * added a new function -- `indy_qualify_did` -- that updates DID stored in the wallet to make it fully qualified, or to do other DID maintenance. This functions also updates all DID related entities stored in the wallet. * added correspondent `did qualify` command to Indy-CLI.   * Indy-CLI - added `did qualify` command to Indy-CLI that updates DID stored in the wallet to make it fully qualified (corresponds to `indy_qualify_did`).  * Libvcx - Extended provisioning config to accept `did_method_name` filed.  This field specifies method name to create fully qualified DIDs.    Anoncreds workflow  FQ - fully-qualified U - unqualified  Credential Issuance Cases: Issuer (FQ) - Holder (U)  * Issuer creates DID in fully qualified way. Schema and CredentialDefinition created for this DID will be fullyqualified also. * Issuer creates CredentialOffer for Holder (U).  * Issuer should call `indy_to_unqualified` wit `cred_offer_json` to get unqualified form. Later Issuer must use this unqualified form for sending Prover and on credential issuance. * all next steps are exactly same as before. Issuer (FQ) - Holder (FQ) * usual flow. identifiers will be fully-qualified. Issuer (U) - Holder (U) * usual flow. identifiers will be unqualified. Issuer (U) - Holder (FQ)  * usual flow. identifiers will be unqualified. Holder can handle unqualified identifiers.  Proof Presentation Cases: Proof requests now support versioning (`ver` field) -- it specifies whether restrictions are full qualified or not.  - omit or set "1.0" to use unqualified identifiers.  - set "2.0" to use fully qualified identifiers.    Verifier (FQ) - Prover (U)  * Verifier should set `ver` field as '1.0' or omit it into ProofRequest.  * Verifier -- if restrictions are fully-qualified -- `indy_to_unqualified` function with `proof_request_json` should be called to get unqualified form.  * Prover - no changes * Verifier -- proof verification -- must use *_id's (`schema_id`, `cred_def_id`, `rev_reg_id`) listed in `proof identifiers `  as the keys for corresponding `schemas_json`, `credential_defs_json`, `rev_reg_defs_json`, `rev_regs_json` objects. Verifier (FQ) - Prover (FQ)  * Verifier can create as fully-qualified as unqualified ProofRequest Verifier (U) - Prover (FQ)  * Verifier should set `ver` field as '1.0' or omit it into ProofRequest.  * Prover will create unqualified proof in this case. No additional steps are required. Verifier (U) - Prover (U)  * usual flow. identifiers will be unqualified.  Vcx: everything will be done automatically based on the type of remote DID. How to test VCX: run python demo in two containers with different versions.  ></body> </Action>
<Action id="63775" issue="42136" author="sergey.minaev" type="comment" body="https://github.com/hyperledger/indy-sdk/pull/1862 should be finished in scope of this task as well" created="2019-09-16 12:27:10.0" updateauthor="sergey.minaev" updated="2019-09-16 12:27:10.0"/>
<Action id="64178" issue="42136" author="artemkaaas" type="comment" body="Build version: master-1336" created="2019-09-27 06:22:28.0" updateauthor="artemkaaas" updated="2019-09-27 06:22:28.0"/>
<Action id="64207" issue="42136" author="sergey.minaev" type="comment" body="Validation would be done in scope of IS-1384 " created="2019-09-30 14:56:23.0" updateauthor="sergey.minaev" updated="2019-09-30 14:56:23.0"/>
