<Issue id="19113" key="IS-201" number="201" project="10401" reporter="gudkov" assignee="peacekeeper" creator="gudkov" type="10004" summary="Java Wrapper: Callbacks GC Issue" priority="1" resolution="10000" status="10001" created="2017-07-10 14:09:17.0" updated="2017-07-18 12:43:34.0" resolutiondate="2017-07-18 12:43:34.0" votes="0" watches="2" workflowId="50957"> <description><! CDATA We are creating a new instance of Callback each time when user invokes API call and passing of this callback to C function. JVM can't manage reference counting in C code. As result, GC will free this object on the next GC iteration and it will cause bad behavior like crashes or missed callback calls.  To avoid this I suggest the following:  1. For each call create one static callback instance and `static Map<i32 /* command handle */, Future>` 2. Use global atomic counter to generate new command handles 3. When user calls our method generate new command handles and put corresponded Future to static Map 4. When libsovrin calls our callback resolve corresponded future with result  For reference see https://github.com/java-native-access/jna/blob/master/www/CallbacksAndClosures.md  "If your callback needs to live beyond the method invocation where it is used, make sure you keep a reference to it or the native code will call back to an empty stub after the callback object is garbage collected."  ></description> </Issue>
