<Action id="60215" issue="39792" author="esplinr" type="comment" created="2019-05-21 17:46:04.0" updateauthor="esplinr" updated="2019-05-21 17:46:04.0"> <body><! CDATA Notes from our discussions on this issue: {quote} Contemporary versions of rustc are supposed to use bitcode by default.  I also found that the nightly builds enable the passing of parameters through to rustc / cargo / Xcode.  This command is supposed to enable bitcode using that method:  RUSTFLAGS="-Z embed-bitcode" cargo lipo --release  However, the error persists.  I did find that on macOS 10.15.5 that apple is using "Apple LLVM version 10.0.1 (clang-1001.0.46.4)” while rust is using "LLVM version: 8.0” {quote}  {quote} 1) To test bitcode implementations, I have built libindy.a from scratch and also built my own tiny rust lib and iOS test app.  I get the same results from either.  2) I’m reading that bitcode is enabled by default in recent rust versions.  The RUSTFLAGS can also be used to enable bitcode explicitly, but only in the rust nightly builds.  I’ve tried both.  3) building libindy.a (or even my small rust test lib) shows that there are indeed bitcode sections when viewed with otool.  4) importing the ‘bitcode enabled’ lib into Xcode for an iOS app (with the app project's 'enable bitcode' set to ‘yes') causes an ld error stating that the library “does not contain bitcode”.  If the otool report (step 3) is correct, then my guess is that something between the rust LLVM and Xcode’s Apple LLVM is incompatible.  If I set “enable bitcode” within the Xcode project to “no”, then everything builds successfully.  LLVM incompatibilities regarding bitcode (incl how to stay compatible with Apple) have been discussed at length in the rust forums over the last few years.  5) building the bitcode enabled lib is done with “cargo lipo”, I went to the author’s site (https://github.com/TimNN/cargo-lipo) and his instructions explicitly state "In your "Build Settings" change "Enable Bitcode" to No.”  I have read other comments from him where he describes bitcode a ‘experimental’ and tells people to disable it. I sent him a message to see if he has any recommendations, but have not heard back.  6) I have also read where some have gotten bitcode to work between rust and iOS.  However, I haven’t found source code that I can recompile and get a successful build.  My guess is that the toolchain versions that I have (most current) and those that they used are different, but I don’t know what the versions are.  7) Apple has different completeness standards for bitcode in iOS apps and Apple Watch apps, which said to be more strict.  That’s irrelevant for this task, but I found it noteworthy. {quote}  ></body> </Action>
<Action id="60216" issue="39792" author="esplinr" type="comment" created="2019-05-21 17:47:32.0" updateauthor="esplinr" updated="2019-05-21 17:56:43.0"> <body><! CDATA A open rust issue that is for adding bitcode support to rust –  https://github.com/rust-lang/rust/issues/35968   {quote} I’ve attached the rust lib & iOS app that I’m using to test the bitcode issue.  It originated from a Mozilla article, btw.  The reason that I’m using this to test the bitcode issue is that it’s smaller than Libindy, which is many more moving parts.   When you open the .zip, the main dir “rust-ios-example” will contain 2 dirs “rust” and “hello-rust”.  “rust" contains the rust lib source, which implements 2 functions.  The 1st receives a string, prepends “Hello ”, and returns it.  The 2nd frees the string memory.  The library can be compelled by running the install script in the main dir (the script requires all the standard rust / iOS tools).  In addition to compiling ‘librust.a’, the script also copies the lib into the iOS project.  For rust, I am using ver 1.34.1 with LLVM version: 8.0.   After building the librust.a  go into “hello-rust” and open hello-rust.xcodeproj.  I have set “enable bitcode” to “no”, so you can see the app run in either the simulator or on a device.  Once in the running app, type a name in the 1st field and then press “Call Rust Library”.  This will pass your entered string down to the rust library and display the returned result in the “Greeting” field.   Now, go in to Xcode and in to “Build Settings” and set “Enable Bitcode” to “Yes”.  Since lipo removes bitcode references in simulator targets, running in a simulator should just run as before.  The real test will be on a physical device.   Now, change the deployment target to a physical iOS device (I’m using my iPhone X) and execute.  Since bitcode is still on, but is apparently incompatible with Xcode tools, you should see the following error:   ld: '/Users/mccown/Development/rust/test/rust-ios-example/hello-rust/libs/librust.a(rust.1almsbpsxryokvrf.rcgu.o)' does not contain bitcode. You must rebuild it with bitcode enabled (Xcode setting ENABLE_BITCODE), obtain an updated library from the vendor, or disable bitcode for this target. for architecture arm64 clang: error: linker command failed with exit code 1 (use -v to see invocation)   What that’s telling us is that Xcode doesn’t think that librust.a has bitcode enabled.  However, if you go to the terminal and into “rust-ios-example/hello-rust/libs”, you can verify that there is bitcode in the rustlib.a by typing:   otool -lv librust.a  | grep bitcode   This will show that the bitcode sections are present in the library.  In the terminal, type 'clang —version —verbose’, which should show something like:   Apple LLVM version 10.0.1 (clang-1001.0.46.4) Target: x86_64-apple-darwin18.6.0 Thread model: posix InstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin   Since rustc is using "LLVM 8.0" and Xcode is using “Apple LLVM version 10.0.1”, I’m thinking that there must be a version incompatibility.  What I’m reading in various forums (incl the link you sent) is that Apple’s LLVM is a version or two behind rust’s (despite the numbering) and that the bitcode additions are not compatible and/or are ignored.   What this all means is that libindy.a is compiled by rustc with bitcode enabled, because rustc now does that by default.  However, due to the differences with Xcode and/or Apple LLVM, the importing iOS app cannot have the “Enable Bitcode” option set to “Yes”.  When that option is set to “No”, then all the bitcode elements in libindy.a are ignored and the iOS app builds machine code just fine — only without bitcode.   Apple currently allows apps to be submitted to the App Store with or without bitcode, so this isn’t a problem unless the apps are big and approach apple’s size limit.     {quote}  ></body> </Action>
<Action id="60217" issue="39792" author="esplinr" type="comment" created="2019-05-21 17:48:23.0" updateauthor="esplinr" updated="2019-05-21 17:48:23.0"> <body><! CDATA Xcode to llvm version mappings: https://en.wikipedia.org/wiki/Xcode#Toolchain_versions. Xcode 8.3  --> swift 3.1 --> llvm 3.9.0 Xcode 9.0  --> swift 4.0 --> llvm 4.0.0 Xcode 9.3  --> swift 4.1 --> llvm 5.0.2 Xcode 10.0 --> swift 4.2 --> llvm 6.0.1 Xcode 10.1 --> swift 4.2.1 --> llvm 6.0.1 Xcode 10.2 --> swift 5.0 --> llvm 7.0.0 Xcode 10.2.1 --> swift 5.0.1 --> llvm 7.0.0  I have not tried this out myself but here is the route I would pursue to get the rust-ios-example working with bitcode / app thinning enabled. Some of these ideas/thoughts are taken from here: https://github.com/rust-lang/rust/issues/35968.  # Build the rust-lang source yourself using Xcode 10.1 (we use xcode 10.1 because we are not yet ready for swift 5.0 on xcode 10.2) ** The way to build the rust-lang source yourself is to follow a similar process as the Dockerfile here -- https://github.com/rust-lang/rust/blob/706e67b0a0143d651eb03f2fa2c30645899e81ff/src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile ** Use steps from the given Dockerfile but do steps on a Mac using Xcode 10.1 and compile the rust-lang source. Ideas/instructions here may help -- https://github.com/rust-lang/rust/tree/706e67b0a0143d651eb03f2fa2c30645899e81ff/src/ci/docker # Once you have rust-lang source code built using Xcode 10.1 then use the resultant build artifacts to build the rust code from the rust-ios-example into a library (librust.a) that has bitcode enabled. # Use the resultant librust.a to build the hellorust swift mobile app with bitcode enabled -- smile big if/when it works.  ></body> </Action>
<Action id="60975" issue="39792" author="mccown" type="comment" created="2019-06-13 15:58:17.0" updateauthor="mccown" updated="2019-06-13 15:58:17.0"> <body><! CDATA I did some in-depth research on why Xcode doesn't recognize bitcode being present in libraries created by the rust compiler and converted to iOS Universal format by cargo-lipo. There are a lot of recommendations in technical chat forums, but none of those have worked. Below are a number of things that I learned that might be helpful for future researchers:  1) Indy is complex, so I used a very simple rust library and associated iOS app to demonstrate the problem (see rust-ios-example.zip above). This made compile times quicker and eliminated most other potential incompatibility sources.  2) "Is bitcode present in the .a library?" To test this, I used "otool", which is a great way to see if bitcode sections are present in a library. This is done by "otool -lv librust.a | grep LLVM" or also by "otool -lv librust.a | grep bitcode". From this, I observed that bitcode sections appear to be present in the library – even though they are not recognized by Xcode.  3) "llvm-bcanalyzer". Another great tool for checking on bitcode is llvm-bcanalyzer, which is run on the original bitcode output files.  4) "Enable bitcode". It was recommended to turn enable bitcode at the rust level using compiler flags that would pass through cargo to rustc using this command "RUSTFLAGS="-Z embed-bitcode" cargo lipo --release". Firstly, the "-Z" option only works with rust nightly builds. It had no effect. Reading some of the rust github comments, it looks like bitcode was set as the default compile option in ~2018 and appears to be the case at present.  5) "Use an older LLVM version". It has been noted that the current LLVM version is not the same used by Apple. This appears to be the case, because Apple is currently using "Apple LLVM version 10.0.1 (clang-1001.0.46.4)” while rust is using "LLVM version: 8.0". I tried recompiling the test library from rust using 3 previous LLVM versions, but none of those were recognized by Xcode as having bitcode.  6) "Rebuild rust". Some recommendations referred to rebuilding the rustc compiler. I did this using both stable and nightly code, but it had no effect.  7) "Cargo-lipo". I walked through the cargo-lipo code to see if that was creating an issue. I played with adding various lipo options, but Xcode did not recognize any change.  At this point, I tried everything that I could thought would help and none of this resulted in a bitcode-enabled library that was acceptable to Xcode.  Upon further rust forum reading, I came across an issue where Mozilla Firefox developers found that clang is apparently not tagging the bitcode sections correctly (in a library created from rust code). They found a workaround that seemed to work, but it wasn't a good generalized solution. Here is a link to that discussion from Apr 2019, which is worth monitoring:  rustc LTO bitcode incompatible with clang LTO bitcode files by default on OS X #60235  https://github.com/rust-lang/rust/issues/60235    At this point, there does not appear to be a fix that the Indy community can create independently. I think that the real fix is for the rust, LLVM, and Apple Xcode developers to achieve a consensus on how to standardize the bitcode tagging.  In the meantime, Apple has increased the allowable iOS app size by 33%, so that will ease the need for bitcode by providers of large apps. If I come across any new / good solutions, I will post them in the future.  ></body> </Action>
<Action id="61061" issue="39792" author="esplinr" type="comment" body="Thank you for reporting on your research  ~mccown . I expect it will be useful to others. I&apos;ll close this issue as &quot;deferred&quot;." created="2019-06-17 20:03:02.0" updateauthor="esplinr" updated="2019-06-17 20:03:02.0"/>
