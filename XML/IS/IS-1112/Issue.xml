<Issue id="36128" key="IS-1112" number="1112" project="10401" reporter="olegwb" assignee="olegwb" creator="olegwb" type="10005" summary="Create demo  for the revocations where ledger operations with registry definition and accumulators are highlighted" priority="3" resolution="10000" status="10001" created="2018-12-13 10:27:16.0" updated="2019-08-06 14:30:36.0" resolutiondate="2019-08-06 14:30:36.0" votes="0" watches="2" workflowId="51725"> <description><! CDATA Integration test suite of libindy features several tests and/or demonstrations of revocation functions.  All of them except one, interactions.rs , do not employ the externalization of revocation artefacts: the relevant objects exist in the memory of single process and they got exchanged between virtual Issuer/Prover/Verifier by sharing them. Real use cases involve objects shared throughout messaging and read-ledger transactions. Prover should be able to find and  obtain objects required for the creation of the revocation state and the proof from available credential(s) only.  Verifier should be acting similarly.  Another challenge is in dealing with accumulator deltas, where both prover and verifier should read the ledger state providing timestamps which make sense for the case.  Let's see what existing integration  test “ interactions.rs|http://interactions.rs/ ” comprises: there are 4 tests there: issuance and revocation of one credential in default revocation registry mode, the same identical  test but with on demand revocation registry mode, the test where three credentials are issued for three different provers and the first is verified, and the same test but this time all three are verified.  The problems with "interactions" are the following: #  Both test #3 and #4 do not use revocations. It makes good sense to revoke one of three credentials and to see if the verification of others is not broken.   #  The test #4 subsumes test #3 # The test #1  has very subtle difference with test #2.   Beside all,  It is quite difficult to read and understand the code due to flat architecture of test functions. It makes sense to factor out all operations with ledger. It also makes sense to dedicate separate functions with own lexical scope for prover and for verifier's activities.   However there is bigger concern here regarding the usage of timestamps. All these tests seem to be bit short on showing correclty what timestamps must be used by Prover and by Verifier. Note that proper time stamping is critical for anoncred algorithms. Developers experience various sorts  of verification failures if timestamps are not used correctly.   * The tests contain small mistakes, which diminish their usefulness as demos. For example, the timestamp used by Verifier in first test ( line 367 ) is obtained correctly from the proof, while the next test uses just a value of the variable initialised by the Prover earlier in the function( line 598). Same mistake is  presented in line 1219, test #3. Right after that Verifier shadows previous value of timestamp , and next Prover uses this new, presumably senseless value for building its proof.   It is proposed in this ticket to add new test or to modify an existing one such as real  scenario is facilitated. The test case should be serving as integration test , as well as a good demonstration of interactions with the ledger for all parties. It would also be a bonus if  test case is able to connect to  the ledger in its non-genesis state. Such test  writes several NYM transactions to identify parties of the test on the basis of random DIDs.  Note that the author has previously implemented interaction test based upon the test from anaoncreds.rs  where revocation step has been added and few refactoring steps were applied for the clarity of test semantics.      ></description> </Issue>
