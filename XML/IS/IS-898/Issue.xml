<Issue id="33038" key="IS-898" number="898" project="10401" reporter="gudkov" creator="gudkov" type="10006" summary="Performance: Implement concurrency improvements Step 2" priority="3" status="10405" created="2018-08-20 08:28:02.0" updated="2019-03-29 21:04:24.0" votes="0" watches="1" workflowId="50677"> <description><! CDATA Implement concurrency improvements Step 2 described in corresponded HIPE:  https://github.com/hyperledger/indy-hipe/tree/master/text/0012-concurrency-improvement    * Add configurable dedicated thread pool for inexpensive crypto * Add configurable dedicated thread pool for expensive crypto * Add dedicated thread for default wallet storage (we don't need pool as sqlite serializes queries) * Async interface for pluggable storage (as result threading will be responsibility of storage implementation) * All commands will be split to parts and each part will be executed on corresponded thread pool. As results there will be no command executor thread locking. As each thread pool will allow configuration application can create good threads configuration for maximum throughput and concurrency.  As managing of each command as STM will cause significant amount of boilerplate we can consider switching to more modern async-io approach (Futures, Promises, Async/Await). For example all, internal interfaces can return tokio.rs Future created with single-shot tokio channel message from thread pool. CommandExecutor will be tokio stream that handles composed Futures.  Acceptance criteria:  * Proposed solution implemented in libindy with TDD approach * Automated test procedure provided * Changes documented * Migration guide updated * Release notes updated  ></description> </Issue>
