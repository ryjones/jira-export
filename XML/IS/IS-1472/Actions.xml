<Action id="67691" issue="44101" author="artemkaaas" type="comment" created="2020-01-28 13:43:32.0" updateauthor="artemkaaas" updated="2020-01-28 13:45:14.0"> <body><! CDATA  ~swcurran   ~sklump    Thank you for the report and the provided test. It's extremely useful.  I updated the test and created PR to indy.  There is a tricky moment related to the preparation of a `revocation state`.  We definitely need to document it somewhere.   In your original test:  * proving before revocation: you get revocation delta from '0' to 'now' and create 'revocation_state' for this delta ---- that is correct.  * proving after revocation: you get revocation delta from 'revoke time' to 'now' and create revocation state for this delta ----- that is wrong.  There are two possible ways of proper preparation revocation state after revocation: * get revocation delta from '0 ' to 'now' and create revocation state from scratch. (as you did for the first proving)  * save 'revocation_state' and 'timestamp' prepared for first proving (before the revocation loop) -> get revocation delta from this 'timestamp' to 'now' ---> use update_revocation_state function. (so you update previously create revocation state by applying a new delta generated since that time). It's faster than the second option.  ></body> </Action>
<Action id="67710" issue="44101" author="artemkaaas" type="comment" body="PR:  https://github.com/hyperledger/indy-sdk/pull/2060 " created="2020-01-29 05:54:37.0" updateauthor="artemkaaas" updated="2020-01-29 05:54:37.0"/>
<Action id="67732" issue="44101" author="sergey.minaev" type="comment" body="Improved documentation is in master 1.14.1 1467" created="2020-01-30 13:00:37.0" updateauthor="sergey.minaev" updated="2020-01-30 13:00:37.0"/>
<Action id="67773" issue="44101" author="sklump" type="comment" created="2020-01-31 14:59:39.0" updateauthor="sklump" updated="2020-01-31 15:07:14.0"> <body><! CDATA I was timing the two approaches, plus a third ( 1: update state since last timestamp, 2: create state from timestamp=0 3: merge deltas since last timestamp, then create state ).  Imagine my surprise when consistently, the 2nd approach (create state from timestamp=0) came out consistently fastest (the idea is to time the actions after parsing the revocation registry delta response - so it's not too surprising that #3 comes in slowest, since it repeats two calls: merge deltas, then create state).  This is certainly no longer urgent, but when someone has the time and inclination, feel free to look over the sample at https://drive.google.com/open?id=1g_EhrTtB0NAvAM8F5dsMovPl30Ctmlgs for wonder and speculation.   ></body> </Action>
<Action id="67781" issue="44101" author="sergey.minaev" type="comment" body="Thanks for details  ~swcurran . I&apos;ve created IS-1475 to track unexpected  performance issue" created="2020-02-03 09:30:54.0" updateauthor="sergey.minaev" updated="2020-02-03 09:30:54.0"/>
<Action id="67807" issue="44101" author="chempel" type="comment" created="2020-02-04 14:17:16.0" updateauthor="chempel" updated="2020-02-04 14:17:16.0"> <body><! CDATA I'm not sure if this really solves the problem. In my tests, I used the entire time span.   ^code.txt   ></body> </Action>
<Action id="67816" issue="44101" author="artemkaaas" type="comment" created="2020-02-05 06:12:04.0" updateauthor="artemkaaas" updated="2020-02-05 06:12:04.0"> <body><! CDATA  ~CHempel    `CreateRevocationStateAsync` must be called on the whole revocationRegistryDelta.  In your test,  you use `revocationRegistryDelta` which is the result of `IssuerCreateCredentialAsync` to Prover createRevocationState. The first time you create proof after first issuing it's acceptable.  But the second – it's wrong because the first delta isn't applied.  You need to get the whole delta every time before calling `createRevocationState`.  like you do: `delta = await _ledgerService.LookupRevocationRegistryDeltaAsync(await agentContext.Pool, revRegId, -1, timestamp);`  Additional note: for Verifier: you can use `getRevocationRegistry` request instead of `getRevocationDelta`.  ></body> </Action>
<Action id="67820" issue="44101" author="chempel" type="comment" created="2020-02-05 14:32:17.0" updateauthor="chempel" updated="2020-02-05 14:32:17.0"> <body><! CDATA  ~Artemkaaas   Thank you very much for your reply.  I have updated my code, but have encountered some other problems.  The proofs happen to be either true or false.  I tested it in a loop, and if it is false once, it stays false, and vice versa.  It would be great if someone could help me solve the problem.   ^updated_code.txt      ></body> </Action>
<Action id="67833" issue="44101" author="artemkaaas" type="comment" created="2020-02-06 05:46:37.0" updateauthor="artemkaaas" updated="2020-02-06 05:46:37.0"> <body><! CDATA  ~CHempel     You have two credentials matching ProofRequest. When you get `credentialsForAttribute1` — you don't check which one you received (first or second) Next on `createRevocationState` you always use `credRevId` which corresponds to the second credential. So if `credentialsForAttribute1` is the second credential — valid proof will be generated else wrong.  `ProverFetchCredentialsForProofRequestAsync` returns credential info that looks like:    {code:java} { "referent": string,  "attrs": {"key1":"raw_value1", "key2":"raw_value2"}, "schema_id": string,  "cred_def_id": string,  "rev_reg_id": Optional<string>,  "cred_rev_id": Optional<string>  } {code} You should take `cred_rev_id` here to create the correct revocation state.  ></body> </Action>
<Action id="67836" issue="44101" author="sklump" type="comment" body="Thanks a million, Artem, good catch." created="2020-02-06 13:16:06.0" updateauthor="sklump" updated="2020-02-06 13:16:06.0"/>
