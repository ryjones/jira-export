<Issue id="31757" key="IS-810" number="810" project="10401" reporter="gudkov" creator="gudkov" type="10006" summary="DID API: Allow to use multiple key pairs with one DID" priority="3" status="10405" created="2018-07-10 13:26:35.0" updated="2019-10-10 12:06:42.0" votes="0" watches="4" workflowId="50651"> <description><! CDATA  from Daniel  On a recent agent call, it became clear that we need to try hard to dramatically speed up our ability to support the semantics of multiple keys for a single DID (one being a cloud key, one being the key of the agency's message routing inbox, and one or more being edge keys). This is a precursor to full microledger support with AuthZ policies, where each DID has different keys (some edge, maybe one a cloud). If we don't figure out a way to do a super simple form of this soon (e.g., in indy-sdk 1.6), we may experience a very painful divergence as existing A2A explorations force a different DID for each agent due to the restriction that each DID can only have one keypair at a time.   from Slava  Libindy already provides call *indy_create_key* that allows creation of key/pairs. Important point that keys now don't have a name and identified by verkey.  All crypto functions are completely keys based and don't know anything about DID. Roughly libindy mostly allow to solve the problem already.  The only problem is mapping between DID and set of key. For the main key libindy stores the mapping in wallet and allow to get DID key by calling *key_for_did* endpoint and we need similar behavior for secondary keys. Right now application can store this mapping in DID metadata with *indy_set_did_metadata*, but i more like more standard approach for this and suggest to add new endpoints: - *indy_asso**c**iate_key*(did, keyname, verkey) - *indy_get_**associated**_key*(did, keyname) -> key - *indy_get_**associated**_keys*(did) -> keys  *indy_get_**associated**_key_* _and  *indy_get*_*associated**_keys* can look for association stored in the wallet and if not found lookup ledger with GET_ATTRIB transaction that is similar on what ** *indy_key_for_d**id* endpoint is doing.  To standardize the way how keys are stored on the ledger we can add corresponded transaction builders and parsers: - *indy_build_associated_keys_request*(did, keys) - *indy_build_get_associated_keys_request*(did) -> req - *indy_parse_get_associated_keys_request*(req) -> keys  format of keys param can be the same as *indy_get_associated_keys* returns.  ></description> </Issue>
