<Action id="52645" issue="32686" author="ianco" type="comment" created="2018-10-25 15:25:30.0" updateauthor="ianco" updated="2018-10-25 15:25:30.0"> <body><! CDATA  ~danielhardman  please see the test approach outlined in indy-hipe PR 49 (wallet storage plug-in) and the related indy-sdk PR (#1247).  I'm proposing a method to "shim" a plug-in into the standard set of unit tests, which should address your concern here, as well as provide a facility to test new plug-ins (without a ton of new effort, since it re-uses existing tests).     ></body> </Action>
<Action id="52656" issue="32686" author="gudkov" type="comment" created="2018-10-25 17:28:40.0" updateauthor="gudkov" updated="2018-10-25 17:29:39.0"> <body><! CDATA  ~ianco   ~danielhardman  Re-usage of part of current wallet tests as a test harness for walket storage plugin is a good idea, but I don’t like idea of making existing libindy test procedure to be generic over different storage or payment plugins. It will be really hard to explain for storage plugin developers and will not guide in storage plugin development at all as only 2% of tests are about plugin storage. Also it is very hard to consume as you need to work with libindy source code and hack cargo test.   We can just use existing tests to create dedicated test harness library that can be executed in any language and installed with package manager. It will not cost a lot more as it will be based on the same existing tests, but will provide much better UX and don’t cause indirect hacks to libindy test procedure.   ></body> </Action>
<Action id="52657" issue="32686" author="gudkov" type="comment" created="2018-10-25 17:37:06.0" updateauthor="gudkov" updated="2018-10-25 17:37:06.0"> <body><! CDATA  ~danielhardman  In current code base situation between default storage plugin and plugged storage separation is much better than you explained in ticket description. Both implements WalletStorage trait and the most of code is generic over this trait.  The layer of difference is very-very thin.   Forcing DefaultStorage to be implemented as a C interface will cause 2-3 reallocation of each string in each wallet call and significantly reduce performance for high-load use cases.   ></body> </Action>
<Action id="52746" issue="32686" author="ianco" type="comment" created="2018-10-29 16:47:34.0" updateauthor="ianco" updated="2018-10-29 16:47:34.0"> <body><! CDATA  ~gudkov  thanks for your comments.  FYI regarding performance - we are running the Postgres walet storage as a plugin and haven't seen any noticeable performance impact when running under load.  (I expect that any high-volume/high performance applications will have to run with some storage other than the default SQLite, so will probably be running under the plugged model.)     ></body> </Action>
<Action id="55100" issue="32686" author="esplinr" type="comment" created="2018-12-21 19:38:58.0" updateauthor="esplinr" updated="2018-12-21 19:38:58.0"> <body><! CDATA  ~danielhardman  and I discussed this issue, and I want to document my current thinking.   ~ianco  We do not expect that you will have a performance impact for the Postgres wallet storage as a plugin. Slava's concern is that the SQLite wallet storage is implemented in Rust and LibIndy is implemented in Rust, but the plugin interface expects a C-callable storage plugin. As a result, moving the default SQLite storage to use the plugin interface will force a conversion from Rust types to C types and back to Rust types. This will have a performance impact.  Daniel agrees that there will be a performance impact, but we don't think it will be enough to negate the benefits of having all storage methods implemented using the same plugin interface.  If our plugin interface is not adequate for implementing the default storage handler, we should reconsider the architecture of the plugin interface.  Having the default SQLite storage method implemented as a plugin does not prevent having tests specific to that storage method.  In my opinion, the default wallet storage should be implemented as a plugin. But migrating the current implementation does not provide much immediate value now that the Postgres and in-memory plugins are available to document and exercise the plugin interface.  We won't be doing this in the short term, but we will keep this story open to re-evaluate implementing after our current batch of work.  ></body> </Action>
<Action id="63624" issue="32686" author="ianco" type="comment" body="Was updated at some point, I can&apos;t remember" created="2019-09-09 16:31:56.0" updateauthor="ianco" updated="2019-09-09 16:31:56.0"/>
