<Action id="43421" issue="29670" author="gudkov" type="comment" created="2018-04-25 15:30:59.0" updateauthor="gudkov" updated="2018-04-25 15:30:59.0"> <body><! CDATA I spend some time yesterday and today to investigate tokio.rs and future-rs (basic part of tokio that will be soon part of standard lib) and seems we can perform this refactoring in 1-2 weeks:  - API layer can be leaved without changes - CommandExecutor will use "channel" from future-rs instead of std, but interface is quite similar - CommandExecutor will execute handler of stream of commands as the main async task on the thread pool (by default 1 thread, but we can allow configuration with env variable) - CryptoService and AnoncredsService will manage dedicated thread pool to handle cpu-intensive operations. Methods will return Future instead of result, changes will be very small - For default wallet we can just use thread pool with one thread leaving the code without big changes - PoolService will be leaved without changes with some thin infrastructure added to return Future instead of Result - The most of refactoring will be needed in command layer. Instead of synchronous code for each command we will need to compose futures received from different services  The main question is how to handle pluggable wallet. There are 2 options:  1. Make interface asynchronous. It is quite easy to implement on libindy side. 2. Leave interface without changes, but claim that it must be thread safe. In this case we can use thread pool with configurable amount of threads.  I vote for option 1. (edited)  ></body> </Action>
<Action id="43610" issue="29670" author="gudkov" type="comment" created="2018-04-28 14:08:21.0" updateauthor="gudkov" updated="2018-04-28 14:08:21.0"> <body><! CDATA  ~danielhardman   ~dkulic   ~esplinr   ~rajesh.kalaria   Here are results of our performance testing https://docs.google.com/spreadsheets/d/1MHqpA_gEw69pWJtJo7aFoaf8Hu0qMQgIBoeK5JPnM5g/edit#gid=0  sqlsypher based wallet seems too slow, but new wallet that Darko's team is creating seems performant enough to provide acceptable performance in one libindy thread.   ></body> </Action>
<Action id="45412" issue="29670" author="gudkov" type="comment" body="There is a HIPE with proposal https://github.com/hyperledger/indy-hipe/pull/16/files" created="2018-06-01 14:02:57.0" updateauthor="gudkov" updated="2018-06-01 14:02:57.0"/>
<Action id="45451" issue="29670" author="gudkov" type="comment" created="2018-06-04 11:22:18.0" updateauthor="gudkov" updated="2018-06-04 11:22:18.0"> <body><! CDATA  ~danielhardman   ~esplinr  I formalized my proposal. We need to start some approval process.   Do you have ideas how we can move it forward?  ></body> </Action>
<Action id="46809" issue="29670" author="sergey.khoroshavin" type="comment" created="2018-07-02 12:12:02.0" updateauthor="sergey.khoroshavin" updated="2018-07-02 12:12:12.0"> <body><! CDATA  ~sergey.minaev   ~gudkov   Recently I've looked into code of Indy SDK (besides just being curious I was interested if it is possible to create memory-effective multithreaded load script with current libindy) and one thing took my attention: https://github.com/hyperledger/indy-sdk/blob/master/libindy/src/commands/mod.rs#L63 1. There is just one command executor guarded by mutex, which can potentially become bottleneck - and as I learned later there are already some proposals to fix this 2. Sender part of Rust's mpsc channel is guarded by mutex as well. This a bit bugged me, because usual way to use mpsc's channels when there are multiple producers is to clone senders, not share them. Given that rust mutex is implemented using plain pthread_mutex, and mpsc is using lock-free queue there is quite high chance that moving sender out of mutex and placing it in thread_local storage can noticeably reduce thread contention on libindy's client side. 3. There are several approaches described in https://github.com/hyperledger/indy-hipe/pull/16/files, one of them proposes to explicitly create command executors and provide handles to them, but states that in order to get benefit applications need deep refactoring. I think that it's possible to use work-stealing thread pool inside libindy to run several command executor threads and get benefits without refactoring of application code - or I might be missing something.  ></body> </Action>
<Action id="49080" issue="29670" author="gudkov" type="comment" created="2018-08-20 08:36:03.0" updateauthor="gudkov" updated="2018-08-20 08:36:03.0"> <body><! CDATA * Corresponded HIPE with design was created and accepted https://github.com/hyperledger/indy-hipe/tree/master/text/0012-concurrency-improvement * Corresponded implementation user stories were created (IS-898, IS-899)  ></body> </Action>
