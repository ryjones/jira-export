<Issue id="31151" key="IS-785" number="785" project="10401" reporter="mikelodder" creator="mikelodder" type="10002" summary="Security: Zeroing Memory for private keys" description="We should double check that libindy does indeed erase memory when disposing of private keys. It looks like it assumes that Rust zeros RAM when dropping variables. If you move around a value it will only get dropped in the last spot it ended up and the rest keep copies until they&apos;re overwritten by other data. The way to work around this usually is to box the data, as moving around a pointer won&apos;t leak the actual data, and Drop can clear that only copy (assuming nobody else accessed it improperly and caused copies on their own). If you move a value, it gets copied to another location in memory and the old value is never dropped. Tons of things move in Rust, and auditing for it is likely to be fairly involved. At least this is what I have observed with Rust." priority="3" resolution="10200" status="10001" created="2018-06-18 19:17:12.0" updated="2019-03-29 20:57:34.0" resolutiondate="2019-03-29 20:57:34.0" votes="0" watches="3" workflowId="51432"/>
