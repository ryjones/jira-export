<Action id="52906" issue="34997" author="sklump" type="comment" body="Using python subprocess.Popen() promises to work around this issue. As such I&apos;ve reduced its priority to LOW." created="2018-11-01 15:59:52.0" updateauthor="sklump" updated="2018-11-01 15:59:52.0"/>
<Action id="54016" issue="34997" author="mattraffel" type="comment" created="2018-11-29 16:33:20.0" updateauthor="mattraffel" updated="2018-11-29 17:04:21.0"> <body><! CDATA 1) the expectation is calling blob_storage.open_writer leaves a process still running after the test completes.  I do not see this as happening. 2) the test crashes on somewhere during the return of blob_storage.open_writer  and before the process gets to back to test_fork (which probably explains #1 above)  Output from run attached as test_output.txt   ^test_output.txt    FYI: other ledger tests run successfully.  More information.  Looking at the logs, I do see statement like  {noformat} Grandchild process 4453 calling blob_storage.open_writer() {noformat} .  however, when the test run is over, that process does not exist.     {noformat} matt.raffel@mattraffel:~$ kill 4453 -bash: kill: (4453) - No such process {noformat}   ></body> </Action>
<Action id="54213" issue="34997" author="mattraffel" type="comment" created="2018-12-03 19:21:54.0" updateauthor="mattraffel" updated="2018-12-03 19:25:34.0"> <body><! CDATA The problem is as described below (from a rocket chat discussion with  ~sklump ) {noformat} "A fork duplicates only the main thread. The command executor is a separate thread, so it never gets duplicated. If any out-of-process requirements are possible, the caller must fork first before any calls to libindy. Then the subprocess will instantiate its own command executor thread." {noformat}   The following reproduces the problem in rust:   {noformat} use nix::unistd::{fork, ForkResult}; use nix::sys::wait::wait; use std::os::unix::process;   extern crate nix;  # test  fn test_mlt() { use std::thread;  use std::sync::mpsc::{Sender, channel}; let (sender, receiver) = channel();  println!("main"); sender.send("main");  thread::spawn(move || { match fork() { Ok(ForkResult::Parent { child, .. }) => { println!("parent"); sender.send("parent"); } Ok(ForkResult::Child) => { println!("child"); sender.send("child"); } Err(_) => println!("Fork failed"), } for i in 0..10 { thread::sleep(::std::time::Duration::from_secs(5)); println!("pid 1 {}", ::std::process::id()); //            let ev = receiver.recv(); //            println!("received: {:?}", ev); } }); match fork() { Ok(ForkResult::Parent { child, .. }) => { println!("parent"); sender.send("parent"); } Ok(ForkResult::Child) => { println!("child"); sender.send("child"); } Err(_) => println!("Fork failed"), }  println!("pid 2 {}", ::std::process::id()); thread::sleep(::std::time::Duration::from_secs(50)); } {noformat}      ></body> </Action>
<Action id="54243" issue="34997" author="artemkaaas" type="comment" created="2018-12-04 07:01:03.0" updateauthor="artemkaaas" updated="2018-12-04 07:01:03.0"> <body><! CDATA I added it to the main Libindy Read.me https://github.com/hyperledger/indy-sdk/pull/1333  ></body> </Action>
