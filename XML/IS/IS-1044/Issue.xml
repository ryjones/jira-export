<Issue id="34865" key="IS-1044" number="1044" project="10401" reporter="danielhardman" assignee="esplinr" creator="danielhardman" type="10002" summary="need build artifact (or build command) that enumerates dependencies" priority="3" status="10405" created="2018-10-24 17:15:15.0" updated="2020-03-24 15:53:28.0" votes="0" watches="3" workflowId="50712"> <description><! CDATA Sooner or later, developers that build atop Indy SDK may run into an infosec or regulatory compliance requirement like this one:  "Besides the immediate source that you have placed in the open, please tell me about each dependency that you have, along with the corresponding versions, licenses, and source code for those dependencies."  This may be required, for example, to satisfy an organization that wishes to develop proprietary code against libindy without fear that there's a copyleft provision lurking somewhere in the stack.  Because the source code is open, these dependencies can be discovered with enough effort–and I think it's okay for consumers of the codebase to feel some duty to solve the problem themselves, since we can't anticipate all possible ways the code will be consumed. For example, today a developer could find libindy's Cargo.toml file and examine the  dependencies  section, and have a moderately good start on answering this question. However, there are subtleties–for example, does libindy's java wrapper introduce java dependencies that a consumer of the codebase should know about, over and above the Rust ones? Is there a python library somewhere, but it's only a dependency of the test automation, instead of being a dependency of the python wrapper at runtime?  Making this all the more complicated is that answers to these more subtle questions may change without notice.  For these reasons, I think it's worthwhile to provide some ready answers to this need, somewhat alleviating the burden of consumers of the codebase.  What we need is a build artifact (or a build command that produces an artifact) that is maintained by the developers, and that is assigned the job of accurately reporting runtime dependencies at any given point in time. I imagine this artifact to be a text file that contains sections for each binary produced by the build, listing its runtime dependencies, something like this:  {{ libindy.so }}  {{rusqlite=Rust crate, version =0.13.0, MIT license}}  {{rust-openssl=Rust crate, version >=0.10.12, Apache 2 license}}  {{openssl=system library, version >=1.1.1, Apache 1 license}}  {{ python wrapper }}  {{requests=pypi, version >= 2.18, Apache 2 license}}  The logic behind this info could be a simple python script that opens several different Cargo.toml files and combines the  dependencies  sections, suppressing anything that is not a runtime dependency, and supplementing this with a quick peek into pypi / npm manifests or equivalent structures for other programming ecosystems relevant to the codebase. The output of the script could be a file with a standard name (perhaps, "runtime-dependencies.txt"?).     ></description> </Issue>
