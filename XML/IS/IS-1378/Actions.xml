<Action id="64258" issue="42417" author="artemkaaas" type="comment" created="2019-10-02 11:41:54.0" updateauthor="artemkaaas" updated="2019-10-02 13:54:11.0"> <body><! CDATA *Issue*:   What transport to use?  * Update Agency that it be able to collect messages on User associated Agent and add an endpoint/message_type for getting them. This way we can move pairwise connection establishing onto VCX level. We use agency only as an endpoint for collection incoming messages. *   Transports Return Route (https://github.com/hyperledger/aries-rfcs/tree/master/features/0092-transport-return-route)?  *Connection*:  Current VCX flow  Inviter: 1) vcx_connection_create -> state.Initialized = 1 2) vcx_connection_connect -> prepares invite (share somehow) and move state.OfferSent = 2 3) vcx_connection_update_state -> until get invite response and next move state.VcxStateAccepted = 4  Invitee: 1) vcx_connection_create_with_invite -> state.VcxStateRequestReceived = 3 2) vcx_connection_connect -> send invite response and move to state.VcxStateAccepted = 4  Aries flow  Inviter:  1) vcx_connection_create -> state.Initialized = 1 2) vcx_connection_connect -> prepares invite (print and next share somehow) -> move state.Invited = 2 3) vcx_connection_update_state -> wait until get `connection_request` -> move state.Requested = 3 -> send `connection_request` -> move state.Responded = 4 -> wait until get `ack` -> move state.Accepted = 5  Invitee: 1) vcx_connection_create_with_invite -> state.Invited = 2 2) vcx_connection_connect -> send `connection_request` and move to state.Requested = 3 3) vcx_connection_update_state -> wait until get `connection_request` -> move state.Responded = 4 -> send `ack` -> move state.Accepted = 5    Difference: - different number of states but we can hide it under `vcx_connection_update_state` function for both Inviter and Invitee - Inviter should wait for ack - Invitee should wait to respond message and send ack - sending and handling of Error Messages as described here: https://github.com/hyperledger/aries-rfcs/tree/master/features/0160-connection-protocol#errors    *Credential Issuance*  Current VCX flow:  Issuer: 1) vcx_issuer_create_credential -> state.Initialized = 1 2) vcx_issuer_send_credential_offer -> send Offer and move state.OfferSent = 2 3) vcx_issuer_credential_update_state -> wait until get CredentialRequest -> move state.VcxStateRequestReceived = 3 4) vcx_issuer_send_credential -> send Credential -> move state.VcxStateAccepted = 4 5) vcx_issuer_credential_update_state -> wait until state.Accepted    Holder: 1) vcx_credential_get_offers -> wait until get offer ----> offer json 2) vcx_credential_create_with_offer -> state.VcxStateRequestReceived = 3 3) vcx_credential_send_request -> send CredentialRequest -> move state.OfferSent = 2 4) vcx_credential_update_state -> wait until get Credential -> move state.VcxStateAccepted = 4   Aries flow: https://github.com/hyperledger/aries-rfcs/tree/master/features/0036-issue-credential  Issuer: 1) vcx_issuer_create_credential -> state.Initialized = 1 2) vcx_issuer_send_credential_offer -> send Offer -> move state.OfferSent = 2 3) vcx_issuer_credential_update_state -> wait until get CredentialRequest -> move state.RequestReceived = 3 4) vcx_issuer_send_credential -> send Credential -> move state.CredentialSend = 4 5) vcx_issuer_credential_update_state -> wait until `ack` -> move state.Accepted = 5  Holder: 1) vcx_credential_get_offers -> wait until get offer ----> offer json 2) vcx_credential_create_with_offer -> state.OfferReceived = 3 3) vcx_credential_send_request -> send CredentialRequest -> move state.RequestSend = 2 4) vcx_credential_update_state -> wait until get Credential -> move state.CredentialReceived = 4 -> send ack -> move state.Accepted = 5   Difference: - new functions for start with CredentialProposal:  Issuer: vcx_issuer_get_credential_proposols and vcx_issuer_create_credential_with_proposol Holder: vcx_credential_create_with_proposol and vcx_credential_send_proposol  - Issuer start with CredentialRequest  -- new function vcx_issuer_create_credential_with_request will create object with state.RequestReceived = 3 - Issuer handle CredentialProposal from OfferSent state -- Reject or Continue - Handle CredentialRejects on every state   *ProofPresentation*  Current VCX flow:  Verifier: 1) vcx_proof_create -> state.Initialized = 1 2) vcx_proof_send_request -> send ProofRequest -> move state.OfferSent = 2    3) vcx_proof_update_state -> wait until get Proof -> move state.VcxStateAccepted = 4/ state.RequestReceived = 3  Prover: 1) vcx_disclosed_proof_get_requests ->  wait until get proof request ----> proof request json 2) vcx_disclosed_proof_create_with_request -> state.RequestReceived = 3 3) vcx_disclosed_proof_send_proof -> send Proof -> move state.VcxStateAccepted = 4  Aries flow: Verifier: 1) vcx_proof_create -> state.Initialized = 1 2) vcx_proof_send_request -> send ProofRequest -> move state.ProofRequestSent = 2   3) vcx_proof_update_state -> wait until get Proof -> move state.VcxStateAccepted = 4/ state.RequestReceived = 3 -> send ack or reject   Prover: 1) vcx_disclosed_proof_get_requests -> wait until get proof request ----> proof request json 2) vcx_disclosed_proof_create_with_request -> state.RequestReceived = 3 3) vcx_disclosed_proof_send_proof -> send Proof -> move state.ProofSent = 4   4) vcx_disclosed_proof_update_state -> until get ack -> move state.Accepted = 5/ state.Rejected = 3   Difference: - Verifier handle ProofProposal ??? create proof request or reject - Handle ProofReject - Prover should wait until ProofAccepted (call vcx_disclosed_proof_update_state)   *Message encoding* Vcx already support  Encryption Envelope (https://github.com/hyperledger/aries-rfcs/tree/master/features/0019-encryption-envelope) RFC.     ></body> </Action>
