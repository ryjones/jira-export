<Issue id="42929" key="IS-1410" number="1410" project="10401" reporter="magicindustries" assignee="sergey.minaev" creator="magicindustries" type="10004" summary="Unclosed Threads / Mutex Lock in CommandExecutor" priority="3" status="10405" created="2019-10-22 03:49:55.0" updated="2020-03-31 13:19:54.0" votes="0" watches="3" workflowId="56031"> <environment><! CDATA I ran these tests on a Macbook Pro 2018 running macOS High Sierra 10.13.6 with Unity 2019.6.2f1, Mono 6.0, Rustc 1.38.0, .Net 2.2.106 / 3.0.   I've also tested the same problem on a current gen Windows laptop running Windows 10 Home and everything else the same specs  ></environment> <description><! CDATA Test Repository:  https://github.com/MagicIndustries/IndyThreadErrors      I am calling libindy from Unity3D (C#) using the dotnet wrapper. We had problems where everything would work fine the first time we hit "play" in Unity, then we stop, hit play again and Unity freezes, and has to be forcibly shut down.  It turns out that for every command we tried, the same thing occurred - a thread is left hanging that the debugger knows nothing about - one started inside libindy.   If you comment out the execution of callbacks like on line 50 of api/pool.rs ("cb(command_handle, err)") then the error doesn't occur - it only happens when there are callbacks executed. But test methods with the same callback signatures added to the library did work.  The problem is actually the Mutex on line 91 of commands/mod.rs:  pub fn instance<'mutex>() -> MutexGuard<'mutex, CommandExecutor> \{    COMMAND_EXECUTOR.lock().unwrap()}  I found if I changed the call on line 43 from this      let result = CommandExecutor::instance()     to this:      let result = CommandExecutor::new()  And added the lock command on line 102 of commands/mod.rs like so:      COMMAND_EXECUTOR.lock().unwrap();  This fixes my problem, and stops the freeze - no more hanging threads. I am a rust noob and specifically I don't understand the reasons behind the way the instance method for CommandExecutor is setup, so I need some help to write a more permanent fix.  One other note - I tried assigning the mutex guard to a variable within the loop and dropping it manually at the end but it didn't seem to have an effect on the freezing issue.  In the attached code I reverted back to direct interaction with libindy rather than via the wrapper to eliminate possibilities while I tracked down the bug.  TestScript.cs is a C# file used in Unity, simply attached to a gameobject. It manually loads and unloads the DLLs (dylib) but apart from that it creates data, delegates and pointers for the indy_create_pool_ledger_config() function then executes the function passing it a callback.  It all works, the libindy library executes the command and passes the appropriate response, finally executing the callback in C#.  To Replicate: 1) Load the test repo project in Unity 2019.2.6f1 (free personal copy is fine)  2) Once loaded, click the play button to start the program.The console should look like this:      1. Rust Command Called      2. Callback Executed  3) Press the play button again to stop execution.  4) Press the play button a third time, and the Unity editor should become unresponsive.  If you control execution from a debugger (Visual Studio or Rider) and put a breakpoint during the OnApplicationQuit at line 80 of TestScript.cs, you can see the dangling thread.     Happy to help with a fix, get me at  toby@magicindustries.net|mailto:toby@magicindustries.net  or as lyricist1 on Skype.     ></description> </Issue>
