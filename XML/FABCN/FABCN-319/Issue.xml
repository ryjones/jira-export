<Issue id="19347" key="FABCN-319" number="319" project="11207" reporter="jimthematrix" assignee="zhaochy" creator="jimthematrix" type="10003" summary="SDK support - node.js SDK" priority="3" resolution="10000" status="6" created="2017-07-19 03:45:07.0" updated="2020-11-10 15:59:05.0" resolutiondate="2017-09-22 12:24:15.0" votes="0" watches="1" timeoriginalestimate="144000" timeestimate="0" timespent="144000" workflowId="39491"> <description><! CDATA The current "protocol" how the SDK's responsibility for golang is like this: - given the chaincode path, build a chaincode package that includes all the dependencies - then the SDK sends the package to the peer to install - then the SDK calls the peer to instantiate the chaincode. if instantiating for the first time (it may get instantiated multiple times for different channels), the peer will use the fabric-ccenv environment to build it into native binaries, and package the resulting binary into a custom docker image based on a base image (fabric-baseos for golang).  This protocol can be directly translated to handling node.js chaincode lifecycles like the following: - given the node.js chaincode path, which is expected to be a folder containing the chaincode JS code, plus package.json to declare dependencies - then the SDK sends the package to the peer to install - then the SDK calls the peer to instantiate the chaincode. if instantiating for the first time, the peer will use the fabric-ccenv environment to "build" it by running "npm install -production", and package the resulting folder into a custom docker image based on a base image (fabric-baseos at the moment does not have node.js engine, so we should use fabric-baseimage for now).  Another option is to utilize the CAR support.  ></description> </Issue>
