<Issue id="40394" key="FABCN-309" number="309" project="11207" reporter="jlcs" creator="jlcs" type="10001" summary="MockStub tests &quot;read what you write&quot;, opposed to actual behaviour" priority="3" status="10100" created="2019-06-04 15:23:25.0" updated="2020-11-18 10:54:15.0" votes="0" watches="1" workflowId="60258"> <description><! CDATA Fabric doesn't allow "read what you write" in the same proposal transaction, i.e. calling `stub.getState(key)` after a `stub.putState(key, newvalue)` will retrieve oldvalue instead of newvalue.  In the test at mockstub_test.go#L242 :   https://github.com/hyperledger/fabric/blob/eca1b14b7e3453a5d32296af79cc7bad10c7673b/core/chaincode/shim/mockstub_test.go#L242      while testing empty states, it does it by a "read what you write" strategy.        I have confirmed Fabric is "no read what you write" with this sample code, where the functions relating to writing to or reading from ledger just stringify/parse with JSON and transform to/from Buffer: {noformat} try { await saveJSONObjectToLedger(stub, "mahKey", "hello there"); let value = await getJSONObjectFromLedger(stub, "mahKey"); console.log("mahValue = " + value); await saveJSONObjectToLedger(stub, "mahKey", "goodbye there"); value = await getJSONObjectFromLedger(stub, "mahKey"); console.log("mahValue = " + value); } catch(err) { logger.warn("AccessControl.InvokePrenda.ChaincodeState: " + JSON.stringify(err, Object.getOwnPropertyNames(err))); }{noformat} The output in the peer chaincode docker is: {noformat} mahValue = goodbye there mahValue = goodbye there {noformat} meaning that the `hello there` written first cannot be read until after transaction commitment.  ></description> </Issue>
