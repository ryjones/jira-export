<Issue id="39601" key="FABCN-34" number="34" project="11207" reporter="sstone1" assignee="davidkel" creator="sstone1" type="10000" summary="Async iterator support for Node.js chaincode stub APIs" priority="3" resolution="10000" status="6" created="2019-05-03 14:11:53.0" updated="2019-11-30 21:14:00.0" resolutiondate="2019-07-27 13:03:25.0" votes="0" watches="2" workflowId="56852"> <description><! CDATA The following Node.js chaincode stub APIs return iterator objects:  * getHistoryForKey * getPrivateDataByPartialCompositeKey * getPrivateDataByRange * getPrivateDataQueryResult * getQueryResult * getQueryResultWithPagination * getStateByPartialCompositeKey * getStateByPartialCompositeKeyWithPagination * getStateByRange * getStateByRangeWithPagination  These are quite complex to use, as the iterators are asynchronous, and the code seems overly complex for what the user is trying to accomplish:  https://github.com/hyperledger/fabric-samples/blob/release-1.4/chaincode/fabcar/typescript/src/fabcar.ts#L107  Fabric v2.0 has updated to Node.js v10 which includes support for "for await of", allowing users to write simple code that iterates over an asynchronous iterator.  A bit of prototyping shows that it is possible to extend our existing code to support the new AsyncIterable interface, whilst maintaining compatibility with existing smart contract code (I think this would be ideal):  {code:javascript} getQueryResult(query) { // can't be async as we need to edit the returned promise // Access public data by setting the collection to empty string const collection = ''; 		const promise = this.handler.handleGetQueryResult(collection, query, null, this.channel_id, this.txId).then((result) => result.iterator); 		promise Symbol.asyncIterator  = () => { // this is the magic bit 			let iterator; 			return { 				next: async () => { 					if (!iterator) { 						iterator = await promise; 					} 					return iterator.next(); 				} 			}; 		}; return promise; } {code}  This change results in much simpler user contract code:  {code:javascript} async forAwaitOfQuery(ctx, query) { const result =   ; for await (const {key, value} of ctx.stub.getQueryResult(query)) { result.push(value.toString('utf8')); } return JSON.stringify(result); } {code}  One thing to note is that the Iterable and AsyncIterable contracts state that the iterators next() function should not return a value and done = true - from what I've seen, the done flag is checked first, iteration stops, and the value is ignored.   ></description> </Issue>
