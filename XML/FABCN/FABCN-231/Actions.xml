<Action id="58518" issue="38709" author="mbwhite" type="comment" created="2019-03-25 15:57:58.0" updateauthor="mbwhite" updated="2019-03-25 15:57:58.0"> <body><! CDATA There is no intentional data manipulation, and the level of the API you're working at (the init/invoke) level works purely in terms of buffers - the data format within that is entirely left to the developer of the chaincode.Â  Â You are free to choose the format that you wish - the only thing is when you give it to the `shim.success()` it has to be a buffer.  Firstly I would suggest taking a look at the updated programming model - that doesn't need you to return buffers and you might find it easier to work with.Â   Though you are perfectly fine to keep working with the init/invoke apiÂ however I'm a bit confused as the exact sequence of calls... Your StackOverflow is referringÂ toÂ Â other systems.Â  Is this purely between chaincodesÂ that you believe that is data modification.Â   Â   Â   Â   Â   Â  Â  Â   ></body> </Action>
<Action id="58540" issue="38709" author="florianc" type="comment" created="2019-03-26 07:54:57.0" updateauthor="florianc" updated="2019-03-26 07:54:57.0"> <body><! CDATA Thank you for your response  ~mbwhite .  I unfortunately cannot use the new programming model as I work with IBM Blockchain platform that is using Fabric 1.2.1.  Indeed my stackoverflow is not very clear about fabric. It is because I originally wanted to make it a javascript question and not a Fabric one.  The flow is actually quite simple: I call a "query" function in a chaincode from another chaincode and return data as the getState gives it to me. But as shown in the example, when retrieving the data, some unicode characters come in at the beginning of the buffer and the channel ID is put at the end of the buffer, forcing me to extract the data with custom function.  So far it is not really a problem as my data, in JSON, are quite simple (no nesting or anything else), but in the case of complex objects, extracting data from this result would become quite hard.  ></body> </Action>
<Action id="58564" issue="38709" author="mbwhite" type="comment" created="2019-03-26 13:27:51.0" updateauthor="mbwhite" updated="2019-03-26 13:27:51.0"> <body><! CDATA Thanks  ~florianc  ..  On the Fabric1.2.1 topic you are able to use the Chaincode side - as the chaincode programming model sits on top of the shim rather than replaces it - the protocol between the shim and the peer is unchanged. If you wrote your chaincode using `fabric-contract-api@1.4.0` andÂ `fabric-contract-api@1.4.0` `fabric-shim@1.4.0` you should be good to go.  To confirm you usecase..Â is this correct?  Â   let response = await stub.invokeChaincode('secondChaincode', 'fna' ,'secondChannel)  let str = response.payload.toString('utf8')  let obj = JSON.parse(str)  Â   Â   ></body> </Action>
<Action id="58630" issue="38709" author="florianc" type="comment" created="2019-03-27 12:55:02.0" updateauthor="florianc" updated="2019-03-27 12:55:51.0"> <body><! CDATA Not exactly what I am using. So far I am using: {color:#569cd6}var{color}{color:#d4d4d4} bufferIdentity {color}{color:#d4d4d4}={color} {color:#569cd6}await{color}{color:#d4d4d4} stub.invokeChaincode({color}{color:#ce9178}'secondchaincode'{color}{color:#d4d4d4}, myquery, {color}{color:#ce9178}"sameOrDifferentChannel"{color}{color:#d4d4d4});{color}  {color:#569cd6}var{color}{color:#d4d4d4} stringifiedIdentity {color}{color:#d4d4d4}={color}{color:#d4d4d4} JSON.stringify(bufferIdentity);{color} {color:#569cd6}var{color}{color:#d4d4d4} bufferData {color}{color:#d4d4d4}={color}{color:#d4d4d4} Buffer.from(JSON.parse(stringifiedIdentity).payload.buffer.data).toString();{color} With this, I get the altered data. But before going further, with the "old" programming model, in my functions, shoud I: * Return my data without doing anything to it (like a JSON, a string, etc)  {color:#569cd6}return{color}{color:#d4d4d4} myJson;{color} * Return my data as a buffer  {color:#569cd6}return{color}{color:#d4d4d4} Buffer.from(myJson);{color} Â   I am asking this because I am getting confused while reading more about this. * Does shims.success already build the buffer? * Do I have to return data in a buffer I made myself?  Â   No one in rocket.chat was able to answer clearly this question.  Â   Â   ></body> </Action>
<Action id="58635" issue="38709" author="mbwhite" type="comment" created="2019-03-27 14:16:16.0" updateauthor="mbwhite" updated="2019-03-27 14:16:16.0"> <body><! CDATA The shim.success() is expecting a buffer, that you've created, to be supplied as an argument. If one is not supplied at all, then an empty buffer is created for you; but this is the only time the buffer is created.  This buffer can contain data in whatever format you like; typically it will be an object made into JSON, and then put into a Buffer in utf8 format.  Â   So always return the data in a buffer constructed yourself.  Â   Â   ></body> </Action>
<Action id="58640" issue="38709" author="florianc" type="comment" created="2019-03-27 15:45:01.0" updateauthor="florianc" updated="2019-03-27 15:45:01.0"> <body><! CDATA Alright. Then I have made a mistake somewhere. Thank you very much for your support.  I will most likely be able to check/fix my work next week. I will come back to you ASAP (and I hope we can close this issue).  Â   ></body> </Action>
<Action id="58670" issue="38709" author="florianc" type="comment" created="2019-03-28 12:23:07.0" updateauthor="florianc" updated="2019-03-28 12:23:07.0"> <body><! CDATA Hi. I did a test, and unfortunately I got the same result as before:  I have a function in chaincode B that queries the ledger and returns the result: {color:#569cd6}async{color}{color:#d4d4d4} query(stub, args) {{color} {color:#d4d4d4} console.info({color}{color:#ce9178}'============= START : Query method ==========='{color}{color:#d4d4d4});{color} {color:#569cd6}if{color}{color:#d4d4d4} (args.length {color}{color:#d4d4d4}!={color} {color:#b5cea8}1{color}{color:#d4d4d4}) {{color} {color:#569cd6}throw{color} {color:#569cd6}new{color}{color:#d4d4d4} Error({color}{color:#ce9178}'Incorrect number of arguments. Expecting 1'{color}{color:#d4d4d4});{color} {color:#d4d4d4} }{color}  {color:#569cd6}let{color}{color:#d4d4d4} query {color}{color:#d4d4d4}={color}{color:#d4d4d4} args {color}{color:#b5cea8}0{color}{color:#d4d4d4} ;{color} {color:#569cd6}let{color}{color:#d4d4d4} queryAsBytes {color}{color:#d4d4d4}={color} {color:#569cd6}await{color}{color:#d4d4d4} stub.getState(query);{color} {color:#569cd6}if{color}{color:#d4d4d4} ({color}{color:#d4d4d4}!{color}{color:#d4d4d4}queryAsBytes {color}{color:#d4d4d4}||{color}{color:#d4d4d4} queryAsBytes.toString().length {color}{color:#d4d4d4}<={color} {color:#b5cea8}0{color}{color:#d4d4d4}) {{color} {color:#569cd6}throw{color} {color:#569cd6}new{color}{color:#d4d4d4} Error({color}{color:#ce9178}'key'{color} {color:#d4d4d4}+{color} {color:#ce9178}' does not exist: '{color}{color:#d4d4d4});{color} {color:#d4d4d4} }{color} {color:#d4d4d4} console.info({color}{color:#ce9178}'============= END : Query method ==========='{color}{color:#d4d4d4});{color} {color:#569cd6}let{color}{color:#d4d4d4} toReturn {color}{color:#d4d4d4}={color}{color:#d4d4d4} Buffer.from(JSON.stringify(queryAsBytes));{color} {color:#569cd6}return{color}{color:#d4d4d4} toReturn;{color}  {color:#d4d4d4} }{color} Â   The function is invoked from chaincode A with the following: {color:#569cd6}async{color}{color:#d4d4d4} createBadge(stub, args) {{color} {color:#d4d4d4} console.info({color}{color:#ce9178}'============= START : Create Badge ==========='{color}{color:#d4d4d4});{color} {color:#569cd6}if{color}{color:#d4d4d4} (args.length {color}{color:#d4d4d4}!={color} {color:#b5cea8}6{color}{color:#d4d4d4}) {{color} {color:#569cd6}throw{color} {color:#569cd6}new{color}{color:#d4d4d4} Error({color}{color:#ce9178}'Incorrect number of arguments. Expecting 6, got '{color} {color:#d4d4d4}+{color}{color:#d4d4d4} args.length);{color} {color:#d4d4d4} }{color}  {color:#6a9955}// Get the badge creator identity from the identity-manager chaincode{color} {color:#569cd6}var{color}{color:#d4d4d4} query{color}{color:#d4d4d4}={color}{color:#d4d4d4}  {color} {color:#ce9178}"query"{color}{color:#d4d4d4},{color} {color:#d4d4d4} args {color}{color:#b5cea8}5{color}{color:#d4d4d4} {color} {color:#d4d4d4}  ;{color} {color:#569cd6}try{color}{color:#d4d4d4} {{color} {color:#569cd6}var{color}{color:#d4d4d4} bufferIdentity {color}{color:#d4d4d4}={color} {color:#569cd6}await{color}{color:#d4d4d4} stub.invokeChaincode({color}{color:#ce9178}'identity-manager'{color}{color:#d4d4d4}, query, {color}{color:#ce9178}"defaultchannel"{color}{color:#d4d4d4});{color}  {color:#d4d4d4} console.log({color}{color:#ce9178}"TEST "{color} {color:#d4d4d4}+{color}{color:#d4d4d4} Buffer.from(bufferIdentity.payload.buffer).toString({color}{color:#ce9178}'utf-8'{color}{color:#d4d4d4}));{color} Â   It returns me the following result:  {{ï¿½ï¿½ï¿½\{"type":"Buffer","data": 123,34,99,111,109,112,97,110,121,34,58,34,105,98,109,34,44,34,101,109,97,105,108,34,58,34,105,98,109,64,97,100,109,105,110,46,99,111,109,34,44,34,102,105,114,115,116,78,97,109,101,34,58,34,97,100,109,105,110,34,44,34,108,97,115,116,78,97,109,101,34,58,34,97,100,109,105,110,34,44,34,112,114,111,118,105,100,101,114,73,100,34,58,34,108,101,100,103,101,114,73,110,105,116,34,44,34,114,111,108,101,34,58,34,99,104,97,105,110,46,97,100,109,105,110,105,115,116,114,97,116,111,114,34,44,34,115,116,97,116,117,115,34,58,34,79,75,34,125 }"@a5dadb0af706a18dd0eb43736a1ce3268187c4643a3c9d5d454e48d86d32a4b5:defaultchannel}}  Â   The buffer only stringified (JSON.stringify) returns:  {color:#2d2d2d}{"status":200,"message":"","payload":\{"buffer":{"type":"Buffer","data": 8,6,26,177,4,8,200,1,26,171,4,123,34,116,121,112,101,34,58,34,66,117,102,102,101,114,34,44,34,100,97,116,97,34,58,91,49,50,51,44,51,52,44,57,57,44,49,49,49,44,49,48,57,44,49,49,50,44,57,55,44,49,49,48,44,49,50,49,44,51,52,44,53,56,44,51,52,44,49,48,53,44,57,56,44,49,48,57,44,51,52,44,52,52,44,51,52,44,49,48,49,44,49,48,57,44,57,55,44,49,48,53,44,49,48,56,44,51,52,44,53,56,44,51,52,44,49,48,53,44,57,56,44,49,48,57,44,54,52,44,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,44,52,54,44,57,57,44,49,49,49,44,49,48,57,44,51,52,44,52,52,44,51,52,44,49,48,50,44,49,48,53,44,49,49,52,44,49,49,53,44,49,49,54,44,55,56,44,57,55,44,49,48,57,44,49,48,49,44,51,52,44,53,56,44,51,52,44,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,44,51,52,44,52,52,44,51,52,44,49,48,56,44,57,55,44,49,49,53,44,49,49,54,44,55,56,44,57,55,44,49,48,57,44,49,48,49,44,51,52,44,53,56,44,51,52,44,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,44,51,52,44,52,52,44,51,52,44,49,49,50,44,49,49,52,44,49,49,49,44,49,49,56,44,49,48,53,44,49,48,48,44,49,48,49,44,49,49,52,44,55,51,44,49,48,48,44,51,52,44,53,56,44,51,52,44,49,48,56,44,49,48,49,44,49,48,48,44,49,48,51,44,49,48,49,44,49,49,52,44,55,51,44,49,49,48,44,49,48,53,44,49,49,54,44,51,52,44,52,52,44,51,52,44,49,49,52,44,49,49,49,44,49,48,56,44,49,48,49,44,51,52,44,53,56,44,51,52,44,57,57,44,49,48,52,44,57,55,44,49,48,53,44,49,49,48,44,52,54,44,57,55,44,49,48,48,44,49,48,57,44,49,48,53,44,49,49,48,44,49,48,53,44,49,49,53,44,49,49,54,44,49,49,52,44,57,55,44,49,49,54,44,49,49,49,44,49,49,52,44,51,52,44,52,52,44,51,52,44,49,49,53,44,49,49,54,44,57,55,44,49,49,54,44,49,49,55,44,49,49,53,44,51,52,44,53,56,44,51,52,44,55,57,44,55,53,44,51,52,44,49,50,53,93,125,34,64,97,98,49,49,48,100,57,99,97,100,99,98,99,101,102,56,102,102,102,57,57,53,99,98,102,55,54,52,97,52,48,53,50,50,101,97,97,50,55,99,57,49,52,97,102,51,53,99,50,102,49,99,55,54,52,53,100,56,49,54,98,55,54,48,58,14,100,101,102,97,117,108,116,99,104,97,110,110,101,108 },"offset":11,"markedOffset":-1,"limit":566,"littleEndian":true,"noAssert":false}}{color}  Â   {color:#2d2d2d}There are still these weird unicode characters at the beginning and the network ID + channel name at the end. I expect it is a problem from the IBM Blockchain platform?{color}  ></body> </Action>
<Action id="58680" issue="38709" author="florianc" type="comment" created="2019-03-28 13:54:02.0" updateauthor="florianc" updated="2019-03-28 13:54:02.0"> <body><! CDATA Ok. I know why (it is pretty obvious all things considered).  The properties "offset" and "limit" actually represents the "position" of my actual data, without all the other unwanted stuff. So, example to get the data without doing all my for loop stuffs: {color:#d4d4d4}console.log(data.payload.buffer.data.splice({color}{color:#b5cea8}0{color}{color:#d4d4d4},data.payload.offset));{color} {color:#d4d4d4}console.log(data.payload.buffer.data.splice(data.payload.limit {color}{color:#d4d4d4}-{color}{color:#d4d4d4} data.payload.offset, data.payload.buffer.data.length));{color} {color:#569cd6}var{color}{color:#d4d4d4} buf {color}{color:#d4d4d4}={color}{color:#d4d4d4} Buffer.from(data.payload.buffer.data).toString();{color} {color:#d4d4d4}console.log(buf);{color} {color:#569cd6}var{color}{color:#d4d4d4} json {color}{color:#d4d4d4}={color}{color:#d4d4d4} JSON.parse(Buffer.from(JSON.parse(buf)).toString());{color} {color:#d4d4d4}console.log(json){color} Â   Et voila!  Â   Thank you for your support and sorry for brigging here a problem that does not concern fabric. This issue can be closed.  Â   ></body> </Action>
<Action id="58682" issue="38709" author="mbwhite" type="comment" created="2019-03-28 14:28:46.0" updateauthor="mbwhite" updated="2019-03-28 14:28:46.0"> <body><! CDATA Pleased it's working - I'd also suggest just trying payload.buffer.toString('utf8')Â  I don't think you need to go so far into the data structure.  My local test that was ok .  ></body> </Action>
