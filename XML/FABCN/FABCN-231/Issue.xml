<Issue id="38709" key="FABCN-231" number="231" project="11207" reporter="florianc" assignee="mbwhite" creator="florianc" type="10000" summary=" NODEJS shim  invokeChaincode alters returned data" priority="3" resolution="10203" status="6" created="2019-03-25 10:08:22.0" updated="2019-11-30 21:14:52.0" resolutiondate="2019-03-28 14:39:28.0" votes="0" watches="2" workflowId="57049"> <description><! CDATA This happens using the Nodejs fabric-shim.  I have two chaincodes, chaincode A (CCA) and chaincode B (CCB).  CCB invoke CCA to get data stored into its worldstate with invokeChaincode function.     CCA pass the following data into the shim.success() function: {code:java} {\"company\":\"ad\",\"email\":\"ad@i.com\",\"firstName\":\"ad\",\"lastName\":\"ad\",\"providerId\":\"ad\",\"role\":\"ad\",\"status\":\"ad\"}{code} CCA code:    {code:java} var Chaincode = class { Init(stub) { return shim.success(); } async Invoke(stub) { let ret = stub.getFunctionAndParameters(); console.info(ret); let method = this ret.fcn ; if (!method) { console.error('no function of name:' + ret.fcn + ' found'); throw new Error('Received unknown function ' + ret.fcn + ' invocation'); } try { let payload = await method(stub, ret.params); return shim.success(payload); } catch (err) { console.info(err); return shim.error(err); } } async query(stub, args) { console.info('============= START : Query method ==========='); if (args.length != 1) { throw new Error('Incorrect number of arguments. Expecting 1'); }  let query = args 0 ; let queryAsBytes = await stub.getState(query); if (!queryAsBytes || queryAsBytes.toString().length <= 0) { throw new Error('key' + ' does not exist: '); } console.log("IN IDENTITY " + queryAsBytes.toString()); console.info('============= END : Query method ==========='); return queryAsBytes;  } }; {code}     CCB receives the following data: {code:java} \b\u0006\u001au\b�\u0001\u001ap{\"company\":\"ad\",\"email\":\"ad@i.com\",\"firstName\":\"ad\",\"lastName\":\"ad\",\"providerId\":\"ad\",\"role\":\"ad\",\"status\":\"ad\"}\"@736084b8ec863778a2d4825198fbfb7463313cfc03e0247c1e987ab5215dda95:\u000edefaultchannel\n{code}   The same data, but as buffer (original format received): {code:java} {\"status\":200,\"message\":\"\",\"payload\":{\"buffer\":{\"type\":\"Buffer\",\"data\": 8,6,26,117,8,200,1,26,112,123,34,99,111,109,112,97,110,121,34,58,34,97,100,34,44,34,101,109,97,105,108,34,58,34,97,100,64,105,46,99,111,109,34,44,34,102,105,114,115,116,78,97,109,101,34,58,34,97,100,34,44,34,108,97,115,116,78,97,109,101,34,58,34,97,100,34,44,34,112,114,111,118,105,100,101,114,73,100,34,58,34,97,100,34,44,34,114,111,108,101,34,58,34,97,100,34,44,34,115,116,97,116,117,115,34,58,34,97,100,34,125,34,64,55,51,54,48,56,52,98,56,101,99,56,54,51,55,55,56,97,50,100,52,56,50,53,49,57,56,102,98,102,98,55,52,54,51,51,49,51,99,102,99,48,51,101,48,50,52,55,99,49,101,57,56,55,97,98,53,50,49,53,100,100,97,57,53,58,14,100,101,102,97,117,108,116,99,104,97,110,110,101,108 },\"offset\":9,\"markedOffset\":-1,\"limit\":121,\"littleEndian\":true,\"noAssert\":false}}{code}   CCB code:     {code:java} async createBadge(stub, args) { console.info('============= START : Create Badge ==========='); if (args.length != 6) { throw new Error('Incorrect number of arguments. Expecting 6, got ' + args.length); } // Get the badge creator identity from the identity-manager chaincode var badgeCreatorQuery =   "query", args 5   ; try { //TODO CLEAN CODE var bufferIdentity = await stub.invokeChaincode('identity-manager', badgeCreatorQuery, "defaultchannel"); var jsonIdentity = JSON.stringify(bufferIdentity); console.log("L41 " + jsonIdentity); console.log("L42 " + Buffer.from(JSON.parse(jsonIdentity).payload.buffer)); var bufferData = Buffer.from(JSON.parse(jsonIdentity).payload.buffer.data); console.log("L44 " + bufferData); // Other stuff {code}        Despite my questions on  stackoverflow|https://stackoverflow.com/q/55302364/6213883  and on rocket.chat, I have not been able to fix that problem, or to even know if the data modification is supposed to happen or not.   If the data alteration is "normal", then I would recommand to change the function to not do that (unless there is a reason of course). Moreover, It could be quite nice that the function returns exactly the same data in the exact same format that we returned it previously. It would be more intuitive and logical in my opinion.     Alos, the documentation about that function is not clear at all. It just says it returns a promise, but nothing about data format.    ></description> </Issue>
