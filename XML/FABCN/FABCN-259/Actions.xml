<Action id="65666" issue="42808" author="wlahti" type="comment" body="This is specific to how the fabric-contract-api dispatches calls to init and invoke. Tagged this as fabric-sdk-node for now." created="2019-11-20 19:27:17.0" updateauthor="wlahti" updated="2019-11-20 19:27:17.0"/>
<Action id="65796" issue="42808" author="heatherp" type="comment" created="2019-11-27 11:11:16.0" updateauthor="heatherp" updated="2019-11-27 11:11:16.0"> <body><! CDATA Hi  ~Salmandabbakuti  - there is no distinction between smart contract functions that are called on instantiation and any other type of function.   Thoughts: - Why are you calling the init function again on the invoke command?  - Can you update your init function to handle being called after instantiate? i.e. multiple times  ></body> </Action>
<Action id="65906" issue="42808" author="salmandabbakuti" type="comment" body="There are some cases when we wanted to initialize ledger with some predefined values and don&apos;t wanted to override those values once initialized.  just like solidity constructor if you know what I mean? lets say,  there is a key with an Id &quot;admin279&quot; initialized when instantiating chaincode. so this admin Id is used widely particular business application. what if this Id is overrided by malicious user? " created="2019-12-02 16:20:57.0" updateauthor="salmandabbakuti" updated="2019-12-02 16:20:57.0"/>
<Action id="66106" issue="42808" author="heatherp" type="comment" created="2019-12-05 11:54:49.0" updateauthor="heatherp" updated="2019-12-05 11:54:49.0"> <body><! CDATA Hi  ~Salmandabbakuti  I'm not following. If you don't want to "override those values once initialized" - why are you calling init again? You could update your Init function to not override them if they are already initialized if you are calling init again  ></body> </Action>
<Action id="66107" issue="42808" author="salmandabbakuti" type="comment" body="Hello Heather Pollard. do you think I am the only user of business application? there will be plenty of users out there who can initialize init method again for malicious operations for particular business Applications. that&apos;s what I&apos;m talking about man. why you guys are not able to think up to that certainty?" created="2019-12-05 12:22:54.0" updateauthor="salmandabbakuti" updated="2019-12-05 12:22:54.0"/>
<Action id="66339" issue="42808" author="mbwhite" type="comment" created="2019-12-20 12:28:25.0" updateauthor="mbwhite" updated="2019-12-20 12:28:25.0"> <body><! CDATA For others coming to this thread, it's worth reviewing the context, especially with the 2.0.0-beta now available.  In 1.4, when a chaincode was instantiated or upgraded the 'init' function would called (with arguments if supplied). After this when a chaincode was invoked it would call 'invoke' (with arguments if supplied). The chaincode developer would need to provide their own routing/function handling logic... eg for CRUD operations.  With the updated programming model introduced in 1.4; the chaincode developer (or more accurately now the contract developer) would not need to worry about this routing logic it is handled for them. Within this model, each transaction function the developer writes has the same 'status' as other functions. If you call a function 'init' then it's just a choice of name.  There isn't the concept of 'functions that happen specifically and only at instantiation or upgrade'.    As  ~heatherp  notes; if you want to call a tx function at say upgrade you can - but OP's point is that this can be called at any time by anybody - thereby reset the world state;  if you have a function that resets the world state to starting conditions and it's called (accidentally or deliberately) then yes, it will be reset.   Remember though that Fabric is a permissioned system, that in order to get to submit this transaction the user would have had to had some level of access to be able to send the request in the first place.  If the system is open enough to permit this then are potentially bigger problems - eg stopping upgrading to a malicious new chaincode entirely.  As reseting the state would be a big problem - even with just the init semantics - it would be recommended to make sure that it was properly guarded against accidental invocation anyway. Is the correct user invoking it? Is this being called on an upgrade or first instantiation?  Upgrade will, of course, be in the end more common.  If there is any state, does it need to be upgraded or migrated somehow?  It's worth though now reviewing the 2.0.0-beta code and more importantly the lifecycle changes.  The key thing here for this discussion - is that the concept of a distinct 'init' function or phase is not in the updated lifecycle - it has been deprecated.   The Lifecycle epics explain the details behind problems that init causes.  Going forward, therefore; the 1.4 'init' semantics are deprecated - so it's prudent therefore to not rely on this.  True a requirement for some form of state set-up or migration will still exist; this will have to be coded as regular tx function; yes it will need to be invoked at a specific point - however as this is such a critical function for all the organizations, it will have to be orchestrated by the organizations running the peers anyway.  As would upgrading or instantiating in 1.4; it's not something to be done in 5 minutes when you're trying to leave for a long weekend :)  The code for setting up world state, if needed, will have always been in the chaincode - therefore it has always been prudent to protect it.  Future updates to the programming model will look to improving the accessibility of who has submitted a transaction, what org are they from?  What is the data in the world state? What's its schema.  All will help here, and it's important they are delivered for many use cases.   TL;DR:   The contract programming model is working exactly as designed; yes the behavior is different but any chaincode/contract written now on this model will not be sustainable in the long term with the updated lifecycle.  A large proportion of the systems to manage the risk of accidental or otherwise state 'mangling' will be in place for all versions.   I'll close this issue as the code is working as designed, however it has provided a means to discuss the topic fully, so hopefully the above will provide important context for everybody.      ></body> </Action>
