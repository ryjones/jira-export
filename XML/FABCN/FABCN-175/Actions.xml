<Action id="55561" issue="36641" author="yuki-kon" type="comment" created="2019-01-11 20:06:22.0" updateauthor="yuki-kon" updated="2019-01-11 20:06:22.0"> <body><! CDATA I agree with your proposal. We need to improve chaincodeShim to handle data using composite keys efficiently. I made a similar proposal at FAB-10520. I also posted a CR (https://gerrit.hyperledger.org/r/#/c/26943/) to discuss the new APIs. It would be great if you take a look at the JIRA/CR and give some comments on them.   ></body> </Action>
<Action id="56076" issue="36641" author="denyeart" type="comment" created="2019-01-23 06:57:42.0" updateauthor="denyeart" updated="2019-01-23 06:57:42.0"> <body><! CDATA Support for range queries within composite key namespace is planned for a future release under FAB-11281.  Go and Java chaincode has always validated against this. There was a bug in Node.js chaincode where the validation was not occurring, which was fixed in v1.3. See links for more background.  ></body> </Action>
<Action id="56077" issue="36641" author="denyeart" type="comment" body=" ~mbwhite   ~zhaochy  I think the statement above needs to be added to Node.js chaincode release notes in v1.3.1 and v1.4.1, to compensate for the lack of release note in v1.3.0 and v1.4.0." created="2019-01-23 07:00:35.0" updateauthor="denyeart" updated="2019-01-23 07:00:35.0"/>
<Action id="56085" issue="36641" author="mbwhite" type="comment" created="2019-01-23 09:36:42.0" updateauthor="mbwhite" updated="2019-01-23 09:36:42.0"> <body><! CDATA  ~denyeart   I was considering pushing a fix for the problem - simply by checking that the keys for getStateByRange() were either both simple or both composite.  This doesn't break any existing application - nor does it mix the namespaces;  Is another API really necessary?  ></body> </Action>
<Action id="56237" issue="36641" author="denyeart" type="comment" created="2019-01-28 04:16:41.0" updateauthor="denyeart" updated="2019-01-28 04:16:41.0"> <body><! CDATA  ~mbwhite  Underlying existing ledger APIs will return error if composite keys are passed in getStateByRange(). I think a new API is needed as proposed in FAB-11281. For example, how would you specify a query in a composite key namespace with no start key and no end key?   ~manish-sethi   ~Senthil1  may want to provide a 2nd opinion... do you see any path where it would be possible to use the existing range query API but allow composite keys to be passed in?  ></body> </Action>
<Action id="56255" issue="36641" author="senthil1" type="comment" created="2019-01-28 10:29:56.0" updateauthor="senthil1" updated="2019-01-28 10:29:56.0"> <body><! CDATA  ~denyeart  In _GetStateByRange()_, for the _startKey_ and _endKey_, we can allow either only simple keys (as we do now) or only composite keys (modification to the source code needed as chaincode shim throws error).   However, to do a range query on the partialCompositeKey, we need a new API  such as`GetStateByPartialCompositeKeyRange()`. To summarize,   *Existing APIs* * GetStateByRange(startKey, endKey) – keys needs to be simple keys.  * GetStateByPartialCompositeKey(objectType, attributes  ) – a single partial composite key  *Modification to Existing API* * GetStateByRange(startKey, endKey) – if both keys are composite keys, allow instead of throwing an error.  *New APIs* * GetStateByPartialCompositeKeyRange(objectType, startKey_attributes  , objectType, endKey_attributes  ) – two partial composite keys     ></body> </Action>
<Action id="56285" issue="36641" author="yuki-kon" type="comment" created="2019-01-28 21:33:28.0" updateauthor="yuki-kon" updated="2019-01-28 21:33:28.0"> <body><! CDATA  ~Senthil1  Thank you for summarizing the idea. I have a question about the definition of API. - GetStateByRange(startKey, endKey): This API requires application developers to create two composite keys beforehand if we use composite keys. - GetStateByPartialCompositeKeyRange(objectType, startKey_attributes  , objectType, endKey_attributes  ): On the other hand, this API doesn’t require to create partial composite keys beforehand. Is there any reason to change the style of API definition?  ></body> </Action>
<Action id="56307" issue="36641" author="senthil1" type="comment" created="2019-01-29 05:12:43.0" updateauthor="senthil1" updated="2019-01-29 05:12:43.0"> <body><! CDATA  ~yuki-kon  These are just a tentative APIs. It has not been finalised.   Similar to GetStateByPartialCompositeKey(objectType string, attributes   string), I named  GetStateByPartialCompositeKeyRange(). We can in fact, allow the user to construct the partial composite key and pass in as arguments instead of objectType and attributes.   ></body> </Action>
<Action id="56346" issue="36641" author="yuki-kon" type="comment" body=" ~Senthil1  Thanks for your comment. I understand that API is on discussion. Passing objectType and attributes as arguments looks user-friendly. " created="2019-01-29 18:23:53.0" updateauthor="yuki-kon" updated="2019-01-29 18:23:53.0"/>
<Action id="56358" issue="36641" author="denyeart" type="comment" created="2019-01-29 22:30:51.0" updateauthor="denyeart" updated="2019-01-29 22:30:51.0"> <body><! CDATA In this Jira, let's keep focus on the subject API getStateByRange(). For the newly proposed APIs let's use FAB-11281. For getStateByRange(), I assumed we would want to continue to support simple keys only.   ~Senthil1  Are you suggesting that we should modify getStateByRange() to allow composite keys to be passed in?  I thought there would be issues, e.g. how to specify open-ended queries (no start or no end), how to handle if partial composite key is passed in?  How to distinguish partial composite key part from range part?  ></body> </Action>
<Action id="56364" issue="36641" author="senthil1" type="comment" created="2019-01-30 02:01:49.0" updateauthor="senthil1" updated="2019-01-30 02:01:49.0"> <body><! CDATA I see. I thought of partial composite key but missed open ended query though technically it is possible but might look ugly.  For partial composite key, I was suggesting a new API above. Technically, the same old API can be used and we don't need to differentiate between a partial composite key and a full composite key. User would call createcompositekey() with a partial attributes to construct the start and endKey. Then the constructed start and endKey can be used.  Open ended queries on composite key namespace can be done by passing '0x00' as the start key and '0x000xFF' as the endKey instead of empty strings. As you can notice, this does not look good and user should be unaware of simple and composite key namespaces.  Now, I agree that we may not reuse the same range query API for the composite key namespace as the usage of chaincode APIs should look neat without any confusion.  ></body> </Action>
<Action id="56506" issue="36641" author="mbwhite" type="comment" created="2019-02-01 16:21:10.0" updateauthor="mbwhite" updated="2019-02-01 16:21:10.0"> <body><! CDATA Thanks for the inputs to this issue:  For the record I do have a concern about increasing the surface area of the stub api; it is already quite large and this in itself is adding confusion.  I'm also concerned that about the issue of regression - this was observed in systems in use by end consumers;      How does this issue come to a resolution? As a maintainer of chaincode-now and owner of this issue  I would propose the solution I outlined - however as 'new maintainer'  I need to listen to the views of the large community.      ></body> </Action>
