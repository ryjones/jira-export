<Action id="44036" issue="30005" author="mastersingh24" type="comment" body=" ~piyushkumar96  - can you post the contents of your chaincode?  " created="2018-05-08 09:34:08.0" updateauthor="mastersingh24" updated="2018-05-08 09:34:08.0"/>
<Action id="44043" issue="30005" author="piyushkumar96" type="comment" created="2018-05-08 11:20:42.0" updateauthor="piyushkumar96" updated="2018-05-08 11:20:42.0"> <body><! CDATA    First Function  *updateStatus*  async updateStatus(stub , args, thisClass) \{ if (args.length != 2 ) \{ throw new Error(" Incorrect no. of the arguments, Expecting 2 Arguments ") }  let countryid = args 0 ; let status = args 1 ;  let detail1bytes = await stub.getState(args 0 ); if (!detail1bytes || !detail1bytes.toString()) \{ throw new Error("Country does not exist"); }  let countryDetail1 = JSON.parse(detail1bytes); //unmarshal countryDetail1.status = status;  await stub.putState(countryid, Buffer.from(JSON.stringify(countryDetail1)));  }     Second Function *updatePorts*     async updatePorts(stub , args, thisClass) \{ if (args.length != 4 ) \{ throw new Error(" Incorrect no. of the arguments, Expecting 4 Arguments ") }  let countryid = args 0 ; let port1 = args 1 ; let port2 = args 2 ; let port3 = args 3 ;  let detail3bytes = await stub.getState(args 0 ); if (!detail3bytes || !detail3bytes.toString()) \{ throw new Error("Country does not exist"); }  let countryDetail3 = JSON.parse(detail3bytes); //unmarshal countryDetail3.peer0port = port1; countryDetail3.peer1port = port2; countryDetail3.reqport = port3;  await stub.putState(countryid, Buffer.from(JSON.stringify(countryDetail3)));  }              ></body> </Action>
<Action id="44235" issue="30005" author="piyushkumar96" type="comment" body=" ~mastersingh24  what happens ? Is this issue is resolved or Not." created="2018-05-11 12:14:12.0" updateauthor="piyushkumar96" updated="2018-05-11 12:14:12.0"/>
<Action id="61037" issue="30005" author="mastersingh24" type="comment" created="2019-06-16 10:39:00.0" updateauthor="mastersingh24" updated="2019-06-16 10:41:04.0"> <body><! CDATA  ~piyushkumar96   - have you actually looked at the peer logs and/or the ledger?  The CLI does not actually wait to see if the transaction has been committed.  It actually obtains the endorsement and then sends to the orderer.  It doesn't actually wait for transaction to be committed. So what you are seeing is the output of the endorsement but not actually of the commit.     My guess is that if you actually check the ledger and/or query the chaincode after running the two transactions without the sleep, you'll see that the first transaction was committed and the second was rejected due to a read conflict.  When you add the sleep, it's likely that the first transaction is actually committed prior to the second invoke and hence the second invoke ends up modifying the committed data from the first.  What you really need to do is to check the actual ledger state not the results of the invoke.  Not that in later version of Fabric (you should really be using 1.4.1 and later), you can add the "–waitForEvent" option to the invoke command and this will tell you whether or not the transaction actually commits or not.  ></body> </Action>
<Action id="64724" issue="30005" author="heatherp" type="comment" body="Please re-open if you are still seeing this, closing for now" created="2019-10-15 15:18:12.0" updateauthor="heatherp" updated="2019-10-15 15:18:12.0"/>
