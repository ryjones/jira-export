<Action id="21054" issue="14893" author="yacovm" type="comment" created="2017-02-20 11:23:50.0" updateauthor="yacovm" updated="2017-02-20 13:24:01.0"> <body><! CDATA #  Does the Vm object created by Otto have access to the local file system? # I think this needs to be carefully evaluated from the security and life-cycle perspective. Can you please post a public accessible repository where you have been doing this development? some documentation to help to understand the operation flow?  ></body> </Action>
<Action id="21055" issue="14893" author="greg.haskins" type="comment" body="I have no problem with a javascript type for chaincode, but I think the prospect of trying to run user-submitted code coresident in the peer is likely a non-starter.  The reason we have syscc is to support a different type of use case and its not for user submitted execution.  Refactor this logic to run inside Docker and I will be more supportive." created="2017-02-20 13:13:38.0" updateauthor="greg.haskins" updated="2017-02-20 13:13:38.0"/>
<Action id="21057" issue="14893" author="honglei" type="comment" created="2017-02-20 15:36:05.0" updateauthor="honglei" updated="2017-02-20 15:36:05.0"> <body><! CDATA  ~yacovm  answer the questions:  1. VM object has no access to local file system, because there'll no builtin support on local file system access. 2. OK.  I'll push to github.  update to this later.   ~ghaskins  Currently, we took the inproc way.  Any special reason for running in docker? Because the js-chaincode is just some text, otto can load/parse/execute/unload them when necessary.  ></body> </Action>
<Action id="21063" issue="14893" author="mastersingh24" type="comment" created="2017-02-20 17:54:13.0" updateauthor="mastersingh24" updated="2017-02-20 17:54:13.0"> <body><! CDATA given this is not for a native nodejs / javascript chaincode, please take a look at this project:   https://github.com/fabric-composer/fabric-composer  it already uses Otto, has a DSL for defining models and allows you to write functions in Javascript.  It has already been proposed as a Hyperledger project as well.  It currently works with v0.6 but the team is working to port it to 1.0.  I am sure they would WELCOME any help  ></body> </Action>
<Action id="21064" issue="14893" author="dselman" type="comment" created="2017-02-20 19:01:26.0" updateauthor="dselman" updated="2017-02-20 19:01:26.0"> <body><! CDATA Yes, Fabric Composer (http://fabric-composer.org) uses Otto to execute JS transaction processing functions on a standard HL v0.6. We are currently in the process of porting to HL v1 and would like to (also?) support native Node.js chaincode containers in the future.  I'd encourage you to experiment with Fabric Composer, it is already quite full featured: - Model the business network using a DSL - Submit transactions - Execute JS functions on Fabric - Expose business network via REST - Generation of Angular and Node.js skeleton apps - ...  The best place to start is the Quick Start: https://fabric-composer.github.io/start/quickstart.html  We have also implemented a HL Fabric simulator that runs in the brower, or as a node.js process for rapid development and testing.  ></body> </Action>
<Action id="21068" issue="14893" author="greg.haskins" type="comment" created="2017-02-20 22:42:20.0" updateauthor="greg.haskins" updated="2017-02-20 22:42:20.0"> <body><! CDATA  @Cong:  Yes, one of the primary reasons is for isolation for untrusted code.  If you refer to the diagram I attached, you are proposing (IIUC) "Option 1", which is harder to secure than what I am proposing ("Option 3").  I understand that the JS has to go through a translation, but this doesn't mean exploits in the interpreter or DSL will never occur.  Running the interpreter coresident with the peer means that any exploits that may exist will effectively execute with the same privilege as the peer and have access to additional resources.   As an example: the peer has access to all of the ledger, the consensus layer,  and elevated privileges with dockerd, none of which are extended to normal chaincode. This access is naturally restricted by additional layers with option 3 regardless of the integrity of the chaincode execution layer.  !fab-2331.png|thumbnail!   ></body> </Action>
<Action id="21071" issue="14893" author="honglei" type="comment" created="2017-02-21 00:26:51.0" updateauthor="honglei" updated="2017-02-21 00:26:51.0"> <body><! CDATA  ~mastersingh24   ~dselman  Yes.  I just knew fabric composer a few day ago, it's really one great tool. We've started trying to use it, but it seems have big dependency on some specific nodejs version? Still not figure out which version of node can work with it.  But we will continue investigating on it.  Fabric composer uses js to implement chaincode logic, and run it in go-otto-docker.  So from our perspective, it's still one golang-chaincode.  ></body> </Action>
<Action id="21072" issue="14893" author="honglei" type="comment" created="2017-02-21 00:39:59.0" updateauthor="honglei" updated="2017-02-21 00:39:59.0"> <body><! CDATA  ~ghaskins  I agree that interpreter/DSL could also be exploited.   As we known, deployment request is constructed by SDK client, if endorser failed to detect this, all peers on chain will deploy it, and it will be big problem.  We'd like to know how to handle this.  ></body> </Action>
<Action id="21080" issue="14893" author="mne" type="comment" created="2017-02-21 09:53:23.0" updateauthor="mne" updated="2017-02-21 09:53:23.0"> <body><! CDATA From a security perspective I do like the idea of having Javascript chaincode. A Javascript runtime environment can be locked down very well. Browsers have a very similar problem that HL has with chaincode: they need to execute untrusted code. The security that we get with modern day browsers show that such code can be contained effectively. In particular, I/O and other OS services are abstracted and can be granted in a very selective manner.  Thus, it makes sense to have a close look at how browsers do things, for instance, in Google Chrome all untrusted Javascript runs in a separate process, making use of OS-level isolation. So your option 1 is significantly less secure, as  ~greg.haskins  already pointed out compromising the execution environment would be equal to compromise of the whole peer. On the other hand, I think process-level isolation (as with browsers) is sufficient in this case - what would be the benefit of using containers?  ></body> </Action>
<Action id="21086" issue="14893" author="greg.haskins" type="comment" body=" ~mne  I think that ultimately, either option 2 or 3 could be made to work with the proper application of isolation techniques such as a targetted AppArmor profile.  I think the main thing to consider is that Docker, especially how it is used in Fabric, really is just an extension of the process model with some default security isolation applied via cgroups and a convenient command+control infrastructure.  IOW, it has a) no extra overhead over fork/exec&apos;ing a process, b) has a bunch of things already locked down (e.g. certain system calls and filesystem visibility), c) an abstracted common command+control interface that works the same regardless of where the peer executes (linux/osx/windows), etc." created="2017-02-21 13:52:41.0" updateauthor="greg.haskins" updated="2017-02-21 13:52:41.0"/>
<Action id="21114" issue="14893" author="mne" type="comment" created="2017-02-22 15:58:48.0" updateauthor="mne" updated="2017-02-22 15:58:48.0"> <body><! CDATA  ~ghaskins  agreed, Docker is already well integrated into the fabric, offers a homogeneous way to deploy chaincode and cgroups. Still, considering only the Javascript case, I think in the long run it might be worth considering an approach solely based on processes, where the control over the chaincode execution environment shifts from the deployer to the fabric, with the deployer just providing the JS source rather than the whole container image. Chaincode execution processes could be directly cloned from a Zygote (like on Android) and run as an unprivileged, restricted user, potentially with an additional AppArmor profile as you suggested.  ></body> </Action>
<Action id="21122" issue="14893" author="greg.haskins" type="comment" body=" ~mne  Note that we are already in the state that chaincode deployments are purely source (see FAB-678).  So fwiw, I fully envision a JS type chaincode that would only deploy .js files (probably within a .tgz) rather than a container image." created="2017-02-22 22:55:20.0" updateauthor="greg.haskins" updated="2017-02-22 22:55:55.0"/>
<Action id="21125" issue="14893" author="dselman" type="comment" body="We (Fabric Composer team) would like to support a Node.js chaincode container once we have finished porting Fabric Composer to HL v1. We would be very interested to collaborate with others on this project. Our aim is to deploy a Node.js process inside a Docker container, which exposes the gRPC endpoints required to be a good citizen in the Fabric." created="2017-02-23 00:04:18.0" updateauthor="dselman" updated="2017-02-23 00:04:18.0"/>
<Action id="21126" issue="14893" author="honglei" type="comment" created="2017-02-23 00:44:19.0" updateauthor="honglei" updated="2017-02-23 00:44:19.0"> <body><! CDATA  ~mne   ~ghaskins  Thanks for all valuable comments.  Yes, making the source code from SDK client analysable, and one restrict execution environment is what we need.   ~dselman  Looking forward to that project.  We've started working on fabric composer. btw, will you try to disable the 'eval' function in javascript?  I'm not sure if this can be done easily in node, as node is much more complicated that otto :)  ></body> </Action>
<Action id="21127" issue="14893" author="greg.haskins" type="comment" body=" ~dselman  This would be relatively easy, I think.  Would be happy to walk through a skeleton platform driver for nodejs when the time comes." created="2017-02-23 00:48:01.0" updateauthor="greg.haskins" updated="2017-02-23 00:48:01.0"/>
<Action id="28567" issue="14893" author="jimthematrix" type="comment" created="2017-07-18 12:43:30.0" updateauthor="jimthematrix" updated="2017-07-18 12:47:51.0"> <body><! CDATA  ~Honglei   ~greg.haskins  I think it's time we revisit this topic. I also like the approach to build on top of the underlying docker-based isolation mechanism so that future improvements, like adding AppArmor profile, can be done once (in fabric-ccenv) and be automatically picked up by all chaincode execution environments. It's also important that it results in a consistent operational management model, so that DevOps teams only need to worry about one way to manage runtime resources regardless of what chaincode languages are used.  Of the 3 options that Greg listed above, #1 is obviously out of the question due to the lack of isolation. #2 could be accomplished with either Otto, which incurs a pretty significant performance cost as the Composer team have seen, or a separate node.js engine running the chaincode natively, which would provide the separation (separate proc) but would "pollute" the fabric-peer image and in my opinion more difficult to reason about (why shouldn't java be done this way?).  This area has been of interest to me and the node.js SDK team has some bandwidth right now. I'd like to start working on this. Would like to first make sure we all agree on the approach. Looks like  ~greg.haskins  and I are both advocating for #3.  ~mne  it looks like you are advocating for #2.  ~Honglei  can you let us know your thoughts on this? we should collaborate and work toward a common solution. Regardless of where we land, at the minimum the work you guys have done implementing the node.js based shim should be re-usable.  ></body> </Action>
<Action id="28590" issue="14893" author="jimthematrix" type="comment" body="Changed to &quot;Highest&quot; priority due to this blocking the Composer team&apos;s v1 release (they do not want to put out the release with the current approach based on Golang chaincode support with Otto due to observed performance characteristics).  ~sstone1   ~dselman  please chime in if I represented this wrong." created="2017-07-18 15:35:54.0" updateauthor="jimthematrix" updated="2017-07-18 15:35:54.0"/>
<Action id="28623" issue="14893" author="dselman" type="comment" created="2017-07-18 21:36:08.0" updateauthor="dselman" updated="2017-07-18 21:36:08.0"> <body><! CDATA Note that Composer no longer uses Otto (due to performance/memory issues) and uses Go bindings for Duktape instead.  Apart from the support, maintenance (reduce code complexity) and performance improvements of native Node.js execution users are also very interested in having the ability to easily consume JS modules from npm, using the standard 'require' mechanism.  My naive understanding is that if the Node.js process fulfils the gRPC contract to communicate with the other HLF nodes, then native Node.js execution should be possible.  The deployment model is not clear to me however, in particular the lifecycle for code changes (npm update etc) and how that impacts chain code containers.   ></body> </Action>
<Action id="28633" issue="14893" author="honglei" type="comment" created="2017-07-19 00:31:04.0" updateauthor="honglei" updated="2017-07-19 00:31:04.0"> <body><! CDATA  ~jimthematrix  I agree with solution #3.  About the native Node.js, I'm not sure if different versions of Node.js could be an issue.  About the 'require' in Node.js, chaincode composer should take responsibility for all code in chaincode, I'm not sure if it is useful.  btw, I assigned the JIRA to Jim Zhang, because my previous solution is based on #1(and paused for a long time, still based on pre-alpha-1 version.)  ></body> </Action>
<Action id="28635" issue="14893" author="jimthematrix" type="comment" body=" ~Honglei  thanks for the feedback, glad to know we are converging on the proposed solution, I see from previous comments that you have started implementing the shim as part of your work, can you share that with us?" created="2017-07-19 02:52:24.0" updateauthor="jimthematrix" updated="2017-07-19 02:52:24.0"/>
<Action id="28636" issue="14893" author="honglei" type="comment" body="uploaded as jscc.diff.  wish it helps :)" created="2017-07-19 03:27:43.0" updateauthor="honglei" updated="2017-07-19 03:27:43.0"/>
<Action id="28637" issue="14893" author="jimthematrix" type="comment" body="thanks!" created="2017-07-19 03:35:38.0" updateauthor="jimthematrix" updated="2017-07-19 03:35:38.0"/>
<Action id="28640" issue="14893" author="mne" type="comment" created="2017-07-19 08:18:30.0" updateauthor="mne" updated="2017-07-19 08:18:30.0"> <body><! CDATA  ~jimthematrix  given how V1 CC deployment and packaging works, option #3 absolutely makes sense. My suggestion of #2 was based on how V0.6 was working and how browsers have successfully solved the problem of running untrusted Javascript.   ~dselman  lifecycle management is indeed an issue. In my opinion, updating node modules must be part of an explicit CC "upgrade" (after an instantiate), since it potentially changes the behavior of the CC.  ></body> </Action>
<Action id="29304" issue="14893" author="christopherferris" type="comment" body="This has the requisite 5 maintainers approving... " created="2017-08-01 15:57:49.0" updateauthor="christopherferris" updated="2017-08-01 15:57:49.0"/>
<Action id="29360" issue="14893" author="odowdaibm" type="comment" created="2017-08-02 16:34:43.0" updateauthor="odowdaibm" updated="2017-08-02 16:34:43.0"> <body><! CDATA I hope this is the right place for this comment.     I would like to improve the general usability of chaincode/Smart contracts in JavaScript as part of this feature.  Adding JavaScript support for SC/CC should be about providing something that's natural for JS programmers, rather than a simple port of the golang interfaces.     A simple and necessary example, are the golang imports in Go chaincode, which refer to files deep inside the source code, which really isn't ideal.    {color:#569cd6}import{color}{color:#d4d4d4} ({color} {color:#d4d4d4}    {color}{color:#ce9178}"bytes"{color} {color:#d4d4d4}    {color}{color:#ce9178}"encoding/json"{color} {color:#d4d4d4}    {color}{color:#ce9178}"fmt"{color} {color:#d4d4d4}    {color}{color:#ce9178}"strconv"{color}  {color:#d4d4d4}    {color}{color:#ce9178}"github.com/hyperledger/fabric/core/chaincode/shim"{color} {color:#d4d4d4}    sc {color}{color:#ce9178}"github.com/hyperledger/fabric/protos/peer"{color} {color:#d4d4d4}){color}    Likewise, the method definitions could be quite a lot more natural for JavaScript programmers.     Finally, I realize we might not want to pass more structure for the data passed between the SDK and Chaincode over the low level interface, but would we entertain some kind of higher level serialization?  Again, to make it more natural for JavaScript programmers who want to pass JSON objects between their JS SDK program and JS CC/SC.     Thanks, Anthony.     ></body> </Action>
<Action id="29499" issue="14893" author="jimthematrix" type="comment" created="2017-08-07 16:48:49.0" updateauthor="jimthematrix" updated="2017-08-07 16:48:49.0"> <body><! CDATA  ~odowdaibm  totally agree on the design to provide intuitive interfaces to native javascript developers. Can you take a look at the sample chaincode test file here https://github.com/hyperledger/fabric-chaincode-node/blob/master/test/test.js and see if that's going in the right direction in your mind?  Agree that encoding and decoding of passing the arguments should be JSON based (instead of byte arrays). will add this to FAB-5371  ></body> </Action>
<Action id="29503" issue="14893" author="greg.haskins" type="comment" body=" ~jimthematrix   ~odowdaibm  Highly encourage you to consider doing this serialization work as an extension of chaintool (http://fabric-chaintool.readthedocs.io/en/latest/).  I designed the grammar ( http://fabric-chaintool.readthedocs.io/en/latest/interface/)  to be language agnostic based on google protocol buffers and I can say from experience that the support for protobufs on node/javascript is excellent.  It is just as easy to use protobufs/chaintool-cci in a javascript program as json, and you would gain a bunch of things in the process.  I would be more than happy to work with the node-shim team on integrating this.  If you would like a demo of chaintool as it applies to the golang variant, would be more than happy to set this up." created="2017-08-07 16:58:10.0" updateauthor="greg.haskins" updated="2017-08-07 16:58:10.0"/>
<Action id="29559" issue="14893" author="odowdaibm" type="comment" created="2017-08-08 17:07:37.0" updateauthor="odowdaibm" updated="2017-08-08 17:07:37.0"> <body><! CDATA Yes Jim, This is definitely along the right lines.      Personally, I find the word "shim" a little hard to understand, and wonder whether we could use a simpler term**?  I know *var shim* is arbitrary, but I don't know why we don't call it something like *API,* so *require('fabric-api')* and *return api.success();* I just think these would be easier to understand.**     **Also the word shim technically refers to joining 2 things that were not meant to be joined together - putting a new API over an old API for example , and most definitely that's not the case here.     Other than that, this is definitely in the right direction.  Thank you!  ></body> </Action>
<Action id="29560" issue="14893" author="odowdaibm" type="comment" created="2017-08-08 17:20:27.0" updateauthor="odowdaibm" updated="2017-08-08 17:20:27.0"> <body><! CDATA Hi Greg - thanks for this.  I've had a quick read of the fabric-chaintool docs and I see where you're coming from.     The snippet I focused on was this:    {quote}{{var args = new app.PaymentParams(\{'partySrc':'A', 'partyDst':'B','amount':100}); }}  {{var request = \{ chaincodeType: 'car', fcn: 'org.hyperledger.chaincode.example02/fcn/1', args:  args.toBuffer()  };}} {quote}    which I think was close to what I was imagining, but it would be nice to see params even more naturally in the request, and without the toBuffer() method on them.  What would you think of that?     Finally, I've been trying (clearly not hard enough!) to convince folks of the merits of naming conventions, so I'd also like to see whether we might be able to formalize this naming scheme (DNS) as part of this feature? As stated, that sounds too much for this feature, but I wonder whether we might have some kind of assist for that in this feature.  For example, we might have a slightly different for of the start() method, which took a name, and helper functions to generate names?      Thanks for consideration, Anthony.  ></body> </Action>
