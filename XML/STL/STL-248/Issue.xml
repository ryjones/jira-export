<Issue id="16857" key="STL-248" number="248" project="10001" reporter="cintel" assignee="cintel" creator="cintel" type="10002" summary="Complete Supplychain Transaction Processor Permission enforcement." priority="3" resolution="10000" status="10001" created="2017-05-18 13:49:17.0" updated="2017-06-19 19:57:56.0" resolutiondate="2017-06-13 16:03:47.0" votes="0" watches="1" workflowId="16861"> <description><! CDATA Review the permission checks and update the transaction handler to enforce proper permission enforcement in the Transaction Handler. The code below has TBD comments in many of the places to update.            class RecordHandler(object): @classmethod def apply(cls, transaction, state): payload = json.loads(transaction.payload.decode())  LOGGER.debug("apply payload: %s", repr(payload))  tnx_action = payload.get('Action', None) txnrecord_id = payload.get('record_id', None)  header = TransactionHeader() header.ParseFromString(transaction.header) tnx_originator = addressing.get_agent_index( addressing.get_agent_id(header.signer_pubkey)) # Retrieve the stored record data if an ID is provided. record_id = txnrecord_id record_store_key = record_id  record_store = state_get_single(state, record_store_key) # TBD: the originator should be a registered agent # TBD: if it's not Create then the record should exist  # Check Action if tnx_action == 'Create': if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for CreateRecord')  record_store = \{} cls.create_record(tnx_originator, record_id, payload, state, record_store) # TBD: If there are parents they should not be final and they should # have accepted applications from the txn originator. # TBD: If it is an ownership transfer then then the record should # not have custodians. # TBD: What if the sensor is already registered? Should we require # an unregister operation?  elif tnx_action == "CreateApplication": if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for create_application')  cls.create_application(tnx_originator, record_id, payload, state, record_store) # TBD: Check for existing application - for now only one at a # time. # TBD: applicationtype is owner or custodian, terms should be # defined # TBD: If app for ownership, then there should be no custodians  elif tnx_action == "AcceptApplication": if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for accept_application')  cls.accept_application(tnx_originator, record_id, payload, state, record_store) # TBD: must be the record holder # TBD: there must be an open application  elif tnx_action == "RejectApplication": if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for reject_application')  cls.reject_application(tnx_originator, record_id, payload, state, record_store) # TBD: must be the record holder # TBD: there must be an open application  elif tnx_action == "CancelApplication": if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for cancel_application')  cls.cancel_application(tnx_originator, record_id, payload, state, record_store) # TBD: must be the application creator # TBD: there must be an open application  elif tnx_action == "Finalize": if txnrecord_id is None: raise InvalidTransaction( 'Record id expected for Finalize')  cls.finalize_record(tnx_originator, record_id, payload, state, record_store) # TBD: must be the record owner. The only way a custodian can # finalize a record is by making a child. # TBD: record must not be final already else: raise InvalidTransaction('Action \{} is not valid'. format(tnx_action))  # Store the record data back state_put_single(state, record_store_key, record_store)  @classmethod def create_record(cls, originator, record_id, payload, state, my_store): sensor_id = payload.get('Sensor', None) sensor_idx = None if sensor_id != None: sensor_idx = addressing.get_sensor_index(sensor_id)  record_info = \{} # Owner set below record_info 'CurrentHolder'  = originator # Custodians set below record_info 'Parents'  = payload.get('Parents', None) record_info 'Timestamp'  = payload.get('Timestamp') record_info 'Sensor'  = sensor_idx record_info 'Final'  = False record_info 'ApplicationFrom'  = None record_info 'ApplicationType'  = None record_info 'ApplicationTerms'  = None record_info 'ApplicationStatus'  = None record_info 'EncryptedConsumerAcccessible'  = None record_info 'EncryptedOwnerAccessible'  = None my_store 'RecordInfo'  = record_info  my_store 'StoredTelemetry'  = payload.get('Telemetry', \{}) my_store 'DomainAttributes'  = payload.get('DomainAttributes', \{}) # Determine if this record has parents has_parents = record_info 'Parents'  != None and \ len(record_info 'Parents' ) > 0  # If there are parents update Owner and Custodian depending on the # ApplicationType if has_parents: # Use the first parent # TBD: how to handle multiple parents? If there are no custodians # then it seems straight forward to transfer to the new owner. # Maybe if there are custodians then all but the first need to be # held by the owner and we handle it based on the first parent. # One thing that could be useful here is to be able to combine # multiple parents and keep the owner/custodians the same - right # now we can only add a custodian or pop the stack. parent_id = record_info 'Parents'  0  parent_store = state_get_single(state, parent_id) if parent_store 'RecordInfo'  'ApplicationType'  == "Owner": # Transfer ownership - in this case there should be # no custodians. assert len(parent_store 'RecordInfo'  'Custodians' ) == 0 record_info 'Owner'  = originator record_info 'Custodians'  =    else: # Transfer custodianship record_info 'Owner'  = \ parent_store 'RecordInfo'  'Owner'  record_info 'Custodians'  = \ list(parent_store 'RecordInfo'  'Custodians' )  # Check the next to last element of the Custodians array. If it # is the new holder, then this is a 'pop' operation. It's also # a pop if here is one custodian and the applicant is the # owner. is_pop = False if len(record_info 'Custodians' ) > 1 and \ record_info 'Custodians'  -2  == originator: is_pop = True elif len(record_info 'Custodians' ) == 1 and \ record_info 'Owner'  == originator: is_pop = True  if is_pop: record_info 'Custodians' .pop() else: record_info 'Custodians' .append(originator) else: # No parents, just create a new record record_info 'Owner'  = originator record_info 'Custodians'  =     # If there are parents mark them as final. if has_parents: for parent in record_info 'Parents' : parent_store = state_get_single(state, parent) parent_store 'RecordInfo'  'Final'  = True state_put_single(state, parent, parent_store)  # Remove the record from the former owner - even if this # is a custodian transfer we need to store the new # record ID with the owner. AgentHandler.remove_record_owner(state, parent_store 'RecordInfo'  "Owner" , parent)  # Remove the previous holder AgentHandler.remove_record_holder(state, parent_store 'RecordInfo'  "CurrentHolder" , parent)  # Remove the accepted application from the new owner AgentHandler.remove_accepted_application(state, parent_store 'RecordInfo'  'ApplicationFrom' , parent)  # Record the owner of the new record in the agent AgentHandler.add_record_owner(state, record_info "Owner" , record_id, record_info "Owner"  == record_info "CurrentHolder" ) # Record the new record holder in the agent AgentHandler.add_record_holder(state, record_info "CurrentHolder" , record_id)  # Register the sensor if sensor_id != None: if state_get_single(state, sensor_idx) != None: sensor_store = state_get_single(state, sensor_idx) else: sensor_store = \{} sensor_store "Record"  = record_id sensor_store "Name"  = sensor_id state_put_single(state, sensor_idx, sensor_store)  @classmethod def create_application(cls, originator, record_id, payload, state, my_store): record_info = my_store 'RecordInfo'  # Agent ID who initiated the application record_info 'ApplicationFrom'  = originator # custodian or owner record_info 'ApplicationType'  = payload 'ApplicationType'  # Should be encrypted? record_info 'ApplicationTerms'  = payload 'ApplicationTerms'  # To indicate acceptance (or not) of the application. record_info 'ApplicationStatus'  = "Open"  # Record the new application in the current holder AgentHandler.add_open_application(state, record_info 'ApplicationFrom' , record_info 'CurrentHolder' , record_id)  @classmethod def accept_application(cls, originator, record_id, payload, state, my_store): # Mark the application as accepted. After this the new # owner/custodian is able to make a new record with this # record as the parent. record_info = my_store 'RecordInfo'  record_info 'ApplicationStatus'  = "Accepted"  # Record the accepted application in the new holder AgentHandler.remove_open_application(state, record_info 'ApplicationFrom' , record_info 'CurrentHolder' , record_id) AgentHandler.add_accepted_application(state, record_info 'ApplicationFrom' , record_id, record_info 'Sensor' )  @classmethod def reject_application(cls, originator, record_id, payload, state, my_store): # Mark the application as rejected. record_info = my_store 'RecordInfo'  record_info 'ApplicationStatus'  = "Rejected"  # Record the rejected application in the agent AgentHandler.remove_open_application(state, record_info 'ApplicationFrom' , record_info 'CurrentHolder' , record_id)  @classmethod def cancel_application(cls, originator, record_id, payload, state, my_store): # Mark the application as cancelled. record_info = my_store 'RecordInfo'  record_info 'ApplicationStatus'  = "Cancelled"  # Record the cancelled application in the agent AgentHandler.remove_open_application(state, record_info 'ApplicationFrom' , record_info 'CurrentHolder' , record_id)  @classmethod def finalize_record(cls, originator, record_id, payload, state, my_store): record_info = my_store 'RecordInfo'  # TBD: check that there are no custodians before finalizing record_info 'Final'  = True # Remove the record from the agent # TBD: handle any pending applications assert record_info 'Owner'  == originator assert record_info 'CurrentHolder'  == originator AgentHandler.remove_record_owner(state, originator, record_id) AgentHandler.remove_record_holder(state, originator, record_id)  ></description> </Issue>
