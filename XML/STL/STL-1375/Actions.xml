<Action id="52909" issue="32502" author="dan.middleton@intel.com" type="comment" body=" ~yoni  Can you please describe the motivation for the requested feature? What is the use case that benefits from retrieving a branch of state? And is it exclusively discovering the presence or absence of a node? Or is it also retrieving the data at that node?" created="2018-11-01 16:48:11.0" updateauthor="dan.middleton@intel.com" updated="2018-11-01 16:48:11.0"/>
<Action id="53047" issue="32502" author="yoni" type="comment" created="2018-11-05 19:14:18.0" updateauthor="yoni" updated="2018-11-05 19:14:18.0"> <body><! CDATA The motivation came when looking for a way to improve processing transaction logic by making better use of the radix merkle tree.  trying to show an example without getting too much into  our complicated TP logic: let's say we want to add to intkey TP a transaction that will trigger delete all keys with key name with certain length.   one approach will be to store in a special address a list of all key names length, but now for every new key TP will need to update this address, this could be expensive especially when this address data gets huge. a small improvement could come by bucketing keys based on their length but the performance is still not ideal if there are a very big number of keys. all the solutions we considered had its own problems.   the approach we finally decided we would like to use and think would be the best is to use the optimization that comes from using the radix tree. Add prefix for each key address with the key name length. to do an action on all keys that have certain length, we would read all relevant address by prefix. because addresses are in a radix tree, reading a lot of addresses by prefix is much faster than reading the same amount of addresses one by one. there is no need to store list of used keys in a special address.  since we only want to delete the addresses we found we are not interested in the data of these addresses, if read by prefix only returned the list of addresses without the data, the performance would be even better.  this is more or less our motivation for this request, we think that others could also gain from both being able to read by prefix or from detecting if nodes exists.  ></body> </Action>
<Action id="53383" issue="32502" author="benoit.razet" type="comment" created="2018-11-13 13:46:20.0" updateauthor="benoit.razet" updated="2018-11-13 13:46:20.0"> <body><! CDATA Just a couple of thoughts, looking into the proposed idea through the specific criterion of computing resources: in the current design, it looks to me (tell me if I’m wrong) that the relationship between the size of a TP request and the amount of computational process time required by the validator to process this request is arguably linear (maybe the constant is not so small), but not unbounded and not exponential. I think this property is desirable for different reasons including security (limited attack vector of TP on validator), performance (all users share the validator resources, so better control the cost of TP requests) and iii) simplicity (well identified good TP programming practice). For this reason, I’m skeptical of having a `context.get_state` that takes a prefix and returns all the addresses existing. I can see how on the other side extending `context.delete_state` with a prefix address would be more acceptable because deleting a subtree in a radix Merkle Tree can be done in constant time (ignoring the cost of freeing memory).  In the intkey motivating example, I don’t really see the problem with the bucketed solution the way it is presented. Nevertheless I see that the bucketed solution could be problematic if concurrent users are allowed to submit intkey transactions, in this case it would be challenging for a user to delete a set of keys of a certain length because it would be impossible to determine for sure the set keys the txn will meet in during its execution.  ></body> </Action>
