<Issue id="31094" key="STL-1307" number="1307" project="10001" reporter="anton.betsun" assignee="amundson" creator="anton.betsun" type="10004" summary="Validator Error when processing simple transaction" priority="3" status="10100" created="2018-06-15 15:04:49.0" updated="2019-05-21 14:33:43.0" votes="0" watches="1" workflowId="31106"> <environment><! CDATA My Sawtooth node is running on Ubuntu 16 on Exoscale.   My frameworks for Sawtooth Client on Swift are: *  SwiftProtobuf|https://github.com/apple/swift-protobuf  *  SwiftCBOR|https://github.com/myfreeweb/SwiftCBOR  *  CommonCrypto|https://github.com/soffes/CommonCrypto  *  secp256k1|https://github.com/Boilertalk/secp256k1.swift  *  BitcoinKit|https://github.com/kishikawakatsumi/BitcoinKit      ></environment> <description><! CDATA I made simple Transaction Family like *intkey* but without storing or changing value of records. It actually just store string in blockchain. My python and JS clients are working well without any issues. But i'm also developing client for iOS on Swift. There is no any SDK or tutorials about Sawtooth on Swift, and also no one except me is trying to do that. So i start to make my own SDK to present it to community later, when it will be ready. I did all steps to form a valid transaction, but this is what i'm getting each time i send transaction:  !Screen Shot 2018-06-13 at 1.43.35 PM.png!  I think that problem might be in signature algorithm that i use.     For keys generating and signing i use  BitcoinKit framework| https://github.com/kishikawakatsumi/BitcoinKit |https://github.com/kishikawakatsumi/BitcoinKit .  which is based on *secp256k1* library from bitcoin-core. In official instructions about how to develop app without SDK there was mentioned that validator accepts *compact 64-byte signature.* In BitcoinKit.Crypto there is a function _sign()_ that returns signed array of bytes in DER format, and i change it so that it will return compact signature. Here's original sign() code: {code:java} public static func sign(_ data: Data, privateKey: PrivateKey) throws -> Data { let ctx = secp256k1_context_create(UInt32(SECP256K1_CONTEXT_SIGN))! defer { secp256k1_context_destroy(ctx) } let signature = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1) defer { signature.deallocate(capacity: 1) } let status = data.withUnsafeBytes { (ptr: UnsafePointer<UInt8>) in privateKey.raw.withUnsafeBytes { secp256k1_ecdsa_sign(ctx, signature, ptr, $0, nil, nil) } } guard status == 1 else { throw CryptoError.signFailed } let normalizedsig = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1) defer { normalizedsig.deallocate(capacity: 1) } secp256k1_ecdsa_signature_normalize(ctx, normalizedsig, signature) var length: size_t = 128 var der = Data(count: length) guard der.withUnsafeMutableBytes({ return secp256k1_ecdsa_signature_serialize_der(ctx, $0, &length, normalizedsig) }) == 1 else { throw CryptoError.noEnoughSpace } der.count = length return der } {code} This is my version: {code:java} public static func sign(_ data: Data, privateKey: PrivateKey) throws -> Data { let ctx = secp256k1_context_create(UInt32(SECP256K1_CONTEXT_SIGN))! defer { secp256k1_context_destroy(ctx) }  let signature = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1) defer { signature.deallocate(capacity: 1) } let status = data.withUnsafeBytes { (ptr: UnsafePointer<UInt8>) in privateKey.raw.withUnsafeBytes { secp256k1_ecdsa_sign(ctx, signature, ptr, $0, nil, nil) } } guard status == 1 else { throw CryptoError.signFailed }  let normalizedsig = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1) defer { normalizedsig.deallocate(capacity: 1) } secp256k1_ecdsa_signature_normalize(ctx, normalizedsig, signature) var length: size_t = 64 var compact = Data(count: length) guard compact.withUnsafeMutableBytes( { return secp256k1_ecdsa_signature_serialize_compact(ctx, $0, normalizedsig) }) == 1 else { throw CryptoError.noEnoughSpace } compact.count = length return compact } {code} And i am 0% sure that i made it correctly, but with DER signature validator just said that i send him wrong signature. If my sign() function was making wrong signatures, than validator would continue to say "wrong signature". So i am completely stuck with this problem.     This is my Sawtooth.swift: {code:java} //  //  Sawtooth.swift  //  MsgHash  //  //  Created by Anton Betsun on 5/23/18.  //  Copyright © 2018 Sharekey. All rights reserved.  //    import Foundation    //https://github.com/soffes/CommonCrypto  import CommonCrypto    //https://github.com/apple/swift-protobuf  import SwiftProtobuf    //https://github.com/myfreeweb/SwiftCBOR  import SwiftCBOR    //https://github.com/apple/swift-protobuf to combile protos    //https://github.com/kishikawakatsumi/BitcoinKit  //that was very hard to install. cocoapods + install lots of necessary stuff + https://stackoverflow.com/a/44958931/9709932  import BitcoinKit  import BitcoinKit.Private    //https://github.com/Boilertalk/secp256k1.swift  import secp256k1      //// This must be used to sign data instead of function sign() in BitcoinKit.Crypto  //extension Crypto {  //    public static func signCompact(_ data: Data, privateKey: PrivateKey) throws -> Data {  //        let ctx = secp256k1_context_create(UInt32(SECP256K1_CONTEXT_SIGN))!  //        defer { secp256k1_context_destroy(ctx) }  //        let signature = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1)  //        defer { signature.deallocate(capacity: 1) }  //        let status = data.withUnsafeBytes { (ptr: UnsafePointer<UInt8>) in  //            privateKey.raw.withUnsafeBytes {  //                secp256k1_ecdsa_sign(ctx, signature, ptr, $0, nil, nil)  //            }  //        }  //        guard status == 1 else { throw CryptoError.signFailed }  //        let normalizedsig = UnsafeMutablePointer<secp256k1_ecdsa_signature>.allocate(capacity: 1)  //        defer { normalizedsig.deallocate(capacity: 1) }  //        secp256k1_ecdsa_signature_normalize(ctx, normalizedsig, signature)  //        var length: size_t = 64  //        var compact = Data(count: length)  //        guard compact.withUnsafeMutableBytes( { return secp256k1_ecdsa_signature_serialize_compact(ctx, $0, normalizedsig) }) == 1 else { throw CryptoError.noEnoughSpace }  //        compact.count = length  //        return compact  //    }  //}    extension Data {      private static let hexAlphabet = "0123456789abcdef".unicodeScalars.map { $0 }            public func hexEncodedString() -> String {          return String(self.reduce(into: "".unicodeScalars, { (result, value) in              result.append(Data.hexAlphabet Int(value/16) )              result.append(Data.hexAlphabet Int(value%16) )          }))      }  }    class Sawtooth {      public var address: String // Node address      public var port: String // Proxy port      private var urlString: String // Full rest through proxy url      private var key: PrivateKey // BitcoinKit.PrivateKey      public var errorList = ""      public var familyName: String      public var familyVersion: String            /** Generates new private key       */      static func getKeyGenerated() -> PrivateKey {          return PrivateKey(network: .mainnet)      }            /** Restore private key from WIF format       */      static func getKeyFromWif(wif: String) throws -> PrivateKey {          return try PrivateKey.init(wif: wif)      }            /** Returns private key in WIF format       */      static func getWifFromKey(key: PrivateKey) -> String {          return key.toWIF()      }            init(address: String, port: String, key: PrivateKey, familyName: String, familyVersion: String) {          self.address = address          self.port = port          self.key = key          self.urlString = "http://" + address + ":" + port + "/batches"          self.familyName = familyName          self.familyVersion = familyVersion      }            func getAddress(seed: String) -> String {          let hash = sha512Hex(string: seed)          let prefix = String(sha512Hex(string: familyName).prefix(6))          let subhash = String(hash String.Index(encodedOffset: 64)... )          return prefix + subhash      }            /** Makes SHA512 hash of the input string and pins to blockchain.       */      public func pin(toHash: String) -> String {          // Make hash of input data, wrap it into dictionary & calculate it's address          let hash = sha512Hex(string: toHash)          let payload =  "Verb":"pin", "Message":hash           let address = getAddress(seed: hash)                    // Assebmle batchlist          let batches = getBatchList(payload: payload, address:address)                    // do post request and return response          let response = postBatchList(batchList: batches)          return response      }            private func postBatchList(batchList: Data) -> String {          // Specify http params          var request = URLRequest(url: URL(string: urlString)!)          request.httpMethod = "POST"          request.addValue("application/octet-stream", forHTTPHeaderField: "content-type")          request.httpBody = batchList                    // Do request and record responce          var result = ""          let task = URLSession.shared.dataTask(with: request) { data, response, error in              guard let data = data, error == nil else {                                                 // check for fundamental networking error                  result += ("error=\(error)")                  return              }              if let httpStatus = response as? HTTPURLResponse, httpStatus.statusCode != 200 {           // check for http errors                  result += ("statusCode should be 200, but is \(httpStatus.statusCode)")                  result += ("response = \(response)")              }              let responseString = String(data: data, encoding: .utf8)              result += ("responseString = \(responseString)")          }          task.resume()                    // Return response          return result      }   private func getBatchList(payload:  String:String , address: String) -> Data {          //          // TODO console log for Protobuf exceptions          //          let encodedPayload = Data(CBOR.encode(payload))          var txHeader = Sawtooth_Transaction_TransactionHeader()          txHeader.batcherPublicKey = key.publicKey().getRaw().hexEncodedString()          txHeader.dependencies =  ""           txHeader.familyName = familyName          txHeader.familyVersion = familyVersion          txHeader.inputs =  address  //address from which transaction processor will be able to read          txHeader.outputs =  address  //address to which transaction processor will be able to write          txHeader.nonce = String(format:"%f", NSTimeIntervalSince1970)          txHeader.payloadSha512 = sha512Hex(data: encodedPayload)! //TODO check  txHeader.signerPublicKey = key.publicKey().description          var txHeaderData: Data = Data()          do { try txHeaderData = txHeader.serializedData() }          catch { errorList += ("Error: \(error)" + "\n"); return Data() }            var tx = Sawtooth_Transaction_Transaction()          tx.header = txHeaderData          tx.headerSignature = sign(data: txHeaderData)  tx.payload = encodedPayload   var batchHeader = Sawtooth_Transaction_BatchHeader()  batchHeader.signerPublicKey = key.publicKey().description  batchHeader.transactionIds =  tx.headerSignature   var batchHeaderData = Data()          do { try batchHeaderData = batchHeader.serializedData() }          catch { errorList += ("Error: \(error)" + "\n"); return Data() }          let batchHeaderSignature = sign(data: batchHeaderData)   var batch = Sawtooth_Transaction_Batch()          do { try batch.header = batchHeader.serializedData() }          catch { errorList += ("Error: \(error)" + "\n"); return Data() }  batch.headerSignature = batchHeaderSignature  batch.transactions =  tx    var batchList = Sawtooth_Transaction_BatchList()  batchList.batches =  batch           var batchListData: Data = Data()          do { try batchListData = batchList.serializedData() }          catch { errorList += ("Error: \(error)" + "\n"); return Data() }          return batchListData  }            func sign(data: Data) -> String {          let hash = Crypto.sha256(data)          var signedHash = Data()          do { try signedHash = Crypto.sign(hash, privateKey: key)          } catch { errorList += ("Error: \(error)" + "\n") }          return signedHash.hexEncodedString()      }            func sha512Hex(string: String) -> String {          var digest =  UInt8 (repeating: 0, count: Int(CC_SHA512_DIGEST_LENGTH))          if let data = string.data(using: String.Encoding.utf8) {              let value =  data as NSData              CC_SHA512(value.bytes, CC_LONG(data.count), &digest)          }          var digestHex = ""          for index in 0..<Int(CC_SHA512_DIGEST_LENGTH) {              digestHex += String(format: "%02x", digest index )          }          return digestHex      }            func sha512Hex(data:Data) -> String? {          var hashData = Data(count: Int(CC_SHA512_DIGEST_LENGTH))          _ = hashData.withUnsafeMutableBytes {digestBytes in              data.withUnsafeBytes {messageBytes in                  CC_SHA512(messageBytes, CC_LONG(data.count), digestBytes)              }          }          return hashData.map { String(format: "%02hhx", $0) }.joined()      }  } {code}     ></description> </Issue>
