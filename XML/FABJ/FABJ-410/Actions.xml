<Action id="57045" issue="37686" author="rickr" type="comment" body="This is deprecated and not used in the new lifecycle.  Will not fix." created="2019-02-14 15:31:00.0" updateauthor="rickr" updated="2019-02-14 15:31:00.0"/>
<Action id="57135" issue="37686" author="jyellick" type="comment" body=" ~bestbeforetoday  Presumably, there is a bigger picture you&apos;re driving at here.  The way we&apos;re handling Init in the new lifecycle is different, and I suspect fits more naturally into what you&apos;re trying to accomplish here.  Particularly, you may entirely disable the Fabric enforced &apos;Init&apos; semantics, and allow the application to decide whether the chaincode has been initialized.  This means that an application may spread Init across 0 to many calls.  I&apos;d be happy to discuss this in more detail with you." created="2019-02-18 14:16:57.0" updateauthor="jyellick" updated="2019-02-18 14:16:57.0"/>
<Action id="57293" issue="37686" author="bestbeforetoday" type="comment" created="2019-02-19 14:01:43.0" updateauthor="bestbeforetoday" updated="2019-02-19 14:01:43.0"> <body><! CDATA  ~jyellick  Thanks for the response. In Fabric 1.4, chaincode written using the Contract API may have either no init function or use a different function name for set up during instantiate. The Java SDK allows client code to specify the function name to be called on instantiate but then ignores the user-supplied value and is hard-coded to call 'init'. This story addresses the problem by honoring the user-supplied function name (including no function name) used for instantiate.  If Lifecycle is going to be delivered for the 2.0 release, it sounds like 2.0 is covered. My understanding is that Lifecycle will not be going into 1.4.1, so I think this change is required at least in the release-1.4 stream. If you have better information, please let me know.  ></body> </Action>
<Action id="57296" issue="37686" author="jyellick" type="comment" created="2019-02-19 14:27:06.0" updateauthor="jyellick" updated="2019-02-19 14:27:06.0"> <body><! CDATA  ~bestbeforetoday  Thanks for the additional details.  My concern is about making changes for v1.4.1 which will be immediately reverted in v2.0.0.  Let me provide some additional details.  In the old lifecycle, chaincode 'instantiation' is done as a side effect of an invocation of LSCC.  This has a myriad of problems associated with it, which have been outlined in the design doc for the new lifecycle.  Therefore, in the new lifecycle we've split the lifecycle invocation and the initialization invocation into two separate invocations.  So, in the new lifecycle, we _must_ enforce either:  1) That the init function's name is 'init', and it is called exactly once each time the chaincode version is changed 2) That the notion of 'init' goes away, and chaincodes decide for themselves whether they have been appropriately initialized.  I am far and away convinced that (2) is the better option.  It's more flexible, and trivial to implement application side.  However, we've received pushback when suggesting disabling of init entirely.  Therefore, in the new lifecycle, you may either select the behavior of (1) or of (2).  So, back to the point at hand and my concern over encouraging the use of function names other than 'init' for initialization.  In the old lifecycle we could differentiate 'init' transactions from regular invocations because init transactions targeted lscc.  In the new lifecycle the only way we have to differentiate init invocations from standard invocations is via the function name.  I'm concerned that we are taking an existing limitation of the Java SDK (that the init function invocation will always ues 'init' as the first parameter / function name), relaxing it for a minor point release, and then immediately requiring that the constraint be put back in place for v2.0.  For the 'Contract API', what is the plan for compatibility with the new lifecycle? How today do you ensure that the function passed to 'Init' is actually a function which initializes the contract rather than performing some other undesirable action?  Perhaps if I understood better how we see this API evolving it would be easier to understand the path forward.  ></body> </Action>
<Action id="57308" issue="37686" author="bestbeforetoday" type="comment" created="2019-02-19 15:41:40.0" updateauthor="bestbeforetoday" updated="2019-02-19 15:41:40.0"> <body><! CDATA  ~jyellick  Thanks for the detailed response. To make sure I'm explaining clearly, I'm talking here about the arguments passed as part of the deployment spec, where the first argument is treated as initialization function name and additional arguments as the arguments to that named function; not the capital "I" Init function. In Fabric 1.4 using the Node chaincode APIs and SDK, we allow client code to specify the initialization function name that will be included in the deployment spec arguments. No arguments are also allowed, in which case no initialization function gets called on instantiate. So there is a mismatch between how chaincode (regardless of its implementation language) can be instantiated using the Node and Java SDKs in Fabric 1.4. Surely the bahavior should be consistent. I'm happy to take guidance on what that consistent behavior should be.  In whether the function name specified is really the right one... this invocation is being done by an administrator who has privilege to instantiate chaincode and likely invoke any other transaction functions they like, right? I'm not sure why having them specify arguments to the instantiate is an additional risk.  ></body> </Action>
<Action id="57321" issue="37686" author="jyellick" type="comment" created="2019-02-19 19:17:01.0" updateauthor="jyellick" updated="2019-02-19 19:17:01.0"> <body><! CDATA  ~bestbeforetoday  {quote}To make sure I'm explaining clearly, I'm talking here about the arguments passed as part of the deployment spec, where the first argument is treated as initialization function name and additional arguments as the arguments to that named function; not the capital "I" Init function. {quote} Yes, I did understand that. In Fabric v1.x, the invocation included in the deployment spec, is passed to the chaincode handler as a message type of {{ChaincodeMessage_INIT}}. In the golang case, this triggers the handler to invoke the {{Init}} function of the golang chaincode.  In the test chaincodes used in the integration tests, when the 'Init' function is called (as a result of a ChaincodeMessage_INIT, as a result of an lscc deploy/upgrade), they either: 1) Simply ignore the 'function name', as it is known to be 'init' –  https://github.com/hyperledger/fabric/blob/e91c57c5fcb338b05fff6ac413ba5895dcebd06b/integration/chaincode/simple/chaincode.go#L23  2) Simply ignore everything (including the function name), as init is not particularly useful –  https://github.com/hyperledger/fabric/blob/e91c57c5fcb338b05fff6ac413ba5895dcebd06b/integration/chaincode/marbles_private/chaincode.go#L40  3) Ignore all of the arguments passed to 'Init' –  https://github.com/hyperledger/fabric/blob/e91c57c5fcb338b05fff6ac413ba5895dcebd06b/integration/chaincode/keylevelep/chaincode.go#L35   In short, as far as golang chaincodes go, I've never seen anyone actually depend on that first parameter. {quote}In Fabric 1.4 using the Node chaincode APIs and SDK, we allow client code to specify the initialization function name that will be included in the deployment spec arguments. No arguments are also allowed, in which case no initialization function gets called on instantiate. {quote} Based on the revision history of the code, this looks like the logic was changed in v1.4? It looks like the user was always free to overwrite the chaincode input arguments, but that if they were omitted, then 'init' was automatically filled in? {quote}So there is a mismatch between how chaincode (regardless of its implementation language) can be instantiated using the Node and Java SDKs in Fabric 1.4. Surely the bahavior should be consistent. I'm happy to take guidance on what that consistent behavior should be. {quote} Yes, I'd agree, we should probably homogenize this behavior. {quote}In whether the function name specified is really the right one... this invocation is being done by an administrator who has privilege to instantiate chaincode and likely invoke any other transaction functions they like, right? I'm not sure why having them specify arguments to the instantiate is an additional risk. {quote} To me, this is a very dangerous assumption, and points out one of the fundamental failures of the first iteration of lifecycle. No single user should have superpowers, nor be allowed to escape the checks of conventional invocation.  The only value in 'init' is that chaincode authors are guaranteed that it is invoked (and committed) before any other invocation occurs. If this value proposition is gone (as any function can be invoked) then why even allow it? I hope that you'll agree that the answer is "You should not allow it."  In conclusion (and what I was slowly driving at with all of the above), I would much rather see the contract API evolve in a direction where init is strictly not allowed period, which will significantly simplify life for users moving to the new lifecycle. If we continue to use init in the contract API, then starting in lifecycle v2.0 _only_ the function name "init" will be allowed as the first parameter. So, moving to allow all SDKs to specify a function other than "init" is a move in the wrong direction to me. IMO we should be pushing to get rid of init, rather than generalizing it to look more like an invoke.  ></body> </Action>
<Action id="57348" issue="37686" author="sstone1" type="comment" created="2019-02-20 10:50:18.0" updateauthor="sstone1" updated="2019-02-20 10:50:18.0"> <body><! CDATA  ~jyellick  the v1.4 changes to the SDK you reference allow a user to not specify an instantiate time function (by explicitly passing null/undefined as the function name), in which case nothing in the user's contract is called during instantiate. In the v2.0 SDK, no instantiate time function is called by default, unless explicitly specified.  I'm okay with banning "instantiate time functions" altogether if that's what gets decided, I can't disagree with any of your arguments for banning them ;-)  What we do need to get away from is having two things called "init" because it causes so much confusion: # The "Init" (capital I) function in the chaincode interface that chaincode developers have to specify # The "init" (lowercase i) string conventionally passed as the first argument to the above function  The second one is the one that causes most confusion, as I've spoken to a lot of people who incorrectly believe you *have* to specify it as "init" (as they mix it up with the first one), where instead as you point out no chaincode developers ever bothers to read the value of this argument, and you could really pass in whatever you like.  I'd also argue that "init" (whatever case it may be in) is a bad name for something that currently gets called during the instantiate or upgrade operations. The Fabric operator does not currently perform an "init" operation, so why do we have this chaincode method called "init"? Because the name is vague, it sounds like it could be called during any of these chaincode events: build, startup, instantiate, or upgrade. I appreciate the naming might have changed with lifecycle though?  If we do decide not to ban "instantiate time functions" then I would be more in favour of allowing contract developers to specify any function name, but explicitly annotate them as the function to be called during "instantiate time" or "upgrade time" (or insert new lifecycle phase time), e.g:  {code} @Instantiate public setupWorldState() {  }   @Upgrade public migrateWorldState() {  }  {code}   ></body> </Action>
