<Action id="21507" issue="14483" author="suganuma" type="comment" created="2017-03-14 15:29:41.0" updateauthor="suganuma" updated="2017-03-14 15:29:41.0"> <body><! CDATA I completed the work and now Java SDK can enroll with Fabric-CA over TLS protocol. I will ask code review some time soon.  ></body> </Action>
<Action id="21540" issue="14483" author="suganuma" type="comment" created="2017-03-16 14:38:31.0" updateauthor="suganuma" updated="2017-03-16 14:38:31.0"> <body><! CDATA Here is my code for TLS connection support for Fabric CA.  1) Add  the following code in the two methods named httpPost in HFCAClient.java (to be non-static method). // <-- added SSLContext sslContext = SSLContexts.custom() .loadTrustMaterial(getCryptoSuite().getTrustStore(), null) .build();  SSLConnectionSocketFactory sslConnectionFactory = new SSLConnectionSocketFactory(sslContext);  Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory> create() .register("https", sslConnectionFactory) .register("http", new PlainConnectionSocketFactory()) .build(); // added -->  HttpClient client = HttpClientBuilder.create() 		.setConnectionManager(new PoolingHttpClientConnectionManager(registry))        // added 		.setDefaultCredentialsProvider(provider).build();  HttpPost httpPost = new HttpPost(url);  AuthCache authCache = new BasicAuthCache();  HttpHost targetHost = new HttpHost(httpPost.getURI().getHost(), httpPost.getURI().getPort());  authCache.put(targetHost, new BasicScheme());  final HttpClientContext context = HttpClientContext.create(); context.setCredentialsProvider(provider); context.setAuthCache(authCache);  httpPost.setEntity(new StringEntity(body)); httpPost.addHeader(new BasicScheme().authenticate(credentials, httpPost, context));    // added  HttpResponse response = client.execute(httpPost, context); ... 2) Add the method declaration of getTrustStore() in CryptoSuite.java 3) Add some statements in TestConfig.java for switching between http and https (e.g. depending on env variable) 3) Add the following for the fabric-ca command in docker-compose.yml --tls.enabled  --tls.certfile /etc/hyperledger/tls/ca/tls_server-cert.pem  --tls.keyfile /etc/hyperledger/tls/ca/tls_server-key.pem, and volumes: - ./tls/ca:/etc/hyperledger/tls/ca The tls_server-*.pem files are from testdata directory in fabric-ca  ></body> </Action>
<Action id="21543" issue="14483" author="tuand" type="comment" created="2017-03-16 17:58:31.0" updateauthor="tuand" updated="2017-03-16 17:58:31.0"> <body><! CDATA Suganama-san,   is the sdk-java <-> fabric-ca connection mutual tls ?  How does the SDK load the certs from fabric-ca and how does fabric-ca load the cert from sdk-java ?  the CryptoSuite trust store may not necessarily have the fabric-ca tls cert  You might have to deal with tls separately from MSP/BCCSP   ></body> </Action>
<Action id="21549" issue="14483" author="suganuma" type="comment" created="2017-03-17 08:24:53.0" updateauthor="suganuma" updated="2017-03-17 08:24:53.0"> <body><! CDATA This is not mutual TLS. We do not provide client cert and key, which I'm not sure what to be used. Also how can we start fabric-ca-server with mutual TLS? Read.md describes something about mutual_tls_ca, but I'm not sure how we can specify the pem files in the command line argument to request client to send its certificate.  The trust store in CryptoPrimitive is currently initialized with cert files stored in cacerts dir which I assume the fabric-ca tls certs. Do you mean this assumption may not hold in the future and we have to set up a separate trust store?   ></body> </Action>
<Action id="21551" issue="14483" author="tuand" type="comment" created="2017-03-17 13:17:09.0" updateauthor="tuand" updated="2017-03-17 13:17:09.0"> <body><! CDATA Suganuma-san, I do not understand how fabric-ca does tls well enough.  You should talk to the fabric-ca folks to make sure how both sides need to be configured.  The CryptoPrimitives trust store does not contain the fabric-ca certs.  CryptoPrimitives is for signing and verifying signatures between the sdk and fabric peer/orderer.  Very soon now,  the sdk will populate the trust store with certs from a channel's genesis block.  Fabric-ca authentication/authorization is separate from this.  ></body> </Action>
<Action id="21576" issue="14483" author="suganuma" type="comment" created="2017-03-20 12:51:34.0" updateauthor="suganuma" updated="2017-03-20 12:51:34.0"> <body><! CDATA I checked this with the fabric-ca community and they do not use mutual TLS at this point. I also confirmed Gari Singh that sdk-node supports just one-way TLS for fabric-ca.  ></body> </Action>
<Action id="21577" issue="14483" author="rickr" type="comment" created="2017-03-20 13:04:43.0" updateauthor="rickr" updated="2017-03-20 13:07:27.0"> <body><! CDATA It's not mutual auth both for Fabric and Fabric_ca.  The server does not require the clients certificates.   Only the client requires the server's certificates.  Trust of the fabric_ca client is done via basic auth.   Trust of the fabric client is done via the signed payloads   TLS besides the encryption of the payload ensures that server you are initially communicating with is the one intended and not some rogue system.  ></body> </Action>
<Action id="21610" issue="14483" author="rickr" type="comment" body="I missing where did you load the fabric_ca certs into the trust store ?" created="2017-03-23 14:59:36.0" updateauthor="rickr" updated="2017-03-23 14:59:36.0"/>
<Action id="21612" issue="14483" author="suganuma" type="comment" body="The certs in the cacerts directory in the fabric-sdk-java root are loaded into the trust store by the method loadCACerts() called by cryptoSuite.init()." created="2017-03-23 15:57:22.0" updateauthor="suganuma" updated="2017-03-23 15:57:22.0"/>
<Action id="21614" issue="14483" author="rickr" type="comment" created="2017-03-23 18:30:43.0" updateauthor="rickr" updated="2017-03-23 18:30:43.0"> <body><! CDATA How did you for http get past for development the hostname certifificate check ?   Caused by: javax.net.ssl.SSLPeerUnverifiedException: Host name 'localhost' does not match the certificate subject provided by the peer (CN=ca0, OU=CA, O=Hyperledger Fabric, L=Raleigh, ST=NC, C=US) 	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.verifyHostname(SSLConnectionSocketFactory.java:465) 	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:395) 	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:353) 	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:141) 	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:353) 	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:380) 	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:236) 	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:184) 	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:88)   ></body> </Action>
<Action id="21617" issue="14483" author="suganuma" type="comment" created="2017-03-24 01:05:56.0" updateauthor="suganuma" updated="2017-03-24 01:05:56.0"> <body><! CDATA Which cert and key files did you use for fabric_ca TLS? Please try tls_server-*.pem under the fabric-ca/testdata directory.  ></body> </Action>
