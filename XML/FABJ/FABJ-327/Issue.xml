<Issue id="23223" key="FABJ-327" number="327" project="10605" reporter="dubovitskaya" assignee="dubovitskaya" creator="dubovitskaya" type="10000" summary="Idemix - Java SDK MVP" priority="1" resolution="10000" status="6" created="2017-10-31 19:17:39.0" updated="2020-06-11 15:31:20.0" resolutiondate="2018-10-10 05:18:00.0" votes="0" watches="9" workflowId="34735"> <description><! CDATA Provide Idemix crypto library in Java and integrate it with java-sdk for signing transactions.  *Idemix background:* From the client side the flow is the following.   A user gets an Idemix enrollment certificate, which is a signature (not ECDSA) on a set of attributes and a commitment to the user's private key. A commitment to the user's private key is called a pseudonym and can be seen as a public key. The only difference here is that the user can generate many public keys (pseudonyms) from the same secret key and prove that the corresponding secret key is signed inside a certificate by the CA (CA signs in a blind fashion, by singing a pseudonym). Using this single certificate a user can sign messages unlinkably, selectively revealing the attributes. The reason that this signatures are unlinkable is that instead of showing the certificate in clear, the user generates a zero-knowledge proof of possession of the certificate that hides all the (linkable) info and still can be verified with the public key of the CA who issued the certificate.   Therefore, a signing identity in the case of Idemix is not the original certificate, not something long-term, but rather a fresh unlinkable zero-knowledge proof of the certificate (so-called pseudonymous identity).  So the Idemix integration on the peer side (in Go) implements the SigningIdentity interface with the Idemix algorithms, since the MSP interface in Go supports different types of MSPs with different underlying crypto providers.  *Idemix & java-sdk:* The Enrollment.java interface of the java-sdk is tailored to X.509 enrollment certificates (something long term) that are also used to sign transactions. User.java only provides GetEnrollment() method to sign a transaction.  To support different crypto underlying the User.java interface and unlinkable transaction signing and also to stay in line with Node.js sdk and Go implementation, we propose to extend the User.java interface with the getSigningIdentity() method that would return a Signing Identity (a term from the Go MSP) to be used for that particular transaction.  A Signing Identity in the case of Idemix is a user private key, a pseudonym, and a zero-knowledge proof of possession of the (enrollment) certificate that only selectively discloses attributes. (In case of X.509 and no TCerts: Signing Identity = Enrollment). This can be used to sign a transaction.   GetEnrollment() in the case of Idemix would return the original certificate, attributes, user's private key and the original pseudonym that was signed inside the enrollment certificate. Since this is linkable it will not be used for signing transactions if privacy is required.  *Our contribution:*  (1) Provide the Idemix crypto library in java that supports all the crypto operations.  (2) Implement Signing Identity interface, like we did for Go. SigningIdentity will sign transactions and proper serialize Idemix Identity to be verified by the peers.  (3) We would extend the User interface with getSigningIdentity() to allow the generation of fresh unlinkable Signing Identites or retrieving the existing one.  (4) Integrate with transaction signing. We can add another TransactionContext constructor for the tech preview to support unlinkable signing and avoid breaking the interfaces. It will invoke Idemix User with SigningIdentity to sign a transaction.  (5) SampleStore implementation that supports Idemix certificates. The certificates will be generated and serialised using an existing tool.   (6) Integration with fabric-ca for credential issuance.  ></description> </Issue>
