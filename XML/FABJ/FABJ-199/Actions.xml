<Action id="46282" issue="31207" author="denyeart" type="comment" body=" ~rickr  Could you assess?" created="2018-06-20 12:16:08.0" updateauthor="denyeart" updated="2018-06-20 12:16:08.0"/>
<Action id="46294" issue="31207" author="rickr" type="comment" body="Needs at least a trace from the client side. Can we start out removing anything with mulithreads and see if it connects ?" created="2018-06-20 14:14:10.0" updateauthor="rickr" updated="2018-06-20 14:14:10.0"/>
<Action id="46341" issue="31207" author="gsqtds" type="comment" created="2018-06-21 02:36:00.0" updateauthor="gsqtds" updated="2018-06-21 02:36:00.0"> <body><! CDATA I know this bug! In org.hyperledger.fabric.sdk.Peer, line 207-217:  if (null == localEndorserClient || !localEndorserClient.isChannelActive()) \{     endorserClent = new EndorserClient(new Endpoint(url, properties).getChannelBuilder());     localEndorserClient = endorserClent; }     try \{      return localEndorserClient.sendProposalAsync(proposal); } catch (Throwable t) \{     endorserClent = null;     throw t; }     there is two errors:  one:     because there has localEndorserClient  if endorserClent is execption , at the same time  many thread  run sendProposalAsync,there will be  throw many exception.  two:  if(!localEndorserClient.isChannelActive())   boolean isChannelActive() \{     ManagedChannel lchannel = managedChannel;     return lchannel != null && !lchannel.isShutdown() && !lchannel.isTerminated() &&              ConnectivityState.READY.equals(lchannel.getState(true)); }  if lchannel.getState(true) is ConnectivityState.CONNECTING ,!localEndorserClient.isChannelActive() will be true.  many thread will create EndorserClient, and then it will be remove reference, and it will be gc,so the exception happend.     I suppose modify this code  with the following：  if (null == endorserClient ) \{     synchronized (this) \{        if (null == endorserClient) \{          endorserClient = new EndorserClient(new Endpoint(url, properties).getChannelBuilder());        }   } }  try \{     return endorserClient.sendProposalAsync(proposal); } catch (Throwable t) \{     endorserClient = null;     throw t; }              ></body> </Action>
<Action id="46494" issue="31207" author="rickr" type="comment" created="2018-06-25 16:33:36.0" updateauthor="rickr" updated="2018-06-25 16:33:36.0"> <body><! CDATA I created the below patch to the end2endAndBackagainIT  to create 10 threads and do nothing but endorsing. I seen all the threads doing the endorsing just fine.  I then while it was running shutdown a peer.  While the peer was down as expected I seen a lot of errors.  I then restarted the peer.  While it's not instance cause all threads need to make new connections it got to the point where it was when it started that all threads were seeing all peers successfully endorsing.     Index: src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java IDEA additional info: Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP <+>UTF-8 =================================================================== --- src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java	(revision edd54f832351452ef6aea3d9cb505b2f38b12711) +++ src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java	(date 1529944045000) @@ -529,58 +529,93 @@  }  +    static boolean goOn = true; + CompletableFuture<BlockEvent.TransactionEvent> moveAmount(HFClient client, Channel channel, ChaincodeID chaincodeID, String moveAmount, User user) {  -        try { -            Collection<ProposalResponse> successful = new LinkedList<>(); -            Collection<ProposalResponse> failed = new LinkedList<>(); +        List<Thread> threads = new LinkedList<>(); + +        for (int i = 100; i > 0; --i) { +            final int ii = i; +            Thread thread = new Thread(new Runnable() { +                @Override +                public void run() { + +                    do { +                        try { + +                            out("running thread %d", ii); +                            Collection<ProposalResponse> successful = new LinkedList<>(); +                            Collection<ProposalResponse> failed = new LinkedList<>();  -            /////////////// -            /// Send transaction proposal to all peers -            TransactionProposalRequest transactionProposalRequest = client.newTransactionProposalRequest(); -            transactionProposalRequest.setChaincodeID(chaincodeID); -            transactionProposalRequest.setFcn("move"); -            transactionProposalRequest.setArgs(new byte     {//test using bytes .. end2end uses Strings. -                    "a".getBytes(UTF_8), "b".getBytes(UTF_8), moveAmount.getBytes(UTF_8)}); -            transactionProposalRequest.setProposalWaitTime(testConfig.getProposalWaitTime()); -            if (user != null) { // specific user use that -                transactionProposalRequest.setUserContext(user); -            } -            out("sending transaction proposal to all peers with arguments: move(a,b,%s)", moveAmount); +                            /////////////// +                            /// Send transaction proposal to all peers +                            TransactionProposalRequest transactionProposalRequest = client.newTransactionProposalRequest(); +                            transactionProposalRequest.setChaincodeID(chaincodeID); +                            transactionProposalRequest.setFcn("move"); +                            transactionProposalRequest.setArgs(new byte     {//test using bytes .. end2end uses Strings. +                                    "a".getBytes(UTF_8), "b".getBytes(UTF_8), moveAmount.getBytes(UTF_8)}); +                            transactionProposalRequest.setProposalWaitTime(testConfig.getProposalWaitTime()); +                            if (user != null) { // specific user use that +                                transactionProposalRequest.setUserContext(user); +                            } +                            out("thread %d sending transaction proposal to all peers with arguments: move(a,b,%s)", ii, moveAmount);  -            Collection<ProposalResponse> invokePropResp = channel.sendTransactionProposal(transactionProposalRequest); -            for (ProposalResponse response : invokePropResp) { -                if (response.getStatus() == Status.SUCCESS) { -                    out("Successful transaction proposal response Txid: %s from peer %s", response.getTransactionID(), response.getPeer().getName()); -                    successful.add(response); -                } else { -                    failed.add(response); -                } -            } +                            Collection<ProposalResponse> invokePropResp = channel.sendTransactionProposal(transactionProposalRequest); +                            for (ProposalResponse response : invokePropResp) { +                                if (response.getStatus() == Status.SUCCESS) { +                                    out("Successful transaction proposal response Txid: %s from peer %s", response.getTransactionID(), response.getPeer().getName()); +                                    successful.add(response); +                                } else { +                                    failed.add(response); +                                } +                            }  -            out("Received %d transaction proposal responses. Successful+verified: %d . Failed: %d", -                    invokePropResp.size(), successful.size(), failed.size()); -            if (failed.size() > 0) { -                ProposalResponse firstTransactionProposalResponse = failed.iterator().next(); +                            out("Received %d transaction proposal responses. Successful+verified: %d . Failed: %d", +                                    invokePropResp.size(), successful.size(), failed.size()); +                            if (failed.size() > 0) { +                                ProposalResponse firstTransactionProposalResponse = failed.iterator().next();  -                throw new ProposalException(format("Not enough endorsers for invoke(move a,b,%s):%d endorser error:%s. Was verified:%b", -                        moveAmount, firstTransactionProposalResponse.getStatus().getStatus(), firstTransactionProposalResponse.getMessage(), firstTransactionProposalResponse.isVerified())); +                                final ProposalException proposalException = new ProposalException(format("Not enough endorsers for invoke(move a,b,%s):%d endorser error:%s. Was verified:%b", +                                        moveAmount, firstTransactionProposalResponse.getStatus().getStatus(), firstTransactionProposalResponse.getMessage(), firstTransactionProposalResponse.isVerified())); +                                out("%s", proposalException.getMessage());  -            } -            out("Successfully received transaction proposal responses."); +                            } +                            out("Successfully received transaction proposal responses.");  -            //////////////////////////// -            // Send transaction to orderer -            out("Sending chaincode transaction(move a,b,%s) to orderer.", moveAmount); -            if (user != null) { -                return channel.sendTransaction(successful, user); -            } -            return channel.sendTransaction(successful); -        } catch (Exception e) { +                        } catch (Exception e) {  -            throw new CompletionException(e); +                            e.printStackTrace(); + +                        } +                    } while (goOn); + +                } +            }); + +            threads.add(thread); +        } + +        threads.forEach(thread -> thread.start()); + +        try { +            threads.forEach(thread -> +            { +                try { +                    thread.join(); +                } catch (InterruptedException e) { +                    e.printStackTrace(); + +                } +            });  +        } catch (Exception e) { +            e.printStackTrace(); } + +        System.exit(0); + +        return null;  }  ></body> </Action>
<Action id="46495" issue="31207" author="rickr" type="comment" body="I see no link to FAB-10604 " created="2018-06-25 16:34:38.0" updateauthor="rickr" updated="2018-06-25 16:34:38.0"/>
<Action id="46496" issue="31207" author="rickr" type="comment" body="Can you please provide a patch like I did above that reproduces this issue ? " created="2018-06-25 16:36:59.0" updateauthor="rickr" updated="2018-06-25 16:36:59.0"/>
<Action id="46498" issue="31207" author="rickr" type="comment" body="I also just tried putting a breakpoint at the begining of the move routine brought the peer down.  Then started up the threads. As expected nothing but errors.  Then started the peer and all threads started reporting successuflly endorsing." created="2018-06-25 16:41:42.0" updateauthor="rickr" updated="2018-06-25 16:41:42.0"/>
<Action id="46500" issue="31207" author="rickr" type="comment" created="2018-06-25 18:00:43.0" updateauthor="rickr" updated="2018-06-25 18:00:43.0"> <body><! CDATA I have noticed this : https://ctrlv.it/id/129163/1743181400  The Peer is accepting connections when it's really not ready to handle requestes. When not connecting this is sent :  ``` Thread Thread-757 Received 2 transaction proposal responses. Successful+verified: 1 . Failed: 1 Thread Thread-757 Not enough endorsers for invoke(move a,b,25):500 endorser error:Sending proposal to peer0.org1.example.com failed because of: gRPC failure=Status{code=UNAVAILABLE, description=io exception, cause=java.io.IOException: Connection reset by peer 	at sun.nio.ch.FileDispatcherImpl.read0(Native Method) 	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:39) 	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223) 	at sun.nio.ch.IOUtil.read(IOUtil.java:192) 	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380) 	at io.netty.buffer.PooledUnsafeDirectByteBuf.setBytes(PooledUnsafeDirectByteBuf.java:288) 	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1108) 	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:345) 	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131) 	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580) 	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497) 	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459) 	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886) 	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) 	at java.lang.Thread.run(Thread.java:745) }. Was verified:false Thread Thread-747 Successful transaction proposal response Txid: 04048dc9e0b32db18654c69f4529d6ddb6a8a2f366ff7293c783a370405cad9b from peer peer1.org1.example.com Thread Thread-747 Received 2 transaction proposal responses. Successful+verified: 1 . Failed: 1 T ``` but then  changes to :  ``` Thread Thread-747 Received 2 transaction proposal responses. Successful+verified: 1 . Failed: 1 Thread Thread-747 Not enough endorsers for invoke(move a,b,25):500 endorser error:failed to execute transaction 04048dc9e0b32db18654c69f4529d6ddb6a8a2f366ff7293c783a370405cad9b: failed to register example_cc_go:1 as launching: chaincode example_cc_go:1 has already been launched. Was verified:false Thread Thread-869 Successful transaction proposal response Txid: 5c188b5120278f8f0787c014c6898698cee58a6ca08bac5fe04092fa4d45d530 from peer peer1.org1.example.com T ``` After a while it will then fully be up and you get :  ``` Thread Thread-357 Not enough endorsers for invoke(move a,b,25):500 endorser error:failed to execute transaction b06e3df8d23b2330e8b90229c5fcf213ecf50fc0b9df0f61aa8ec46455ff2546: failed to register example_cc_go:1 as launching: chaincode example_cc_go:1 has already been launched. Was verified:false Thread Thread-676 Successful transaction proposal response Txid: ac27f86f6120278958eb075e56a36b50bc187fd12eb883ab33aebb01ee6bcbd2 from peer peer1.org1.example.com Thread Thread-676 Received 2 transaction proposal responses. Successful+verified: 1 . Failed: 1 Thread Thread-676 Not enough endorsers for invoke(move a,b,25):500 endorser error:failed to execute transaction ac27f86f6120278958eb075e56a36b50bc187fd12eb883ab33aebb01ee6bcbd2: failed to register example_cc_go:1 as launching: chaincode example_cc_go:1 has already been launched. Was verified:false Thread Thread-686 Successful transaction proposal response Txid: a29f9a539ad3fe19e378fa5e5cb07e1b55c748bc87d8bffbe32a8c559d14f7c5 from peer peer0.org1.example.com Thread Thread-686 Successful transaction proposal response Txid: a29f9a539ad3fe19e378fa5e5cb07e1b55c748bc87d8bffbe32a8c559d14f7c5 from peer peer1.org1.example.com Thread Thread-686 Received 2 transaction proposal responses. Successful+verified: 2 . Failed: 0 ```  IMO Peer shouldn't accept connections till it's fullly operational   ~denyeart   ~wlahti     ></body> </Action>
<Action id="46501" issue="31207" author="wlahti" type="comment" body="Agreed with that last part,  ~rickr  (&quot;IMO Peer shouldn&apos;t accept connections till it&apos;s fullly operational). Jason already created FAB-10804 to fix that. " created="2018-06-25 18:15:29.0" updateauthor="wlahti" updated="2018-06-25 18:15:29.0"/>
<Action id="46518" issue="31207" author="gsqtds" type="comment" created="2018-06-26 06:53:33.0" updateauthor="gsqtds" updated="2018-06-26 06:53:33.0"> <body><! CDATA Index: src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java IDEA additional info: Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP <+>UTF-8 =================================================================== --- src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java	(revision d186e02f3f7de0a058166bb0925464c0e71f3e57) +++ src/test/java/org/hyperledger/fabric/sdkintegration/End2endAndBackAgainIT.java	(revision ) @@ -29,6 +29,10 @@ import java.util.Set; import java.util.concurrent.CompletableFuture; import java.util.concurrent.CompletionException; +import java.util.concurrent.ExecutorService; +import java.util.concurrent.Executors; +import java.util.concurrent.LinkedBlockingQueue; +import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicLong;  @@ -696,12 +700,56 @@ //Begin tests with de-serialized channel.  //Query the actual peer for which channels it belongs to and check it belongs to this channel + + + +        int index = 0; for (Peer peer : newChannel.getPeers()) { -            Set<String> channels = client.queryChannels(peer); -            if (!channels.contains(name)) { +            //Set<String> channels = client.queryChannels(peer); +            /*if (!channels.contains(name)) { throw new AssertionError(format("Peer %s does not appear to belong to channel %s", peer.getName(), name)); +            }*/ +            index++; +            if (index == 2) { +                ThreadPoolExecutor executorService = new ThreadPoolExecutor(100, 100, +                        0L, TimeUnit.MILLISECONDS, +                        new LinkedBlockingQueue<Runnable>()); +                executorService.prestartAllCoreThreads(); +                for (int i = 0 ; i < 100 ; i++) { +                    executorService.execute(() -> { +                        try { +                            QueryByChaincodeRequest queryByChaincodeRequest1 = client.newQueryProposalRequest(); +                            queryByChaincodeRequest1.setArgs("b".getBytes(UTF_8)); // test using bytes as args. End2end uses Strings. +                            queryByChaincodeRequest1.setFcn("query"); +                            queryByChaincodeRequest1.setChaincodeID(chaincodeID); +                            //System.out.println("haha"); +                            client.queryChannels(peer); +                        } catch (ProposalException e) { +                            e.printStackTrace(); +                        } catch (InvalidArgumentException e) { +                            e.printStackTrace(); +                        } +                    }); +                } + } } + +        try { +            System.out.println("wait....."); +            List<Object> l = new ArrayList<Object>(); +            for (int i =0; i< 1000;i++) +            { +                l.add(new byte 1024*1024  ); +                if (i % 10 ==0) +                { +                    System.gc(); +                } +            } +            Thread.sleep(10000); +        } catch (InterruptedException e) { +            e.printStackTrace(); +        }  //Just see if we can get channelConfiguration. Not required for the rest of scenario but should work. final byte   channelConfigurationBytes = newChannel.getChannelConfigurationBytes();   ></body> </Action>
<Action id="46520" issue="31207" author="gsqtds" type="comment" body=" ~rickr  you can try this , it will also invoke sendProposalAsync method  . because peer1 in channel.initialize() do this method. so i invoke sendProposalAsync in peer2" created="2018-06-26 06:57:05.0" updateauthor="gsqtds" updated="2018-06-26 06:57:05.0"/>
<Action id="46522" issue="31207" author="gsqtds" type="comment" body="  ^test_exception.patch  " created="2018-06-26 07:10:14.0" updateauthor="gsqtds" updated="2018-06-26 07:10:14.0"/>
<Action id="46554" issue="31207" author="rickr" type="comment" created="2018-06-26 16:25:16.0" updateauthor="rickr" updated="2018-06-26 16:26:34.0"> <body><! CDATA I attached what I tested which basically your patch But I added some output for the queryChannels request in the threads. I think this is still representative of the test. Here's the output I got >  RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo: RICK channels foo:  This is what I think I'd expect.   With out the output I get ---  RUNNING: End2endAndBackAgainIT.  Reconstructing foo channel wait.....  Process finished with exit code 0  ></body> </Action>
<Action id="46808" issue="31207" author="gsqtds" type="comment" created="2018-07-02 09:46:49.0" updateauthor="gsqtds" updated="2018-07-02 09:48:51.0"> <body><! CDATA  Hi, ~rickr ,i was travel these days。 I saw your code，there is a little different。 you should Commented out below code  {code:java} Set<String> channels = client.queryChannels(peer); if (!channels.contains(name)) { throw new AssertionError(format("Peer %s does not appear to belong to channel %s", peer.getName(), name)); } {code} because of this code will execute connect operate. this is my test case.  ^End2endAndBackAgainIT.java    ></body> </Action>
<Action id="47179" issue="31207" author="rickr" type="comment" body="Made no difference in the result that I get.  I&apos;m also running on a change FAB-10966  There was a grpc infinite loop that they fixed. Can&apos;t say for sure if that had anything to do with this or not." created="2018-07-10 16:51:32.0" updateauthor="rickr" updated="2018-07-10 16:51:32.0"/>
<Action id="47192" issue="31207" author="gsqtds" type="comment" body="I try this with grpc 1.13.1 , it sometimes run well，and sometimes run exception 。I guess the reason is the network connect is very good。So if the sdkintegration network run other machine，the anomaly probability will became bigger" created="2018-07-11 04:23:52.0" updateauthor="gsqtds" updated="2018-07-11 05:59:43.0"/>
<Action id="47466" issue="31207" author="rickr" type="comment" body="I have never been able to reproduce this behavior. Unless I get something that does it regularly and repeatedly I&apos;m closing this for now." created="2018-07-18 12:40:20.0" updateauthor="rickr" updated="2018-07-18 12:40:20.0"/>
