<Issue id="26731" key="FABJ-198" number="198" project="10605" reporter="ryokawajp" assignee="rickr" creator="ryokawajp" type="10004" summary="SDKUtils.getProposalConsistencySets() uses RWsets to compare ProposalResponses, which is not sufficient to detect tampering of DB or non-determinism" priority="3" resolution="10000" status="6" created="2018-01-11 03:26:13.0" updated="2018-07-19 00:20:42.0" resolutiondate="2018-01-23 14:05:40.0" votes="0" watches="3" workflowId="33636"> <environment><! CDATA * Hyperledger Fabric v1.0.1 * fabric-sdk-java v1.0.1 * 2 Orderer nodes, 4 Kafka brokers, 3 Zookeeper nodes * 4 peers (3-out-of-4 endorsement policy) * Couch DB * Docker v17.06.0-ce * Ubuntu Linux 16.04 (x86_64) * WebSphere Application Server v9.0.0.4 * IBM Java v1.8.0  ></environment> <description><! CDATA *Background:*  As far as I know, a Byzantine failure in a query transaction must be handled in the client-side. This is because in the case of an invoke transaction, an endorsement policy is checked in committing peer, while in the case of a query transaction, there is no such check in a peer.  So we used SDKUtils.getProposalConsistencySets() to implement this checking of consistency among the ProposalResponse objects returned from different peers.  To verify this implementation, we did some tampering tests. That is, we changed the values of some keys in Couch DB using Couch DB's REST API directly in one or two peers and tried to query the keys through a query transaction sent to 4 peers including the tampered peer.  Then we got 4 Proposal Responses, which were passed to SDKUtils.getProposalConsistencySets(). Additionally, I implemented the client to chose the largest consistency set as the "consensus".  *Expected behavior:*  Let PR = \{p1, p2, p3, p4} be a set of queried values in a Proposal Responses from peer 1, 2, 3, and 4. Let A be the correct value of a key and B be a tampered value of the key. Then, getProposalConsistencySets() is expected to convert PR as follows: * input: PR -> output: Consistency Sets (please ignore the order of elements) * \{A, A, A, A} -> \{ \{A, A, A, A} } * \{A, A, B, A} -> \{ \{A, A, A}, \{B} } * \{A, B, B, A} -> \{ \{A, A}, \{B, B} }  *Observed behavior:* * \{A, A, A, A} -> \{ \{A, A, A, A} } * \{A, A, B, A} -> \{ \{A, A, A, B} } * \{A, B, B, A} -> \{ \{A, A, B, B} }  *Cause of this result:*   https://github.com/hyperledger/fabric-sdk-java/blob/master/src/main/java/org/hyperledger/fabric/sdk/SDKUtils.java#L124   According to the source code, getProposalConsistencySets() uses the read-write set in the Proposal Response object as a key of a hash map in order to group the collection of  Proposal Response objects.    https://github.com/hyperledger/fabric-sdk-java/blob/master/src/main/proto/ledger/rwset/kvrwset/kv_rwset.proto#L67   In the case of a query transaction, Proposal Responses contain read sets only. According to the comment in kv_rwset.proto, a read set does not contain the value of a key. It only contains a key and its version number. The version number is determined from the block height and the TX number. Therefore, if a key in a World State DB is tampered by an external tool, a read set does not contain enough information to detect the change of the value.  *Proposed fix:*  In general, not only a tampering of World State DB but also non-determinism of a chaincode could cause a Byzantine failure. So it seems better to use the return value of a chaincode in addition to the RW set as a key of the hash map.  (I have not evaluated side-effects or performance changes by this modification yet.)     ></description> </Issue>
