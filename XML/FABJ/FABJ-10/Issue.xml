<Issue id="17706" key="FABJ-10" number="10" project="10605" reporter="mikegardiner" creator="mikegardiner" type="10001" summary="Fabric Java SDK Crypto interface should use standard JCA/JCE provider abstraction" priority="2" resolution="10000" status="6" created="2017-06-09 18:20:49.0" updated="2018-07-20 19:17:08.0" resolutiondate="2017-10-19 14:33:46.0" votes="0" watches="3" workflowId="33448" security="10001"> <description><! CDATA  The CryptoSuite interface as well as CryptoPrimitives is needlessly complex containing dead code from previous implementations and doesn't take advantage of native java crypto abstraction provided via the Java Crypto Architecture/Extension Service Provider Interfaces.  Here are a number of suggestions to improve the interface based on years of experience creating JCA/JCE implementations.      1.      Consider eliminating the CryptoSuite interface I don’t really see a specific need to have multiple implementations of the interface.  We should be thinking of the JCA/JCE interface as the abstraction  2.      The new CryptoSuite/PrimitiveCrypto class should inspect the configured provider to ensure it has implementations for the required algorithms. This may mean we want to configure providers per operation type.. Could be for asymmetric/symmetric.  Or more likely to do verification (low assurance) operations in software and signature / key agreement/generation (high assurance) operations in hardware.  If the provider cannot do the operations then throw an exception, never fall back to a different crypto implementation.   3.      Management of keys (load KeyStore or PEM files) should be up to the application since the CryptoSuite is only concerned with keys/certs directly.  KeyStore implementations as a more Java native approach, so I would suggest that the SDK and samples use that approach rather than PEM files.  It would be beneficial to have separate trust and key stores.    4.      CryptoPrimitives.verify : what’s going on here? Is it really true that you try to verify the data with the algorithm of the cert?  The algorithm of the cert shouldn’t have any bearing on the algorithm that was used to sign the data.  The algorithm in the cert lets you know that the cert was signed with, that’s all.  For now it would be safe to assume that the DEFAULT_SIGNATURE_ALGORITHM is the one to use.. but as a general comment to the wider fabric community, a homogeneous crypto system is something you shouldn’t assume.  I would recommend having it as a parameter.    5.      The identifier P-256 isn’t a standard name for the prime256 curve.  You should use “prime256v1” or “secp256r1”  6.      Rather than a “security level” with a bit value it would be better to explicitly name the curve.. but I understand this is a wider ‘fabric’ issue  7.      In general.. I really hate seeing functions that only call another function.  Eg:  keyGen() just calls ecdsaKeyGen which just fills some values and calls generateKey.  There isn't any reason why keyGen() couldn't do the work in generateKey or take parameters which can alter the defaults and generate with those parameters.  8.      EciesDecrypt Is this used anywhere?  It feels like CryptoPrimitives may have a bunch of dead code that should be removed? Some providers support ECIES.. but the challenge is that there are a few standards calling themselves ecies so they are often not compatible.   It’s probably fine to leave this function here if it’s actually used  9.      CalculateMac This function should use javax.crypto.Mac rather than the bouncy castle HMac class.   10.  aesDecrypt this method doesn’t use the specified provider and instead uses the first one on the java.security list which can do the symmetric operation.  It should specify a provider  11.   ECNamedCurveParameterSpec… replace this with the java named curve classes rather than BC  12.  ecdsaSign method… why is this here, not part of the interface or used in the project.  Dead Code?  {color:#004080}13.{color}{color:#004080}  {color}sign->ecdsaSignToBytes.. again, why call another function needlessly? It should be using standard Java Signature class rather than bouncy castle.  All of the Malleability portions (enforce low s value) should be applicable to any provider after you decode the signature to get the R and S value.  We have code to do this that can be provided.  The code we have is using Bouncy Castle ASN1 Primitives.  We could continue with that or build something bespoke.  14.  creating CSRs, haven’t looked at this code yet.. should work with the private key in another provider but I believe you also had to specify the signer provider for the JcaContentSignerBuilder to be the one used for key generation since that’s where the keys is.  In the case of our provider you would call csBuilder.setProvider(“LunaProvider”).  This call is commented out in the code right now.  So I would leave BouncyCastle as a dependency on this SDK.  Chiefly because every provider which does include certificate generation support does it in a different way and the BC Cert classes have always been friendly to using a private key in another provider.   15.  hash / Digest methods This should use MessageDigest classes, not Digest from BouncyCastle.  It is true that not all providers will support all hashes (SHA3 for example) but you probably can just leave the provider selection blank and get any provider that supports the hash since it isn't a security issue.  ></description> </Issue>
