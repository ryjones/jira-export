<Issue id="35328" key="FABJ-389" number="389" project="10605" reporter="connect2b" assignee="rickr" creator="connect2b" type="10004" summary="Channel.shutdown() does not terminate SingleThreadScheduledExecutor" priority="3" resolution="10000" status="6" created="2018-11-14 06:16:24.0" updated="2018-12-17 20:30:14.0" resolutiondate="2018-12-17 20:30:14.0" votes="0" watches="2" workflowId="46792"> <description><! CDATA Gerrit CS https://gerrit.hyperledger.org/r/#/c/28133/  Channel.shutdown() does only cancel the sweeping job. {code:java} ScheduledFuture<?> lsweeper = sweeper; sweeper = null;  if (null != lsweeper) { lsweeper.cancel(true); }{code} At first glance, it doesn't matter but it could be reason memory leaking occurs.  When sweeper has been created, Channel.sweeper only refers to sweeping job  and created SingleThreadScheduledExecutor thread is running as daemon. {code:java} sweeper = Executors.newSingleThreadScheduledExecutor(r -> { Thread t = Executors.defaultThreadFactory().newThread(r); t.setDaemon(true); return t; }).scheduleAtFixedRate(() -> { try {  ...{code} So, there is no way to control the created thread.  If Channel.shutdown() and Client.newChannel() is repeatedly invoked,   all created channel will produce orphan thread until main thread is terminated.  I think it's not complete shutdown expected.  ></description> </Issue>
