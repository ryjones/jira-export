<Issue id="33543" key="FAB-11894" number="11894" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Fix gossip state transfer" priority="2" resolution="10000" status="6" created="2018-09-06 08:29:01.0" updated="2018-09-19 22:05:53.0" resolutiondate="2018-09-06 21:06:15.0" votes="0" watches="1" workflowId="44832"> <description><! CDATA Currently when gossip state transfer tries to complete block via state transfer it checks for peers which has more advanced ledger height and send appropriate request, the code which handles it works as following:  {code} 			ourHeight, err := s.ledger.LedgerHeight() 			if err != nil { 				// Unable to read from ledger continue to the next round 				logger.Errorf("Cannot obtain ledger height, due to %+v", errors.WithStack(err)) 				continue 			} 			if ourHeight == 0 { 				logger.Error("Ledger reported block height of 0 but this should be impossible") 				continue 			} 			maxHeight := s.maxAvailableLedgerHeight() 			if ourHeight >= maxHeight { 				continue 			}  			s.requestBlocksInRange(uint64(ourHeight), uint64(maxHeight)) {code}  where the request produced after the   {code} s.requestBlocksInRange(uint64(ourHeight), uint64(maxHeight)) {code}  with  {code} // GetBlocksInRange capable to acquire blocks with sequence // numbers in the range  start...end . func (s *GossipStateProviderImpl) requestBlocksInRange(start uint64, end uint64) { 	atomic.StoreInt32(&s.stateTransferActive, 1) 	defer atomic.StoreInt32(&s.stateTransferActive, 0)  	for prev := start; prev <= end; { 		next := min(end, prev+defAntiEntropyBatchSize)  		gossipMsg := s.stateRequestMessage(prev, next) {code}  The actual problem is that it considers peers ledger height as next available sequence to request missing block, however since we count blocks from zero, it has to be actually peers ledger height minus one. Therefore it might cause for following issue  {quote} 2018-09-04 22:48:57.152 UTC  kvledger  CommitWithPvtData -> INFO 1e28 0m Channel  consortium : Committed block  6657  with 2 transaction(s)  31m2018-09-04 22:48:59.101 UTC  gossip/state  handleStateRequest -> ERRO 1e29 0m cannot read block number 6658 from ledger, because Entry not found in index, skipping...  31m2018-09-04 22:48:59.105 UTC  gossip/state  handleStateRequest -> ERRO 1e2a 0m cannot read block number 6658 from ledger, because Entry not found in index, skipping...  31m2018-09-04 22:48:59.109 UTC  gossip/state  handleStateRequest -> ERRO 1e2b 0m cannot read block number 6658 from ledger, because Entry not found in index, skipping...  31m2018-09-04 22:48:59.113 UTC  gossip/state  handleStateRequest -> ERRO 1e2c 0m cannot read block number 6658 from ledger, because Entry not found in index, skipping...  31m2018-09-04 22:48:59.139 UTC  gossip/state  handleStateRequest -> ERRO 1e2d 0m cannot read block number 6658 from ledger, because Entry not found in index, skipping... 2018-09-04 22:48:59.561 UTC  kvledger  CommitWithPvtData -> INFO 1e2e 0m Channel  consortium : Committed block  6658  with 1 transaction(s) {quote}  the fix is pretty simple, we should do the range query for open range as following:  {code} // GetBlocksInRange capable to acquire blocks with sequence // numbers in the range  start...end). func (s *GossipStateProviderImpl) requestBlocksInRange(start uint64, end uint64) { 	atomic.StoreInt32(&s.stateTransferActive, 1) 	defer atomic.StoreInt32(&s.stateTransferActive, 0)  	for prev := start; prev < end; { 		next := min(end-1, prev+defAntiEntropyBatchSize) {code}  ></description> </Issue>
