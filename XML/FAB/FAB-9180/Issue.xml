<Issue id="28910" key="FAB-9180" number="9180" project="10002" reporter="elli-androulaki" creator="elli-androulaki" type="10002" summary="Group identity functions into two interfaces, the one of ValidatedIdentity, and Identity interfaces." priority="3" resolution="10001" status="6" created="2018-03-27 08:30:34.0" updated="2020-06-11 15:30:37.0" resolutiondate="2020-01-22 22:32:48.0" votes="0" watches="1" workflowId="35654"> <description><! CDATA *Motivation*. The reason for this task is to make the procedure of validation of an identity cleaner to the developer making use of MSP functions. We propose the validation of identity to result into a new structure, called "ValidatedIdentity" that would be the one exposing **SatisfiesPrincipal** operations. In this way the developer would be protected to only check principal satisfaction on an identity that has already been validated.     *Proposed design*  Currently two identity related interfaces are defined. The *msp.Identity* interface supports identity validation and signature verification related operations, while *msp.SigningIdentity* extends *msp.Identity* to add signing capabilities. Here we propose to break *msp.Identity* interface into two parts: * *msp.Identity* interface to represent a (deserialised) identity, and whose only ability is to run Identity.Validate() (or _Identity.ValidateAt()_) function to validate itself (at a given time) and produce its *msp.ValidatedIdentity* equivalent. * *msp.ValidatedIdentity* interface that would expose _Verify_, _SatisfiesPrincipal_ as well as a special/new function “_ValidateAt(..)_" that on input a timestamp would assess the validity of the identity with the respect to the passed time reference. Getters also of all the fields of an identity are provided via the msp.ValidatedIdentity interface.  With the above split, *msp.SigningIdenity* will inherits from *msp.ValidatedIdentity*.     More specifically, the proposed change in the interfaces would set *msp.Identity* interface to be:       {code:java} // Identity interface represents a deserialised identity that has not yet been // validated against the rules of its owning MSP. It exposed functions to validate // itself (Validate), and at a given timestamp (ValidateAt). type Identity interface {  // Validate uses the rules that govern this identity to validate it.  // E.g., if it is a fabric TCert implemented as identity, validate  // will check the TCert signature against the assumed root certificate  // authority.  Validate() (ValidatedIdentity, error)    // ValidateAt uses the rules that govern this identity to validate it  // at a given timestamp, i.e., considering potential expiration of the identity.  // E.g., if it is a fabric TCert implemented as identity, validate  // will check the TCert signature against the assumed root certificate  // authority.  ValidateAt(ts timestamp.Timestamp) (ValidatedIdentity, error)    // Serialize converts an identity to bytes  Serialize() (  byte, error) } {code}        The *msp.ValidatedIdentity* supports most of validation related operations of the former msp.Identity, and would thus consist of the following operations:       {code:java} // ValidatedIdentity represents a deserialized identity that has been // validated using the rules of its owning MSP. ValidatedIdentity // exposes mechanisms to perform revalidation at another timestamp (to assess // expiration), signature verification capabilities, as well as principal evaluation.   type ValidatedIdentity interface { Identity  // ExpiresAt returns the time at which the Identity expires.  // If the returned time is the zero value, it implies  // the Identity does not expire, or that its expiration  // time is unknown  ExpiresAt() time.Time    // GetIdentifier returns the identifier of that identity  GetIdentifier() *IdentityIdentifier   // GetOwnerIdentifier returns a representation of the identity’s owner  GetOwnerIdentifier() *OnwerIdentifier    // GetMSPIdentifier returns the MSP Id for this instance  GetMSPIdentifier() string    // CheckExpiration would ensure that this identity is valid at a given timestamp,  // and return an error if it has expired in the meantime.  CheckExpiration(ts time.Time) error    // GetProperty returns zero or more properties of the identity that correspond to the  // property type that is provided as input. For example, propertyType can be set to “OU”,  // “O”, or “CN”, “DN” for the organisational units (OU field of X.509 certs), organizations  // (O field of X.509 certs), common name (CN field of X.509 certs) or  distinguished  // name (DN field of X.509 certs) respectively. IdentityProperty object is separately  // defined.  GetProperty(properyType PropertyType)   *Property    // Verify a signature over some message using this identity as reference  Verify(msg   byte, sig   byte) error    // SatisfiesPrincipal checks whether this instance matches  // the description supplied in MSPPrincipal. The check may  // involve a byte-by-byte comparison (if the principal is  // a serialized identity) or may require MSP validation  SatisfiesPrincipal(principal *msp.MSPPrincipal) error }   {code}    In this way, the flow to check a signature w.r.t. a given SerialisedIdentity would be:    *SerializedIdentity* -> _Deserialise(.)_ -> *Identity* -> _Validate(.)_ -> *ValidatedIdentity* -> _Verify(.)_     The new *msp.SigningIdentity* will just inherits from the *msp.ValidatedIdentity* and keep the same methods as before.       {code:java} // SigningIdentity is an extension of Identity to cover signing capabilities. // E.g., signing identity should be requested in the case of a client who wishes // to sign transactions, or fabric endorser who wishes to sign proposal // processing outcomes. type SigningIdentity interface {    // Extends ValidatedIdentity  ValidatedIdentity    // Sign the message  Sign(msg   byte) (  byte, error)    // GetPublicVersion returns the public parts of this identity  GetPublicVersion() Identity }   {code}    OwnerIdentifier, Property and PropertyType are defined as follows:       {code:java} type OwnerIdentifier struct {    // identifier of the msp of the identity  mspid string  // identifier of the owner of an identity computed as the HASH(signingCAcert, DN, CN, OU, O),  // where DN, CN, OU, O are the respective fields of the certificates  identifier   byte }   type Property struct {    // type of the property  Type PropertyType  // value of the property  Value   byte }   {code}    Finally, *msp.PropertyType* is just the following enumeration:       {code:java} // PropertyType indicates the type of a property type PropertyType int   // The PropertyType of an identity’s property const ( ORGANIZATIONAL_UNIT PropertyType = iota // Identity’s OrganizationalUnit property ORGANIZATION                     // Identity’s Organizational property COMMON_NAME                     // Identity’s Common Name property DISTINGUISHED_NAME                     // Identity’s Distinguished Name property ) {code}    *Remark: msp.ValidatedIdentity* could expose a special “validation” function taking input  a set of options that can elegantly include various parameters that affect this identity’s validation. To its minimum definition, *IdentityValidityOptions* would include a timestamp, pairs of attributes, and proofs of attribute ownership that the validate would need to consider.  ></description> </Issue>
