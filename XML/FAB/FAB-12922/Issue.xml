<Issue id="35455" key="FAB-12922" number="12922" project="10002" reporter="senthil1" creator="senthil1" type="10002" summary="filter stale private: optimisation" priority="3" status="10000" created="2018-11-19 13:15:46.0" updated="2020-01-08 04:34:27.0" votes="0" watches="2" workflowId="57702"> <description><! CDATA Currently, to filter the stale missing pvtData, we use the hashedData and perform certain comparison using version and hashedValue. Ideally, we need to perform the privatedata version check first because it gives us a tighter condition than a loose one performed currently. As we back-fill missing data in the reverse order of the block numbers, pvtdata version check is expected to filter out much more stale entries. In fact, we would expect very few entries to be marked stale with the upper if-check.  Proposed Approach:  First, we need to check against version of pvtdata. In second round, for the remaining keys, using hashed version and third for the still remaining keys against hashed values. In each phase we would require performing bulkload of relevant data.   The cost would be dependent on many factors: (a) size of the actual pvtData, (b) append only, (c) append + update, (d) update only # *size of the actual pvtData*: In the hashed value, we only store 32 bytes data. If the actual pvtData size is larger than 32 bytes, we might be loading more data during the bulk load of pvtData as compared to only hashedData. # *append only*: We might find no entries in the pvtstate for most of the time. Less cost lookup would be performed on the stateDB first followed by loading hashedData. # *append + update*: We might only find some entries in the pvtstate. Hence, we need to load both pvtData and hashedData (mostly for append only). # *update only*: most of the pvtData passed to the stateDB would be stale. load pvtData first – if passed version < committed version, filter the slate entry. if passed version > committed version, load hashedData and compare.  Say that we load only hashedData and compare (current approach): cost associated are (1) loading of 64 bytes (hashedKey, hashedValue) (2) hash computation of passed pvtData (is cost proportional to the data size?) (3) comparison of 32 bytes – this approach is suitable when the pvtData size is larger and append only (not sure about the size though). Further, this would add less complex code.  Loading pvtData first is suitable when the pvtData size is smaller and update heavy.  As we all do these activities within an exclusive lock duration, we need to perform certain experiments before deciding on an approach.  ></description> </Issue>
