<Issue id="38335" key="FAB-14570" number="14570" project="10002" reporter="ales" creator="ales" type="10003" summary="Support ExtractStatedbArtifactsForChaincode in the new lifecycle" priority="3" resolution="10200" status="6" created="2019-03-10 09:47:09.0" updated="2019-05-04 21:57:13.0" resolutiondate="2019-04-20 10:31:44.0" votes="0" watches="2" workflowId="51946"> <description><! CDATA This function {code:java} // ExtractStatedbArtifactsAsTarbytes extracts the statedb artifacts from the code package tar and create a statedb artifact tar. // The state db artifacts are expected to contain state db specific artifacts such as index specification in the case of couchdb. // This function is intended to be used during chaincode instantiate/upgrade so that statedb artifacts can be created. func ExtractStatedbArtifactsForChaincode(ccname, ccversion string, pr *platforms.Registry) (installed bool, statedbArtifactsTar   byte, err error) { ccpackage, err := GetChaincodeFromFS(ccname, ccversion) if err != nil { // TODO for now, we assume that an error indicates that the chaincode is not installed on the peer. // However, we need a way to differentiate between the 'not installed' and a general error so that on general error, // we can abort the chaincode instantiate/upgrade/install operation. ccproviderLogger.Infof("Error while loading installation package for ccname=%s, ccversion=%s. Err=%s", ccname, ccversion, err) return false, nil, nil }  statedbArtifactsTar, err = ExtractStatedbArtifactsFromCCPackage(ccpackage, pr) return true, statedbArtifactsTar, err } {code} is problematic for the new lifecycle because it assumes that it is possible to retrieve the chaincode package directly from the file system by supplying ccname/ccversion. The new lifecycle requires one extra lookup from ccname to package identifier.  ></description> </Issue>
