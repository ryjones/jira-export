<Action id="19301" issue="13012" author="sanchezl" type="comment" created="2016-10-19 18:02:26.0" updateauthor="sanchezl" updated="2016-10-19 18:02:26.0"> <body><! CDATA h2. Generating keys using openssl  Generate a key. This prompts for a password. {noformat} openssl genrsa -aes256 -out server_encrypted.key 2048 {noformat}  To generate with a password, use the {{-passout}} parameter. The {{-passout}} paramenter can get the password from the command line ({{pass:}}), an env var ({{env:}}) or a file ({{file:}}) (or {{fd:}} or {{stdin}}).  {noformat} openssl genrsa -aes256 -out server_encrypted.key -passout pass:secret 2048 {noformat}  Key is saved in  PEM|https://en.wikipedia.org/wiki/Privacy-enhanced_Electronic_Mail  format.  To display key:  {noformat} openssl rsa -text -in server_encrypted.key -passin pass:secret {noformat}  To remove the password:  {noformat} openssl rsa -in server_encrypted.key -out server.key -passin pass:secret {noformat}  To get just the public key:  {noformat} openssl rsa -in server.pass.key -out server_pub.key -passin pass:secret -pubout {noformat}   ></body> </Action>
<Action id="19302" issue="13012" author="sanchezl" type="comment" created="2016-10-19 18:04:53.0" updateauthor="sanchezl" updated="2016-10-19 18:04:53.0"> <body><! CDATA h2. Self Signing Certificates h3. Create a self signed certificate from a key {noformat} openssl req -new -x509 -days 365 -key server.key -out server.crt -subj "/CN=sanchezl@us.ibm.com" {noformat} h3. Create a self signed certificate and key pair in one command {noformat} openssl req -x509 -newkey rsa:2048 -keyout server2.key -out server2_pub.key -days 365 -nodes -subj "/CN=sanchezl@us.ibm.com" {noformat} The {{-nodes}} options turns off encrypting the private key with DES, so no password is required. h3. Create a self signed certificate using Go See {{src/crypto/tls/generate_cert.go}}.  ></body> </Action>
<Action id="19303" issue="13012" author="sanchezl" type="comment" created="2016-10-19 18:17:22.0" updateauthor="sanchezl" updated="2016-10-19 18:19:18.0"> <body><! CDATA h2. Go TLS Client Configuration  h3. Dial using host name, default config  {code} config := &tls.Config{} tls.Dial("tcp", "localhost:9443", config) {code}  h5. Result:  {noformat} x509: certificate is valid for sanchezl, not localhost {noformat}  h3. Dial using host name, enabling {{Config.InsecureSkipVerify}}  {code} config := &tls.Config{InsecureSkipVerify: true} tls.Dial("tcp", "localhost:9443", config) {code}  h5. Result:  The connection is successful.  h5. Analysis:  This seems to disable any host name verification and certificate chain verification.  h3. Dial using ip address, default config  {code} config := &tls.Config{} tls.Dial("tcp", "127.0.0.1:9443", config) {code}  h5. Result:  {noformat} x509: cannot validate certificate for 127.0.0.1 because it doesn't contain any IP SANs {noformat}  h5. Analysis:  The {{tls.Dial}} call can differentiate between the target address being specified as a host name versus an ip address. When it detects an ip address then it expects the certificate to contain an attribute of the form:  {noformat} subjectAltName = IP:XX.XX.XX.XX {noformat}  h3. Dial using host name, setting {{Config.ServerName}}  {code} config := &tls.Config{ServerName: "sanchezl"} tls.Dial("tcp", "localhost:9443", config) {code}  h5. Result:  {noformat} x509: certificate signed by unknown authority {noformat}  h5. Analysis:  * The host name verification has succeeded due to having {{Config.ServerName}} set to the value of the {{CN}} component of the {{Subject}} in the certificate. * The certificate chain could not be authenticated.  h3. Dial using host name, setting {{Config.ServerName}} and {{Config.RootCAs}}  {code} // load server certificate chain to byte array certificates := ioutil.ReadFile("server.crt")  // tls configuration rootCAs := x509.NewCertPool() rootCAs.AppendCertsFromPEM(certificates) config := &tls.Config{ ServerName: "sanchezl", RootCAs:    rootCAs, }  // connect to server conn := tls.Dial("tcp", "localhost:9443", config) {code}  h5. Result:  The connection is successful.  h5. Analysis:  I was not able to force tls to ignore the host name AND validate the certificates at the same time.  ></body> </Action>
<Action id="19316" issue="13012" author="yacovm" type="comment" body="&quot; If these same certificates can be used to initiate the TLS connection between the various nodes that might prove to be enough to &apos;identify&apos; the nodes.&quot; - why is that true? how do you ensure the node&apos;s ID is the ID it claims it is? " created="2016-10-20 14:09:03.0" updateauthor="yacovm" updated="2016-10-20 14:09:03.0"/>
<Action id="19347" issue="13012" author="smithbk" type="comment" body="Self-signed certs are generally a bad idea because if a private key is lost (e.g. via a server crash), then the cert needs to be updated." created="2016-10-21 14:48:17.0" updateauthor="smithbk" updated="2016-10-21 14:48:17.0"/>
<Action id="19364" issue="13012" author="kchristidis" type="comment" body=" ~yacovm : This is far from my area of expertise, but won&apos;t TLS ask for for a signature that corresponds to the certificate that you claim you have during the handshake? _If_ that is the case, isn&apos;t this the way I know that I connected to orderer with self-signed certificate &quot;foo&quot;? (This is this node&apos;s ID, by the way.)" created="2016-10-22 02:28:13.0" updateauthor="kchristidis" updated="2016-10-22 02:28:22.0"/>
<Action id="19365" issue="13012" author="kchristidis" type="comment" created="2016-10-22 02:35:26.0" updateauthor="kchristidis" updated="2016-10-22 02:35:26.0"> <body><! CDATA  ~keithsmith : Unless I'm mistaken, the plan is to have the genesis block include the orderer root CA certs. If that is the case, every orderer just needs to present a certificate chain where the end-user certificate links back one of the orderer root CA certs. Would that solve the problem?  If not, can you please list here the concrete steps we need to take to do things right?  ></body> </Action>
<Action id="19371" issue="13012" author="kchristidis" type="comment" body="Luis, thanks for the detailed write-up. So, what are your conclusions? (And what is still left for this task to be closed?)" created="2016-10-22 03:26:48.0" updateauthor="kchristidis" updated="2016-10-22 03:27:33.0"/>
<Action id="19378" issue="13012" author="yacovm" type="comment" created="2016-10-22 06:58:12.0" updateauthor="yacovm" updated="2016-10-22 06:58:12.0"> <body><! CDATA  ~kchristidis , The thing here is: the orderer doesn't care *who* connects to it, but peers do care.  In the fabric code, when a peer connects to you it sends you first a hello message with its ID inside and you use that to associate the gRPC stream with the remote peer.  What I am saying is that having SSL-layer authentication does not equal application-layer authentication unless you find a way to extract the client certificate in the application (specifically- in the gRPC server-side stream method).  Without this- I can connect to you with my credentials but assert to your peer logic that I'm someone else.   ></body> </Action>
<Action id="19393" issue="13012" author="kchristidis" type="comment" created="2016-10-22 16:38:07.0" updateauthor="kchristidis" updated="2016-10-22 16:38:07.0"> <body><! CDATA {quote}What I am saying is that having SSL-layer authentication does not equal application-layer authentication unless you find a way to extract the client certificate in the application (specifically in the gRPC server-side stream method). {quote}  Ah, I get you now. You are, of course, correct.  ></body> </Action>
<Action id="19397" issue="13012" author="smithbk" type="comment" created="2016-10-23 11:53:42.0" updateauthor="smithbk" updated="2016-10-23 11:53:42.0"> <body><! CDATA So is the issue that go grpc doesn't provide a way to enable mutual TLS and to extract the client cert on the server? I see the following for doing mutual TLS https://github.com/grpc/grpc-go/issues/403 but doesn't give you access to the client cert.   I see this discussed (at length) in https://github.com/grpc/grpc-go/issues/111.  It seems to indicate that we need to implement our own TransportAuthenticator but is not clear.  ></body> </Action>
<Action id="19398" issue="13012" author="yacovm" type="comment" created="2016-10-23 11:59:55.0" updateauthor="yacovm" updated="2016-10-23 12:00:38.0"> <body><! CDATA I already took care of that this morning, in a different way: https://gerrit.hyperledger.org/r/#/c/1915/  ></body> </Action>
<Action id="19401" issue="13012" author="kchristidis" type="comment" body="I&apos;m looking at Yacov&apos;s implementation and the grpc-go thread (https://github.com/grpc/grpc-go/issues/934) - great idea." created="2016-10-23 19:45:09.0" updateauthor="kchristidis" updated="2016-10-23 19:45:09.0"/>
