<Issue id="26723" key="FAB-7688" number="7688" project="10002" reporter="dongming" assignee="dongming" creator="dongming" type="10002" summary="PTE stability test" priority="3" resolution="10001" status="6" created="2018-01-10 19:37:01.0" updated="2019-07-30 02:42:00.0" resolutiondate="2019-07-30 02:42:00.0" votes="0" watches="1" workflowId="35484"> <description><! CDATA network configuration: 3 orderers, 4 kafka, 3 zookeepers, 2 ca, levelDB, 8 channels, 2 org, 2 peers per org, both org are associated with the channel, TLS enabled, batchsize 500, batch timeout 2s, 1 golang chaincode, 1 NodeJS cahincode  6 processes X 10000 constant transaction mode  1 process: sample cc golang, various payload size (1k-2k), invoke, channel event service  1 process: sample cc golang, various payload size (1k-2k), invoke, filtered block event service  1 process: sample cc golang, query  1 process: sample cc NodeJS, various payload (1k-2k), invoke, channel event service  1 process: sample cc NodeJS, various payload (1k-2k), invoke, filtered block event service  1 process: sample cc NodeJS, query     I think we should probably define more channels (8 or 10), a minimum 2 chaincodes, use mutual TLS, use channel delivery service, and use filtered block events.  And later add the use of private channel data (by turning on the experimental feature side-db, and using an enhanced chaincode), couchdb indexing (by enhancing chaincode and using complex queries), ACL fine-grained permissions (per-user, instead of simply per-org, possibly after revoking one (unused) user so the CRL is non-empty), and encryption library (with enhanced chaincode),   ></description> </Issue>
