<Action id="42086" issue="17836" author="lehors" type="comment" body="Had an interesting discussion about this on RocketChat, see: https://chat.hyperledger.org/channel/fabric-scrum?msg=JqX9nhe3KgaAmEKDc" created="2018-03-23 16:23:01.0" updateauthor="lehors" updated="2018-03-23 16:23:01.0"/>
<Action id="43355" issue="17836" author="lehors" type="comment" created="2018-04-24 14:44:55.0" updateauthor="lehors" updated="2018-04-24 14:44:55.0"> <body><! CDATA So, to try and make some progress on this, let me resume the discussion by restating where I think we stand. We essentially have three options:  The Go SDK provides a more powerful CLI that is not worth competing with/duplicating. However, reusing the SDK CLI would require vendoring it into fabric and creating a sort of circular dependency that will require careful handling when changes in fabric require changes to the CLI. Essentially the vendored version would have to be fixed locally and the changes pushed into the SDK so that they can eventually be vendored back in. Some think this is heresy.  If we do reuse the SDK CLI we could then dedicate the peer command to just that - the peer - and remove all other commands we currently have.  One question is whether we could then do away with the core.yaml config file. I'll admit I'm not sure.  The main advantage of this option is reduction of code and increase in power of the CLI. The main drawback is the circular dependency.  If we choose not to reuse the SDK CLI, we could merely separate the current fabric CLI functions (without adding anything) from the peer command. I've done a quick surgery as an experiment and it seems doable. But I think both the peer and CLI would still depend on the core.yaml file.  The main advantage of this option is that we don't introduce any circular dependency with the SDK. The main drawback is that we break current usage for relatively little gain.  The last option is to do nothing. Accept that we have a limited CLI in fabric mixed in with the peer command and point people to the Go SDK CLI for advanced functionality.  The main advantage of this option is that we don't introduce any circular dependency and don't break current usage. The main drawback is that it does nothing to improve the status quo.  ></body> </Action>
<Action id="43509" issue="17836" author="binhn" type="comment" created="2018-04-26 17:56:56.0" updateauthor="binhn" updated="2018-04-26 17:56:56.0"> <body><! CDATA  ~lehors  Thanks for the analysis Arnaud.   I was thinking about the dependency like this  CLI -> Go SDK -> Peer | Orderer. This way we would not run into cyclic dependency.  ~troyronda  please correct if I am wrong.   CLI would be a separate build (from the peer) to produce the executable. It would involve quite a bit of work to pull this off, but I think we should proceed with a prototype branch so that we can collaborate.  Regarding the core.yaml, this is the default config for the Peer and should remain for that, but I don't think we need it for the new CLI.  Troy points me to this CLI sample built with Go SDK  https://github.com/securekey/fabric-examples/tree/master/fabric-cli/ . We should take a closer look.  I will start a google doc so that we can collaborate on the design.     ></body> </Action>
<Action id="43511" issue="17836" author="troyronda" type="comment" created="2018-04-26 18:31:15.0" updateauthor="troyronda" updated="2018-04-26 18:46:01.0"> <body><! CDATA Just to give a bit more clarity, there is no cyclic dependency (in the Go sense) between Go SDK and fabric/fabric-ca. All re-used code from fabric and fabric-ca repo is actually copied into SDK rather than vendored (including protos). into here:  https://github.com/hyperledger/fabric-sdk-go/tree/master/internal/github.com/hyperledger  and here:  https://github.com/hyperledger/fabric-sdk-go/tree/master/third_party/github.com/hyperledger/fabric   The dependency is when a new feature is added to fabric and the CLI needs to be updated, and that update requires the SDK to be updated. But still, the update to the SDK is independent from the update to Fabric due to not actually vendoring fabric or fabric-ca.  The real dependency between Fabric and Go SDK happens with integration tests - i.e., when the SDK runs tests against various docker tags of Fabric. Even in this case, we can imagine a workflow that enables the SDK integration tests once the Fabric change is merged.   ></body> </Action>
