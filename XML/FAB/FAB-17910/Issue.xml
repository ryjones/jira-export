<Issue id="45097" key="FAB-17910" number="17910" project="10002" reporter="tock" assignee="tock" creator="tock" type="10003" summary="Orderer w/o system-channel, joins app channel as member, with genesis block" priority="3" resolution="10000" status="6" created="2020-05-18 06:32:36.0" updated="2020-06-25 16:34:38.0" resolutiondate="2020-06-22 14:29:02.0" votes="0" watches="1" workflowId="59007" archived="N"> <description><! CDATA This task handles the following scenario: * Orderer is a member of the cluster - the config block given at join has the self ID of the orderer. * The config block given at join is number 0 - no onboarding needed.   In this case the join block is first appended to the ledger as a genesis block, and the multichannel.ChainSupport is created in the normal fashion, reading the last-block from the ledger and constructing the consensus.Chain accordingly. h1. Rationale   {{HandleChain}} starts a chain based on the last block in the ledger, which it gets from the ledger resources.  What we need in order to join a chain in cases when on-boarding is needed (see special case below) is to start a {{follower.Chain}}, with a join-block, when the ledger is empty. The follower chain does not need many of the resources that an etcdraft.Chain needs, as it only pulls blocks (for example, it never signs and never uses the BlockWriter) . Moreover, some things it cannot even create, like a BlockWriter, which need to be based on a tip of a ledger (which we do not have at this point). Rather then stud HandleChain with many "ifs and buts", and extend its interface with the join-block, I think it will be much clearer and safer (not introducing bugs to HandleChain) to define a new method that does exactly the job of joining a channel.  The way I want to think about it, conceptually, HandleChain starts from a valid the ledger, so a failure means that something is fatally wrong (e.g. corruption of the ledger). In contrast, JoinChain is started with input from the user, i.e. the join-block, and errors in processing his request should be propagated back to the user.  A special case is when the join-block has number=0, and then it is appended to the ledger and {{HandleChain}} is called. If the orderer is a member ({{detectSelfID()}} no error), an {{etcdraft.Chain}} is created. Otherwise, a follower.Chain be created. However, this follower.Chain is past on-boarding and is just pulling blocks and observing the config.  When considering CFT, an orderer might fail in the middle of on-boarding a channel. When we recover, we'll find a join-block.Number >= ledger.Height, which indicates a gap between the ledger tip and the join-block. In this case we'll also call JoinChain rather than HandleChain.     Here is the flow of a join request with `{{join-block.Number >0}}`. * The `JoinChain` is called synchronously from the client request go-routine. If it fails, the request fails. If it succeeds, a follower.Chain is created and started (it has a go-routine). * The follower.Chain is given a function pointer to a {{createChain}} function just like in the {{inactive.Chain}} and the haltCallback in the {{etcdraft.Chain}}. * The follower.Chain starts pulling blocks. It is in status {{on-boarding}} until it reaches {{join-block.Number}}, then it changes to {{active}}. * If at that point the orderer is in the consenters set of the join-block ("a member"), the call to {{createChain}} in invoked, triggering the transition between follower.Chain -> etcdraft.Chain. This happens with a call to HandleChain. * HandleChain has a switch to create a follower.Chain when there is no sys-chan, and an inactive.Chain when there is a sys-chan. * If the orederer is not in the consenters set of the join-block, it will continue to pull blocks and watch config blocks. * Note that once the ledger catches up with the join-block, the join-block is deleted. * When a config block arrives in which the orderer is a member, {{createChain}} in invoked, again, triggering the transition between follower,Chain -> etcdraft.Chain. This happens with a call to HandleChain.  Conversely, here is the flow of an etcdraft.Chain evicted: * Eviction is detected, halt is called (as usual) * The haltCallback is initialized to create a chain. Calls HandleChain. HandleChain creates a follower.Chain without a join-block.  So, {{JoinChain}} is normally called by the client request go-routine, and always when there is a join-block. HandleChain is called by internal go-routines, and when the chain is started off the ledger.  The {{JoinChain}} call behaves differently from {{HandleChain}} only when {{join-block.Number >0}}, i.e. there is a need for on-boarding. Otherwise, if it is {{join-block.Number==0}}, it just appends the block to the ledger and delegates to {{HandleChain}}. That is what's addressed in this commit, all the rest is future tasks.     ></description> </Issue>
