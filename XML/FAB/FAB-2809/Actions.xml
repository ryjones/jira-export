<Action id="22094" issue="15382" author="denyeart" type="comment" body="There has been a decision to defer significant refactoring from v1, and focus on stabilization. This change will be evaluated once a post-v1 branch becomes available." created="2017-04-11 15:54:48.0" updateauthor="denyeart" updated="2017-04-11 15:54:48.0"/>
<Action id="22095" issue="15382" author="denyeart" type="comment" body=" ~balaji.viswanathan  You have a box document with options enumerated.  Please copy that content into the Description here and update as needed.   Also, the box document mentions to use approach #3 for range queries (startkey), whereas the commit message says approach #1 will be used for range queries (skip/limit). Please reconcile those differences." created="2017-04-11 15:57:40.0" updateauthor="denyeart" updated="2017-04-11 15:57:40.0"/>
<Action id="22103" issue="15382" author="christopherferris" type="comment" body="why isn&apos;t https://gerrit.hyperledger.org/r/7779 related if it is referencing this JIRA? " created="2017-04-11 16:40:29.0" updateauthor="christopherferris" updated="2017-04-11 16:40:29.0"/>
<Action id="22115" issue="15382" author="denyeart" type="comment" body=" ~ChristopherFerris  https://gerrit.hyperledger.org/r/#/c/7779/ implements (and links to) this Jira work item.  Are we supposed to have cross-indexing where each Jira item also points to the Gerrit changeset?" created="2017-04-11 18:18:33.0" updateauthor="denyeart" updated="2017-04-11 18:18:33.0"/>
<Action id="22923" issue="15382" author="denyeart" type="comment" body=" ~balaji.viswanathan  Although this item is deferred from v1.0, Balaji could you address the prior comment while fresh in your mind- copy the box content to Description and reconcile final recommendation as you copy it over." created="2017-04-24 02:54:45.0" updateauthor="denyeart" updated="2017-04-24 02:54:45.0"/>
<Action id="22933" issue="15382" author="balaji.viswanathan" type="comment" body="Done. " created="2017-04-24 12:28:17.0" updateauthor="balaji.viswanathan" updated="2017-04-24 12:28:17.0"/>
<Action id="22956" issue="15382" author="denyeart" type="comment" created="2017-04-24 19:22:17.0" updateauthor="denyeart" updated="2017-04-24 19:22:17.0"> <body><! CDATA Thanks  ~balaji.viswanathan .  Question on approach 1 - it says "For Range queries: this is same as approach 3."   Approach 3 for range queries uses startkey instead of skip, so this is not the same as approach 3.  Please clarify in description what you mean.  Finally, please sync up the commit message to match in https://gerrit.hyperledger.org/r/#/c/7779/.  Currently the commit message says "For range and view queries, this is done using skip and limit.".  I think it should say, "For range queries (and view queries in the future), this is done using startkey and limit."   Right?  ></body> </Action>
<Action id="22969" issue="15382" author="balaji.viswanathan" type="comment" body="Done" created="2017-04-25 06:51:17.0" updateauthor="balaji.viswanathan" updated="2017-04-25 06:51:17.0"/>
<Action id="23325" issue="15382" author="denyeart" type="comment" created="2017-05-03 10:47:34.0" updateauthor="denyeart" updated="2017-05-03 10:47:34.0"> <body><! CDATA This item has been deferred from v1. See proposed changeset for future: https://gerrit.hyperledger.org/r/#/c/7779/  ></body> </Action>
<Action id="31582" issue="15382" author="sstone1" type="comment" created="2017-10-03 19:16:53.0" updateauthor="sstone1" updated="2017-10-03 19:16:53.0"> <body><! CDATA Just to back up what Dave said - this is a real pain for Composer users. It comes up without fail at least once a week, if not more. Composer users want to be able to build apps that page through large result sets (perhaps lists of assets matching a given query), and they can't do that at the moment. Their only option is to mirror the Blockchain data into an external database and build an app which queries that instead.  Have left the same comment in FAB-5369.  ></body> </Action>
<Action id="33106" issue="15382" author="balaji.viswanathan" type="comment" body="An alternative, which could both be safe and satisfy composer style requirements (where UI/app layer wants pagination control), would be to expose an iterator position externally (say as a opaque value) with *new* ledger APIs. something like https://docs.mongodb.com/manual/reference/method/js-cursor/" created="2017-10-24 09:35:39.0" updateauthor="balaji.viswanathan" updated="2017-10-24 09:35:39.0"/>
<Action id="35664" issue="15382" author="balaji.viswanathan" type="comment" created="2017-11-30 08:06:52.0" updateauthor="balaji.viswanathan" updated="2017-11-30 08:07:39.0"> <body><! CDATA CouchDB 2.1.1 supports a new 'bookmark' field for pagination (http://docs.couchdb.org/en/latest/api/database/find.html#db-find)  _Mango queries support pagination via the bookmark field. Every ??_find?? response contains a bookmark - a token that CouchDB uses to determine where to resume from when subsequent queries are made. To get the next set of query results, add the bookmark that was received in the previous response to your next request. Remember to keep the ??selector?? the same, otherwise you will receive unexpected results. To paginate backwards, you can use a previous bookmark to return the previous set of results._  This would be preferable to skip and limit. We could continue to have a system wide limit and discontinue skip completely. 2 Options. The query results could expose the bookmark to the chaincode and let the user decide how to use it subsequently. It could also use the bookmark internally for the iterator.  ></body> </Action>
<Action id="37860" issue="15382" author="denyeart" type="comment" created="2017-12-29 16:56:39.0" updateauthor="denyeart" updated="2017-12-29 16:56:39.0"> <body><! CDATA  ~balaji.viswanathan  We actually weren't going to use the 'skip' approach since it is inefficient.  We had decided on these approaches:  # startkey/limit approach for range queries - #3 in Description # storing all the docids in iterator(in-memory) for rich (selector _find) queries - #2 in Description.  Now that bookmark is available for selector _find queries, I would agree that we should shift as follows: # startkey/limit approach for range queries - #3 in Description # bookmark approach for rich (selector _find) queries.  This also simplifies the solution.  I would prefer the iterator do the paging against CouchDB implicitly, and not expose it to chaincode.  This will keep consistent behavior for the chaincode user, whether they are iterating through a range query or selector query.  This will require upgrading to CouchDB 2.1.1 first, I've created FAB-7572 for that.  ></body> </Action>
<Action id="37872" issue="15382" author="sstone1" type="comment" body=" ~denyeart  without exposing the bookmark to the chaincode, how could a client application page through a large result set from a rich query? This would have to be done across multiple requests to the chaincode." created="2018-01-02 07:38:12.0" updateauthor="sstone1" updated="2018-01-02 07:38:12.0"/>
<Action id="37879" issue="15382" author="denyeart" type="comment" created="2018-01-02 12:50:57.0" updateauthor="denyeart" updated="2018-01-02 12:50:57.0"> <body><! CDATA  ~sstone1  In all the approaches discussed here, the chaincode container would implicitly fetch the next page of results from couchdb, without the client or chaincode author having to do anything.  If the chaincode nexts to the 1001st record, the chaincode container implicitly gets the next page of 1000 from couchdb without requiring the client or chaincode to do anything.  This is good for scenarios where the chaincode is doing logic against the result set but the client does not need all the results back.  I think in the scenario you mention the client actually wants to get all the results back, and in this case you are right, we will need to expose the bookmark to the client so that they can request the next page themselves.  I think this is a good balance - handle the chaincode to couchdb paging implicitly, while allowing the client to control client to chaincode paging.  Does that make sense?  ></body> </Action>
<Action id="37882" issue="15382" author="sstone1" type="comment" created="2018-01-02 13:20:14.0" updateauthor="sstone1" updated="2018-01-02 13:20:14.0"> <body><! CDATA  ~denyeart  that sounds good, just to make sure we're on the same page I think the 3 approaches are: # startkey/limit approach for range queries # bookmark approach for rich queries, built into the query iterator and hidden from the user so the chaincode can process large result sets without sending them all back # bookmark approach for rich queries, externalised so the same user can use the bookmark in subsequent chaincode invocations to get the next page in the result set.  For 3), I guess the only question for me is how is the page size controlled - it's not clear from the CouchDB docs whether or not "limit" is used to control the page size.      ></body> </Action>
<Action id="38213" issue="15382" author="balaji.viswanathan" type="comment" created="2018-01-05 05:47:10.0" updateauthor="balaji.viswanathan" updated="2018-01-05 05:47:10.0"> <body><! CDATA I think there is real value in exposing the bookmark to the client and allowing it to do pagination. Most UI apps would want control over how much to display w/o having to fetch all the results into memory. Another frequent ask has been count of documents returned without having to go through the iterator. We will need a new interface to expose these (bookmark and count) for an iterator.  However, exposing bookmark _and_ using it internally might mean doing 2 queries for every executeSelect query and also complicate applying system wide limits.  Case 1: User provides a limit N which is greater than batch size B  a. Execute the selector query as-is and record the bookmark and #count of documents received. The selector query can be modified here to just return _id field and not the full documents.  b. Execute the selector query again with limit = B, populate the iterator cache and use the bookmark internally for retrieving next batch on Next()  Case 2: User provides a limit N which is greater than system-wide limit R   a. Execute the selector query with limit overridden to R, record the bookmark, #count and fact that limit was overridden.  b. Execute the selector query again with limit = B, populate the iterator cache and use the bookmark internally for retrieving next batch on Next()  We need to record that the limit was overridden as the client uses the condition #count < limit to identify that its on the last page. The client needs to be aware that its limit of N has been overridden to R.  Case 3: User provides a limit N which is smaller than batch limit B  Here we can do just one query for limit=N  Case 4: User does not provide a limit  CouchDB defaults to limit=25, here we have an option to use the limit as B and perform one query.  All UI driven queries are likely to fall in case 3. A page is unlikely to be > batch size.  Note: CouchDB bookmarks are returned for only selector queries and not views and limit is used for pagination. bookmark is 'nil' if no results are returned.   ></body> </Action>
<Action id="39371" issue="15382" author="denyeart" type="comment" created="2018-01-30 15:38:24.0" updateauthor="denyeart" updated="2018-01-30 15:38:24.0"> <body><! CDATA Thanks for the comments  ~sstone1  and  ~balaji.viswanathan  .  I agree that we will need a chaincode API that allows external control of paging.  In some scenarios the client app needs to page/iterate through many records, for these scenarios the explicit paging control will be passed to chaincode ( bookmark/limit for selector queries, startkey/limit for range queries).  I think we will need a new chaincode API such as ExecuteQueryWithOptions() which could take a map of query options (this will allow the API to work across various state databases in the future).  In other scenarios the chaincode needs to iterate through many records, for these scenarios the implicit paging upon Next() in the chaincode will drive the query for the next page, e.g. upon Next() to the 1001st record if the default page size is 1000.  I agree we'll need some controls like  ~balaji.viswanathan  mentioned to coordinate the explicit and implicit paging.  Fabric just moved up to CouchDB 2.1.1 which supports the more efficient 'bookmark' style of paging, so this work can begin now.  Note that 1.1 is in feature freeze, therefore the paging support is targeted for 1.2.  ></body> </Action>
<Action id="42067" issue="15382" author="chris.elder" type="comment" created="2018-03-23 13:33:20.0" updateauthor="chris.elder" updated="2018-03-23 13:33:20.0"> <body><! CDATA Created design document for CouchDB pagination changes:     https://docs.google.com/document/d/1AzcVjVbuvZGRozfNe3ksIpK-cBMlhhbGOUZhg2bzPW8/edit?usp=sharing  ></body> </Action>
<Action id="46191" issue="15382" author="denyeart" type="comment" body="Deferred to v1.3." created="2018-06-19 12:38:29.0" updateauthor="denyeart" updated="2018-06-19 12:38:29.0"/>
<Action id="46533" issue="15382" author="alexvicegrab" type="comment" created="2018-06-26 12:19:41.0" updateauthor="alexvicegrab" updated="2018-06-26 12:19:41.0"> <body><! CDATA Any chance we can get this in as a 1.2 patch feature?  This is a critical issue for deploying to production.  ></body> </Action>
<Action id="46594" issue="15382" author="denyeart" type="comment" body=" ~alexvicegrab  v1.2 content is finalized. The next vehicle for new features will be v1.3.  Agreed this is important, only constraint has been resource availability." created="2018-06-27 11:29:42.0" updateauthor="denyeart" updated="2018-06-27 11:29:42.0"/>
