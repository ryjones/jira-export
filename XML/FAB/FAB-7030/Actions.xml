<Action id="34737" issue="24013" author="denyeart" type="comment" body=" ~binhn   ~muralisr  Would appreciate your thoughts, since I don&apos;t recall the reasons for removing Query() in 1.0." created="2017-11-18 16:07:48.0" updateauthor="denyeart" updated="2017-11-18 16:07:48.0"/>
<Action id="34738" issue="24013" author="binhn" type="comment" created="2017-11-18 16:33:47.0" updateauthor="binhn" updated="2017-11-18 16:33:47.0"> <body><! CDATA  ~denyeart  The thought here was that we shouldn't complicate things unnecessarily. The chaincode execution model doesn't dictate read or write, but it is up to the application logic, so we have 1 entry point Invoke, and the appropriate logic controls read and/or write.  The description above seems to argue about streamlining, but that is internal implementation , and we shouldn't surface that to the application programming model. Even if we introduced Query, what would prevent developers from coding queries as part of Invoke? So it would be better if we optimize based on the usage rather than additional controls.  Chaincode ACL is much more application specific, so we shouldn't attempt to impose one without ability for the application to reconfigure.   ></body> </Action>
<Action id="34739" issue="24013" author="muralisr" type="comment" body=" ~denyeart  also I&apos;d note that fine-grained ACL (FAB-3621) - if and when released - would help better organize access policies so user can separate out proposal ACL from individual chaincode ACL. And within the chaincode each function can have its own ACL policy. " created="2017-11-18 16:51:57.0" updateauthor="muralisr" updated="2017-11-18 16:55:05.0"/>
<Action id="34740" issue="24013" author="yacovm" type="comment" created="2017-11-18 18:27:10.0" updateauthor="yacovm" updated="2017-11-18 18:27:29.0"> <body><! CDATA Why was it channel writers in the first place? To write you need to send a transaction to ordering. A chaincode simulation isn't a write, it's a read.     Is it possible to change it to channel readers?  ></body> </Action>
<Action id="34741" issue="24013" author="muralisr" type="comment" body=" ~yacovm   PUTs are intended writes." created="2017-11-18 18:58:30.0" updateauthor="muralisr" updated="2017-11-18 18:58:52.0"/>
<Action id="34742" issue="24013" author="denyeart" type="comment" created="2017-11-18 19:11:42.0" updateauthor="denyeart" updated="2017-11-18 19:11:42.0"> <body><! CDATA  ~binhn  My primary objective is to allow channel readers to call chaincode that reads from the ledger, as the role name would imply.  The streamlining would be a side benefit.   ~yacovm  I see your point, but is confusing to users to change default behaviors between versions.  Plus why allow channel readers to call chaincode that does PutState().  While it is not actually writing to ledger yet, it gives them a false sense that they could write to ledger. Better to flag failure scenarios earlier than later in the transaction lifecycle in my opinion.  I thought Query() for channel readers (Gets allowed), and Invoke() for channel writers (Gets and Puts allowed), would be the most intuitive and compatible solution.  ></body> </Action>
<Action id="34743" issue="24013" author="yacovm" type="comment" created="2017-11-18 19:48:54.0" updateauthor="yacovm" updated="2017-11-18 19:48:54.0"> <body><! CDATA {quote} ~yacovm  PUTs are intended writes. {quote} Not sure why this is in capital letters? this isn't HTTP... {quote} ~yacovm  I see your point, but is confusing to users to change default behaviors between versions {quote} Though that's true, it's something they have no control of, and I doubt most of them are even aware of that.  The channel creation sets all users as channel writers anyway, and I'm sure that only a few of the users actually change this policy to some orgs after the channel is created. {quote}Plus why allow channel readers to call chaincode that does PutState(). {quote} Well as you know, you don't actually need a peer to make a transaction, you can imitate a peer yourself having a client certificate, and send a transaction to the orderer. (unless, we use  ~adc  's node types enforcement)    {quote}I thought Query() for channel readers (Gets allowed), and Invoke() for channel writers (Gets and Puts allowed), would be the most intuitive and compatible solution. {quote}   I agree it's intuitive and I think that's what might should have been done in the 1st place instead of deprecating the Query(), however:   * If you extend the interface that the chaincode developer needs to implement, you make all previous code not being able to compile and now all users will need to rewrite their chaincodes or just implement a "no-op" Query(). * Wouldn't it be odd that we deprecated Query and now we're bringing it back? My rule of thumb says that API changes are things that users hate, while they can't really feel a change that changes the default policy of chaincode proposals to channel readers.       ></body> </Action>
<Action id="34744" issue="24013" author="tbltzk" type="comment" created="2017-11-18 20:39:23.0" updateauthor="tbltzk" updated="2017-11-18 20:39:23.0"> <body><! CDATA It's not too late to revert a wrong decision!  Better change now than dragging a flawed interface into the LTS version...  ></body> </Action>
<Action id="34748" issue="24013" author="muralisr" type="comment" created="2017-11-19 16:10:06.0" updateauthor="muralisr" updated="2017-11-19 16:10:06.0"> <body><! CDATA  ~tbltzk   ~denyeart  Taking a step back, the rationale behind one Invoke  API is this ...  "PutState", "GetState" are building blocks with which we can define various high level Invoke functions.  Users decide how to use them and, if they want to, submit them as transactions. This is similar to web services, servlets, RPC calls etc that use  low level building blocks such as SQL select or update which are used to build these high level services. The services can call any of the low level read/write apis to do their work. Paraphrasing  ~binhn ,  would you want to restrict CC to use only GET (basically all the "get" calls  ~yacovm  :-) ) in the Query call ?  I think we are conflating function with access control.  The ChannelReaders and ChannelWriters policies are at the bottom of this. Proposal being controlled by "ChannelWriters" policy begs the question "what about read-only calls ?" - seems odd one has to be a "ChannelWriter" to do what the chaincode developer knows to be read only call.  The problem with using ChannelWriters (among other things) is discussed in detail in FAB-3621.  The finer grained mechanism proposed there to specify who can do Proposal for a channel not only removes the confusion surrounding "ChannelWriter" semantics but also help users implement ACL at different levels (Proposal level and individual chaincode level) to suit the function.  Thoughts ?  ></body> </Action>
<Action id="34759" issue="24013" author="denyeart" type="comment" created="2017-11-20 11:53:54.0" updateauthor="denyeart" updated="2017-11-20 12:00:53.0"> <body><! CDATA  ~muralisr  I think you are suggesting that every deployment that wants to separate chaincode readers and writers should override the default ACL for Propose, and set the Propose ACL to be the identities that should be allowed to read from chaincode.  If that is our answer, it seems we should simply make the default for Propose to be Channel Readers as Yacov suggested, in order to eliminate the configuration step.  I realize that a small percentage of deployments will want to differentiate between Channel Readers and Channel 'Proposers', and therefore it is nice that you can specify 'Proposers' separately, I just think the overriding requirement will be to distinguish Readers from Writers and therefore think the default setup should support this, either by setting Propose ACL to be Channel Readers (Yacov suggestion) or by adding a new Query() function for Channel Readers (my original suggestion).  I've updated the title and description to be more aligned with the comments. Thoughts?     ></body> </Action>
<Action id="34760" issue="24013" author="yacovm" type="comment" created="2017-11-20 12:09:24.0" updateauthor="yacovm" updated="2017-11-20 13:04:27.0"> <body><! CDATA So, w.r.t option 2: {quote}Option 2: Set the Propose ACL to be ChannelReaders instead of ChannelWriters. {quote} I'd add that we an do something more complex so lets add version (3): # Set the default policy for propose to channel readers. # After simulation, check the TXSimulator if the simulation has anything in the write set. If so - evaluate whether the user is a channel writer and either return an access denied or the data.     Edit: It's also worth to mention that if we adopt the MSP interface changes that are  proposed|https://docs.google.com/document/d/1FyvjMlBFasdFlOpjcaurNG8jYipHE8ENXfdbY122mdA/edit# , then we can do it without an overhead of twice the signature checks via taking the identity, turning it into a ValidatedIdentity, calling Verify() once to check the signature, and then calling twice SatisfiesPrincipal which should be then computationally "cheap" (please correct me if I'm wrong  ~elli-androulaki  /  ~adc  /  ~ales  )  ></body> </Action>
<Action id="34761" issue="24013" author="denyeart" type="comment" body=" ~yacovm  I like that, I&apos;ve updated Option 2 in Description." created="2017-11-20 12:44:30.0" updateauthor="denyeart" updated="2017-11-20 12:44:30.0"/>
<Action id="34767" issue="24013" author="muralisr" type="comment" created="2017-11-20 14:48:22.0" updateauthor="muralisr" updated="2017-11-20 14:53:56.0"> <body><! CDATA  ~yacovm   ~denyeart  Seems ok for default policy to be ChannelReaders with the understanding that its the responsibility of the chaincode to put in second-level, stricter, ACL check if necessary (like the built-in system chaincodes do today). ...what do you think  ~ales   ~adecaro   ~elli-androulaki  ?  bq. After simulation, check the TXSimulator if the simulation has anything in the write set. If so - evaluate whether the user is a channel writer and either return an access denied or the data.  We could generalize this so we associate a  writeset with a "resource" to make the treatment uniform (as opposed to going back to hard-coding ChannelWriters).  ></body> </Action>
<Action id="34795" issue="24013" author="binhn" type="comment" body=" ~denyeart  Have you thought about something like linux filesystem  rwx=read/write/execute?  Calling a chaincode would be equivalent to execute on the channel, so ChannelExecute. ChannelRead/Write would only be applicable to transactions involving either read and/or write-set respectively. " created="2017-11-20 21:17:58.0" updateauthor="binhn" updated="2017-11-20 21:17:58.0"/>
