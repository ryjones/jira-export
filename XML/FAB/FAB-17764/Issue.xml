<Issue id="44825" key="FAB-17764" number="17764" project="10002" reporter="btl5037" assignee="dongming" creator="btl5037" type="10001" summary="ReCreate State Fork Environment" priority="1" resolution="10001" status="6" created="2020-04-16 03:05:53.0" updated="2021-01-10 17:38:12.0" resolutiondate="2021-01-10 17:38:12.0" votes="0" watches="4" workflowId="58744" archived="N"> <description><! CDATA We had a development team notify us they were able to introduce a state fork into their ledger. We will need to recreate their scenario as a means of debugging the fork and will maintain the assets as a test scenario.  The scenario is as follows: * Client driver should be able to work against any Fabric version v1.1 through v2.x - we'll want to test against Fabric v1.1 initially for best chance of reproduction, with ability to also run against current releases to compare results.  * Test will initially use legacy chaincode lifecycle, although it could be extended later to use new chaincode lifecycle if we see merit in running the test going forward.  * Don't use Composer, since those tests would not be applicable in future versions, but drive similar workload as Composer from peer perspective (e.g chaincodes with CouchDB indexes, JSON queries, and Init() reads/writes)  * Chaincode Init() should read/write a key that represents JSON with two fields, field1 and field2 Utilize 10 channels.  * Each chaincode upgrade will alter index definition to ensure index is continuously rebuilt, e.g. alternate index definition to include (field1) only and (field1,field2), in every other chaincode definition.  * Run two peer processes on hardware with reduced CPU and io resources, to increase likelihood of reproduction  * Run chaincode upgrades against all 10 channels in a continuous loop.  * If there is a fork in any channel, the chaincode upgrade commit will fail with MVCC conflict on one of the two peers. It will then be known that the prior chaincode upgrade commit was the faulty transaction, and debug logs can be evaluated for that transaction.  * A second client workload should also be applied, to perform continuous JSON queries. For example the JSON query can filter on both field1 and field2. Note, in this case all queries should result in an index hit, regardless of whether the index is currently based on one field or both fields.  Acceptance Criteria: We observe the fork. If unable to recreate the assets will still be used for future testing.  ></description> </Issue>
