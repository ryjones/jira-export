<Issue id="15743" key="FAB-3156" number="3156" project="10002" reporter="elli-androulaki" assignee="ales" creator="elli-androulaki" type="10004" summary="Add pre-endorsement check for the invoked chaincode" priority="1" resolution="10000" status="6" created="2017-04-14 10:19:52.0" updated="2018-07-20 14:12:13.0" resolutiondate="2017-05-11 12:18:13.0" votes="0" watches="7" workflowId="37989"> <description><! CDATA When a chaincode is installed to a peer, it is followed by an instantiation policy that would specify who is authorised to "instantiate" this chaincode (to any chain).  To ensure that this instantiation policy is honored for a chaincode installed on a peer, we incorporate the instantiation policy to the chaincode's "identifier". That is, we no longer fully determine the chaincode by its name, and version, but with the triplet <name, version, instantiation policy>.   With this we benefit the following: 1. when the chaincode is being instantiated, full details of the identity of the chaincode to be instantiated are provided inside the transaction, i.e., the writeset contains the new entry to channel instantiated chaincodes (part of LSCC state) that includes the chaincode name, version, and instantiation policy 2. when committing peers validate the instantiation transaction can immediately check the writeset of the transaction, retrieve the instantiation policy of that chaincode (even if they do not have that chaincode installed locally) and approve or not the instantiation of that chaincode. Notice that committing peers do more checks (e.g., check if a chaincode with the same name has been instantiated in the past, etc ) that are ommitted in view of simplicity of presentation of the issue, but in any case they **should not** be required to check their local state to validate such a transaction cause LSCC state fork could occur. Validation of instantiation transactions depend only on chain data.  **Our claim:** When an endorser receives a proposal that refers to a chaincode in a channel, it needs to ensure that the chaincode instance as appeared in the chain (name, version, instantiation policy) is the same as the one locally installed prior to proceeding with the invocation of that chaincode. If this check is not satisfied, then the endorser should return an error to the client and not proceed with the simulation of execution of the invoked chaincode.  **Why do we need to do this?**  Because otherwise, we could have instantiation policies by-passed.  **Example**: This shows a candidate attack bypassing instantiation policy if equality of this is not checked at chaincode invocation time.    So org1 and org2 appear on channel A and B.  In *channel A*, org1 has instantiated chaincode cc with instantiation policy that says only the Org1.admin is allowed to instantiated it.   org2 can see all the instantiation details of cc on channel A, as it is a member of channel A.  org2 wants to trick peers of org1 to instantiate cc on *channel B* but understands it is not allowed to because cc's instantiation policy does not allow it.  However, org2 can do something to bypass the instantiation policy (i.e., trick the peers of org1 into simulating and executing invocations of cc as if cc were to have been instantiated in channel B).   What org2 can do is leverage the entry for cc from channel 1 to retrieve cc.name, cc.hashcode, cc.version and creates an instantiation transaction for   cc.name, cc.hashcode, cc.version, instantiation policy for org2.admin  . This entry will be accepted by all peers in channel B, cause no other chaincode with that name has been deployed on channel 2, and org2 satisfies the fake instantiation policy it listed in the instantiation transaction.   Now if org2 attempts to send a proposal to org1 peers for invoking a chaincode <cc.name, cc.input> if instantiation policy is not checked, peers of org1 would blindly retrieve the chaincode they have installed that has the same name (but different instantiation policy) than the one on the chain, would simulate the execution and provide an endorsement for a chaincode proposal they should have ignored.   Peers of org1 who see this this instantiation should consider this to refer to a different chaincode than the one they have installed and ignore any proposals on channel 2 associated to this. This is the topic of changes of group (2) of CR https://gerrit.hyperledger.org/r/#/c/8313/ of  ~ales .  Adding also  ~adc .  Inviting  ~muralisr ,  ~mastersingh24 ,  ~binhn , to comment on this. Thanks!      ></description> </Issue>
