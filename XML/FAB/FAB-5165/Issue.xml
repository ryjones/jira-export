<Issue id="18946" key="FAB-5165" number="5165" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10004" summary="Avoid the redundant block verifications in gossip" priority="3" resolution="10000" status="6" created="2017-07-04 13:56:10.0" updated="2018-07-20 14:13:42.0" resolutiondate="2017-07-07 15:10:15.0" votes="5" watches="4" workflowId="39378"> <description><! CDATA In gossip, when block messages are gossiped among peers the signature of the ordering service on them is validated.  This causes a message to be validated in several places: # When it is received from the ordering service # When it is received from a peer via forwarding or pull Since the block is forwarded among peer several times, this has an amplifying effect. # When it is received from a peer via state tranfer  Empirical performance tests I have conducted show that for blocks of 100KB, the time spent on verifying a block is between 700 micro-seconds to 2milliseconds.  When testing a benchmark scenario of 1000 blocks with a single leader disseminating to 7 non-leader peers, with propagation factor of 4, a block entry rate (to the leader peer) of bursts of 20 blocks every 100ms, the gossip network is over committed and starting from block 500 - most blocks were dropped because the gossip internal buffers were full (we drop blocks in order for the network not to be "deadlocked").  However - when I did the following bypass in  channel.go|https://github.com/hyperledger/fabric/blob/master/gossip/gossip/channel/channel.go#L547-L565  :  {code} func (gc *gossipChannel) verifyBlock(msg *proto.GossipMessage, sender common.PKIidType) bool { 	if gc.GetConf().SkipBlockVerification { 		return true 	} {code}  *No block was dropped because of comm layer buffer overflow!*  -Therefore I suggest we use the skipBlockVerification configuration property (not used in the code but exists in the  core.yaml|https://github.com/hyperledger/fabric/blob/master/sampleconfig/core.yaml#L157 ) in order to give the user (the network administrator) a chance to increase throughput on the expense of byzantine tolerance, while preserving correctness and validity (the blocks are in any case validated before they enter the ledger and when they are pulled from the ordering service)-    *UPDATE*  I realized the reason for the performance penalty is that we have an inefficient order of steps at block handling: *Background*: The flow of blocks from the comm layer to the state transfer layer (the last stop in the gossip layer before the block is passed to the committer service of the peer) works as follows: Communication layer -->  gossip module routes to the right channel object ---> channel module checks if the block was received for the first time  ---> published to the state transfer layer ---> block is put in a data structure that ensures blocks are passed in-order to the committer  There are actually 2 inefficiencies that exist in the code and when they are improved I get the same (good) results as above without blocks being dropped: # Blocks are verified when they arrive from the communication layer in  gossip_impl.go|https://github.com/hyperledger/fabric/blob/master/gossip/gossip/gossip_impl.go#L440-L457  but are in any case verified (again) in the  channel module|https://github.com/hyperledger/fabric/blob/master/gossip/gossip/channel/channel.go#L547-L565  which handles everything related to channels. # When the block reaches the channel module it is *first verified* and then checked if it has been received before (this is done by adding it to the message store and seeing if the message store rejected the message or not).  From random nature of the forwarding phase in gossip, each message might be received a few times and this causes redundant verification of messages.   I pushed the following commit https://gerrit.hyperledger.org/r/#/c/11377/ to take care of this.  This commit ensures that a message is verified only after it is decided that it can be added to the message store or not.    ></description> </Issue>
