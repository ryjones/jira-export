<Action id="60366" issue="40137" author="yacovm" type="comment" created="2019-05-24 16:26:55.0" updateauthor="yacovm" updated="2019-05-24 17:41:03.0"> <body><! CDATA  ~ales  - seems to me somehow somewhere we have a missing conversion to a policyError.... is is this v1.1 by chance?  Â   actually - scratch that, i think it comes from the ledger  ></body> </Action>
<Action id="60367" issue="40137" author="mastersingh24" type="comment" body="Looks like 1.4.x (based on the . separator in the named loggers)" created="2019-05-24 16:32:42.0" updateauthor="mastersingh24" updated="2019-05-24 16:32:42.0"/>
<Action id="60368" issue="40137" author="yacovm" type="comment" created="2019-05-24 17:58:45.0" updateauthor="yacovm" updated="2019-05-24 18:01:05.0"> <body><! CDATA I think I reproduced the problem by making the peer CLI remove the first identity from the signature policy collection policy and instantiate a chaincode in the integration tests and after lots of *fmt.Printlns* I think it comes from the npp.NewPolicy(polBytes)  returning an error|https://github.com/hyperledger/fabric/blob/eca1b14b7e3453a5d32296af79cc7bad10c7673b/core/common/privdata/util.go#L32 , while being invoked by  AmMemberOf|https://github.com/hyperledger/fabric/blob/eca1b14b7e3453a5d32296af79cc7bad10c7673b/core/common/privdata/membershipinfo.go#L28  which is done as part of the post commit process where the ledger tries to figure out which organizations it wasn't eligible, and now is eligible.  I recommend: # Validate the collection config correctness at validation for v2.0 channels # Treat the bespoken error as the peer not being eligible of the collection and "move on".  {code} 		membershipEnabled, err := n.elgEnabled(ledgerID, existingConf.MemberOrgsPolicy, postCommitConf.MemberOrgsPolicy) 		if err != nil { 			return nil, err <---- change this to "continue" and log the error 		} 		if !membershipEnabled { 			continue 		} {code}   ~manish-sethi   ~denyeart    ></body> </Action>
<Action id="60369" issue="40137" author="denyeart" type="comment" created="2019-05-24 18:03:20.0" updateauthor="denyeart" updated="2019-05-24 18:03:20.0"> <body><! CDATA  ~yacovm  I don't think we even need to check for v2.0 channel capability. We can immediately invalidate the transaction (instead of panic) in all v1.x releases.  This may be a good one for  ~wenjian .  ></body> </Action>
<Action id="60370" issue="40137" author="yacovm" type="comment" body="This passes VSCC, so if you don&apos;t check capability then when Matt W upgrades his peers and brings new peers that are upgraded, he will have a fork. " created="2019-05-24 18:08:14.0" updateauthor="yacovm" updated="2019-05-24 18:08:14.0"/>
<Action id="60371" issue="40137" author="manish-sethi" type="comment" created="2019-05-24 18:10:51.0" updateauthor="manish-sethi" updated="2019-05-24 18:10:51.0"> <body><! CDATA  ~yacovm  - I think that (2) can cause problems later when gossip tries to disseminate the private data to peers using this collection config - can you confirm?  So, a fix would be to add this additional check to the list of lscc validation and invalidate the transaction and add the same check during simulation for lscc and new lifecycle as well.  ></body> </Action>
<Action id="60372" issue="40137" author="manish-sethi" type="comment" body="About the fork - if this kind of configuration has ever been submitted to a 1.3/1.4 channel, the panic would have happened since this reconciliation code was added in 1.3 (if I recall correctly). The issue of fork could happen if this kind of configuration exists in some of the 1.2 channel but then won&apos;t it panic during regular dissemination of private data?" created="2019-05-24 18:18:27.0" updateauthor="manish-sethi" updated="2019-05-24 18:18:27.0"/>
<Action id="60374" issue="40137" author="yacovm" type="comment" created="2019-05-24 18:20:22.0" updateauthor="yacovm" updated="2019-05-24 18:20:22.0"> <body><! CDATA  ~manish-sethi  actually you have a point - it will either just refuse to disseminate it, or if it will have the private data missing at time of commit, then it will halt the chain processing but not panic.   Another possible solution can perhaps be to make the *getPolicy* function to return a reject all policy - that one is invoked both by gossip and ledger, no?  ></body> </Action>
<Action id="60375" issue="40137" author="yacovm" type="comment" created="2019-05-24 18:23:20.0" updateauthor="yacovm" updated="2019-05-24 18:23:20.0"> <body><! CDATA {quote} The issue of fork could happen if this kind of configuration exists in some of the 1.2 channel but then won't it panic during regular dissemination of private data?{quote}  If you always endorse on all the peers, or the private data is sent to all peers during endorsement then they will never have missing private data, hence will never check if they are eligible of the policy.  ></body> </Action>
<Action id="60380" issue="40137" author="manish-sethi" type="comment" created="2019-05-24 19:58:37.0" updateauthor="manish-sethi" updated="2019-05-24 19:58:37.0"> <body><! CDATA  ~yacovm  - Just to understand this further when you say -  "_if it will have the private data missing at time of commit, then it will halt the chain processing but not panic_" Does this mean that coordinator first checks in the transient store and if not found then checks the eligibility (instead of other way around?)  On your suggestion, yes, treating a faulty config as equal to everyone removed from the collection could be a possible choice. Because, even if such a config exists this is almost certain (assuming the answer to above question is yes) that this was never used for dissemination.   On a side note, this problem can surface not only because of the proposed config being faulty but also if the existing policy is faulty - because function "AmMemberOf" is invoked on both to determine the eligibility change.  ></body> </Action>
<Action id="60383" issue="40137" author="yacovm" type="comment" created="2019-05-24 20:44:14.0" updateauthor="yacovm" updated="2019-05-24 21:28:07.0"> <body><! CDATA {quote}Does this mean that coordinator first checks in the transient store and if not found then checks the eligibility (instead of other way around?){quote}  It means that, but I double checked the code and it seems like we first check eligibility. This code was changed by so many people (Artem, Nir, Senthil) since I wrote the first version of the coordinator... (though that's not an excuse because we always checked for our eligibility first, since v1.1, and I wrote it back then :O )      ></body> </Action>
<Action id="60384" issue="40137" author="manish-sethi" type="comment" body="OK, so if this code is like this since 1.2 (since we officially started supported private data), we can safely mark the trans invalid. Your suggestion is also applicable irrespective." created="2019-05-24 21:14:28.0" updateauthor="manish-sethi" updated="2019-05-24 21:14:28.0"/>
<Action id="60385" issue="40137" author="manish-sethi" type="comment" body="If three people means so many what will you call this - one of the most critical files - https://github.com/hyperledger/fabric/blob/release-1.2/core/committer/txvalidator/validator.go :-)" created="2019-05-24 21:18:29.0" updateauthor="manish-sethi" updated="2019-05-24 21:18:45.0"/>
<Action id="60386" issue="40137" author="yacovm" type="comment" created="2019-05-24 21:23:15.0" updateauthor="yacovm" updated="2019-05-24 21:26:51.0"> <body><! CDATA what do you mean by: {quote}we can safely mark the trans invalid. {quote} ? This wasn't caught by the coordinator at the commit of the block.  I guess this is because instantiate doesn't have private data writes in it, so the block gets through and it fails at your post commit listeners.   The next transaction of private data for that collection would probably raise a *VSCCExecutionFailureError* upon error, so by making *getPolicy* return a reject all policy we will simply skip that collection.   What do you mean by marking this invalid? I am hesitant to mark transactions invalid outside of VSCC...   ~ales  what is your opinion of all this?     ></body> </Action>
<Action id="60390" issue="40137" author="manish-sethi" type="comment" created="2019-05-24 21:54:11.0" updateauthor="manish-sethi" updated="2019-05-24 21:54:34.0"> <body><! CDATA On "_it fails at your post commit listeners._" listeners are not post commit. They execute before block commit. That's why you see the message in the logs "commit failed".  What I meant was that not about _this_ transaction that updates the collection config rather a later user transaction would have cause panic/chain processing halt. Yes, there is a possibility that user trans did not contain any private data at all to start with in which case, fork would happen. BTW, I never suggested marking a transaction invalid outside VSCC. The discussion is only to determine whether to go for marking invalid in retrospection (which is only safe if we can conclude that no such transaction could have happened in the past, for instance its true for 1.4 but not for 1.2).  As I said before, I tend to agree with your suggestion of treating the faulty config in a RejectAll way.  ></body> </Action>
<Action id="60395" issue="40137" author="yacovm" type="comment" created="2019-05-25 08:22:03.0" updateauthor="yacovm" updated="2019-05-25 11:38:42.0"> <body><! CDATA I think that something like the below should work... perhaps as Dave said - Wenjian can take on this.  But I also think that  ~ales  should take a look as well.  Regardless, we should make sure to reproduce the problem first, and only after that - apply the fix, in order to mimic what happens to  ~mistogans  's environment since I think he is kind of stuck in fabric limbo the moment.  !Screenshot from 2019-05-25 11-13-51.png|thumbnail!  ></body> </Action>
<Action id="60399" issue="40137" author="ales" type="comment" created="2019-05-26 08:07:53.0" updateauthor="ales" updated="2019-05-26 08:07:53.0"> <body><! CDATA # If we add a new validation check in 1.X nodes, we must gate it behind a capability, otherwise we will fork right? # If we change the post-commit dissemination code, will all nodes in the network either ** a) panic (if they run with the old peer code); or ** b) end up with the exact same set of preimage data as other nodes that didn't panic?  If 2a) is true, then I think it's safe to go with Yacov's proposal; but someone should be sure of this. Otherwise we'll end up with a different type of fork, where 2 nodes which on paper should have the same sets of preimages don't.  ></body> </Action>
<Action id="60400" issue="40137" author="yacovm" type="comment" created="2019-05-26 08:42:03.0" updateauthor="yacovm" updated="2019-05-26 08:42:03.0"> <body><! CDATA So  ~manish-sethi  raised an argument (that I think is correct, but we need to verify it) that if any peer at version of v1.1 or v1.2 would have been effected by that - then at the time of parsing of a transaction of private data with such a corrupt policy - gossip would have not passed the block to commit in the ledger because it cannot verify whether it is eligible of a collection or not. The code handling we do makes the chain processing halt, and not panic.  Else, the peer is at versions v1.3 or v1.4 and it would have panicked before committing the block.  So in any case - the block isn't committed so it will pass VSCC again once the upgrade is done.  Â   ></body> </Action>
<Action id="60406" issue="40137" author="ales" type="comment" created="2019-05-27 09:28:50.0" updateauthor="ales" updated="2019-05-27 09:28:50.0"> <body><! CDATA So re. my point above {quote} * If we change the post-commit dissemination code, will all nodes in the network either ** a) panic (if they run with the old peer code); or ** b) end up with the exact same set of preimage data as other nodes that didn't panic?{quote} It seems that the answer is no, some 1.X nodes might commit the transaction and panic later, others might halt before committing (and get a second chance to process the transaction later after the peer is upgraded). This really sounds like we need a capability for post-commit changes as well. So, do we agree on the following: # lifecycle changes; namely ** Collection validation at LSCC invoke time ** Collection validation at _lifecycle invoke time ** Collection validation at LSCC custom validation time # post-commit processing changes; namely ( ~yacovm  would be able to better articulate these)  Both 1) and 2) must be gated behind capabilities in order to be fork-safe.  ></body> </Action>
<Action id="60408" issue="40137" author="ales" type="comment" body="After talking to  ~yacovm , it sounds like for point 2) we might not need a capability, iff we are able to guarantee that all versions, no matter the committed or proposed collection configuration, will not change the ledger or stateDB in any permanent way before either panicking or halting processing. If we&apos;re able to get hard evidence of this fact, we might not need a capability for the change at point 2. FWIW, sounds like the creation of the capability is just less of a hassle compared to the code review to determine whether we might not needed :)" created="2019-05-27 09:55:13.0" updateauthor="ales" updated="2019-05-27 09:55:13.0"/>
<Action id="60452" issue="40137" author="manish-sethi" type="comment" created="2019-05-29 04:06:49.0" updateauthor="manish-sethi" updated="2019-05-29 04:06:49.0"> <body><! CDATA  ~ales  - As an additional thought - In addition to treating a faulty configuration as 'RejectAll', if we add another validation in vscc in 1.2, 1.3 and 1.4 which checks if a user transaction (not the collection config transaction) that includes private data and the corresponding committed collection config is faulty (i.e., 'RejectAll'), the user transaction be marked invalid. This additional check may not need any capability and will prevent loss of private data.   Again, this is based on the fact that has been mentioned above a few times - i.e., no such block would have anyway been committed in either of the versions. In nutshell, the treatment of 'RejectAll' will help proceed the processing and marking the user transactions invalid would help prevent loss of private data (and give users a hint that they need to fix the broken config).   ~yacovm  - Can you confirm this assertion that the possibility of loss of private data is a corner case where configuration sets the "requiredPeerCount" to zero, otherwise the problem may have happened during simulation as well and no such user transaction would get in a block at the first place. If this is true, we can discuss if we can leave this corner case and just go with 'RejectAll' behavior.  ></body> </Action>
<Action id="60454" issue="40137" author="yacovm" type="comment" body=" ~manish-sethi  I don&apos;t follow... and we should assign someone to *thoroughly* test any fix we make, on all versions we decide to backport." created="2019-05-29 06:49:29.0" updateauthor="yacovm" updated="2019-05-29 06:49:29.0"/>
<Action id="60475" issue="40137" author="wenjian" type="comment" body=" ~mistogans  Can you attach the collections_config.json file that caused peer panic?" created="2019-05-29 18:45:22.0" updateauthor="wenjian" updated="2019-05-29 18:45:22.0"/>
<Action id="60539" issue="40137" author="denyeart" type="comment" created="2019-05-30 23:05:40.0" updateauthor="denyeart" updated="2019-05-31 11:35:29.0"> <body><! CDATA The above comments are fairly confusing. Let me summarize where I think we are...  We want to avoid adding new capabilities if at all possible, and it does in fact seem possible.  In v1.2 a bad collection config will result in the instantiation transaction getting validated, but subsequent user transactions that reference the private data collection will cause channel processing to terminate. In order to fix channels in this state, a code fix will be made (on all releases) such that getPolicy() will return a RejectAllPolicy if the policy cannot be parsed, plus an error will be logged. This will cause AmMemberOf() to always return false. User transactions that reference the bad collection config will get validated, but no private data will be persisted. Between private data not getting persisted, and the log message, users will become aware of the bad collection config and will update their collection configs.  In v1.4 (and perhaps v1.3) a bad collection config will cause instantiation transaction to panic peer. A code fix will be made (in release-1.4, and potentially in release-1.3 if it demonstrates the same problem) in lscc validation logic so that the bad collection config will cause the instantiation transaction to be invalidated. User will fix collection config and try instantiation again.  In both cases, no forks are possible. We are not changing any prior validation status (no capability update is required). The fixes simply allow channel processing that was previously blocked to proceed.  A similar check for bad collection config will also be made at endorsement time, both for lscc and for v2.0 new lifecycle.  ></body> </Action>
<Action id="60541" issue="40137" author="manish-sethi" type="comment" created="2019-05-31 02:07:56.0" updateauthor="manish-sethi" updated="2019-05-31 02:07:56.0"> <body><! CDATA {quote} We want to avoid adding new capabilities if at all possible, and it does in fact seem possible. {quote} We need to fix the problem without capability anyways else the channel that are stuck simply cannot proceed. Capability is an orthogonal discussion for the channels that may not have struck this in the current deployed versions and the capability will help avoid this situation in the upgraded versions.  For fixing the problem in the current versions (i.e., with no capability), the proposal from  ~yacovm  is to make getPolicy() return a RejectAllPolicy. In addition my, suggestion was to mark a user transaction invalid if the user transaction contains any private data corresponding to such collection (the block processing would have halted at a block with any such transaction). The problem with not marking such user transactions invalid is that the private data would not be committed anywhere (because of RejectAllPolicy) whereas the hashed versions will be committed. i.e., no further transactions on such private data will be possible (endorsement for any mutation on such private data will receive error - private data version does not match with hashed version - which I referred to as loss of private data in my previous comment)  So, if you would look at the transactions in a chain, ideally a transaction with faulty collection config should have been marked invalid (which can improve in the future versions by tacking at the simulation side and optionally at validation side with new capability). However, since we are fixing this in retrospection with current capabilities under the assumptions some channel is stuck, the chain would have already marked a transaction with faulty collection config as valid (however, its collection config part would never be used) and the user transaction that referred to such config would appear as invalid.   ></body> </Action>
<Action id="60552" issue="40137" author="denyeart" type="comment" created="2019-05-31 11:37:53.0" updateauthor="denyeart" updated="2019-05-31 11:37:53.0"> <body><! CDATA  ~manish-sethi  Thanks for the additional clarifications. Are you suggesting changes to any of the fixes I proposed in the summary above? For example are you suggesting to change "User transactions that reference the bad collection config will get validated" to "User transactions that reference the bad collection config will get invalidated"   ></body> </Action>
<Action id="60561" issue="40137" author="manish-sethi" type="comment" body="Yes  ~denyeart  - that is one change I suggested apart from stressing the fact that we need a solution without a new capability (just to bring focus to the discussion) - thanks" created="2019-05-31 13:49:26.0" updateauthor="manish-sethi" updated="2019-05-31 13:49:26.0"/>
<Action id="60562" issue="40137" author="ales" type="comment" body=" ~manish-sethi : I don&apos;t follow why we want to code in this extra fix. Why would we want to mark the transaction as invalid, only because the dissemination policy would ultimately be converted into a reject all policy? I would keep the fix as minimal and simply convert on the fly the policy to a reject all... We could print appropriate warnings perhaps. What do you think?" created="2019-05-31 14:34:58.0" updateauthor="ales" updated="2019-05-31 14:34:58.0"/>
<Action id="60600" issue="40137" author="ales" type="comment" created="2019-06-03 14:43:30.0" updateauthor="ales" updated="2019-06-03 14:43:30.0"> <body><! CDATA Btw, I've doubled checked and if the same bogus policy is supplied as endorsement policy, we won't panic but "simply" fail validation. {noformat}  e  org1.peer1  2019-06-03 16:35:18.455 CEST  vscc  Validate -> ERRO 070 VSCC error: stateBasedValidator.Validate failed, err validation of endorsement policy for chaincode mycc in tx 4:0 failed: identity index out of range, requested 0, but identies length is 0{noformat} Should we catch these at LSCC/_lifecycle endorsement time?  ></body> </Action>
<Action id="60602" issue="40137" author="yacovm" type="comment" body="what about the pre 1.3 where we didn&apos;t have SBE  ~ales  ? " created="2019-06-03 15:00:05.0" updateauthor="yacovm" updated="2019-06-03 15:00:05.0"/>
<Action id="60617" issue="40137" author="manish-sethi" type="comment" created="2019-06-03 19:57:40.0" updateauthor="denyeart" updated="2019-06-12 14:25:01.0"> <body><! CDATA Discussed with  ~ales  offline and summarizing here again on the choices of user transactions with private data that reference a collection config that cannot be parsed that therefore returns RejectAllPolicy.  Option-1 - invalidate transactions As explained in my earlier message, if we do not mark the transactions with private data invalid, a channel may suffer loss of private data. For including this in the _minimum_ fix, we need to verify that - If a faulty config has been committed in version 1.2, a block with private data transaction (that includes a collection of faulty config) would halt the block commit. If this is true, then we have an opportunity to save ourselves from loss of private data by invalidating user transactions. Otherwise, users may keep submitting private data transactions after applying this fix that would just keep widening the loss of private data.  Option-2 - validate transactions  On a second thought, a block containing a transaction with private data for faulty collection may not at all be possible based on how this configuration is used during endorsement phase. If this faulty config is guaranteed to cause failure during endorsement in the previous versions here - ( https://github.com/hyperledger/fabric/blob/dafa10882ed2e675023ec9f465ca2e6a98275546/core/endorser/endorser.go#L297 ) ( ~yacovm  - this is what I wanted to confirm with you) then the alternate fix could be to change the above code for returning error on having found "RejectAll" policy. The benefit of this approach is that this reduces the changes we have to make in the validation code in retrospection. However, the down side is that we would rely on the endorsement side code for this behavior which could be changed to fix some other bug and hence we would need to specify in comments clearly about this.  ></body> </Action>
<Action id="60619" issue="40137" author="yacovm" type="comment" created="2019-06-03 21:16:16.0" updateauthor="yacovm" updated="2019-06-03 21:16:16.0"> <body><! CDATA Indeed if we fix the getPolicy to return a reject all policy in case of a malformed collection config, then all peers (regardless of branch version) would *not panic* and also *not halt the chain processing*, and would happily endorse the transaction, *however* all peers would skip that collection (because of the reject all policy conversion) at time of private data analysis at the private data part of gossip and (as you correctly say) - private data would be lost because the hashes are in the block but the pre-images are not in the private data DB.  Also you are right that changing the endorser code to explicitly check (I guess via a reference comparison) whether the policy we have is the reject all policy or not prior to dissemination, and aborting the endorsements in such a case - would make sure peers (after the fix) won't endorse private data for collections with malformed config.   However, this is simply because we didn't fix the core issue - there is no collection policy sanity check at LSCC validation. If we assume we put a validation check (without a capability) of the collection config in LSCC: * All 1.4 peers that receive a block with a malformed collection config die from the instantiate, so after fixing them and restarting them - they will skip the instantiate transaction.  * All pre 1.4 peers that receive a block with a malformed collection config don't die, but halt the chain and never commit the block, so after fixing them and restarting them - they will skip the instantiate transaction. * All pre and post 1.4 peers that never received a block with a malformed collection config and are upgraded and *later* receive a block with malformed collection config, don't validate the transaction either.   So I agree on the facts but I am not sure I agree with the resolution. It's true that a validation check is riskier than a check in the endorsement path, but doing a specific check to see if it's a "reject all" policy seems to me a bit hacky.  ~manish-sethi   ~ales  what do you think?   ></body> </Action>
<Action id="60624" issue="40137" author="wenjian" type="comment" created="2019-06-04 01:07:55.0" updateauthor="wenjian" updated="2019-06-04 01:36:34.0"> <body><! CDATA I tested with node.js SDK in v1.4 (I ran the e2e tests using old API, install chaincode, instantiate chaincode, upgrade chaincode) * Instantiating a chaincode with a malformed collection config (sign-by is out of index) was successful, no panic. * Invoke such a chaincode failed - chaincode container stopped with :"identity index out of range, requested 2, but identies length is 2" error.  * Upgrading such a chaincode caused peer panic.  deliverPayloads -> PANI 69f9^  0m Cannot commit block to the ledger due to identity index out of range, requested 2, but identies length is 2  commit failed  github.com/hyperledger/fabric/gossip/privdata.(*coordinator).StoreBlock  Â  Â  Â  Â  /go/src/github.com/hyperledger/fabric/gossip/privdata/coordinator.go:257  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).commitBlock  Â  Â  Â  Â  /go/src/github.com/hyperledger/fabric/gossip/state/state.go:863  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads  Â   .......  Â   ></body> </Action>
<Action id="60629" issue="40137" author="manish-sethi" type="comment" created="2019-06-04 02:42:18.0" updateauthor="manish-sethi" updated="2019-06-04 03:44:25.0"> <body><! CDATA Thanks  ~wenjian  for reproducing this. Can you please confirm the following  with version 1.2 and 1.3 (1.3 should be similar to 1.2, I guess) -  1) The instantiation transaction with wrong collection config gets committed 2) The user transaction for faulty collection gets rejected at the endorsement phase 3) The user transaction that contains only public data or private data for non faulty collections gets committed   ~yacovm  - I agree that "reject all" policy seems a hacky fix and as an alternative, I had considered the solution that you listed above in three bullets. If the problem would have been limited to version 1.4, first and third bullet would work best. The problem is with the second bullet... {quote} All pre 1.4 peers that receive a block with a malformed collection config don't die, but halt the chain and never commit the block, so after fixing them and restarting them - they will skip the instantiate transaction. {quote} Pending verification from above tests, Pre 1.4, peer don't halt at the block that contains the instantiate transaction, rather , they don't even halt on a further user transactions. Because, any user transaction that contains private data for the faulty collection is rejected in the endorsement phase and does not ever make it to a block. So, if we go for second bullet, we would need to also supply a tool that detects if such a faulty transaction has been committed. If the answer is positive, a reset of peer to that block (i.e., rebuild that block onward) would be required which would cascade-invalidate the user transactions (that contains only public data or private data for other collections). So, we need to make a call to take a chance with this approach which - has a low probability at the first place however, this solution could be catastrophic if it has happened.   May be the answer is that in the larger interest, it should be OK to take a chance if some users get affected. Still, it is a point that asks for opinions. So, better to confirm the outcome of above tests and then take a call.  BTW, as observed by  ~wenjian  test above, the first time instantiate transaction with faulty config would get committed even in version 1.4  ></body> </Action>
<Action id="60634" issue="40137" author="yacovm" type="comment" created="2019-06-04 07:14:14.0" updateauthor="yacovm" updated="2019-06-04 07:14:37.0"> <body><! CDATA yeah  ~manish-sethi  you're right - The network is going to end up with a collection that you can't use, and if we don't gate it behind a capability then a new peer with the fix will invalidate the collection and we're going to reach a state where you can have peers with the collection and peers without that collection. This is actually not that bad if it's a collection config that was corrupted by an upgrade, because we could always fix the upgrade for both types of peers since upgrade overwrites the collection config.  However the problematic part is that you can have an instantiate transaction that gets invalidated (due to us not gating it behind a capability and marking that invalid) in the new peers, and is valid in the old peers - and then you reach a state where you have peers with chaincode definition in the old peers and peers without that chaincode definition in the new peers and then it's bad  - because the organizations might have detected this and "fixed" the collection config by an upgrade and then continued using it.  So your proposal sounds much more appealing now :)   ~ales  what do you think?  ></body> </Action>
<Action id="60767" issue="40137" author="manish-sethi" type="comment" created="2019-06-07 17:39:59.0" updateauthor="denyeart" updated="2019-06-24 22:43:55.0"> <body><! CDATA A summary of fixes: 1) Without capability (backport to -1.2, 1.3-, and 1.4.2) a) Treating faulty config in user transactions as RejectAllPolicy (fix in function getPolicy suggested by  ~yacovm ) b) Need to make a choice from the two options (option-1=add new invalidation logic; option-2=let transactions validate but don't disseminate private data)Â  https://jira.hyperledger.org/browse/FAB-15543?focusedCommentId=60617&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-60617.  2) Fix for not allowing faulty-policy in lscc chaincode instantiate/upgrade for all releases (endorsement side fix) and validation side with capability starting in 1.4.2 (unfortunately, that's how lscc is - i.e., checks at both endorsement side and validation side).  3) Fix for not allowing faulty-policy in new lifecycle (endorsement side fix)   ~ales ,  ~yacovm  - Does this sound good to you?  ></body> </Action>
<Action id="60777" issue="40137" author="wenjian" type="comment" created="2019-06-07 21:06:18.0" updateauthor="wenjian" updated="2019-06-07 21:06:18.0"> <body><! CDATA I have attached the test results. Also associate Jira tickets to the summary above.  1a)Â Treating faulty config as RejectAllPolicy (fix in function getPolicy suggested byÂ  ~yacovm ): FAB-15594  2)Â Fix for not allowing faulty-policy in lscc chaincode instantiate/upgrade for 1.4.2 (endorsement side fix) and validation side with capability 1.4.2: FAB-15593  3) Fix for not allowing faulty-policy in new lifecycle (endorsement side fix): FAB-15567  Â   ></body> </Action>
<Action id="60882" issue="40137" author="ales" type="comment" body=" ~manish-sethi , agreed on 1a), 2) and 3). Re 1b), the endorser route seems more attractive to me because it gets the job done and guarantees resistance to forks. Not sure I would do it in the endorser proper, we could do it in the peer-side of the shim. Wdyt?" created="2019-06-11 17:04:27.0" updateauthor="ales" updated="2019-06-11 17:04:27.0"/>
<Action id="60913" issue="40137" author="denyeart" type="comment" body="Discussed with  ~manish-sethi  and  ~ales  , for 1b) we decided on option-2, that is, don&apos;t add code to invalidate these transactions with bad collection configs. For existing chains with transactions that reference bad collection configs, the new RejectAllPolicy fix will essentially cause private data not to be persisted but the transaction will still get validated and be committed. With the new endorser side fixes we don&apos;t expect a transaction with bad collection config to get all the way to validation phase though." created="2019-06-12 14:19:52.0" updateauthor="denyeart" updated="2019-06-12 14:47:06.0"/>
<Action id="61150" issue="40137" author="wenjian" type="comment" created="2019-06-20 15:08:46.0" updateauthor="wenjian" updated="2019-06-20 15:08:46.0"> <body><! CDATA  ~manish-sethi   For fix #1 ( https://gerrit.hyperledger.org/r/#/c/fabric/+/31904/ ), the panic was caused by how AsMemberOf handles the getPolicy error. Don't think it is applicable to v1.2 and v1.3. * v1.2: no AsMemberOf method * v1.3: the method is there, but not called anywhere. Can we delete the method to avoid confusion?  ></body> </Action>
<Action id="61161" issue="40137" author="manish-sethi" type="comment" body="Yes, ~wenjian  - in 1.3 this function can be removed to look it more like 1.2." created="2019-06-20 20:43:30.0" updateauthor="manish-sethi" updated="2019-06-20 20:43:30.0"/>
<Action id="61208" issue="40137" author="wenjian" type="comment" created="2019-06-24 15:00:16.0" updateauthor="wenjian" updated="2019-06-24 15:01:14.0"> <body><! CDATA Added manual test resultsÂ jira15593_15594_tests.pdf and deleted the earlier test result snapshot.  Â   ></body> </Action>
