<Issue id="33597" key="FAB-11918" number="11918" project="10002" reporter="guoger" assignee="guoger" creator="guoger" type="10003" summary="Support WAL in etcdraft-based Chain" priority="3" resolution="10000" status="6" created="2018-09-09 09:40:40.0" updated="2018-11-08 15:30:14.0" resolutiondate="2018-11-08 15:30:06.0" votes="0" watches="2" workflowId="44891"> <description><! CDATA The etcd/raft-based chain should be able to persist log entries on disk using the etcd/wal library. When the chain is restarted, it reads the WAL data and resume from where it was left off.  It's worth to call out two terms: # *committed*: messages that are consented by the majority of cluster. # *applied*: messages that are applied to state machine; in our case, written into ledger  Given a series of persisted messages, we may have: {code:java} |      applied      |         committed         |  unstable  | -------------------------------------------------------------- {code} We can recover {{Commit}} index from {{HardState}}, but *not* {{Applied}}.  A quick scan of {{etcd}} and {{swarmkit}} shows that their state machines are *idempotent*, meaning _it doesn't matter if an applied message is being applied again_, i.e. with /'my-key': 'foo'/, it doesn't matter if we set 'my-key' to 'foo' again during restart.  However, this is not the case for orderer, as we must not write a block to ledger more than once.  -Luckily, {{etcd/raft}} provides a nice config  option|https://github.com/etcd-io/etcd/blob/master/raft/raft.go#L145-L149  *Applied uint64* to prevent raft from reporting already applied messages.- This does not work due to  this issue|https://github.com/etcd-io/etcd/issues/10217 . Luckily we have the check  here|https://github.com/hyperledger/fabric/blob/3b0e8171b7827afadb7a229ff891b630b0cf4236/orderer/consensus/etcdraft/chain.go#L528-L546   We should *persist raft {{Index}} in every block metadata*, which is used to restart a raft node. This is similar to what we have today for Kafka.   ></description> </Issue>
