<Issue id="14801" key="FAB-2241" number="2241" project="10002" reporter="elli-androulaki" creator="elli-androulaki" type="10001" summary="Construction of the chaincode identifier in the new deployment model" priority="3" resolution="10000" status="6" created="2017-02-14 20:45:05.0" updated="2018-07-20 18:54:46.0" resolutiondate="2017-04-13 07:52:16.0" votes="0" watches="3" workflowId="37442"> <description><! CDATA *Background*:  For regulatory reasons installation of software needs to be accompanied by a list of chaincode signers/owners/guarantors, and their signature on the chaincode code (hash). For simplicity we will refer to the latter by the chaincode's "owners", and assume that each of these owners can be expressed by means of serialized certificates ("SerializedIdentity").  In the new deployment model chaincodes acquire an identifier at installation time that is essential to be unique across all chaincodes of a specific blockchain network. This is because, chaincode identifiers are henceforth used in subsequent chaincode instantiation requests (invocations of LCCC) to reference installed chaincodes that are to be instantiated on a given chain.   In the new deployment model, for instantiation requests for a specific chaincode to be successful, the instantiator (i.e., client requesting the chaincode instantiation using chain's LCCC) needs to be among the LCCC admin list. In addition, the instantiator needs to be one of the owners of the chaincode to be instantiated.   *Problem*:   At the lccc (chaincode instantiation) transaction validation time: - all peers that have joined the chain are aware of the LCCC admin policy and can run the instantiator data against that policy - a subset of peers that have joined the chain are aware of the owners of the chaincode to be instantiated, and therefore only those can check if the instantiator is among them.   *Suggested Solution*:  Here we suggest a way of constructing the chaincode identifier such that: - chaincode identifier is unique per chaincode within a blockchain network installation - chaincode identifier can be derived by the chaincode content and metadata - the previous issue is tackled   In the following we assume a chaincode whose source code is represented by CC and its list of owners by OwnCC (denoted as a list of SerializedIdentities). We also assume a collision resistant hash function H. For this chaincode we pick identifier IDcc as follows: IDcc = { H(CC) || H(OwnCC) }, where "||" denotes concatenation.  At chaincode instantiation time, LCCC would require as parameters:  - IDcc - OwnCC (to this one there is an optimization if the list is too long) - Signatures on IDcc from entities in OwnCC (more info to be added here by  ~muralisr  ) Now let that the creator of instantiation proposal / transaction is SerializedIdentity Cr.  At endorsement time (LCCC invocation), an endorser (within LCCC logic) would need to do the following: 1. Check that H(OwnCC) = LSHalfOf(IDcc), where LastHalfOf(m) returns the least significant half of m. 2. Deserialize OwnCC to a list of identities  3. Check that Cr is included in deserialized OwnCC 4. Check that Cr is part of LCCC admin policy (provided in the chain's genesis block) 5. Check the signature of tx/proposal matching the key in Cr 6. If the checks above succeed, proceed with the processing of instatiation request; otherwise reject.  At validation time (LCCC_VSCC) committing peers would need to do the following: 1. Check that H(OwnCC) = LSHalfOf(IDcc), where LastHalfOf(m) returns the least significant half of m. 2. Deserialize OwnCC to a list of identities  3. Check that Cr is included in deserialized OwnCC 4. Check that Cr is part of LCCC admin policy (provided in the chain's genesis block) 5. Check the signature of tx/proposal matching the key in Cr 6. (optionally check the simulation result) 7. If the checks above succeed, apply the simulation results to the locally stored ledger, otherwise reject.  This means that peers will look locally if they have installed a chaincode with id IDcc and prepare it for instantiation accordingly. If  they don't they simply apply simulation results to the ledger referring to the instantiation of a chaincode with identifier IDcc.  What do we achieve? - At the validation of instantiation transaction it is guaranteed that all the peers have the same picture of whether the instantiation should proceed or not. - Even if a malicious chain admin tries to bypass OwnCC by creating an alternate ownership list OwnCC' for CC, (e.g., where it's certificate is included), this would result into a different chaincode identifier IDcc' = {H(CC), H(OwnCC')}, that the peers who have actually installed the chaincode will treat it as a chaincode someone else owns/has installed.   *Additional remarks/extensions*: - We need someway of providing Cr, and serialized identities in OwnCC to be serialized in deterministic way. - If there are many owners on can build a merkel tree of these and only pass at instantiation time the sibling path of the creator CR's certificate to the root.    ></description> </Issue>
