<Issue id="30948" key="FAB-10577" number="10577" project="10002" reporter="jyellick" assignee="jyellick" creator="jyellick" type="10004" summary="Peer may be tricked into executing attacker provided chaincode bytes" priority="2" resolution="10000" status="6" created="2018-06-07 21:06:48.0" updated="2018-07-20 14:16:55.0" resolutiondate="2018-06-09 18:45:21.0" votes="0" watches="3" workflowId="42426"> <description><! CDATA The current peer lifecycle accepts a {{pb.ChaincodeDeploymentSpec}} as the parameter to the {{deploy}} and {{upgrade}} LSCC functions.  Because users do not want to send in the full, real CDS each time they deploy a chaincode to the channel, the LSCC ignores most of the values in the parameter, and instead, looks up the 'real' {{ChaincodeDeploymentSpec}} from the filesystem and performs the checks against it.  Then, when it is successful, control returns to {{endorser.go}} who passes in the original user supplied CDS to the {{chaincode.Execute}} function.  The {{chaincode}} package eventually performs a check that, if the {{ChaincodeDeploymentSpec}} {{CodePackage}} is not nil, then it does _not_ load the code package from the filesystem, but uses the one provided.  There is a comment from https://github.com/hyperledger/fabric/blob/1575ea62a7b77fdadc19c3b5f26d20178270a838/core/chaincode/chaincode_support.go#L638-L647 which claims that:   {noformat} 		//NOTE-We need to streamline code a bit so the data from LSCC gets passed to this thus 		//avoiding the need to go to the FS. In particular, we should use cdsfs completely. It is 		//just a vestige of old protocol that we continue to use ChaincodeDeploymentSpec for 		//anything other than Install. In particular, instantiate, invoke, upgrade should be using 		//just some form of ChaincodeInvocationSpec. 		// 		//But for now, if we are invoking we have gone through the LSCC path above. If  instantiating 		//or upgrading currently we send a CDS with nil CodePackage. In this case the codepath 		//in the endorser has gone through LSCC validation. Just get the code from the FS. {noformat}  This describes the situation fairly well.  The code expects that on upgrade or deploy that the code package is nil, even though nothing enforces this fact.  So, if the code package is not-nil, it is passed directly into the container building process.   ----  To exploit this as an attack vector is fairly trivial.  First, two parties agree to run a chaincode, denoted "Alice" and "Eve".  There is the true chaincode "cc-true", and an evil version of the chaincode, constructed by Eve, "cc-evil".  # Alice installs "cc-true" to her peer # Eve uses a custom peer which skips certain validation checks on chaincode, and installs "cc-evil" under the name/version of "cc-true" # Eve constructs a {{deploy}} transaction with parameters matching the chaincode {{Alice}} installed, and includes the code-bytes of "cc-evil" and sends it to Alice's peer. # Alice's peer blindly accepts the cc bytes for "cc-evil" and starts a container executing them. # Eve discards the proposal which included the "cc-evil" bytes and constructs a new proper deploy with a nil code-package and sends it to Alice's peer. # Alice's peer detects that "cc-true" is already running (although the actual container is executing the bytes of "cc-evil") and passes the request through. # Eve submits the deploy to ordering and it commits normally.  Now, Alice believes that her peer is executing "cc-true" while in fact, Alice and Eve are both executing "cc-evil".  Transactions will endorse and commit successfully and Alice will have no way to detect that the correct chaincode is not executing.  Eventually, if Alice discovers the discrepancy, there is no evidence on the blockchain which might indicate that "cc-evil" exists or that Eve has done anything wrong.   ----  The fix for this is fairly trivial.  {{endorser.go}} should simply use the supplied CDS to look up the one from the filesystem, then use it as a basis for invoking the {{chaincode}} package.  ></description> </Issue>
