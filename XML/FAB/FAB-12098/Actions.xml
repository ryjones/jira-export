<Action id="50989" issue="33987" author="c0rwin" type="comment" body=" ~yacovm  I&apos;m just wondering whenever that connected to intermittent failures: https://jira.hyperledger.org/browse/FAB-12066?" created="2018-09-22 09:04:59.0" updateauthor="c0rwin" updated="2018-09-22 09:04:59.0"/>
<Action id="50990" issue="33987" author="yacovm" type="comment" created="2018-09-22 09:42:56.0" updateauthor="yacovm" updated="2018-09-22 09:42:56.0"> <body><! CDATA That's what I also thought at first, but - before the stream creation - we ping the remote peer via the Ping RPC.  If it's not online, since the gRPC dial and Ping RPC is called with a timeout-context we shouldn't get to the stream establishment.  On top of it - the gRPC connection is closed, and according to the gRPC documentation:  {quote} // NewStream creates a new Stream for the client side. This is typically // called by generated code. ctx is used for the lifetime of the stream. // // To ensure resources are not leaked due to the stream returned, one of the following // actions must be performed: // //      1. Call Close on the ClientConn. //      2. Cancel the context provided. //      3. Call RecvMsg until a non-nil error is returned. A protobuf-generated //         client-streaming RPC, for instance, might use the helper function //         CloseAndRecv (note that CloseSend does not Recv, therefore is not //         guaranteed to release all resources). //      4. Receive a non-nil, non-io.EOF error from Header or SendMsg. // // If none of the above happen, a goroutine and a context will be leaked, and grpc // will not call the optionally-configured stats handler with a stats.End message. {quote}  So we do (1) and we should be fine  ></body> </Action>
