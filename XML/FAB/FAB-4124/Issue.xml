<Issue id="17038" key="FAB-4124" number="4124" project="10002" reporter="jyellick" assignee="manish-sethi" creator="jyellick" type="10001" summary="Encode block metadata TRANSACTIONS_FILTER as proto message" priority="3" resolution="10000" status="6" created="2017-05-23 17:21:58.0" updated="2018-07-20 18:56:38.0" resolutiondate="2017-06-05 18:26:25.0" votes="0" watches="2" workflowId="38652" security="10001"> <description><! CDATA The ledger currently encodes the invalid transactions into the TRANSACTION_FILTER section of the block metadata as a raw byte slice as a bitmask for the invalid transactions.  This has several problems.  1. All other block metadata fields are simply marshaled Metadata message structures.  This makes the TRANSACTION_FILTER field inconsistent with the other marshaling awkward/confusing for anyone trying to use the message. 2. There is no way to deprecate or extend this field.  If for instance we later wish to add a another bitmask like "sidechain affecting txs" or other metadata, there is no way to encode this information in a forward/backward compatible way. 3. The TRANSACTION_FILTER field currently has no way for the peer to sign over the information.  Because the blockmetadata is necessarily not part of the hash chain, it's impossible to detect tampering (especially for those receiving forwarded blocks) without checking signatures.  Proposed improvement:  The TRANSACTION_FILTER field should be encoded as a Metadata message.  Put in golang syntax, initializing the field would look something like this.  {noformat} block.Metadata BlockMetadataIndex_TRANSACTIONS_FILTER  = utils.MarshalOrPanic(&Metadata{ Value: utils.MarshalOrPanic(&NewLedgerProtoMessage{ InvalidTxBitmask:   byte(theBitMask), }, }) {noformat}  The peer may then optionally populate signatures into the Signatures field of the Metadata structure (or, for the moment leave it vacant).  You may see examples of this encoding in {{orderer/multichain/chainsupport.go}} particularly see the method:  {noformat} func (cs *chainSupport) addLastConfigSignature(block *cb.Block) { configSeq := cs.Sequence() if configSeq > cs.lastConfigSeq { cs.lastConfig = block.Header.Number cs.lastConfigSeq = configSeq }  lastConfigSignature := &cb.MetadataSignature{ SignatureHeader: utils.MarshalOrPanic(utils.NewSignatureHeaderOrPanic(cs.signer)), }  lastConfigValue := utils.MarshalOrPanic(&cb.LastConfig{Index: cs.lastConfig}) logger.Debugf(" channel: %s  About to write block, setting its LAST_CONFIG to %d", cs.ChainID(), cs.lastConfig)  lastConfigSignature.Signature = utils.SignOrPanic(cs.signer, util.ConcatenateBytes(lastConfigValue, lastConfigSignature.SignatureHeader, block.Header.Bytes()))  block.Metadata.Metadata cb.BlockMetadataIndex_LAST_CONFIG  = utils.MarshalOrPanic(&cb.Metadata{ Value: lastConfigValue, Signatures:   *cb.MetadataSignature{ lastConfigSignature, }, }) } {noformat}  ></description> </Issue>
