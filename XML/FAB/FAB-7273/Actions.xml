<Action id="35749" issue="24694" author="denyeart" type="comment" body=" ~manish-sethi  As author of PeerLedger and BlockStore, what is your opinion?" created="2017-12-02 16:22:24.0" updateauthor="denyeart" updated="2017-12-02 16:22:24.0"/>
<Action id="35753" issue="24694" author="yacovm" type="comment" created="2017-12-03 00:17:08.0" updateauthor="yacovm" updated="2017-12-03 00:17:08.0"> <body><! CDATA The *deliverServer* receives in the constructor a *SupportManager* which has a *Reader() ledger.Reader* method which is: {code:java} // Reader allows the caller to inspect the ledger type Reader interface { 	// Iterator returns an Iterator, as specified by a cb.SeekInfo message, and 	// its starting block number 	Iterator(startType *ab.SeekPosition) (Iterator, uint64) 	// Height returns the number of blocks on the ledger 	Height() uint64 } {code} You can implement this easily (I think) via the existing ledger interface the peer has access to: {code:java} // PeerLedger differs from the OrdererLedger in that PeerLedger locally maintain a bitmask // that tells apart valid transactions from invalid ones type PeerLedger interface { 	commonledger.Ledger {code} Notice the common ledger here is embedded in the *PeerLedger* and has: {code:java} // Ledger captures the methods that are common across the 'PeerLedger', 'OrdererLedger', and 'ValidatedLedger' type Ledger interface { 	// The iterator is a blocking iterator i.e., it blocks till the next block gets available in the ledger 	// ResultsIterator contains type BlockHolder 	GetBlocksIterator(startBlockNumber uint64) (ResultsIterator, error) 	// Close closes the ledger 	Close() } {code} This is implemented in the peer via: {code:java} // GetBlocksIterator returns an iterator that starts from `startBlockNumber`(inclusive). // The iterator is a blocking iterator i.e., it blocks till the next block gets available in the ledger // ResultsIterator contains type BlockHolder func (l *kvLedger) GetBlocksIterator(startBlockNumber uint64) (commonledger.ResultsIterator, error) { 	return l.blockStore.RetrieveBlocks(startBlockNumber)  } {code} Now lets go back to the orderer and see: {code:java} type fileLedgerIterator struct { 	ledger         *fileLedger 	blockNumber    uint64 	commonIterator cl.ResultsIterator } type fileLedger struct { 	blockStore blkstorage.BlockStore 	signal     chan struct{} } {code} And you can see that it uses the very same *BlockStore* as the peer, and returns an iterator that is hidden within: {code:java} 	iterator, err := fl.blockStore.RetrieveBlocks(startingBlockNumber) 	if err != nil { 		return &ledger.NotFoundErrorIterator{}, 0 	}  	return &fileLedgerIterator{ledger: fl, blockNumber: startingBlockNumber, commonIterator: iterator}, startingBlockNumber {code} So I think that you can just implement the needed interface for initializing the deliver instance, using the peer's ledger and unless I'm missing something (as  ~denyeart  said -  ~manish-sethi  is really the expert here - we should get confirmation from him) - you should be good to go and you don't need a notification signal whenever a block is appended into the ledger, because the ledger should take care of that for you because every ledger's block iterator has a reference to the ledger's block manager which broadcasts via a condition variable a signal that the iterator waits on (but again - lets wait for  ~manish-sethi  to confirm ;) )        ></body> </Action>
<Action id="35810" issue="24694" author="wlahti" type="comment" created="2017-12-04 21:14:54.0" updateauthor="wlahti" updated="2017-12-05 13:08:44.0"> <body><! CDATA With help from  ~sanchezl  and  ~manish-sethi , I think we have a working solution.   The reason we can't simply reuse the ledger's block iterator as-is is that the orderer has the error condition for when it's backing consenter is no longer functioning for whatever reason. When this is the case, we need the deliver client to break out of its block retrieval loop and close.   To achieve this, the delivery client will use a separate go function that uses the ledger's block iterator to wait for the next block and signals when it retrieves it. While looping for blocks, the code also checks for the signal that a background error has occurred (which in this case is the backing consenter error), at which point it will close the block retrieval loop and the delivery client.   ></body> </Action>
<Action id="35957" issue="24694" author="wlahti" type="comment" body="https://gerrit.hyperledger.org/r/#/c/16007" created="2017-12-07 00:56:30.0" updateauthor="wlahti" updated="2017-12-07 00:56:30.0"/>
