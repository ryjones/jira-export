<Issue id="18852" key="FAB-5125" number="5125" project="10002" reporter="hongquan.zhang" assignee="hongquan.zhang" creator="hongquan.zhang" type="10001" summary="creating channel always time out when using kafka consensus" priority="4" resolution="10000" status="6" created="2017-06-30 07:46:25.0" updated="2018-07-20 18:54:59.0" resolutiondate="2017-07-09 20:56:02.0" votes="0" watches="3" timeoriginalestimate="7200" timeestimate="7200" workflowId="39357"> <environment><! CDATA Ubuntu Linux 16.04  The Fabric 1.0.0 rc1 release and the latest codes in master branch   ></environment> <description><! CDATA when using kafka consensus mode, we can not create channel due to time out problem when we try the Fabric example e2e_cli.  reproduce steps: # change ordererType from solo to kafka in configtx.yaml of Faric example e2e_cli (fabric/examples/e2e_cli) # start up test environment by docker-compose # execute script.sh under scripts folder # The script always failed to create channel due to time out or service unavailable message  After I dig into the source code of orderer, I found that there's a problem in function retryProcess::try.  in this function, we must wait for tickInterval.C before executing target function, this lead to useless time waiting for the first try. It shall try first and wait a while for next retry.    {code:java} // the bug is located in fabric source code file: fabric/orderer/kafka/retry.go func (rp *retryProcess) try(interval, total time.Duration) error {     // ... some code removed     tickInterval := time.NewTicker(interval)     tickTotal := time.NewTicker(total)     defer tickTotal.Stop()     defer tickInterval.Stop()     logger.Debugf(" channel: %s  Retrying every %s for a total of %s", rp.channel.topic(), interval.String(), total.String())      for {         select {         case <-rp.exit:             exitErr := fmt.Errorf(" channel: %s  process asked to exit", rp.channel.topic())             logger.Warning(exitErr.Error()) // Log it at the warning level             return exitErr         case <-tickTotal.C:             return err         case <-tickInterval.C:             logger.Debugf(" channel: %s  "+rp.msg, rp.channel.topic())             if err = rp.fn(); err == nil {                 logger.Debugf(" channel: %s  Error is nil, breaking the retry loop", rp.channel.topic())                 return err             }         }     } }  {code}       ></description> </Issue>
