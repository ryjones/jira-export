<Action id="66787" issue="44024" author="denyeart" type="comment" body=" ~jyellick   ~ales  What do you think?" created="2020-01-17 23:41:18.0" updateauthor="denyeart" updated="2020-01-17 23:41:18.0"/>
<Action id="66904" issue="44024" author="jyellick" type="comment" created="2020-01-22 18:35:16.0" updateauthor="jyellick" updated="2020-01-22 18:35:16.0"> <body><! CDATA This is a bit of a tricky one. Lifecycle v2.0 chose to use implicit collections to indicate agreement to execute a chaincode. This closes what is arguably a security problem in the v1.x lifecycle, in that if your peer had a chaincode installed, but you did not want your peer to run that chaincode on a channel, there was essentially no (good) way to prevent it.  I agree with the mechanics of what you outlined above, as a way to completely exclude an org from having the ability to submit transactions, but really, it's hard to claim the org is a part of the channel if it cannot transact in any way. For instance, what if the org wants to revoke one of its user certificates? In this case, you must have configured the org's MSP definition (and therefore identity/membership) to be controlled by another org. If that's the case, where is the utility in encoding them as their own org? If another org is handling their administration, then why not let that org hold the admin certificate keys?  Assuming that's the route you want to go, then it's relatively simple to instead of entirely denying this org write permissions on the channel, to instead restrict this org's write ability to its admin users. This accomplishes the same goal – standard org users cannot transact – and only the admins of this org (which the org doesn't actually own) can.  ></body> </Action>
