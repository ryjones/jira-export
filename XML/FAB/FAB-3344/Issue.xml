<Issue id="15936" key="FAB-3344" number="3344" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Fix CSCC error messages reporting. " priority="3" resolution="10000" status="6" created="2017-04-22 21:29:44.0" updated="2018-07-20 14:12:21.0" resolutiondate="2017-04-23 10:48:32.0" votes="0" watches="1" workflowId="38114"> <description><! CDATA After ACL check has been added to CSCC, there are few places with incorrect logging messages, which need to be fixed.  The body of *Invoke* method: {code} 	args := stub.GetArgs()  	if len(args) < 1 { 		return shim.Error(fmt.Sprintf("Incorrect number of arguments, %d", len(args))) 	}  	fname := string(args 0 )  	if fname != GetChannels && len(args) < 2 { 		return shim.Error(fmt.Sprintf("Incorrect number of arguments, %d", len(args))) 	}  	cnflogger.Debugf("Invoke function: %s", fname)  	// Handle ACL: 	// 1. get the signed proposal 	sp, err := stub.GetSignedProposal() 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed getting signed proposal from stub:  %s ", err)) 	}  	switch fname { 	case JoinChain: 		// 2. check local MSP Admins policy 		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Admins, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"JoinChain\" request failed authorization check for channel  %s :  %s ", args 1 , err)) 		}  		return joinChain(args 1 ) 	case GetConfigBlock: 		// 2. check the channel reader policy 		if err = e.policyChecker.CheckPolicy(string(args 1 ), policies.ChannelApplicationReaders, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"GetConfigBlock\" request failed authorization check for channel  %s :  %s ", args 1 , err)) 		} 		return getConfigBlock(args 1 ) 	case UpdateConfigBlock: 		// TODO: It needs to be clarified if this is a function invoked by a proposal or not. 		// The issue is the following: ChannelApplicationAdmins might require multiple signatures 		// but currently a proposal can be signed by a signle entity only. Therefore, the ChannelApplicationAdmins policy 		// will be never satisfied.  		return updateConfigBlock(args 1 ) 	case GetChannels: 		// 2. check local MSP Members policy 		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Members, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"GetChannels\" request failed authorization check for channel  %s :  %s ", args 1 , err)) 		}  		return getChannels()  	} 	return shim.Error(fmt.Sprintf("Requested function %s not found.", fname)) {code}  So based on the invoke API *JoinChannel* and *UpdateConfigBlock* calls receives as a parameter genesis block and configuration update block respectively. Therefore:  {code} 	case JoinChain: 		// 2. check local MSP Admins policy 		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Admins, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"JoinChain\" request failed authorization check for channel  %s :  %s ", args 1 , err)) 		} 		return joinChain(args 1 ) {code}  In particular:  {code} shim.Error(fmt.Sprintf("\"JoinChain\" request failed authorization check for channel  %s :  %s ", args 1 , err)) {code}  Will print the content of the genesis block rather the channel id.   Next, the code  {code} 	case GetChannels: 		// 2. check local MSP Members policy 		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Members, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"GetChannels\" request failed authorization check for channel  %s :  %s ", args 1 , err)) 		}  		return getChannels()  	} {code}  Call to the *GetChannels*  doesn't receives any input parameters, therefore   {code} shim.Error(fmt.Sprintf("\"GetChannels\" request failed authorization check for channel  %s :  %s ", args 1 , err)) {code}  Will end up with panic, since no {{arg 1 }} is provided.  ></description> </Issue>
