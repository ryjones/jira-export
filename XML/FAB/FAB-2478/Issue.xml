<Issue id="15041" key="FAB-2478" number="2478" project="10002" reporter="farhan3" assignee="mastersingh24" creator="farhan3" type="10004" summary="Issue with Peer-to-Peer TLS" priority="3" resolution="10000" status="6" created="2017-02-24 22:16:39.0" updated="2018-07-20 14:11:48.0" resolutiondate="2017-04-02 13:43:54.0" votes="0" watches="2" workflowId="37605"> <description><! CDATA When Peer A is trying to communicate with Peer B, Peer A acts as the client and Peer B acts as the server. This means Peer A calls {{fabric/core/comm/connection.go#InitTLSForPeer()}}. However, this method is wrong. More specifically, the following line:  {code} creds, err = credentials.NewClientTLSFromFile(viper.GetString("peer.tls.cert.file"), sn) {code}  The method being called ({{NewClientTLSFromFile}}) is from  gprc-go|https://github.com/grpc/grpc-go/blob/master/credentials/credentials.go#L205 . The first parameter to this method is a PEM file containing Root CAs that are trusted. If you look at the source for this (https://github.com/grpc/grpc-go/blob/master/credentials/credentials.go#L214), it creates a {{NewCertPool}} and adds the certs from the provided PEM file. These certs are the Root CAs that should be trusted when the connection is being established.  However, the cert file being given as a parameter in {{fabric/core/comm/connection.go#InitTLSForPeer()}} is the cert file of Peer A, not the Root CA cert!  Instead of {{"peer.tls.cert.file"}}, it should be {{"peer.tls.rootcert.file"}}. This would mean that the rootcert, which has signed Peer A cert and Peer B cert, is the added to the NewCertPool and the TLS connection can be established.   In order for P2P TLS to work at the moment in v0.6 and v1.0, all peers must be using the same self-signed certificate, which is wrong. The above fix will only resolve the issue in v1.0 because {{peer.tls.rootcert.file}} is already defined in core.yaml. However, in v0.6 there is no {{peer.tls.rootcert.file}}.  ></description> </Issue>
