<Action id="71941" issue="47029" author="yacovm" type="comment" created="2021-07-17 07:34:44.0" updateauthor="yacovm" updated="2021-07-17 07:42:09.0"> <body><! CDATA I think that ideally, whenever there is a config transaction that is consented upon, it would have made all other pending transactions after it, be re-validated in the leader.   This is  what we do in our BFT library|https://github.com/SmartBFT-Go/consensus/blob/leader_rotation/internal/bft/controller.go#L644-L657 , but in Raft this would need to be done inside the chain.  ></body> </Action>
<Action id="71942" issue="47029" author="guoger" type="comment" body=" ~yacovm  thanks for taking a look at this! I&apos;m not familiar enough with the bft lib, but it seems you are re-verifying transactions in the request pool (pending) upon sequence change. My question is, how do you verify in-flight transactions (those already picked from pool, cut into block and going through consensus)? some explanation or pointer to code would be appreciated" created="2021-07-18 11:13:30.0" updateauthor="guoger" updated="2021-07-18 11:13:30.0"/>
<Action id="71943" issue="47029" author="yacovm" type="comment" created="2021-07-18 12:08:07.0" updateauthor="yacovm" updated="2021-07-18 12:08:07.0"> <body><! CDATA In our library we don't have a pipeline, so at every point in time there is but a single block being consented upon.  In case of a pipeline like in Raft, the right thing to do for the leader, when cutting a config block, would be to wait until it is committed, and only afterwards cut the remaining blocks, and never send them to the Raft FSM until the config block before them has committed.   ></body> </Action>
<Action id="71949" issue="47029" author="guoger" type="comment" created="2021-07-22 08:06:55.0" updateauthor="guoger" updated="2021-07-22 08:06:55.0"> <body><! CDATA bq. the right thing to do for the leader, when cutting a config block, would be to wait until it is committed, and only afterwards cut the remaining blocks, and never send them to the Raft FSM until the config block before them has committed.   as i looked into code again, it already does what you described above. Although, it could not detect double-creation for two reasons: - channel creation tx does *not* advance config seq, therefore revalidation is skipped - revalidation via system channel's {{ProcessConfigMsg}} does *not* hold an instance of {{Registrar}}, and cannot perform this type of check  i could not think of any solution without significant refactoring though...  ~yacovm   ></body> </Action>
<Action id="71950" issue="47029" author="yacovm" type="comment" body="But I think we can just forcefully re-validate all transactions in the system channel only for the system channel, no?" created="2021-07-22 08:17:17.0" updateauthor="yacovm" updated="2021-07-22 08:17:17.0"/>
<Action id="71951" issue="47029" author="guoger" type="comment" created="2021-07-22 09:27:36.0" updateauthor="guoger" updated="2021-07-22 09:27:36.0"> <body><! CDATA that would solve problem 1, but we still have problem 2.  IIUC, we need to expose registrar to system channel, so it can check whether channel already exists  ></body> </Action>
<Action id="72074" issue="47029" author="denyeart" type="comment" body=" ~guoger  Do you think  https://github.com/hyperledger/fabric/pull/2934  fully resolves this?" created="2021-09-23 20:47:49.0" updateauthor="denyeart" updated="2021-09-23 20:47:49.0"/>
<Action id="72075" issue="47029" author="yacovm" type="comment" body="The bug fix you pointed may solve the symptom Jay described but it essentially makes the system channel have two channel creation transactions for the same channel. This might bite you in other code paths such as onboarding.... worth to check to see what happens" created="2021-09-24 08:52:33.0" updateauthor="yacovm" updated="2021-09-24 08:52:33.0"/>
