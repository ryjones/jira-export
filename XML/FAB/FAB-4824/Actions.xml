<Action id="26503" issue="18136" author="yacovm" type="comment" created="2017-06-16 10:28:58.0" updateauthor="yacovm" updated="2017-06-16 10:28:58.0"> <body><! CDATA {quote}we could leverage the TLS certificate of the peer that the client receives during the TLS handshake to bind the request to the intended recipient. {quote}  This sounds to me like a good idea. We may (or may not, depends on implementation) need to change the signed event message but I think that's not that bad.   ></body> </Action>
<Action id="26608" issue="18136" author="binhn" type="comment" created="2017-06-16 18:54:56.0" updateauthor="binhn" updated="2017-06-19 17:00:25.0"> <body><! CDATA  ~elli-androulaki , so basically we try to prevent a malicious peer from taking a SignedEvent from a client and registering for events.  We have 2 tasks: # Peer: check signedEvent = event payload + hash(peer tls cert) # SDK: sign(event payload + hash(peer tls cert))   ~jimthematrix  SDK side to expand the signature to include the hash   ~troyronda    ~yeasy   ></body> </Action>
<Action id="26776" issue="18136" author="mastersingh24" type="comment" created="2017-06-19 17:21:47.0" updateauthor="mastersingh24" updated="2017-06-19 17:21:47.0"> <body><! CDATA While I agree that Attack 3 is a *bit* of an exposure (I say this because in order to actually capture the request would at least take some forethought on the part of Trudy's organization), overall the current design of Fabric assumes trust within your own organization.  We also have some future work to do to revamp the event infrastructure in the next release, so I personally do not think we need to make any changes at this point  ></body> </Action>
<Action id="26815" issue="18136" author="baohua" type="comment" created="2017-06-20 04:13:08.0" updateauthor="baohua" updated="2017-06-20 04:13:25.0"> <body><! CDATA 1) For step 1: Need to discuss an appropriate timeout value. There's risk if set the valid timeout too long.  Beside binding the receipt id to the request, maybe it's also helpful to bind the sender id.  Consider a scenario: Alice sends valid request to Bob, while Charlie steals that request, and use it to connect to Bob.  2) Another question is that are we forced to enable TLS from sdk side?  3) I also agree with gari, this can be considered as post v1.0 design.  ></body> </Action>
<Action id="29486" issue="18136" author="elli-androulaki" type="comment" body="Hi, would now be a good time to resume with this ? :)" created="2017-08-07 10:47:00.0" updateauthor="elli-androulaki" updated="2017-08-07 10:47:00.0"/>
<Action id="29487" issue="18136" author="yacovm" type="comment" created="2017-08-07 11:01:22.0" updateauthor="yacovm" updated="2017-08-07 11:01:22.0"> <body><! CDATA Since  ~wlahti  is already defining a new event type - ( FAB-5568 )  I think now is actually the perfect time to extend the  SignedEvent|https://github.com/hyperledger/fabric/blob/release/protos/peer/events.proto#L78-L83  to have an additional field which would be a binding. With this way we can have backwards compatibility with clients that don't populate the binding field, and only apply the logic if the binding field exists.   ></body> </Action>
<Action id="29552" issue="18136" author="rickr" type="comment" body="This is targeted for v1.1  it looks like the suggestion is to incorporate this into  FAB-5568  but that has no target for v1.1.  Trying to find out what impact to the JDKs here for v1.1  ~muralisr   ~jimthematrix   When if at all CR for the work will be ready for the SDKs" created="2017-08-08 15:11:23.0" updateauthor="rickr" updated="2017-08-08 15:11:23.0"/>
<Action id="29594" issue="18136" author="elli-androulaki" type="comment" body="Ok, will bring this up to our scrum then. Thanks  ~yacovm ,  ~rickr !" created="2017-08-09 12:58:26.0" updateauthor="elli-androulaki" updated="2017-08-09 12:58:26.0"/>
<Action id="30441" issue="18136" author="elli-androulaki" type="comment" created="2017-09-01 11:28:04.0" updateauthor="elli-androulaki" updated="2017-09-01 11:29:44.0"> <body><! CDATA Here there is a small backward compatibility issue with 1.0 in the following sense:   - A client would always be motivated to include the recipient into its registration request; hence:     * a client who includes the recipient into the request runs 1.1     * a  client who does not include the recipient into the request runs 1.0   - A peer who runs v1.1 would be able to parse both even registration requests: the requests that originate from a client with v1.0 would simply have empty recipient field   - A peer who runs 1.0 and receives a request from a client running 1.1 would reject the event registration request as invalid. Would this be considered a backward compatibility issue? If we assume the client has the information of which peer runs which version we can go around this, but not sure this is a valid assumption?   ~yacovm ,  ~rickr ,  ~harrisob@us.ibm.com ,  ~wlahti ,  ~angelo.decaro ,  ~mastersingh24 , what do you think?   ></body> </Action>
<Action id="30446" issue="18136" author="yacovm" type="comment" created="2017-09-01 13:20:21.0" updateauthor="yacovm" updated="2017-09-01 13:20:21.0"> <body><! CDATA {quote}A peer who runs 1.0 and receives a request from a client running 1.1 would reject the event registration request as invalid{quote}  why? If the events are as following: {code} // SignedEvent is used for any communication between consumer and producer message SignedEvent { // Signature over the event bytes bytes signature = 1; // Marshal of Event object bytes eventBytes = 2; }  message Event {  oneof Event { //Register consumer sent event Register register = 1;  //producer events common.Block block = 2; ChaincodeEvent chaincode_event = 3; Rejection rejection = 4;  //Unregister consumer sent events Unregister unregister = 5; } // Creator of the event, specified as a certificate chain bytes creator = 6; bytes TLS_cert_of_peer = 7; } {code} In the case of v1.1 client and v1.0 peer, the eventBytes are unmarshaled according to the proto schema of v1.0 and the proto parser would just skip parsing the last field since it doesn't have it in its schema (the schema of v1.0 should be the schema of v1.1 modulo the 7th field). This, btw - can be easily verified with a code example.  ></body> </Action>
<Action id="30529" issue="18136" author="rickr" type="comment" created="2017-09-05 20:33:08.0" updateauthor="rickr" updated="2017-09-05 20:33:08.0"> <body><! CDATA I'm not sure if obtaining the *exact certificate bytes* from the server is possible with Java. I've asked on the grpc forum.  In general, I don't think that this is a good assumption that all language implementations would have this capability.    https://groups.google.com/forum/#!topic/grpc-io/LoB4mflwy9k    ~wlahti   ~jimthematrix   ></body> </Action>
<Action id="30561" issue="18136" author="rickr" type="comment" body="Don&apos;t think this is *reliably* possible with Java SDK." created="2017-09-06 13:19:10.0" updateauthor="rickr" updated="2017-09-06 13:19:10.0"/>
<Action id="32803" issue="18136" author="rickr" type="comment" body="Where are we with the ETA of this and what the SDKs specifically need to do for it ?" created="2017-10-19 15:46:53.0" updateauthor="rickr" updated="2017-10-19 15:46:53.0"/>
<Action id="32805" issue="18136" author="wlahti" type="comment" body="FAB-6075 is almost ready to be merged. After that, a timestamp should be added to the registration message the SDKs send to the eventhub. " created="2017-10-19 15:57:22.0" updateauthor="wlahti" updated="2017-10-19 15:57:22.0"/>
<Action id="32959" issue="18136" author="yacovm" type="comment" created="2017-10-21 10:14:06.0" updateauthor="yacovm" updated="2017-10-21 10:15:51.0"> <body><! CDATA {quote}As a second step we need to bind the event registration request to the intended recipient. The challenge here is twofold. On one side, the client is not possible to be authenticated at the tls layer (nodejs limitations) {quote}  I tried and I think it works, at least with the grpc version in the node_modules that is in the balance_transfer sample.   I just did the following crude change: {code} var d = '/home/yacovm/fabricDeployment/crypto-config/peerOrganizations/hrl.ibm.il/peers/vm2.hrl.ibm.il/tls/'; var cert = fs.readFileSync(d + 'server.crt'); var key = fs.readFileSync(d + 'server.key'); 			this.creds = grpc.credentials.createSsl(new Buffer(pem), key, cert); {code} in *Remote.js* and then added an *else* to the secureServer in the peer: {code} grpcServer.tlsConfig.ClientAuth = tls.RequestClientCert {code}  Also the java grpc implementation,  according to the documentation|https://github.com/grpc/grpc-java/blob/master/SECURITY.md#mutual-tls  - supports it.  ></body> </Action>
<Action id="32960" issue="18136" author="yacovm" type="comment" created="2017-10-21 10:33:47.0" updateauthor="yacovm" updated="2017-10-21 10:33:47.0"> <body><! CDATA So, what I'm trying to say is: Instead of obtaining the server cert from the gRPC connection what we really need to do is have the client either have a preconfigured TLS certificate, or if lacking one - generate a self signed one itself, and then include the cert's hash in the request sent to the peer.  The peer, in turn would extract the TLS certificate from the gRPC context (there is sample code in gossip/comm/crypto.go and in core/chaincode/accesscontrol/mapper), hash it, and compare the hash to the one in the request. * If it's not the same, it means that request wasn't signed by the client on the other side of the connection, but instead was forwarded. * If it's the same, it means the client on the other side of the connection has: ** The TLS cert's private key ** A signature of the signing identity matching the one in the creator field of the request over the TLS certificate.    ></body> </Action>
<Action id="33290" issue="18136" author="angelo.decaro" type="comment" body="I agree with  ~yacovm , let&apos;s have that." created="2017-10-27 11:29:43.0" updateauthor="angelo.decaro" updated="2017-10-27 11:29:43.0"/>
<Action id="35419" issue="18136" author="denyeart" type="comment" body=" ~elli-androulaki  Could you (or somebody else) summarize the work required and propose owner(s)?" created="2017-11-27 02:10:38.0" updateauthor="denyeart" updated="2017-11-27 02:10:38.0"/>
<Action id="35530" issue="18136" author="harrisob@us.ibm.com" type="comment" body="Removed the SDK tag as the SDK&apos;s are not required to implement this change" created="2017-11-27 21:00:57.0" updateauthor="harrisob@us.ibm.com" updated="2017-11-27 21:00:57.0"/>
<Action id="35534" issue="18136" author="yacovm" type="comment" created="2017-11-27 21:12:20.0" updateauthor="yacovm" updated="2017-11-27 21:12:20.0"> <body><! CDATA {quote}Removed the SDK tag as the SDK's are not required to implement this change {quote} How so? Can you elaborate please?  ></body> </Action>
<Action id="35587" issue="18136" author="harrisob@us.ibm.com" type="comment" created="2017-11-28 18:30:47.0" updateauthor="harrisob@us.ibm.com" updated="2017-11-28 18:30:47.0"> <body><! CDATA # the SDK client will not be able to connect with a 1.0 fabric # there will be a new secure event service # timestamp is only a partial fix  ></body> </Action>
<Action id="35613" issue="18136" author="elli-androulaki" type="comment" created="2017-11-29 07:58:47.0" updateauthor="elli-androulaki" updated="2017-11-29 09:07:45.0"> <body><! CDATA Hi,  Regarding (1): Why not? We could have a version on the peer side to detect if the client he is talking to is a 1.0 or a 1.1 one? So when the clientsdk is updated, it can leverage this feature.   Regarding (2): I am not familiar with the architecture of the new event infrastructure. Is the attacks described above already covered? If not, I think we need to adopt a similar mechanism to address them.   Regarding (3): Indeed, it is a first step towards it. Notice that including a timestamp in an event request is not something that can hurt the system in any case. IN addition to this, and moving towards the full fix  ~yacovm  has already submitted this  CR|https://gerrit.hyperledger.org/r/#/c/15137/  that was merged.   ></body> </Action>
<Action id="35616" issue="18136" author="yacovm" type="comment" created="2017-11-29 09:00:46.0" updateauthor="yacovm" updated="2017-11-29 09:00:46.0"> <body><! CDATA {quote}# the SDK client will not be able to connect with a 1.0 fabric # there will be a new secure event service # timestamp is only a partial fix  {quote}  # We're discussing v1.1, not v1.0. Unless we do something in the client side, this problem will persist in v1.1  # To my understanding, unless the client-side cooperates - it will not be secure, as long as the only way we identify the client stays the same as it is now. # Right, and I would say we should leverage mutual TLS when possible (if the client has a TLS certificate) and when not - fallback to timestamp, so we should implement both.    ~jimthematrix    ~mastersingh24  your thoughts?  ></body> </Action>
<Action id="35678" issue="18136" author="jeffgarratt" type="comment" created="2017-11-30 16:38:46.0" updateauthor="jeffgarratt" updated="2017-11-30 16:38:46.0"> <body><! CDATA Just spoke with  ~elli-androulaki  and  ~yacovm  and  ~wlahti  and  ~harrisob@us.ibm.com   about this..     Will create items to address the plan immediately.  ></body> </Action>
<Action id="35789" issue="18136" author="dhuseby" type="comment" created="2017-12-04 17:51:03.0" updateauthor="dhuseby" updated="2017-12-04 17:51:03.0"> <body><! CDATA Hi Everybody,  This is clearly a security issue and the bug should have been flagged as a security issue so that we can have a private conversation about it.  Hopefully you are all watchers and can see this.  ></body> </Action>
<Action id="37201" issue="18136" author="ryjones" type="comment" body="Watchers that are not in the security LDAP group should now be able to see this issue." created="2017-12-15 01:08:38.0" updateauthor="ryjones" updated="2017-12-15 01:08:38.0"/>
<Action id="37909" issue="18136" author="dhuseby" type="comment" body=" ~wlahti  any updates on this bug?" created="2018-01-02 22:39:05.0" updateauthor="dhuseby" updated="2018-01-02 22:39:05.0"/>
<Action id="37912" issue="18136" author="dhuseby" type="comment" body=" ~rickr  this bug looks to be a duplicate of FAB-6030.  Is that is true, I will close out FAB-6030 and we can focus on this bug." created="2018-01-02 22:50:39.0" updateauthor="dhuseby" updated="2018-01-02 22:50:39.0"/>
<Action id="38294" issue="18136" author="wlahti" type="comment" body="The server-side fixes have been merged. We now need the SDKs to make sure they&apos;re setting the timestamp and TLSCertHash in each event &quot;registration&quot; message they&apos;re sending. " created="2018-01-08 16:07:48.0" updateauthor="wlahti" updated="2018-01-08 16:07:48.0"/>
<Action id="38300" issue="18136" author="yacovm" type="comment" body="Just to add to what Will said - this needs to happen only when mutual TLS is activated + this also needs to be done for peer and orderer Deliver clients (the peer deliver client side (when the peer pulls blocks from the orderer) is already ready)" created="2018-01-08 16:31:51.0" updateauthor="yacovm" updated="2018-01-08 16:32:49.0"/>
<Action id="39454" issue="18136" author="rickr" type="comment" created="2018-01-31 19:35:47.0" updateauthor="rickr" updated="2018-01-31 19:36:54.0"> <body><! CDATA The above does not appear to match what was pasted into java sdk JIRA {quote}mutual TLS: the TLSCertHash must be set in the envelope's channel header. The TLS certificate hash to set is the SHA256 hash of the DER representation of the client's TLS certificate {quote}  ></body> </Action>
<Action id="39457" issue="18136" author="rickr" type="comment" created="2018-01-31 19:57:18.0" updateauthor="rickr" updated="2018-01-31 19:57:18.0"> <body><! CDATA I don't think all SDK's can get the Peer's tls certifiate as the exact bytes sent on the wire.  Best I could find for the JSDK was a certificate object.  Which I don't think will guarrentee it would be serialized to exact bytes on the wire.   For TLS client certificate I was told that TLS on the server side will not enforce that certificate matches the host or its IP.  Sort of seems reasonable given the more dynamic nature of clients.   But if the certificate is not tied and guaranteed coming from the client source what's to prevent a rovked peer from using a previous collected clients tls cert . to connect to any other peer ?  ></body> </Action>
<Action id="39460" issue="18136" author="wlahti" type="comment" created="2018-01-31 20:13:53.0" updateauthor="wlahti" updated="2018-01-31 20:24:06.0"> <body><! CDATA This JIRA needs to be updated to incorporate the subsequent discussions and decisions made in the linked JIRA items for the peer-side handling of this vulnerability.  ~elli-androulaki  Do you think you can update this item when you have a chance?  To sum it up briefly until the updates have been made, the linked JIRA items for the SDKs are accurate. The SDKs should always set the timestamp and, when mutual TLS is enabled, the TLSCertHash of the client's TLS certificate in the messages sent to register for the eventhub and deliver services.   ></body> </Action>
<Action id="39746" issue="18136" author="harrisob@us.ibm.com" type="comment" body="Removed the NodeSDK component as this causes double counting of issue when there is a child issue for NodeSDK" created="2018-02-06 22:01:16.0" updateauthor="harrisob@us.ibm.com" updated="2018-02-06 22:01:16.0"/>
<Action id="40793" issue="18136" author="denyeart" type="comment" body=" ~smithbk  I believe you were working on the last piece of this.  Could you provide an update?" created="2018-02-26 12:07:55.0" updateauthor="denyeart" updated="2018-02-26 12:07:55.0"/>
<Action id="40974" issue="18136" author="denyeart" type="comment" body="Resolved by FAB-8563. I will close, but please re-open if anything else is needed." created="2018-02-27 22:31:49.0" updateauthor="denyeart" updated="2018-02-27 22:33:16.0"/>
