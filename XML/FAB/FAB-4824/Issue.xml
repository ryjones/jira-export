<Issue id="18136" key="FAB-4824" number="4824" project="10002" reporter="elli-androulaki" assignee="wlahti" creator="elli-androulaki" type="10004" summary="SECURITY Event registration request should not be &quot;relayable&quot;" priority="2" resolution="10000" status="6" created="2017-06-16 09:00:42.0" updated="2018-07-20 14:13:30.0" resolutiondate="2018-02-27 22:33:24.0" votes="0" watches="15" workflowId="39172"> <description><! CDATA This issue was reported by  ~yacovm , and respective attacks / solutions discussed with  ~angelo.decaro , and  ~jimthematrix .     This bug has to do with client impersonation attack for event registration that a malicious peer can spawn to escalate its access rights. The attacker in this case would be a peer who had once access to a channel, and after a while its organisation revoked its certificate and should thus be restricted access to the organisation's resources.     *Background/source of the problem*:  Essentially event messages that (among others things) serve event registration, and the required requestor authentication/authorisation assessment is based on these messages.   Event messages contain requestor signature, *but* the message signed is not bound to the underlying connection in which the message was exchanged (e.g., communication parties), and can thus be easily relay-able. That is the recipient of such messages can easily initiate another (TLS) connection with another node (of the same org), and request registration to events using the request once received by a client. Implicitly, that peer would be allowed to _impersonate the message creator._  In particular,  events have the following form:    {code:java} // SignedEvent is used for any communication between consumer and producer message SignedEvent { // Signature over the event bytes bytes signature = 1; // Marshal of Event object bytes eventBytes = 2; }  //Event is used by // - consumers (adapters) to send Register // - producer to advertise supported types and events message Event { //TODO need timestamp  oneof Event { //Register consumer sent event Register register = 1;  //producer events common.Block block = 2; ChaincodeEvent chaincode_event = 3; Rejection rejection = 4;  //Unregister consumer sent events Unregister unregister = 5; } // Creator of the event, specified as a certificate chain bytes creator = 6; } {code}    *Potential attacks*:     *Attack 1*: Alice (client) and Bob( peer), and Charlie (peer) are members of the same org, Org.  # Alice (client) connects to Bob(peer) requesting registration to events.  # Bob accepts, and stores Alice's registration request, say AliceReq # Org revokes Bob # Bob contacts Charlie and requests to register for events using AliceReq     *Attack 2*: Alice (client) and Bob( peer), and Charlie (peer) are members of the same org, Org.  # Alice (client) connects to Bob(peer) requesting registration to events, with a request AliceReq # Bob accepts # Bob uses AliceReq to connect to Charlie (and potentially to other peers of the same org). Notice that Bob at this point has access to the channels himself, but with this act of his, he is able to receive events of the same org as "Alice". # Org revokes Bob # Charlie stops sending other types of messages to Bob, but as for the event connections Bob was also registered under Alice's name, Charlie will keep sending messages to Bob.      *Attack 3*: Alice (client) and Bob( peer), and Charlie (peer) are members of the same org, Org. Trudy (peer) is a member of another org. # Alice (client) wants to register to events and sends a registration request AliceReq by mistake to Trudy.  # Trudy will reject the request as Alice comes from different org, but can now use AliceReq to register under Alice's name and receive events for Org. # Trudy connects to Bob using AliceReq (and potentially to other peers of the same org). # Bob, not being able to recognise the relay, will accept the request and open a connection with Trudy (thinking that it is talking to Alice). # Trudy will be receiving events of Org.       *Solutions:*  As a first step we can add a timestamp inside the signed message in event registration requests (as already marked in the code) that is checked at the recipient end. Messages that are deemed by the peer as "old" will be rejected. This would prevent attacks of type Attack1. This would require changes to the following parts:  - change to the Event proto message to include a timestamp  - enhancement to clientsdk to fill in the timestamp field of Event  - enhancement of peer to check the timestamp field (with version dependency)  - enhancement of the peer setup configuration with a time-window, assuming the peer is to be considering requests within time-window < |peer-local-time - event-timestamp|  As a second step we need to bind the event registration request to the intended recipient. The challenge here is twofold. On one side, the client is not possible to be authenticated at the tls layer (nodejs limitations), and on the other hand the client who sends the event registration requests does not know in advance the enrollment/tls certificate of the party it will end up connecting to. However, we could leverage the TLS certificate of the peer that the client receives during the TLS handshake to bind the request to the intended recipient.  The flow would be the following. The client *does* know the certificate of the root CA of TLS certificates of its organisation, and authenticates the peer it connects to using that root CA cert, and the TLS certificate received by the peer side during TLS hand-shake. After the TLS handshake is completed successfully, the client retrieves the tls certificate of the peer, it hashes it and signs current event registration payload concatenated with the hash of the tls peer certificate.  The peer side, that receives the event registration request will need to check that the signature in it matches the event request payload and the hash of the peer's tls cert. The peer will reject the request if this is not the case.   Note: Ultimately, when long enough tls-unique TLS connection identifiers are supported, the tls-unique of the client-peer connection can be used to bind the event request to the underlying connection.  With this second step Attacks 2 and 3 will not be possible to be spawned.     ></description> </Issue>
