<Issue id="17969" key="FAB-4687" number="4687" project="10002" reporter="ratnakar" creator="ratnakar" type="10004" summary="Orderer bootstrap is incomplete when delayed after channel created; failure to execute invoke transaction" priority="4" resolution="10000" status="6" created="2017-06-14 20:05:23.0" updated="2018-07-20 14:13:22.0" resolutiondate="2017-06-15 02:32:54.0" votes="0" watches="3" workflowId="39048" security="10001"> <description><! CDATA * Create _genesis_block_ and channel _configuration transaction_  Three orderers included in configtx.yaml under OrdererType kafka (enclosed  ^configtx.yaml  ) {code:java} OrdererType: kafka Addresses: - orderer0:7050 - orderer1:7050 - orderer2:7050 {code} * Launch the network with following configuration (enclosed  ^docker-compose.yaml  &  ^base.yaml files)  - 4 kafka brokers and 3 zookeepers - Bootstrap 2 Orderers  _orderer0_ and _orderer1_ (*make sure orderer2 is not started yet*) - & 4 peers (Two organizations contains 2 peers each)  * wait for 60 seconds to allow the clusters (KB and ZK) to bootstrap and elect leaders etc., remember *orderer 2* is not started  * Create a channel '*mychannel*' and join all the peers to the channel 'mychannel'  * Install *example02 chaincode* on the _anchor peers_ of each organization  * Now, start the container for _orderer 2_. {panel} docker-compose -f docker-compose.yaml up -d orderer2.example.com {panel}  This will bootstrap the orderer2, wait for 60 seconds while this orderer sync with other orderers  * Now instantiate a _*example02 chaincode*_ (with initialized values a=100, b=200 ) on anchor peer of Org2 on the channel '*_mychannel_*' by connecting to the orderer0  * Query chaincode for value "a" on _anchor peer_ of _Org1_ and validate the query result. (result should be 100)  * Send a transaction (transfer 10 from a to b) to the _anchor peer_ of _Org1_ on the channel '_*mychannel*_' by connecting to the orderer _orderer2_  During this step transaction fails with the below error message  _*Error: Error getting broadcast client: Error connecting to orderer2.example.com:7050 due to tls: first record does not look like a TLS handshake*_  After chaincode Instantiate orderer2 logs indicates that it syncs with other orderers (_orderer0_ and _orderer1_), However while sending a transaction fails with the following error  _*transport: http2Server.HandleStreams received bogus greeting from client: "\x16\x03\x01\x00\xa9\x01\x00\x00\xa5\x03\x03\x8foD#\x9e\x86\xd1%#\x14W\x18*_  Gist of _*Orderer2*_ logs    {code:java} 2017-06-14 16:58:33.713 UTC  fsblkstorage  updateCheckpoint -> DEBU 6ea Broadcasting about update checkpointInfo: latestFileChunkSuffixNum= 0 , latestFileChunksize= 38727 , isChainEmpty= false , lastBlockNumber= 3  2017-06-14 16:58:33.713 UTC  orderer/multichain  WriteBlock -> DEBU 6eb  channel: mychannel  Wrote block 3 2017-06-14 16:58:33.713 UTC  orderer/kafka  processTimeToCut -> DEBU 6ec  channel: mychannel  Proper time-to-cut received, just cut block 3 2017-06-14 16:58:33.713 UTC  orderer/kafka  processMessagesToBlocks -> DEBU 6ed  channel: mychannel  Successfully unmarshalled consumed message, offset is 7. Inspecting type... 2017-06-14 16:58:33.713 UTC  orderer/kafka  processTimeToCut -> DEBU 6ee  channel: mychannel  It's a time-to-cut message for block 3 2017-06-14 16:58:33.713 UTC  orderer/kafka  processTimeToCut -> DEBU 6ef  channel:  mychannel  Ignoring stale time-to-cut-message for block 3 2017-06-14 16:58:33.713 UTC  orderer/kafka  processMessagesToBlocks -> DEBU 6f0  channel: mychannel  Successfully unmarshalled consumed message, offset is 8. Inspecting type... 2017-06-14 16:58:33.713 UTC  orderer/kafka  processTimeToCut -> DEBU 6f1  channel: mychannel  It's a time-to-cut message for block 3 2017-06-14 16:58:33.713 UTC  orderer/kafka  processTimeToCut -> DEBU 6f2  channel: mychannel  Ignoring stale time-to-cut-message for block 3 2017-06-14 16:58:44.954 UTC  grpc  Printf -> DEBU 6f3 transport: http2Server.HandleStreams received bogus greeting from client: "\x16\x03\x01\x00\xa9\x01\x00\x00\xa5\x03\x03\x8foD#\x9e\x86\xd1%#\x14W\x18{code}    NOTE: When all the orderers (orderer0, orderer1 & orderer2 ) are bootstrapped together, do not  see the above issue. and transactions are going through Enclosed both successful (when all orderers are bootstraped together) and failure logs  ></description> </Issue>
