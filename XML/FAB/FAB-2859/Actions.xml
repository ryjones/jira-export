<Action id="21616" issue="15432" author="yacovm" type="comment" created="2017-03-23 23:11:45.0" updateauthor="yacovm" updated="2017-03-24 15:12:31.0"> <body><! CDATA 1) I guess the * <user provided CC name>.<user provided version>* is part of a file path, so we should ensure the strings don't have any special character sequences that could cause problems, like: *.* *..*, etc.  2) {quote}Step 3. LCCC checks the timestamp in the proposal and rejects if outdated.{quote} Maybe we can do this in step 2? Checking the timestamp is "cheaper" than validating a signature, no?  3) {quote}Step 7. LCCCchain, checks if Creator is within OwnCC, and rejects if this is not the case.{quote} This is the pivot of the whole deal, isn't it? To bind between the owner of the chaincode, passed at installation - to the instantiation phase? I think it's a good idea to be able to specify MSP Principals here, because it can make the whole process be much more flexible. In example- an admin installed a chaincode on all peers in the organization, and then it can specify that anyone in orgA, orgB and orgC can instantiate the chaincode on the peer of its org, but at the same time- it can do something restrictive- that only admins of orgA can do that, etc. etc. 4) {quote}Step 8. Endorser produces from LCCCchain the simulation result of its execution (essentially, DBcc_chain enhanced with an entry for the chaincode to be freshly instantiated){quote} That's the result of invoking the init function, right? {quote}Step 12. Committing peers receive TXcc_chain as part of the channel with identifier “chainID”. They then run LCCCchain_vscc, where a big part of LCCCchain “instantiation” simulation is to be re-done. Essentially, LCCCchain_vscc would need to repeat steps 3-7, after which it would need to evaluate the obtained simulation result. If the simulation result the LCCCchain_vscc is the same as the one included in the transaction, and there is no version conflict, the LCCCchain_vscc validates the transaction as valid, and applies LCCCchain state changes to ledger.{quote} I don't understand why the validating phase needs to do a simulation. This (simulation at validation) isn't done in normal transaction validations- we just check version numbers of read sets from what I know. What is the purpose of running a simulation again? Isn't it possible to attack peers in such a way? (Or, maybe I mis-understood and you meant something else?) 5) {quote}2. list the instantiated chaincodes on a channel (“list cc (-installed) --chain channelid”) However there is a chance that this reveals to the querier implicitly which channels that peer has joined, cause it will only list instntiated chaincodes in these chanels. For this reason, it may make sense to allow that also this query is allowed for the peer’s MSP admin.{quote} What if we add a more fine-grained option: *list cc (-installed) --chain channelid --ccName chaincodename* ?  What is the use case behind querying the list of chaincodes on a specific channel of a peer anyway? In my opinion, a user has a list of chaincodes he/she wants to work with, and a specific channel, and it wants to know which peers can he/she use, so knowing all the chaincode names is not too useful to the user.  ></body> </Action>
<Action id="21618" issue="15432" author="ashutosh_kumar" type="comment" created="2017-03-24 01:44:59.0" updateauthor="ashutosh_kumar" updated="2017-03-24 01:44:59.0"> <body><! CDATA I'll ask questions in pieces: On Chaincode installation  1) What is the registration process , meaning , what is the process to map Certificate , say , owner of certificate to owner role , or admin cert to admin role.  To me there exists two possibilities :  1) Chaincode security model provides registration capability or 2) We can make an assumption that the Fabric is not in the business in Role Management/Registration. It lies with enterprise who owns fabric deployment.  Please let me know your thoughts.  ></body> </Action>
<Action id="21619" issue="15432" author="ashutosh_kumar" type="comment" created="2017-03-24 01:59:47.0" updateauthor="ashutosh_kumar" updated="2017-03-24 02:01:04.0"> <body><! CDATA On Step 2 of Chaincode installation :  1) Is owner , not same as creator or creator can be one of the Owners ? If that is the case , should not we make additional check that the creator is one of the owners ?  2) How are you going to do Time Stamp validation ? Are you going to take care of time skewness ? Are you going to validate against NTP ? Are you going to have some sliding window ?     ></body> </Action>
<Action id="21636" issue="15432" author="muralisr" type="comment" created="2017-03-25 00:51:37.0" updateauthor="muralisr" updated="2017-03-25 00:52:09.0"> <body><! CDATA  ~yacovm  ..response below  1) We check for special chars in name. The plan is to do the same for version as well.  2) Validating the creator is being done as part of any proposal.. we just continue to do that for install too. Actually I'm not sure we need the "outdatedness" check infact.   ~ellaki ,  why we would we need this ?  3) leave this to  ~ellaki   4) _ I don't understand why the validating phase needs to do a simulation_ Agreed... I meant to clean it up. The "simulation" part shouldn't read as though we are going to run the chaincode again but do the usual ledger version checks against the simulation results. Should look something like this.  {code:java} Committing peers receive TXcc_chain as part of the channel with identifier “chainID”. They then run LCCCchain_vscc, where LCCCchain_vscc would need to repeat steps 3-7, after which it would need to evaluate the RW set. If the RWset validation still holds as current, validates the transaction as valid, and applies LCCCchain state changes to ledger. {code}   ></body> </Action>
<Action id="21637" issue="15432" author="muralisr" type="comment" created="2017-03-25 01:09:05.0" updateauthor="muralisr" updated="2017-03-25 01:09:05.0"> <body><! CDATA  ~ashutosh_kumar    _What is the registration process , meaning , what is the process to map Certificate , say , owner of certificate to owner role , or admin cert to admin role._  This is closely related to this comment  Step 5. LCCC retrieves the ChaincodeDeploymentSpec and Endorsement array. At this point, we need to decide what to do. *One option would be that the LCCC checks if any of the endorsements in the array of endorsements, correspond to its local MSP admin, and reject if this such a signature is not detected. An other alternative is that we do not do any signature verification there, as there is already a peer MSP admin signature on the proposal (see comment).* If we decide there is some signature check that needs to take place, then we should have the endorser rejecting the proposal if this check fails. Otherwise, it continues to next step.  The alternative to not do any signature verification would be basically same as your suggestion  _We can make an assumption that the Fabric is not in the business in Role Management/Registration. It lies with enterprise who owns fabric deployment._  Would you agree ?  ></body> </Action>
<Action id="21638" issue="15432" author="muralisr" type="comment" created="2017-03-25 01:11:46.0" updateauthor="muralisr" updated="2017-03-25 01:11:46.0"> <body><! CDATA  ~ashutosh_kumar    _should not we make additional check that the creator is one of the owners_  This is also related to previous comment...  Yes, we could (this was one of the questions in Step 5).  However it maybe better to keep who "owns" separate from who "administers" (installs).  ></body> </Action>
<Action id="21639" issue="15432" author="elli-androulaki" type="comment" created="2017-03-25 01:37:34.0" updateauthor="elli-androulaki" updated="2017-03-25 01:37:34.0"> <body><! CDATA Hi,  So,  ~yacovm ,  ~muralisr : Regarding (3), timestamp checking is our only way of doing replay attack detection of an elder version of a chaincode that is already instlled but has been upgdared, no? Can we tell this by the version itself if its a string?  Regarding (4), though we could add policies, my personal opinion is that for now we keep it simple and go for just a list of identities, at least till we ensure that orderers check that an msp identity / configuration is checked by the orderer at a channel's genesis time :) But not a strong opinion.  Regarding (5), right. But the rationale there is to avoid problematic behavior when an instantiator from OrgA can maliciously update the state of LCCC to erase chaincodes instantiated by other Orgs instantiators.    ~ashutosh_kumar  will come back to you later :)  ></body> </Action>
<Action id="21643" issue="15432" author="muralisr" type="comment" created="2017-03-25 15:39:01.0" updateauthor="muralisr" updated="2017-03-25 18:24:16.0"> <body><! CDATA  ~ellaki   _timestamp checking is our only way of doing replay attack detection of an elder version of a chaincode that is already instlled but has been upgdared, no? Can we tell this by the version itself if its a string?_  Install is implemented as a proposal. The same rules for replay attack detection for a normal proposal should apply for install as well - but you are right on one account ... we cannot check for duplicate TxID against a ledger (as install is not tied to a channel). However, we do check for uniqueness based on name and version. Till we have a fabric provided time, should we stay away from timestamp based checks ?   Note that instantiate does go through normal replay attack checks like all invokes.  ></body> </Action>
<Action id="21713" issue="15432" author="mastersingh24" type="comment" created="2017-03-29 12:17:24.0" updateauthor="mastersingh24" updated="2017-03-29 12:17:54.0"> <body><! CDATA  ~muralisr    ~ellaki   While I do have some potential issues with the implementation above, my main issue is that I don't see where we have actually enumerated the requirements / problems we are trying to solve.  While it's possible to infer them from reading the proposed implementation, we need to document the actual requirement(s) and agree on them before proceeding to implementation.  After reading all of the above and based on recollection of some conversations, it seems that there are two proposed requirements here:  1) better method for uniquely identifying chaincode and ensuring that the chaincode which is instantiated is actually the chaincode which was installed  2) provide a mechanism to restrict who has the ability to instantiate a given chaincode on a specified channel (although I don't think the channel is actually important - it's just a necessary part of the way things work)  Are these they requirements?  If so, then we also fail to mention that we need mechanism which do not make installing and instantiating monumental tasks for people who just want the basics - e.g. if you are a member of a channel you can instantiate chaincode on that channel  ></body> </Action>
<Action id="21714" issue="15432" author="mastersingh24" type="comment" body="also, its unclear to me where &quot;lifecycle instantiation&quot; policy comes from and it seems we have not covered how upgrades are handled based on the security mechanisms.  Is the assumption that the policy of the current version is enforced on upgrades?" created="2017-03-29 12:20:45.0" updateauthor="mastersingh24" updated="2017-03-29 12:20:45.0"/>
<Action id="21716" issue="15432" author="elli-androulaki" type="comment" created="2017-03-29 12:43:54.0" updateauthor="elli-androulaki" updated="2017-03-29 12:43:54.0"> <body><! CDATA  ~muralisr , well the fabric-provided time is crucial when it comes to chainfull operations that affect the state of the ledger somehow. For chainfless requests, e.g., join channel, or list channels, or install chaincode one could use the time to avoid answering queries to a old requests.   ~mastersingh24 , yes indeed these were not clearly mentioned in the writeup. Requirements are as you wrote it. For (2), ideally a chainocde can be instantiated to a channel, as long as the creator of the instantiation tx is withing chaincode owners/admins and among the channel's chaincode instantiators.  Chaincode instantiators was an additional policy that  ~jyellick  was to add in the genesis block of a channel (this is the lifecycle instantiation policy), sort of the channel admins, but for application operations. Originally we were thinking of using the config admins, but these ones would require > 1 signatures that existing tx proposal formats to not support...  For the latter/added requirements that you mentioned, I can only agree. But we could set defaults for the developers not to need to actually configure manually anything(?) Any alternative proposal would also be welcome of course!    ></body> </Action>
<Action id="21725" issue="15432" author="muralisr" type="comment" created="2017-03-29 15:16:59.0" updateauthor="muralisr" updated="2017-03-29 15:16:59.0"> <body><! CDATA  ~ellaki  In general, when we have a fabric provided time, I agree we can put it to good use.  My suggestion to not use timestamp was based on this comment  {noformat} Regarding (3), timestamp checking is our only way of doing replay attack detection of an elder version of a chaincode that is already instlled but has been upgdared, no? {noformat}  Install just places the code on the filesystem and will error out if the code is already there. Instantiate is the operation that affects the ledger and does replay attack protection based on TXID. As long as we don't have a fabric based time, I vote we don't introduce additional complexity for timestamp based checks for install (or perhaps I missing something ?)  ></body> </Action>
<Action id="21778" issue="15432" author="mastersingh24" type="comment" created="2017-04-01 13:06:47.0" updateauthor="mastersingh24" updated="2017-04-01 13:32:00.0"> <body><! CDATA  ~muralisr   ~ellaki   ~binhn   {quote}The package will have the following structure Envelope Payload Header ChannelHeader with type PACKAGE (other fields in header will be nulled out as the package needs to be deterministic) SignatureHeader nulled out as the package needs to be deterministic. Data ChaincodeDeploymentSpec (CDS) in bytes _*Array of Endorsement (basically “owners” of this package) where Endorsement is a predefined type (see proposal_response.proto)*_{quote}  I don't see the value in having an array of Endorsements as part of the package.  Install is an action against individual peers and as such of course the the overall transaction will be signed.  Maybe we need an additional signature that is part of the actual "package" to ensure that the package bytes on the filesystem match the bytes which were installed, but attaching a bunch of owner endorsements does not seem to add any value above actually including a list of owners (perhaps using MSP principals?)  Then when chaincode is instantiated, a peer would only "endorse" instantiate for a chaincode if the transactor was one of the "owners" (if that's the problem we are trying to solve here)  ></body> </Action>
<Action id="21781" issue="15432" author="binhn" type="comment" created="2017-04-01 15:35:55.0" updateauthor="binhn" updated="2017-04-01 15:35:55.0"> <body><! CDATA  ~mastersingh24  My thought on endorsements is that a chaincode, in some form, represents a contract between parties, who implement the contract and agree to the final form and sign it. The endorsements indicate the ownership and the attestation to the agreed contract. This also allows the installer to verify the authenticity of the contract prior to installing it on his peers. LCCC can also verify this during instantiation.   This mechanism is similar to signed apps (apple store) that would enable community to create marketplace to publish chaincodes. The users of the chaincodes can decide whom to trust.  ></body> </Action>
<Action id="21782" issue="15432" author="muralisr" type="comment" created="2017-04-01 17:23:34.0" updateauthor="muralisr" updated="2017-04-01 17:23:34.0"> <body><! CDATA  ~mastersingh24   ~binhn   Clarified certain points * the non malleability of package via signatures has some value (at least in terms of "auditing", non-repudiation etc) for the installation (as opposed to instantiation) * but we would need a policy in the package to complete to capture ownership (did all the people who should have signed off sign off ?) * that policy will also play a dual role at chaincode instantate time to verify the instantiator satifies the policy  Will look to add policy to the package.  ></body> </Action>
