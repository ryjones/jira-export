<Action id="60940" issue="33156" author="yoheiueda" type="comment" body="I upload my prototype code:  https://gerrit.hyperledger.org/r/c/fabric/+/31884 " created="2019-06-13 08:24:56.0" updateauthor="yoheiueda" updated="2019-06-13 08:24:56.0"/>
<Action id="60942" issue="33156" author="yoheiueda" type="comment" created="2019-06-13 08:30:17.0" updateauthor="yoheiueda" updated="2019-06-19 09:00:18.0"> <body><! CDATA  ~ChristopherFerris   ~bmos299   This is the JIRA issue about Optimistic Transaction Manager I talked with you previously.  I prepared a design doc, implemented a prototype, and conducted performance evaluation. We obtained 15*%* on average, and up to 48*%* TPS improvement.   https://docs.google.com/spreadsheets/d/1S7ppaHAXfksSWB1PaqcKjNxfxYCDIsQXnnh4qQmvHAs/edit?usp=sharing      ></body> </Action>
<Action id="61100" issue="33156" author="christopherferris" type="comment" created="2019-06-18 20:31:54.0" updateauthor="christopherferris" updated="2019-06-18 20:31:54.0"> <body><! CDATA  ~yoheiueda  can you share the tests and results somewhere? Thanks     ></body> </Action>
<Action id="61111" issue="33156" author="yoheiueda" type="comment" created="2019-06-19 07:24:50.0" updateauthor="yoheiueda" updated="2019-06-19 07:24:50.0"> <body><! CDATA  ~ChristopherFerris   Our testing scripts are available at  https://github.com/yoheiueda/ccperf   The used chaincode is this  https://github.com/yoheiueda/ccperf/blob/master/go/src/ccperf/ccperf.go      I uploaded performance numbers here.  https://docs.google.com/spreadsheets/d/1S7ppaHAXfksSWB1PaqcKjNxfxYCDIsQXnnh4qQmvHAs/edit?usp=sharing  ></body> </Action>
<Action id="61186" issue="33156" author="yoheiueda" type="comment" created="2019-06-22 07:41:40.0" updateauthor="yoheiueda" updated="2019-06-22 07:41:40.0"> <body><! CDATA I come up with the following idea after discussion. This approach don't need replays, and simplifies implementation.  I will update my prototype using this idea.  Solution without replays: * Record version=0 in read set for a GetState call that violates snapshot isolation * Do MVCC check at tx commit as usual  Example: # Suppose the block height is 1000 at the beginning of the chaincode simulation # Chaincode simulation with two GetState calls is executed with the following result GetState(“key1”) → \{value:“val1”, version:999} GetState(“key2”) → \{value:“val2”, version:1001} # This indicates that the second GetState call violates snapshot isolation level. In this case, read set is modified to the following one.   \{ key:”key1”, version:999}, \{key:”key2”, version:0}   (version:0 is the smallest version number that indicates the value of “key2” is stale) # MVCC checks at commit phase can invalidate this transaction.    This solution does not need neither simulation replays nor modification of the MVCC logic.  ></body> </Action>
