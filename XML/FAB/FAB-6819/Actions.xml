<Action id="33605" issue="23201" author="mne" type="comment" created="2017-10-31 12:22:23.0" updateauthor="mne" updated="2017-10-31 12:22:57.0"> <body><! CDATA Why store it in core.yaml? This file is more for platform configuration parameters, such as timeouts, IPs, etc. As  ~ales  suggested in an earlier discussion, I think it would be nicer to have a different infrastructure for application-level local configuration, say a simple file-based KVS that extends the way CC packages are currently stored in the filesystem. So for example, a CC package would be stored using the local config with name+version as its key and the package as value. The peer-private information (say, crypto material) would be stored the same way, with some ID as its key and the information as the value.  Along similar lines the Node SDK already uses a simple file-based KVS to store such material and can also be used to store other things.  ></body> </Action>
<Action id="33606" issue="23201" author="angelo.decaro" type="comment" body="Yeah, yeah. I wanted just to start from something that has minimum impact. Then move to a more invasive solution." created="2017-10-31 12:25:42.0" updateauthor="angelo.decaro" updated="2017-10-31 12:25:42.0"/>
<Action id="33607" issue="23201" author="ales" type="comment" created="2017-10-31 13:28:01.0" updateauthor="ales" updated="2017-10-31 13:28:01.0"> <body><! CDATA I think there are many different approaches to this: # we could build ad-hoc storage (in core.yaml?) for value strings; in its favour, it's simple; against it, it's a bit too restrictive (how would we handle binary content?); also, we would proliferate ad-hoc local storage solutions (core.yaml, the installed chaincode repository...) # we could build one KVS storage that is local to the peer, storing installed chaincodes and any binary artifact needed by the peers or by the chaincode; in its favour, it would be a common mechanism for a shared purpose; against it, it's new infrastructure that we need to build # we could build a private chain for the peer, exposing a ledger-like interface to store installed chaincodes and any binary artifact needed by the peers or by the chaincode; in its favour, it would be a common mechanism for a shared purpose; also, we could reuse all of the existing infrastructure for channels; against it, it might be a bit of an overreach  Thoughts?   ></body> </Action>
<Action id="33610" issue="23201" author="angelo.decaro" type="comment" created="2017-10-31 13:49:18.0" updateauthor="angelo.decaro" updated="2017-10-31 13:49:18.0"> <body><! CDATA I like the first two, the third one looks to me an overkill.   Actually, from the chaincode point of view nothing will change. The additional method will remain the same.  The first two options might, in principal, even coexist by assigning them a lookup priority. First the KVS storage and after what is in core.yaml.  1. is definitely easier to implement and will allow us to have quickly a storage place where to put strings (therefore, PEM encoded content) and make them available to the chaincode. Later we can introduce the unified KVS storage with its entire lifecycle. Wdyt?   ~mastersingh24 , would this be a viable solution?    ></body> </Action>
<Action id="33611" issue="23201" author="ales" type="comment" body="Let me play the devil&apos;s advocate: 1 sounds to me a bit &quot;quick&apos;n dirty&quot;. How can local information be updated, for instance, if rekeying is required? If the backing media is core.yaml, do we have to restart the peer or send it a signal to reparse the file? How are chaincode versions handled? What happens if there is a mismatch between the namespace defined for this auxiliary storage and the one on the ledger? E.g. a malicious peer of another org deploys a cc image with a different name just to &quot;steal&quot; some of the crypto material associated to another cc? Just thinking aloud.." created="2017-10-31 13:55:10.0" updateauthor="ales" updated="2017-10-31 13:55:10.0"/>
<Action id="33618" issue="23201" author="angelo.decaro" type="comment" created="2017-10-31 15:15:02.0" updateauthor="angelo.decaro" updated="2017-10-31 15:15:02.0"> <body><! CDATA Fair points. Going for solution 2. directly, at this point can be the right decision. So, we can split the task at least in two then: 1. implementing the chaincode part related to the shim and the communication back to the peer 2. implementing the backend to respond to the chaincode.  Good :)  ></body> </Action>
<Action id="33623" issue="23201" author="yacovm" type="comment" created="2017-10-31 15:57:46.0" updateauthor="yacovm" updated="2017-10-31 17:35:20.0"> <body><! CDATA {quote} If the backing media is core.yaml, do we have to restart the peer or send it a signal to reparse the file?{quote} I don't think so. We just need to stop the chaincode container, delete the image, and it will pick up the new file(s) at creation time. This of course- imposes an overhead.  Do I understand properly the requirements? * The chaincode shim needs to be able to query configuration that is stored and can potentially be updated by the peer  * The chaincode shim will never write to that config, only read. * The information is scoped only to the peer and is sensitive (i.e, signing identities)  My opinion is: * To have basic capabilities in place, implement it as a separate YAML file that the peer would parse at startup. Put it in sampleconfig folder so that the entire chaincode shim is packaged with it too. *I would suggest not adding a method to the chaincode stub interface at this early stage, as long as we're not 100% sure we need to extend the API.*  1    2  Instead - just use viper commands and a library/package that the developer can import when writing the chaincode. * When we decide that we have to have the ability to refresh the configuration, we can think about how to do that. I think that to preserve atomicity and also have performance we should have the peer send the config to the chaincode shim at startup of the container, and then when the config changes - send an update, and the chaincode shim will have some atomic pointer. Whenever an invocation comes - it grabs the pointer and uses the config for the life-time of the invocation. This is to prevent config from changing partly while an invocation takes place. Of course-  the peer would need to update config atomically too. * As for the storage - why can't we just use levelDB?    ~C0rWin  what do you think?    1  Lets not forget that adding stuff to APIs is easy, but subtracting from them is hard and painful.   2  Another argument against extending the stub API is that the configuration is not scoped to a transaction invocation, but is scoped to the peer itself. We have the stub API because that's a good way to inject stuff derived from the proposal (like arguments, txID, etc.) into the logic of the smart contract. However - here the configuration will be the same across all transactions so if we just have a library that can be imported I guess that would also work.  ></body> </Action>
<Action id="33646" issue="23201" author="c0rwin" type="comment" body=" ~yacovm  I personally like the idea of not adding a new API and copying config file while instantiating the chaincode, since this is less intrusive way to provide viable solution. " created="2017-10-31 20:30:01.0" updateauthor="c0rwin" updated="2017-10-31 20:30:01.0"/>
<Action id="33814" issue="23201" author="angelo.decaro" type="comment" body=" ~jyellick , your take?" created="2017-11-01 14:09:02.0" updateauthor="angelo.decaro" updated="2017-11-01 14:09:02.0"/>
<Action id="34474" issue="23201" author="shaih" type="comment" created="2017-11-08 19:38:43.0" updateauthor="shaih" updated="2017-11-08 19:38:43.0"> <body><! CDATA Hi Yacov, can you give a few more details for your proposal above? * Where is the information actually stored? What is LevelDB? Is there existing support for it in Hyperledger? Is there an instance of this database already available? I can see why storing everything in core.yaml is not a good idea, especially if we are going to store crypto keys and other sensitive stuff, is LevelDB suitable for storing sensitive stuff?   * What is the sequence of steps that needs to happen so that this information is loaded with the CC? Specifically, what files in the current implementation we need to look at and modify for doing this? * How will this information be accessed from within the chaincode? I'm assuming that the interface it will be similar, regardless if we are using the shim or something else? So here we will use someGlobalVariable.GetLocalConf("localConfVarName") as opposed to stub.GetLocalConf(...)     ></body> </Action>
<Action id="34485" issue="23201" author="yacovm" type="comment" created="2017-11-09 00:31:41.0" updateauthor="yacovm" updated="2017-11-09 00:31:41.0"> <body><! CDATA Sure.  {quote}Where is the information actually stored?{quote} what information? {quote} What is LevelDB {quote} It's a key value store database that runs embedded in the peer. {quote} Is there existing support for it in Hyperledger?{quote} yes {quote}  Is there an instance of this database already available? {quote} yes. it's the default database used by the peer. {quote}  I can see why storing everything in core.yaml is not a good idea, especially if we are going to store crypto keys and other sensitive stuff, is LevelDB suitable for storing sensitive stuff? {quote} That's a great question, and I think the answer is yes since it's an embedded database -> meaning, the files are stored locally (unless you're using NFS or a SAN / NAS, right?)  I assume a good place to store crypto keys will be a local file system, with only user (no g, o permission bits set) access control. Are there any more considerations when selecting where to store your keys? I guess if someone is *really* paranoid he/she can store the keys in encrypted form with a symmetric encryption key and have the key stored in an environment variable that is set at runtime, or something of the sort, but again - this change seems to me like a long one and thus we should start with something simple and gradually evolve it.  {quote} What is the sequence of steps that needs to happen so that this information is loaded with the CC? Specifically, what files in the current implementation we need to look at and modify for doing this? {quote} So, the chaincode <---> peer protocol roughly works like this: # Chaincode process spawns in a container, sends a REGISTER message to the peer # Peer registers the chaincode and sends back a REGISTERED message (sort of an ack) # From now on, whenever the peer receives a transaction from a user, it sends a  transaction message (this function is a bit scary, beware)|https://github.com/hyperledger/fabric/blob/release/core/chaincode/handler.go#L1293  to the chaincode # The chaincode might query the peer for data, or send it commands like "the logic stored value Y for key X" # ... So, I think that we can extend the message of REGISTERED and send the secret configuration in it, and whenever we get to the stage of having the peer be able to dynamically reload this config, we can then piggyback this on the transaction message as well.  But please - before anyone does any coding let's come to an agreement on the method, otherwise work might be thrown away. {quote}How will this information be accessed from within the chaincode? {quote} So I think the information should be accessed via a singleton function (i.e *GetSecretConfig()* )since the chaincode is a very minimal piece of code - just a handler that chats with the peer and invokes the function implemented in the struct, that's it.  This gives us the benefit of flexibiity - no need to extend the stub API.  Of course, this is all my opinion,  ~adc  and  ~ales  and  ~C0rWin  are welcome to share their opinions and/or scrutinize my view.     ></body> </Action>
<Action id="34598" issue="23201" author="jyellick" type="comment" created="2017-11-13 21:08:08.0" updateauthor="jyellick" updated="2017-11-13 21:08:08.0"> <body><! CDATA This seems to be the combination of a number of questions.  # Do we wish to facilitate chaincodes behaving differently per peer.  I can certainly see the utility, but up until this point, the chaincode mechanisms all seem to lean very heavily towards all peers running the exact same logic.   ~muralisr  do you have an opinion here? # Assuming we do, should the implementation be global to the peer, like the install operation, or should it be scoped by channel?  It sounds like the proposal is to scope it globally for the peer, but will we regret this decision? # Assuming we do, how should the local data be passed in and exposed to the chaincode? These are probably a bit tied together, as what is exposed will likely dictate how the data is passed in, but I think there are still questions of whether the data should be built into the chaincode container, be referenced from the DB, be referenced from the peer filesystem, or some other mechanism.  I'm not sure if it would be more helpful to create sub-tasks to discuss each of these questions separately, or if we can just address these individually here in this JIRA, but we should be careful not to conflate them together.  ></body> </Action>
<Action id="34611" issue="23201" author="muralisr" type="comment" created="2017-11-14 12:30:39.0" updateauthor="muralisr" updated="2017-11-14 12:31:06.0"> <body><! CDATA  ~jyellick   ~tzipih0  let me make sure I understood the requirement * chaincode in a peer needs to look up some information available only on that peer * this information is used to compute some state but itself will not be stored on the ledger  As the data does not go on to the ledger but is just used for processing, this has a distinct "business logic" feel to it. Extending chaincode protocol or other invasive chaincode framework work for this doesn't seem like a good idea.  Couldn't this be implemented with a system chaincode which can access the peer directly with some knowledge of the local peer identity ?   Adding   ~mastersingh24   ~binhn    ></body> </Action>
<Action id="34612" issue="23201" author="angelo.decaro" type="comment" body=" ~muralisr , actually, this sounds as another good option. It can be definitely done that way as well. Btw, would the SCC be able to learn from which chaincode it has been invoked?" created="2017-11-14 12:34:00.0" updateauthor="angelo.decaro" updated="2017-11-14 12:35:24.0"/>
<Action id="34613" issue="23201" author="angelo.decaro" type="comment" body=" ~jyellick , the business logic will still be the same. The private data will only drive the computation." created="2017-11-14 12:38:04.0" updateauthor="angelo.decaro" updated="2017-11-14 12:38:04.0"/>
<Action id="34617" issue="23201" author="muralisr" type="comment" created="2017-11-14 13:41:55.0" updateauthor="muralisr" updated="2017-11-14 13:41:55.0"> <body><! CDATA {quote}would the SCC be able to learn from which chaincode it has been invoked? {quote}  ~angelo.decaro  I don't think there's an API to do that... but the calling chaincode can certainly pass its name as an argument.  ></body> </Action>
<Action id="34618" issue="23201" author="angelo.decaro" type="comment" body=" ~muralisr , right but then the calling chaincode might cheat as well and trying to access sections that belong to other chaincodes. We have now so many approaches listed in the comments. We have to decide which one is the best. How can we have a vote?" created="2017-11-14 13:49:39.0" updateauthor="angelo.decaro" updated="2017-11-14 13:49:39.0"/>
<Action id="34620" issue="23201" author="muralisr" type="comment" created="2017-11-14 14:03:39.0" updateauthor="muralisr" updated="2017-11-14 14:03:39.0"> <body><! CDATA  ~angelo.decaro  I'd have thought the syscc would have to do some ACL to make sure it does not give out sensitive info ? Is just checking the chaincode ID enough ? Some info is in the proposal of course assuming the call is 1-level deep.     ></body> </Action>
<Action id="51031" issue="23201" author="denyeart" type="comment" created="2018-09-23 20:18:15.0" updateauthor="denyeart" updated="2018-09-23 20:18:15.0"> <body><! CDATA Bulk Jira update: For remaining tasks with FixVersion v1.3.0, the Reporter should update to v1.4.0 or Future, or Close. Add a comment with any clarification needed, so that release managers can close out v1.3.0 release cleanly.  ></body> </Action>
<Action id="51920" issue="23201" author="denyeart" type="comment" body="There are plans to refactor chaincode shim in v2.0.0, let&apos;s consider this as part of the refactor." created="2018-10-09 14:37:02.0" updateauthor="denyeart" updated="2018-10-09 14:37:02.0"/>
<Action id="67166" issue="23201" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:14:32.0" updateauthor="sykesm" updated="2020-01-22 22:14:32.0"/>
