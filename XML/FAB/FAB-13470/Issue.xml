<Issue id="36448" key="FAB-13470" number="13470" project="10002" reporter="dongming" creator="dongming" type="10004" summary="peer panic with invalid blocks" priority="3" resolution="10203" status="6" created="2019-01-02 15:52:34.0" updated="2019-01-04 19:53:19.0" resolutiondate="2019-01-04 19:53:19.0" votes="0" watches="2" workflowId="47981"> <description><! CDATA Test scenarios:  network: 1 channel, 5 orgs, 2 peers per org, only org5 has persistent data * execute transactions * bring down network, org5 has blocks * then bring up network with org 5 has persistent data from previous test * create the same channel and join to channel, the peers of org5 fails as expected due to persistent data * ledgers begin to catch-up since the persistent data in org5 peers * then the first peer of org1-org4 panic     The peer log from peer1 of org1:  2018-12-31 19:19:10.990 UTC  gossip.privdata  StoreBlock -> DEBU 1eb  testorgschannel1  No missing collection private write sets to fetch from remote peers 2018-12-31 19:19:10.994 UTC  gossip.state  commitBlock -> ERRO 1ec Got error while committing(unexpected Previous block hash. Expected PreviousHash =  8c6051f32c1c4b99da4eab9979eaa90c30c795932dbec5d6e61d31923bcf869c , PreviousHash referred in the latest block=  a4ce6643c4379723edcbf81f9fad80b3acddf1f3be1e290ece3d2e7e8c0a2525  github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage.(*blockfileMgr).addBlock /opt/gopath/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/blockfile_mgr.go:254 github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage.(*fsBlockStore).AddBlock /opt/gopath/src/github.com/hyperledger/fabric/common/ledger/blkstorage/fsblkstorage/fs_blockstore.go:42 github.com/hyperledger/fabric/core/ledger/ledgerstorage.(*Store).CommitWithPvtData /opt/gopath/src/github.com/hyperledger/fabric/core/ledger/ledgerstorage/store.go:132 github.com/hyperledger/fabric/core/ledger/kvledger.(*kvLedger).CommitWithPvtData /opt/gopath/src/github.com/hyperledger/fabric/core/ledger/kvledger/kv_ledger.go:312 github.com/hyperledger/fabric/core/ledger/ledgermgmt.(*closableLedger).CommitWithPvtData <autogenerated>:1 github.com/hyperledger/fabric/core/committer.(*LedgerCommitter).CommitWithPvtData /opt/gopath/src/github.com/hyperledger/fabric/core/committer/committer_impl.go:93 github.com/hyperledger/fabric/gossip/privdata.(*coordinator).StoreBlock /opt/gopath/src/github.com/hyperledger/fabric/gossip/privdata/coordinator.go:233 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).commitBlock /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:771 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:558 runtime.goexit /opt/go/src/runtime/asm_amd64.s:1333 commit failed github.com/hyperledger/fabric/gossip/privdata.(*coordinator).StoreBlock /opt/gopath/src/github.com/hyperledger/fabric/gossip/privdata/coordinator.go:235 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).commitBlock /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:771 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:558 runtime.goexit /opt/go/src/runtime/asm_amd64.s:1333 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).commitBlock /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:772 github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:558 runtime.goexit /opt/go/src/runtime/asm_amd64.s:1333)     It is understood that ledger catch-up will fail, due to the test scenario leading to the hash mismatch.  Our questions: 1. Are peers on other orgs expected to panic due to the catch-up failure? 2. Is there a good reason why the peers have to panic? Why not just halt processing blocks on that one chain? We think the peer should still be able to continue with other blockchains.  ></description> </Issue>
