<Issue id="37844" key="FAB-14268" number="14268" project="10002" reporter="sstone1" assignee="sstone1" creator="sstone1" type="10004" summary="BYFN and service discovery can&apos;t be used outside of Docker" priority="3" resolution="10000" status="6" created="2019-02-20 16:48:08.0" updated="2019-02-24 14:59:24.0" resolutiondate="2019-02-22 16:18:55.0" votes="0" watches="3" workflowId="49460"> <description><! CDATA The BYFN has two organisations with two peers, with the following port mappings:  * peer0.org1.example.com 7051 (external) 7051 (internal) * peer1.org1.example.com 8051 (external) 7051 (internal) * peer0.org2.example.com 9051 (external) 7051 (internal) * peer1.org2.example.com 10051 (external) 7051 (internal)  Service discovery returns the following end points:  peer0.org1.example.com:7051 peer1.org1.example.com:7051 peer0.org2.example.com:7051 peer1.org2.example.com:7051  This works great when your application is inside Docker, because those hostnames/ports work as expected.  However, when your application is outside Docker this does not work.  Problem 1 is that the hostnames don't resolve; however, the Node.js SDK already allows you to override hostnames returned by service discover to localhost for this exact reason. Using this option gives you:  localhost:7051 localhost:7051 localhost:7051 localhost:7051  Problem 2 then is that the ports now conflict; service discovery doesn't know about the external port numbers!  We could change CORE_PEER_GOSSIP_EXTERNALENDPOINT to have the external port numbers, but then applications inside Docker wouldn't work.  I propose that we change the peer configuration for each container so that the internal peer ports and the external peer ports are the same:  * peer0.org1.example.com 7051 (external) 7051 (internal) * peer1.org1.example.com 8051 (external) 8051 (internal) * peer0.org2.example.com 9051 (external) 9051 (internal) * peer1.org2.example.com 10051 (external) 10051 (internal)  Then service discovery will always return the right port, regardless of whether or not the application is running outside or inside Docker, and then the "as localhost" override will deal with the hostname problem.  ></description> </Issue>
