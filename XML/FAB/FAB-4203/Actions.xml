<Action id="24638" issue="17213" author="jyellick" type="comment" created="2017-05-30 13:48:47.0" updateauthor="jyellick" updated="2017-05-30 13:48:47.0"> <body><! CDATA > However - it may pose a challenge if the field is introduced only in a proto structure that exists solely in configuration updates, because it would require the ordering service to append a configuration update as part of an upgrade/migration of each "chain" from v1.0 to v1.1  This actually seems like a fairly sane migration path to me.  Create a test channel with the v1.0 code, perform the upgrade to v1.1, and verify that your application functions correctly on the new v1.1 fabric.  If everything is fine, continue a rolling update across the channels, or abort.  > and this may enforce a one-way upgrade with no ability to revert to v1.0 should problems arise.  Of course this depends on implementation, but I'm not sure why encoding it into the config precludes the possibility of rollback.  In general, elements may be deleted from a configuration with a configuration update.  I would agree, it would most likely to be problematic to roll-back while leaving the v1.1 config in place.  > Forward compatibility: > This is more challenging and needs to be considered if it is indeed something that should be addressed or not.  I think this is something maybe we need to answer first.   * Do we want to allow a fabric channel to operate in a mixed-version-mode across version boundaries?   * What do we expect the typical upgrade process to follow?  Here is the first proposal which comes to mind:  1. Channel members agree to move to next version of fabric 2. Channel members upgrade their peer code to v1.1, but leave the chain running in v1.0 mode 3. Channel members agree that there are no longer peers running the v1.0 code on the channel 4. Channel members send a config transaction which sets the fabric version of the channel to v1.1 5. Any peers which were not upgraded to v1.1 (should be none) fail to process the config update because of the unknown version 6. All remaining and upgraded channel peers have a discrete and deterministic point to begin applying v1.1 logic (such as endorsement cert expiration validation), which does not require downtime  ></body> </Action>
<Action id="24668" issue="17213" author="yacovm" type="comment" created="2017-05-30 15:08:23.0" updateauthor="yacovm" updated="2017-05-30 15:08:23.0"> <body><! CDATA {quote}Do we want to allow a fabric channel to operate in a mixed-version-mode across version boundaries?  {quote} I think it makes sense, no?If you have 3 orgs: A, B, C and they have channels: X: {A, B} and Y: {B, C}  and org A upgraded to v1.1, what should org B do? It needs to do business with org C which is at version v1.0  ></body> </Action>
<Action id="24670" issue="17213" author="yacovm" type="comment" created="2017-05-30 15:20:59.0" updateauthor="yacovm" updated="2017-05-30 15:23:16.0"> <body><! CDATA {quote} Any peers which were not upgraded to v1.1 (should be none) fail to process the config update because of the unknown version{quote} Where does the version exist in the current code? Can you point me to the proto field you're talking about?  ></body> </Action>
<Action id="24688" issue="17213" author="jyellick" type="comment" created="2017-05-30 17:26:36.0" updateauthor="jyellick" updated="2017-05-30 17:50:32.0"> <body><! CDATA > and org A upgraded to v1.1, what should org B do? It needs to do business with org C which is at version v1.0  I would agree that \{A,B} wishing to transact with fabric 1.1 not require \{B,C} to do so.   Note though that the question was: "Do we want to allow a fabric **channel** to operate in a mixed-version-mode" (emphasis added).  So I would assert that \{A,B} can choose to move to 1.1 without requiring \{B,C} to do so, because they would be different channels.  > Where does the version exist in the current code? Can you point me to the proto field you're talking about?  It does not.  The more accurate statement would be to say that, any peers which were not upgraded to v1.1 fail to process the config update because of the unknown config field "version".  Then, for v1.1 to v1.2 the value of version would be incremented.  ></body> </Action>
<Action id="24691" issue="17213" author="yacovm" type="comment" created="2017-05-30 17:53:12.0" updateauthor="yacovm" updated="2017-05-30 17:54:35.0"> <body><! CDATA {quote}Note though that the question was: "Do we want to allow a fabric *channel* to operate in a mixed-version-mode" (emphasis added).{quote}  Well but if all of the peers in org B were in both channels that'd require to bring up new peers, wait for them to sync, change anchor peers in one of the channels, etc. etc. It's quite difficult and complex.  I think that we should: # Consider either adding a version field now to the block header as this solves the forward compatibility problem easily, or: # Think thoroughly along your line of thought with the structured upgrade  But in any case I think this should be at least planned and thought about.   ></body> </Action>
<Action id="24742" issue="17213" author="mastersingh24" type="comment" created="2017-05-31 10:36:51.0" updateauthor="mastersingh24" updated="2017-05-31 10:37:17.0"> <body><! CDATA Actually, block validation should not be related to channels / channel config at all.  Peer's validate blocks / transactions based on the VSCC which is associated with chaincode.  So validation is actually associated with chaincode and not with a channel -   https://github.com/hyperledger/fabric/blob/master/core/committer/txvalidator/validator.go#L500  And technically we provide the ability to specify the VSCC for chaincode during chaincode deploy/instantiate ( https://github.com/hyperledger/fabric/blob/master/core/scc/lscc/lscc.go#L774 )  as well as during chaincode upgrade ( https://github.com/hyperledger/fabric/blob/master/core/scc/lscc/lscc.go#L827 ) .  My take has been that we would NOT change the current vscc but rather we would add a new vscc and if people want to use it, they would choose it during deploy or upgrade of chaincode.  Now clearly if the vscc does not exist (i.e. in would be in v1.x and not v1.0) endorsement for the upgrade / instantiate should fail.  I'm not sure that we handle all the error scenarios with missing / wrong vscc /escc - so we should make sure we address those  Tagging  ~muralisr   ></body> </Action>
<Action id="24744" issue="17213" author="yacovm" type="comment" created="2017-05-31 10:47:00.0" updateauthor="yacovm" updated="2017-05-31 10:55:04.0"> <body><! CDATA {quote}Actually, block validation should not be related to channels / channel config at all. Peer's validate blocks / transactions based on the VSCC which is associated with chaincode. So validation is actually associated with chaincode and not with a channel - https://github.com/hyperledger/fabric/blob/master/core/committer/txvalidator/validator.go#L500{quote} The code that has changed to address the issue of the time based certificate validation is in the mspimpl.go which is global in the peer and not per VSCC. (Tagging  ~adc  and  ~elli-androulaki  to confirm and/or chime in on this)  ok so let me play devil's advocate here. We have a channel and a CC with 2 orgs - orgA and orgB. The ordering service is in orgA (yeah I know that it's supposed to be separate but lets assume it's not because it's not important) orgA has upgraded its peers and ordering service to v1.1 where the code does time-based certificate validation and orgB is still in v1.0 a peer in orgB gets a block from a peer in orgA and the block has a transaction that its endorser's certificate has expired. How does the peer in orgB get to the point where it does not process the block at all?  Note that this is the only thing that a peer in orgB can do since it doesn't possess the logic required to process the block as orgA since, well - the code is written in the future and orgB lives in the past.  Are you saying that orgA would upgrade all the chaincodes in the channel and put a different VSCC or something?  ></body> </Action>
<Action id="24748" issue="17213" author="yacovm" type="comment" created="2017-05-31 11:25:01.0" updateauthor="yacovm" updated="2017-05-31 11:26:01.0"> <body><! CDATA Another option that we should consider is perhaps when we reach v1.1 - tell customers/users that if they want to do "business" with organizations that run v1.1 code, they have to apply a patch, and the patch would contain the needed protobuf addition from v1.1 + a code section that would stop processing the chain once the new populated field from v1.1 would be detected.  This requires out of band sync but we could make the migration process seamless with this.  ></body> </Action>
<Action id="24856" issue="17213" author="binhn" type="comment" created="2017-05-31 21:01:44.0" updateauthor="binhn" updated="2017-05-31 21:01:44.0"> <body><! CDATA  ~yacovm  {quote}This requires out of band sync but we could make the migration process seamless with this. {quote} In general, compatibility is much more difficult when the changes involve: # changing protocol (as in this case) # changing ledger structure  Currently we do have a protocol version defined (Header.ChannelHeader.Version) and set to 0. This header is in every transaction and proposal; however, only few places that we use this field, so the 1.0 code currently is not ready to handle forward compatibility. It will require 1.1 to patch up.  In addition, the ledger files don't contain an explicit version. Discussing with  ~jyellick  and  ~denyeart  on how to manage ledger compatibility, we need to have some kind of version written on the ledger so that the code can decide to load or not. We can use this JIRA to discuss a story for upgrade.  Here are my thoughts:  # We leverage the `version` field in the protocol in post 1.0 development # We increase this version to the next one (eg 1.01) if we change protocol # Release 1.0 doesn't know about this, so it would likely to either blow up or process incorrectly – forward compatibility issue that we will have to patch like you suggested or just require upgrade # Post 1.0 new code checks version and process; errors if version not supported # At some point post 1.0, we need to do checkpoint on block validation to weed out minority peers with incompatible releases. # After that (eg 2.0), we will be able to handle compatibility  In summary, this is post 1.0   Thoughts?  ></body> </Action>
<Action id="24859" issue="17213" author="yacovm" type="comment" created="2017-05-31 21:16:30.0" updateauthor="yacovm" updated="2017-05-31 21:32:29.0"> <body><! CDATA The channel header is in a client call though, no? This means you have to enforce that customers upgrade the clients to v1.1, because you somehow have to enforce that the client sends a proposal with the "next" version and that means also no ability for clients to talk to v1.1 chains/orderers (don't know that code *that* well).  {quote} We can use this JIRA to discuss a story for upgrade.{quote} +1  ></body> </Action>
<Action id="24971" issue="17213" author="binhn" type="comment" body="Right, the message is sent from the client app, and the version is set by the sdk. So if the app wants to use the new version of the protocol, and it uses the SDK, then the SDK must be upgraded. " created="2017-06-01 17:14:18.0" updateauthor="binhn" updated="2017-06-01 17:14:18.0"/>
<Action id="25054" issue="17213" author="elli-androulaki" type="comment" created="2017-06-02 00:59:24.0" updateauthor="elli-androulaki" updated="2017-06-02 01:00:27.0"> <body><! CDATA So would we then reach to a level where transactions submitted in the channel can correspond to different protocol version and still get validated? E.g., we have tx1-> tx2 -> tx3, and then tx2 using protocol version 1, tx1 and tx3 using protocol version 2,and all being properly validated?     I feel that for certain cases, e.g., block format, msp version, could be easier if they were just another config parameter of the config of the channel and msp respectively, modifiable by properly authorized request.     In this case msp config would be enhanced with a version number, as is the block structure (as Yacov was saying).  As binaries with support of the new version of each of them are installed on the nodes:    - old versions are still supported until the new version becomes active    - new version is not active till a version activation config tx goes into the blockchain (from properly authorized parties) and validated  Essentially a similar mechanism as for installation/instantiation of chaincodes.     Regarding the FIX-VERSION of this FAB,  ~yacovm ,  ~angelo.decaro ,  ~binhn ,  ~mastersingh24 ,  ~jyellick  do you agree that we label this for *post v1*? Is there something that you think we ought to do for v1 related to this task?     ></body> </Action>
<Action id="25065" issue="17213" author="yacovm" type="comment" created="2017-06-02 06:11:25.0" updateauthor="yacovm" updated="2017-06-02 06:11:25.0"> <body><! CDATA {quote}Is there something that you think we ought to do for v1 related to this task?{quote} Agree on a concrete upgrade plan and guidelines from v1.0 v1.1 so that customers that would wish to upgrade their system won't get stuck, or assert that there is no need of one, because of such and such reasons.  {quote}Release 1.0 doesn't know about this, so it would likely to either blow up or process incorrectly – forward compatibility issue that we will have to patch like you suggested or just require upgrade{quote}  ~binhn  regarding the version field of the channel header - I looked in the IDE and it doesn't seem like someone reads the value, only writes. So if we want to make such a change we need to include it in v1.0  ></body> </Action>
<Action id="25486" issue="17213" author="yacovm" type="comment" body="Since this would be likely be resolved with documentation and not with code change, and there isn&apos;t really anything to do regarding to crypto, changed the component to fabric-docs" created="2017-06-06 11:39:11.0" updateauthor="yacovm" updated="2017-06-06 11:39:11.0"/>
<Action id="62376" issue="17213" author="mastersingh24" type="comment" body="No activity in a year or more" created="2019-07-30 02:59:49.0" updateauthor="mastersingh24" updated="2019-07-30 02:59:49.0"/>
