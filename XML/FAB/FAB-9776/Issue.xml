<Issue id="29795" key="FAB-9776" number="9776" project="10002" reporter="yacovm" assignee="manish-sethi" creator="yacovm" type="10004" summary="Transaction validation doesn&apos;t distinguish between endorsement policy failure and VSCC database access failure" priority="2" resolution="10000" status="6" created="2018-04-28 13:11:26.0" updated="2019-01-21 20:57:28.0" resolutiondate="2019-01-21 20:52:52.0" votes="0" watches="7" workflowId="35727"> <description><! CDATA VSCC needs access to the ledger in order to  retrieve data from LSCC|https://github.com/hyperledger/fabric/blob/release-1.1/core/scc/vscc/validator_onevalidsignature.go#L555  (ccprovider.ChaincodeData).  However, it may fail in cases where the database isn't reachable (for example - a temporary network failure to access couchDB).  In such a case, the VSCC returns  shim.Error.|https://github.com/hyperledger/fabric/blob/release-1.1/core/scc/vscc/validator_onevalidsignature.go#L198   Now, it returns the same kind of output (shim.Error) in any other error case, for example -  if the endorsement policy isn't satisfied|https://github.com/hyperledger/fabric/blob/release-1.1/core/scc/vscc/validator_onevalidsignature.go#L182 .  When the validator  calls VSCC|https://github.com/hyperledger/fabric/blob/release-1.1/core/committer/txvalidator/validator.go#L842-L850 , it treats an error as an execution failure, and a shim.Error as an endorsement policy failure: {code:java} 	logger.Debug("Invoking VSCC txid", txid, "chaindID", chid) 	res, _, err := v.ccprovider.ExecuteChaincode(ctxt, cccid, args) 	if err != nil { 		msg := fmt.Sprintf("Invoke VSCC failed for transaction txid=%s, error: %s", txid, err) 		return &commonerrors.VSCCExecutionFailureError{msg} 	}  	if res.Status != shim.OK { 		return &commonerrors.VSCCEndorsementPolicyError{fmt.Sprintf("%s", res.Message)} 	} {code} When *ExecuteChaincode* returns an error, it is most likely because the VSCC cannot be found in the peer.  This is not deterministic and might lead to state fork, since for a valid transaction, retrieval from LSCC in some peers might fail and in some peers might not.  I made a small hacky change to test this hypothesis: {code:java} func (vscc *ValidatorOneValidSignature) getInstantiatedCC(chid, ccid string) (cd *ccprovider.ChaincodeData, exists bool, err error) { 	qe, err := vscc.sccprovider.GetQueryExecutorForLedger(chid) 	if err != nil { 		err = fmt.Errorf("Could not retrieve QueryExecutor for channel %s, error %s", chid, err) 		return 	} 	defer qe.Done()  	bytes, err := qe.GetState("lscc", ccid)  	rand.Seed(time.Now().UnixNano()) 	if rand.Int() % 2 == 1 { 		err = errors.New("this isn't our day") 	} 	if err != nil { 		err = fmt.Errorf("Could not retrieve state for chaincode %s on channel %s, error %s", ccid, chid, err) 		return 	} {code} and ran e2e_cli and it looks like some peers validated the LSCC instantiate, while others didn't:   !fork.png!           A good way to fix this, is to have VSCC send a shim error with error code < 500 to indicate a validation error, and 500 otherwise (the current value it always returns in the case of an error). I suggest we fix this for v1.1.x and possibly also for v1.0.x           ></description> </Issue>
