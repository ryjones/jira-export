<Action id="21148" issue="15020" author="binhn" type="comment" created="2017-02-24 06:34:32.0" updateauthor="binhn" updated="2017-02-24 06:34:32.0"> <body><! CDATA It is not 1 policy fits all.   I would suggest the following: 1) LCCC & CSCC:  local admins only but unfortunately we have to handle specific functions that are channel admins 2) QSCC is readers since it provides ledger query API 3) All other chaincode invokes on a channel are channel writers   ></body> </Action>
<Action id="21158" issue="15020" author="elli-androulaki" type="comment" created="2017-02-24 17:20:01.0" updateauthor="elli-androulaki" updated="2017-02-24 17:20:01.0"> <body><! CDATA Hi Binh,  Would you be fine with the following arrangement?   LCCC & CSCC & QSCC chainless  =>  are only allowed to be invoked by local admins  non-chainless LCCC => chaincodeAdmin of the chain the proposal refers to  non-chainless QSCC chainless  =>  are only allowed to be invoked by channel readers other application chaincodes => invoked allowed within channel writers  The issue so far has been that we use the same policy for non-chainless LCCC and admin policy used for reconfiguration. The latter uses a threshold signature based policy that the former cannot accommodate due to the singularity of the proposal creator (we can only have one signature).   After talking to @jyellick, we would need to have an additional policy for that defining identities that are allowed to "instantiate" chaincodes, and invoke these type of chaincodes.  In the short term though it would make sense to lower the threshold of signatures required in the admin policy to one, till we have this additional policy in.  What do you think?    ></body> </Action>
<Action id="21227" issue="15020" author="binhn" type="comment" created="2017-02-28 22:05:03.0" updateauthor="binhn" updated="2017-02-28 22:06:15.0"> <body><! CDATA  ~ellaki   SCC may operate on any channels since it is not restricted to the chaincode APIs, but often SCC is invoked with a channel in the parameter. However, each function behaves differently depending on the implementation, so I think ACL on SCC should be left to SCC to implement per function, except when a CC calling SCC.  A CC is always called on a channel and can only operate within that channel. When a CC calls an SCC, as part of the API, it has to specify a channel. So the ACL for that (CC2SCC) can be done outside of the SCC, and we can apply the same criteria as CC2CC.  Assuming ability to extract a policy available, we need to provide a function that, given a policy and a proposal (or header), determines ACL so that SCC may call.  Examples LCCC has functions that operate outside of channel such as Install and GetInstalledChaincodes. These functions require local MSP admins; whereas, Instantiate and other functions, that require a channel, can access if the user is a member of channel admins or writers or readers. Similarly for CSCC. JoinChannel requires local MSP admins, but others require channel policies as appropriate. On the other hand, QSCC is a ledger structure query, so ACL should be based on channel readers.   ></body> </Action>
<Action id="21238" issue="15020" author="elli-androulaki" type="comment" created="2017-03-01 13:09:51.0" updateauthor="elli-androulaki" updated="2017-03-01 13:09:51.0"> <body><! CDATA Ok, so regarding   > A CC is always called on a channel and can only operate within that channel. When a CC calls an SCC, as part of the API, it has to specify a channel. So the ACL for that (CC2SCC) can be done outside of the SCC, and we can apply the same criteria as CC2CC. Is there a chance indeed of a CC invoking an SCC? If the answer is "currently no, but in the future it may be the case" we think we should forbid such a call. Angelo's CR on CC2CC does that already after a discussion he and Murali had.  > Assuming ability to extract a policy available, we need to provide a function that, given a policy and a proposal (or header), determines ACL so that SCC may call. A couple of clarification questions here:  - when you say ability to extract a policy available, do you refer to a policy object? policy is actually the expression of the ACL, and evaluating permissions of a signer against it is as simple as invoking policy.evaluate method. - where should the policy be extractable from? it seems to me that for requests/proposals that are not within a channel's scoped it is always only the peer msp admin's that should be considered. For channel scoped proposals, a policy from the channel genesis should be considered. Taking a closer look on what the latter can be  * chain-scoped LCCC (instantiate/terminate chaincodes): chaincode instantiators of the channel * chain-scoped QSCC (queries on the chaincodes/blocks of a channel): channel readers should be checked - for chainless proposals, though we want policies to be extractable, we do not want them to be configurable, correct? E.g., have the peer yaml contain a policy the peer should be authenticating LCCC install/uninstall requests.       ></body> </Action>
<Action id="22131" issue="15020" author="denyeart" type="comment" body=" ~muralisr  ~adc  ~ales  ~ellaki  Is this still needed or has it already been covered and therefore can be closed? If still valid, is it a story or a bug?  Is it required for 1.0.0?" created="2017-04-11 19:56:17.0" updateauthor="denyeart" updated="2017-04-11 19:56:17.0"/>
<Action id="22700" issue="15020" author="elli-androulaki" type="comment" body="If we do this, can&apos;t we extend this config of the peer to define a peer&apos;s trustzone? Essentially, policy defining which identities should be allowed to receive StateInfo messages of peers.  ~yacovm   ~C0rWin ." created="2017-04-19 10:58:47.0" updateauthor="elli-androulaki" updated="2017-04-19 10:58:47.0"/>
<Action id="22701" issue="15020" author="yacovm" type="comment" created="2017-04-19 11:04:02.0" updateauthor="yacovm" updated="2017-04-19 12:45:39.0"> <body><! CDATA Currently - peers receive StateInfo messages from peers that their orgs are channel members, *and* that they know the name of the channel - what benefit does your approach give? There is an overhead of computing the policy over a peer (signature verification overhead).  ></body> </Action>
<Action id="22731" issue="15020" author="muralisr" type="comment" body="This belongs to all the ACL work that is being done.. assigning it to  ~ellaki  for handling." created="2017-04-20 00:10:05.0" updateauthor="muralisr" updated="2017-04-20 00:10:05.0"/>
