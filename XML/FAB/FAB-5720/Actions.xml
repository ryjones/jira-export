<Action id="30100" issue="20114" author="guoger" type="comment" created="2017-08-23 11:05:47.0" updateauthor="guoger" updated="2017-08-23 11:05:47.0"> <body><! CDATA {quote}This is incorrect as validation can fail non-deterministically; consider for example the case of a message that is identified as stale by OSN1 because its certificate just expired. OSN2 has a slower clock however, so it identifies this message as valid. OSN1 drops the message, OSN2 adds it to its ledger, and we now have a fork. {quote} *I'm not exactly sure this is a CFT problem*, as OSNs vote *differently* for the same tx {quote}Therefore we need a way to have each OSN go "I've already processed a copy of this revalidated and reordered stale message, I'll pass." {quote} I'm still not clear about *what's the condition under which a tx is eventually committed?*   I Imagine it would be something like {{OriginalOffset > LastOriginalOffsetProcessed *AND* tx is valid}}?  To elaborate a bit, this is to say * I've deemed this tx (with offset {{x}}) to be valid during re-validation, I'm going to broadcast it again so that others could give it a second chance. * I receive a tx with OriginalOffset {{y}} ** if {{y <= x}}, I'll pass (discard) because I've processed it already. ** if {{y > x}}, there are two possibilities: *** it's from an *OSN who originally failed the validation* and revalidates it to be valid upon receipt of broadcast. If it's valid, I'll commit *** I am *OSN who originally failed the validation* and this is the broadcast from another OSN, if it's valid, I'll commit and re-submit.  However, I'm not sure about the last part, where there may still be OSNs that discard the tx.  cc  ~kchristidis   ~jyellick    ></body> </Action>
<Action id="30132" issue="20114" author="jyellick" type="comment" created="2017-08-24 02:53:58.0" updateauthor="jyellick" updated="2017-08-24 02:53:58.0"> <body><! CDATA >> This is incorrect as validation can fail non-deterministically; consider for example the case of a message that is identified as stale by OSN1 because its certificate just expired. OSN2 has a slower clock however, so it identifies this message as valid. OSN1 drops the message, OSN2 adds it to its ledger, and we now have a fork. > I'm not exactly sure this is a CFT problem, as OSNs vote differently for the same tx  This is not a byzantine attack.  Fundamentally, as hard as we try to make our transaction validation deterministic, there are likely to be cases where two different OSNs reach a different conclusion as to whether a transaction is valid.  Time is a big one, are the OSNs clocks synced, are they in the same timezone, do they perform the validation at the same real time (usually not).  So, the idea behind this issue, is that we should strive such that we _never_ have a case where two OSNs independently decide on the validity of a transaction.  As this is Kafka, and CFT, we can employ a simple "first decision is right" rule (which would not fly in a BFT system).  So, if an OSN detects a TX must be revalidated, it must revalidate it and re-order to determine if its validation was "first".  > I'm still not clear about what's the condition under which a tx is eventually committed?  > I Imagine it would be something like {{OriginalOffset > LastOriginalOffsetProcessed}} AND {{tx is valid}}?  You are close, but missing one critical piece.  The rule is:  {{OriginalOffset > LastOriginalOffsetProcessed}} AND {{configSeq == currentConfigSeq}}  To put it in prose: "If I have not already reprocessed beyond this transaction and it satisfies my normal config seq rule".  The key here is that this rule is definitely deterministic.  If an OSN is committing a transaction, it is because the transaction was found to be valid (the nondeterministic bit) _before (re)ordering_  and the commit rule simply checks to make sure that by simple sequence check, there's no reason this validation should have changed.  ></body> </Action>
<Action id="30191" issue="20114" author="guoger" type="comment" created="2017-08-25 07:08:40.0" updateauthor="guoger" updated="2017-08-25 07:08:58.0"> <body><! CDATA bq. OriginalOffset > LastOriginalOffsetProcessed AND configSeq == currentConfigSeq OSN commits the tx under this condition, yes. However, there's no way to tell if this tx is # *resubmission* (OSN that re-validates tx to be valid and re-submits it) _OR_ # *relay* (OSN that discards a tx because of failed re-validation, received re-submitted tx from others, and re-submits again)  If we re-submit it regardlessly, we will end up resubmitting tx indefinitely. Therefore, we need an additional {{bool ResubmittedMsg}} to differentiate these two cases and re-submit ONLY for condition 1. Partial flow would be: - OSN1 re-submits TX1 because of valid revalidation - OSN2 discards TX1 because of invalid revalidation - OSN1 receives TX1, checks OriginalOffset and discards it - OSN2 receives TX1, checks OriginalOffset and ResubmittedMsg, commits and *re-submit* - OSN1 receives TX1, checks OriginalOffset and ResubmittedMsg, commits and *not re-submit* - OSN2 receives TX1, checks OriginalOffset and discards it  I attached a chart to depicts the message flow and here's the pseudo-code: {code:java} if Seq < ConfigSeq: If Invalid: Discard If Valid: LastOriginalOffsetProcessed = CurrentOffset Re-submit(CurrentOffset, true) else if OriginalOffset == nil || OriginalOffset > LastOriginalOffsetProcessed: Commit LastOriginalOffsetProcessed = CurrentOffset if ResubmittedMsg == true: Re-submit(CurrentOffset, false) else: Discard {code} cc  ~kchristidis   ~jyellick   ></body> </Action>
<Action id="30218" issue="20114" author="jyellick" type="comment" created="2017-08-25 17:07:09.0" updateauthor="jyellick" updated="2017-08-25 17:07:09.0"> <body><! CDATA > If we re-submit it regardlessly, we will end up resubmitting tx indefinitely. Therefore, we need an additional bool ResubmittedMsg to differentiate these two cases and re-submit ONLY for condition 1.  Under what condition is the message resubmitted indefinitely? Only when the config sequence is continuously advancing I assume?  I would propose the correct fix for this possibility is to simply block new requests until the backlog has been cleared.   ~kchristidis  and I discussed the possibility of allowing the consenter to acquire a lock somewhere which would cause the {{Broadcast}} call to block on any attempted writes to the channel until the outstanding messages had been re-processed.  I think this is something we could add after the fact.  For the moment, since the constant resubmission of transactions due to reconfiguration is really only a DoS vector, and since reconfiguration requires minimally the signature of a channel administrator, I think we can defer solving it until later.  I'd encourage you to open a JIRA describing the problem to track it.  ></body> </Action>
<Action id="30237" issue="20114" author="guoger" type="comment" body="A more typical and correct Kafka message flow is uploaded to replace old, incorrect one." created="2017-08-26 17:46:46.0" updateauthor="guoger" updated="2017-08-26 17:46:46.0"/>
<Action id="30665" issue="20114" author="guoger" type="comment" body="https://gerrit.hyperledger.org/r/#/c/12991/" created="2017-09-08 04:05:03.0" updateauthor="guoger" updated="2017-09-19 21:45:42.0"/>
<Action id="30784" issue="20114" author="kchristidis" type="comment" created="2017-09-13 02:33:21.0" updateauthor="kchristidis" updated="2017-09-13 02:33:21.0"> <body><! CDATA As I'm finally catching up to these reviews, I will note that I left out the "constant resubmission" attack on purpose, after discussing this with  ~jyellick , for the reasons noted above. Let us not worry about it for now. (In hindsight I should have written that down when I wrote up the issue.)  The issue of old OSNs not being able to distinguish between original and revalidated messages was a serious omission from my side. Thank you for catching this.  ></body> </Action>
