<Action id="28853" issue="19433" author="c0rwin" type="comment" body="Sounds reasonable, need to keep in mind to clean up this cache also after certificate expiration." created="2017-07-23 10:05:20.0" updateauthor="c0rwin" updated="2017-07-23 10:05:20.0"/>
<Action id="28854" issue="19433" author="yacovm" type="comment" created="2017-07-23 11:16:06.0" updateauthor="yacovm" updated="2017-07-23 11:16:19.0"> <body><! CDATA {quote}Sounds reasonable, need to keep in mind to clean up this cache also after certificate expiration.{quote}  That's what I thought too but when I looked at the code I think there isn't a need: The method of *EligibleForChannel*'s signature is: {code} EligibleForChannel(member discovery.NetworkMember) bool {code} I can just make the new implementation call:   {code}identity := gc.GetIdentityByPKIID(member.PKIid){code}  which does|https://github.com/hyperledger/fabric/blob/release/gossip/gossip/chanstate.go#L163 : {code} 	identity, err := ga.idMapper.Get(pkiID) 	if err != nil { 		return nil 	} 	return identity {code}  Now, recall that when the certificates of the peers are checked for expiration,  SuspectPeers|https://github.com/hyperledger/fabric/blob/release/gossip/gossip/gossip_impl.go#L205  is called which calls  listRevokedPeers|https://github.com/hyperledger/fabric/blob/release/gossip/gossip/certstore.go#L146  which calls  idMapper.ListInvalidIdentities|https://github.com/hyperledger/fabric/blob/release/gossip/identity/identity.go#L146  which  deletes the identities|https://github.com/hyperledger/fabric/blob/release/gossip/identity/identity.go#L153-L154  from the identity mapper. As a result - when the identities expire, they will not be found by *EligibleForChannel*.   ></body> </Action>
<Action id="28876" issue="19433" author="yacovm" type="comment" body="https://gerrit.hyperledger.org/r/#/c/11851/" created="2017-07-24 08:37:25.0" updateauthor="yacovm" updated="2017-07-24 08:37:25.0"/>
<Action id="29381" issue="19433" author="angelo.decaro" type="comment" created="2017-08-03 04:58:57.0" updateauthor="angelo.decaro" updated="2017-08-03 04:58:57.0"> <body><! CDATA  ~yacovm , I think it is important to clarify that what you suggest might work under the assumptions that MSP identities never expire but can only be revoked as we currently assume, Revoking an MSP identity requires a reconfiguration.  Still, there is something that bothers me. We need to be sure that this authorisation that is granted at the parsing of the StateInfo message is not used in malicious ways.  ~elli-androulaki  ~ales , what's your take on this? Btw, is the state info message replayable?   ></body> </Action>
<Action id="29387" issue="19433" author="yacovm" type="comment" created="2017-08-03 08:50:05.0" updateauthor="yacovm" updated="2017-08-03 08:50:05.0"> <body><! CDATA {quote}I think it is important to clarify that what you suggest might work under the assumptions that MSP identities never expire{quote}  It looks like it but that's not the case.  See my answer to Artem and the change set- there is a goroutine that periodically (once a day) goes through all identities and validates them.  When an identity is invalidated it is deleted from the mapping between PKI-ID and identities in the identity mapper. When *EligibleForChannel* is called - it checks that the PKI-ID of the stateInfo message exists in the mapping, thus - expired certificates won't be returned and we are safe.  {quote}Still, there is something that bothers me. We need to be sure that this authorisation that is granted at the parsing of the StateInfo message is not used in malicious ways{quote} I don't understand what you mean, care to elaborate?  I understand that *VerifyByChannel* calls the policy.Evaluate which underneath - verifies the identity, isn't that so?  {quote}Btw, is the state info message replayable? {quote} It is bounded to the PKI-ID so I don't see how that helps someone.    ></body> </Action>
<Action id="29789" issue="19433" author="angelo.decaro" type="comment" body=" ~yacovm , thanks for the explanation. Once a day might be too long. In the future, would it be possible to check for the expiration every time that there is a hit in the cache?" created="2017-08-14 00:43:15.0" updateauthor="angelo.decaro" updated="2017-08-14 00:43:15.0"/>
<Action id="29790" issue="19433" author="yacovm" type="comment" body="FAB-5752 should tackle the expiration issue " created="2017-08-14 06:51:12.0" updateauthor="yacovm" updated="2017-08-14 06:51:12.0"/>
