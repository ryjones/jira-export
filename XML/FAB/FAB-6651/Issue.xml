<Issue id="22461" key="FAB-6651" number="6651" project="10002" reporter="elli-androulaki" assignee="ales" creator="elli-androulaki" type="10001" summary="Improve security checks on the validation of LSCC upgrade" priority="3" resolution="10000" status="6" created="2017-10-17 14:39:33.0" updated="2018-07-20 18:50:30.0" resolutiondate="2018-03-14 11:37:08.0" votes="0" watches="1" workflowId="40290"> <description><! CDATA LSCC upgrade is subjected to custom validation performed by ValidateLSCCInvocation. In particular the following is the piece of code executed during validation of the LSCC upgrade.    {code:java} case lscc.UPGRADE: /**************************************************************/ /* security check 1 - cc in the LCCC table of instantiated cc */ /**************************************************************/ if !ccExistsOnLedger { return fmt.Errorf("Upgrading non-existent chaincode %s", cdsArgs.ChaincodeSpec.ChaincodeId.Name) }  /*****************************************************/ /* security check 2 - check the instantiation policy */ /*****************************************************/ pol := cdLedger.InstantiationPolicy if pol == nil { return fmt.Errorf("No installation policy was specified") } // FIXME: could we actually pull the cds package from the // file system to verify whether the policy that is specified // here is the same as the one on disk? // PROS: we prevent attacks where the policy is replaced // CONS: this would be a point of non-determinism err = vscc.checkInstantiationPolicy(chid, env, pol, payl) if err != nil { return err }  /**********************************************************/ /* security check 3 - existing cc's version was different */ /**********************************************************/ if cdLedger.Version == cdsArgs.ChaincodeSpec.ChaincodeId.Version { return fmt.Errorf("Existing version of the cc on the ledger (%s) should be different from the upgraded one", cdsArgs.ChaincodeSpec.ChaincodeId.Version) } }  {code} In particular, what is checked is if the chaincode requested to be upgraded has already been instantiated in the channel based on the current ledger state, and that the instantiation policy of the chaincode to be upgraded is satisfied by this transaction's creator. Additional checks exist to ensure that the write set included in the LSCC upgrade transaction are consistent with the ledger state and the proposal header and payload.  The checks here need to be enhanced upon proper capabilities flag for 1.1 is switched on so as to ensure that:  - name of the chaincode does not change during the upgrade  - instantiation policy of the chaincode does not change or — if this is not the case — that the instantiation policy of the upgraded chaincode is satisfied by its invokers.  - write set caused by init invocation (i.e., having the namespace of the instantiated chaincode) would need to satisfy the endorsement policy of the instantiated chaincode (ADDRESSED BY LIFECYCLE ENHANCEMENTS INTENDED FOR 1.2).  The latter is to take place for deploy and upgrade.  ></description> </Issue>
