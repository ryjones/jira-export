<Action id="65263" issue="40566" author="sykesm" type="comment" body="Note the genesis file has been overloaded to enable late join - a config block from futher in the chain that is used to then begin pulling from another orderer at the start of the chain." created="2019-11-04 16:19:32.0" updateauthor="sykesm" updated="2019-11-04 16:19:32.0"/>
<Action id="65306" issue="40566" author="sykesm" type="comment" body="https://gerrit.hyperledger.org/r/c/fabric/+/34251 Add &quot;none&quot; as a valid orderer genesis method" created="2019-11-05 21:17:59.0" updateauthor="sykesm" updated="2019-11-05 21:17:59.0"/>
<Action id="68229" issue="40566" author="kopaygorodsky" type="comment" created="2020-03-04 22:46:51.0" updateauthor="kopaygorodsky" updated="2020-03-07 13:05:10.0"> <body><! CDATA  ~sykesm  is None option allowing to receive config block of a system channel from other ordering nodes? Your note says it overloads genesis file, is it what I'm thinking?  Case:   #1 org wants to add another one to an existing network. #2 org shares MSP config to #1 + ordering url with certs (GenesisMethod: None)  #1 adds #2 to the system channel #2 orderer will receive chains from #1 using comm.delivery and start working.  ----- I tried to use none on #2 orderer and running #1 haven't sent anything to #2.  `Failed to send StepRequest to 2, because: aborted channel=testchainid node=1`  Documentation says you need to provide latest config block to a new ordering node, but how could #2 receive chains if it hasn't joined the network yet?   ></body> </Action>
<Action id="68273" issue="40566" author="kopaygorodsky" type="comment" created="2020-03-10 19:00:16.0" updateauthor="kopaygorodsky" updated="2020-03-10 19:00:16.0"> <body><! CDATA Response:  "it's a placeholder for future work that adds support to bootstrap an orderer without a system channel In the future you should be able to create a genesis block of an application channel and then give it to an orderer node and it will start servicing this channel Currently, channel creation is done by sending a transaction to the system channel and then it creates a new application channel stay tuned for more updates"  ></body> </Action>
