<Action id="55331" issue="36263" author="mastersingh24" type="comment" created="2019-01-05 14:56:46.0" updateauthor="mastersingh24" updated="2019-01-05 14:56:46.0"> <body><! CDATA The actual error is thread exhaustion as the program hits the 10000 OS thread limit:   {code:java} runtime: program exceeds 10000-thread limit fatal error: thread exhaustion{code}  ></body> </Action>
<Action id="55335" issue="36263" author="mastersingh24" type="comment" created="2019-01-05 15:29:04.0" updateauthor="mastersingh24" updated="2019-01-05 15:29:04.0"> <body><! CDATA   {code:java} grep "^goroutine " query_block.log | perl -npe 's/\d+/n/' | sort | uniq -c     1 goroutine n  IO wait, 109 minutes :    3 goroutine n  IO wait, 2 minutes :    1 goroutine n  IO wait, 68 minutes :    2 goroutine n  IO wait :    1 goroutine n  chan receive, 109 minutes :    2 goroutine n  chan receive, 2 minutes :    4 goroutine n  chan receive, 68 minutes :    1 goroutine n  chan receive, 89 minutes : 316 goroutine n  runnable :    1 goroutine n  select, 108 minutes :   24 goroutine n  select, 109 minutes :   14 goroutine n  select, 2 minutes :   17 goroutine n  select, 68 minutes :    1 goroutine n  select, 88 minutes :   17 goroutine n  select, 89 minutes : 6636 goroutine n  select :    4 goroutine n  semacquire, 2 minutes : 2339 goroutine n  semacquire :    8 goroutine n  sleep :    1 goroutine n  syscall, 109 minutes : 306 goroutine n  syscall : {code}    ></body> </Action>
<Action id="55337" issue="36263" author="mastersingh24" type="comment" body=" ~sykesm   - would you mind taking a look at this one when you get a chance?  " created="2019-01-05 15:32:04.0" updateauthor="mastersingh24" updated="2019-01-05 15:32:04.0"/>
<Action id="55349" issue="36263" author="denyeart" type="comment" body="I think the question is, how to protect peer from a denial of service attack from a client sending thousands of requests." created="2019-01-06 18:48:40.0" updateauthor="denyeart" updated="2019-01-06 18:48:40.0"/>
<Action id="55378" issue="36263" author="sykesm" type="comment" created="2019-01-07 18:23:56.0" updateauthor="sykesm" updated="2019-01-07 18:23:56.0"> <body><! CDATA > I think the question is, how to protect peer from a denial of service attack from a client sending thousands of requests.  A: throttle at admission  We can use server interceptors and a counting semaphore to implement that.  As for where these threads are coming from, they're almost certainly a result of how we interact with the block storage. Every time a syscall is made from go (e.g. os.OpenFile, os.File#ReadAt), the M (machine/native thread) associated with the G (go routine) is blocked and a new M proc is allocated. These M's are never released.  So, IMO, we need to things to come out of this:  1. A throttle for the grpc server (comm or peer) 2. An investigation into whether or not there are easy optimizations we can make in fsblkstorage to reduce the number of OpenFile calls that are made. This is a secondary issue.  ></body> </Action>
<Action id="55422" issue="36263" author="sykesm" type="comment" created="2019-01-08 22:12:12.0" updateauthor="sykesm" updated="2019-01-08 22:12:12.0"> <body><! CDATA notes:  We probably need to extend this a bit further. Initially I had hoped to have two throttles - global and per connection. That's a bit difficult to implement correctly without a resource leak.  ></body> </Action>
