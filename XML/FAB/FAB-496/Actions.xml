<Action id="19092" issue="12797" author="kchristidis" type="comment" created="2016-10-03 09:03:15.0" updateauthor="kchristidis" updated="2016-10-03 09:09:43.0"> <body><! CDATA Following up on the Kafka discussion in Slack, and how they do it --  The rebalancing mechanism is the closest we have to this. I'll make some simplifications to keep it close to our model.  # The partition in Kafka is what we call a channel/blockchain. Assume a single partition. # The consumer group is what we call a peer, i.e. in our case we deal only with consumer groups of size one. # Consequently, every peer in our system is also a group leader. # The relevant change is the addition or removal of an ordering service node. This maps to changing the number of brokers in the cluster.  Let's assume that the addition/removal of a broker results in changing the leader of the partition. (This may not always be the case, hence us making this assumption explicit.)  Then:  # The cluster controller (a broker tasked with managing the set of brokers) catches wind of that via ZK and notifies all affected brokers ("you are now the leader of this partition", "you and you and you are now followers of it".) # Every consumer group is assigned to a group coordinator, a broker that coordinates who-consumes-what in that group. That group coordinator sends a message to the group leader and lets it know that a rebalancing is in place. "This is the partition we have, this the new leader, and these are its followers. Please decide which consumer will own the partition in your group and let me know." # The group leader gives the assignments to the group coordinator, and the coordinator sends to every consumer in the group its assignment. In our case with a single partition and one consumer per group, this exchange is a bit silly -- it comes down to the group leader saying "OK I will now consume the partition from the new leader", sending this to the group coordinator and getting it back. # After receiving the new assignment from the group coordinator, the group resumes the consumption of messages from the brokers. (This means that during this rebalancing the brokers stop handing out messages.)  If more details are needed, let me know.  ></body> </Action>
<Action id="19093" issue="12797" author="jyellick" type="comment" created="2016-10-03 14:32:29.0" updateauthor="jyellick" updated="2016-10-03 14:32:29.0"> <body><! CDATA So, to summarize at an extremely high level, the brokers agree on the change  because ZK tells them of the change.  The brokers then coordinate directly with the consumers to handle the re-balancing.  Hopefully that is correct, but please correct me if I'm wrong.  My follow up question would be:  How do the broker's communicate this to the consumers at a protocol level?  Is this done on a side channel? Is it embedded in the message stream and then abstracted out to the client?  ></body> </Action>
<Action id="19096" issue="12797" author="kchristidis" type="comment" created="2016-10-03 17:23:40.0" updateauthor="kchristidis" updated="2016-10-03 17:23:40.0"> <body><! CDATA The high-level overview is right. The answer to your follow-up question: Kafka uses TCP to multiplex requests (consumer->broker) and responses (broker->consumer). There can be several ways to communicate the need to rebalance but a common one is: the coordinator responds to the client's (periodical) heartbeat request with an error, the client parses this as a signal that it should restart the join group process, so it immediately stops fetching messages, and send a join group request, etc.  Let me know if you have more questions.  ></body> </Action>
<Action id="22413" issue="12797" author="christopherferris" type="comment" body=" ~jyellick   ~kchristidis  if this is no longer relevant, please mark WONTFIX and close thanks" created="2017-04-14 01:03:29.0" updateauthor="christopherferris" updated="2017-04-14 01:03:29.0"/>
