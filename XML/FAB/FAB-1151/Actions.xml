<Action id="21661" issue="13484" author="yacovm" type="comment" created="2017-03-27 18:20:03.0" updateauthor="yacovm" updated="2017-03-27 19:06:17.0"> <body><! CDATA {quote}Potentially the secret write set could be written directly to Gossip memory cache, so that it is readily available for non-endorsing peers to retrieve.{quote} I don't think we should think in this high granularity. Gossip has message caches for delivery and they are maintained regardless of the message types.  Validation phase: {quote}therefore efficiencies can be built into the gossip to retrieve a batch of secret write sets, potentially an entire blocks worth of secret write sets.{quote} Although that's true, I don't see a reason to gossip them as blocks: * If the Wset is disseminated without the corresponding "non-secret" block sequence number - you have no way of grouping secret transactions into blocks because you do not have the block sequence number yet. * If the Wset is disseminated with the corresponding "non-secret" block sequence number - it means you have waited until the block was created in the ordering service and then reached your peer. This, is a very dangerous thing to do because your peer might die until that happens and they you're left with blocks with "zombie" transactions in them (transactions that have hash, and no corresponding secret plaintext)  If you mean to gossip them in a single batch associated to the same transaction then it's a good idea.   I actually think that latency is much more important here than efficiency* at the first stage* and we can optimize if we see performance problems.   First and foremost, I think that write sets need to be batched as transactions (secret transactions) and maybe even signed by the endorsing peer.  *So for the rest of the comment if I say secret transaction I meant a batch of secret Wsets in the same Txn*  The thing that worries me here, is the flow of the validation: (d) says more or less:  *if the FLAG is set for a k-v pair in the Wset (i.e primary), retrieve the secret value either from (i) locally (piece of cake) or from (ii) some peer that endorsed the transaction, whether directly, or transitively.* So, (ii) is a problem because it may never happen. That peer might be dead and didn't have a chance to send to anyone its transaction. The main reason for this is actually not that you're out of luck but rather that the peer that endorsed might have not even known you at the time of endorsement, and therefore- didn't send the transaction message to *anyone*. I haven't thought of that for too long at the time of writing the comment, but an approach that springs to my mind is that could help is: * Always send transactions to multiple endorsers, for redundancy. * Somehow, send to the endorser the number of endorsers that the transaction was sent to. If the peer's gossip layer doesn't know anyone else in the channel from some reason, but you actively tell the peer that it should have known at least another peer, it gives that peer a sanity check and perhaps some countermeasures needs to be applied in such a case- for example- the peer will deny an endorsement if you send it one with private data, and tell in the request that it needs to know another 2 peers, and it actually doesn't know any peer at all, etc.  I also have a question- what happens now when you get a block (from what I remember from the code) is that you immediately go over its transactions and mark some as valid and some are not, right? Here, it is suggested to halt the commit until all private data for transactions with flags has reached the peer.  Perhaps it's worth to save the block in any case to the disk, without committing it to the state DB, and: whenever a secret transaction comes: * Put it into the tempDB just like you were doing for a transaction endorsed from you  * Search in the blocks you saved on disk for this transaction, and whenever you finally get a block that you can find for each FLAGGED transaction in that block- a corresponding transaction in tempDB - only then you commit that block to the stateDB?  I think it can be more efficient from a distributed system convergence point of view.  {quote}4.	Irrespective of the transaction state (valid/invalid), we preserve the secret write-set in the private temp DB in case other committers still need it. {quote} So, I think we should be able to _link_ between gossip and this stateDB somehow, and we have to do it anyway because we currently only gossip ledger blocks which are signed by the ordering service.  For a transaction endorsement I think a gossip broadcast needs to be used (invocation of the Gossip API call) that performs a best effort dissemination to the target audience of peers. Now, for synchronizing secret data between peers I think the following approach should be employed: * If the transaction has a corresponding block, you batch it with other transactions that have a corresponding block, and use the existing state transfer mechanism that exists now. I guess we'll need to somehow flag the messages as "for secret data" but it's not an issue from what I think * If the transaction doesn't have a corresponding block, you don't use state transfer but instead you use the existing pull mechanism (I can elaborate if needed, but it's outlined  here|https://github.com/hyperledger/fabric/blob/master/gossip/gossip/algo/pull.go#L29-L45 . The messages in the pull "cache" can expire in a peer after it gets a new block committed, because that ensures that these messages can be transferred via state transfer.  {quote}3.1. Gossip of private write-sets How to handle scenarios when private data write-sets cannot be retrieved from remote peers. Is there a precedent for gossip timeouts and error handling that can be used here?{quote} I am wondering, if something can be done in case you got a block and didn't get the corresponding secret transactions for that block for a long time. The transaction has the endorsement inside, which has the identity of the peer. Perhaps, you could use that in order to directly contact that peer and ask for its stuff in tempDB? ( ~C0rWin  ?  what do you think?)  {quote}It was assumed above that private data should be copied to all non-endorsing peers on the channel (via gossip).  However, there may be use cases where the private data should not be made available to all peers on the channel. Two options are possible:{quote} Generally- I guess it's possible to have a custom different routing policy in gossip for secret messages, but - who sets the restriction, who signs it, and- do the peers that are not in the privileged group know about this? because otherwise... they'd keep begging other peers for secret data won't they? Personally- I think this needs to be solved via having 2 different channels, and 2 transactions from the client SDK instead of 1.    ></body> </Action>
<Action id="21665" issue="13484" author="denyeart" type="comment" created="2017-03-27 20:51:53.0" updateauthor="denyeart" updated="2017-03-27 20:52:21.0"> <body><! CDATA  ~yacovm   I have updated the document per your comments.   bq. Potentially the secret write set could be written directly to Gossip memory cache, so that it is readily available for non-endorsing peers to retrieve.  Removed from document now, just wanted to run the idea of updating temp DB and 'priming' the gossip cache during endorsement.  bq. therefore efficiencies can be built into the gossip to retrieve a batch of secret write sets, potentially an entire blocks worth of secret write sets.  Removed. And yes, write sets would be gossiped at the transaction level, e.g. a block with 5 secret transactions would get gossiped as 5 items, each having 1 to N key updates in the transaction's write-set.  About the concerns with private transactions not being gossiped, or not being gossiped quick enough - I share those concerns as being a primary risk, and added your ideas to the document's Open Questions section so that we can iterate them there.  bq. 4. Irrespective of the transaction state (valid/invalid), we preserve the secret write-set in the private temp DB in case other committers still need it.   Are you suggesting we attempt to gossip the secret data at endorsement time to non-endorsers, with the assumption that the non-endorsers will need it eventually?  That will certainly help to minimize delays at validation/commit time.  And is actually in line with my idea of 'priming' the gossip at endorsement time.  On your other two bullets, yes, I was thinking if the block already exists, that the block and private write-sets could be gossiped together. That is in line with my idea of batching transactions associated with a block, if a peer has all of them.  I'd suggest go ahead and update the document directly with these proposed gossip details, since you can explain it better than me.  bq. It was assumed above that private data should be copied to all non-endorsing peers on the channel (via gossip). However, there may be use cases where the private data should not be made available to all peers on the channel. Two options are possible:  I agree the idea of subchannels solves many of the same problems as channels themselves, therefore it may be better to simply handle this via existing channel design. If we do move forward with it, I was thinking the subchannel membership would be done in a config transaction just like channel membership.  The peers that are not in the privileged group would be aware of this and would not ask other peers for the secret data.  ></body> </Action>
<Action id="21666" issue="13484" author="yacovm" type="comment" created="2017-03-27 21:49:33.0" updateauthor="yacovm" updated="2017-03-27 21:49:33.0"> <body><! CDATA {quote}Are you suggesting we attempt to gossip the secret data at endorsement time to non-endorsers, with the assumption that the non-endorsers will need it eventually? That will certainly help to minimize delays at validation/commit time. And is actually in line with my idea of 'priming' the gossip at endorsement time.{quote} Of course. All peers are committers, right? They would need these Wsets very soon- once the block would be sent to them. If you can send them the Wsets before that, there isn't a problem since the block would get to them unless the client crashes (and if it does- then you can clean up the tempDB, right?)  {quote}I'd suggest go ahead and update the document directly with these proposed gossip details, since you can explain it better than me.{quote} Will do (I guess tomorrow) and send you. This needs to be carefully thought, because if we want to gossip signed Wsets, we need to represent the Wset batch of a transaction as a tuple of Txn id and peer identifier, but for blocks of such transactions we'd also need not only the sequence number of the block, but also a *set* of peer IDs (because, if the block has been committed, it means the validation policy has been satisfied, and this means we got a threshold signature, right?)  {quote}I agree the idea of subchannels solves many of the same problems as channels themselves, therefore it may be better to simply handle this via existing channel design{quote} {quote} Each subchannel group has access to private data associated with the subchannel. Whereas channels define which organizations can share/maintain chains, subchannels define which organizations can share/maintain which private data alongside the chain.  For example Subchannel A members have access to private data relating to A keys, while Subchannel B members have access to private data relating to B keys.  A data will only be gossiped to A members, B data will only be gossiped to B members.  {quote} This doesn't list an option, this list a wanted feature and doesn't say how it is to be implemented in fabric. We currently have channels and we know how they work. We don't have sub-channels and it is not clear to me how they are to be implemented should we choose this option.  Now, for option 1: {quote}As part of channel membership configuration, a flag can indicate which organizations should receive private data and which organizations should not. Peers and the gossip layer would honor the configuration.  Additionally, for peers that do not have access to private data, chaincode privateData APIs would not be available.  That is, these peers could not act as endorsers for transactions working with private data.{quote} This is somewhat similar to how gossip works at the moment: We have a list of organizations of a channel at each point of time. We route channel-related messages based on whether a peer in question belongs to an org in the channel or not, while for blocks we also do a more strict check- we consult the channel readers policy for the peers.  I guess, a similar thing can be done here, but it needs to be defined where this information (which organizations are eligible) is taken from, how is it signed, and who decides on it, etc.  ></body> </Action>
<Action id="21673" issue="13484" author="denyeart" type="comment" created="2017-03-28 11:10:44.0" updateauthor="denyeart" updated="2017-03-28 11:10:44.0"> <body><! CDATA  ~yacovm  Agreed, we can start gossiping write-sets at endorsement time, we dont have to wait until commit time.  This is what I was alluding to when I wrote that endorsement should update gossip, in addition to writing to the local temp db. And yes, we will have a way to clean up orphaned temp db entries regardless.  I didn't follow all your comments about signatures required in gossip. Partially because I don't understand existing gossip security and state transfer. I guess update the doc with your gossip design aspects and then maybe it will become clear.  Concerning the options to restrict private data to select peers, these are not in plan currently and as you mention not designed yet.  They are just add-on ideas for consideration at this point.  If it is determined that these are important aspects, we'll move forward to the design phase, and will likely need help from Jason and others on the configuration design aspects. At a high level, I was thinking it would be similar in nature to existing channel membership configuration design.  I'll let you add gossip design to the document, before I make any further changes.  ></body> </Action>
<Action id="21682" issue="13484" author="denyeart" type="comment" created="2017-03-28 16:01:42.0" updateauthor="denyeart" updated="2017-03-28 16:01:42.0"> <body><! CDATA  ~yacovm  ~C0rWin  Here is the document in google docs for collaboration: https://docs.google.com/document/d/1OOoE062XMsZr-T5S-JvxG7ujkU10dipx9r1CCBqi8NE/edit  ></body> </Action>
<Action id="21702" issue="13484" author="yacovm" type="comment" created="2017-03-28 20:43:34.0" updateauthor="yacovm" updated="2017-03-28 20:43:34.0"> <body><! CDATA {quote}I'll let you add gossip design to the document, before I make any further changes.{quote} I don't think that a gossip-aspect design should be added at this stage, until we discussed this internally and thoroughly. The things I outlined here were merely to help point out problems and concerns, not to plan/design it.  {quote}I didn't follow all your comments about signatures required in gossip. Partially because I don't understand existing gossip security and state transfer. I guess update the doc with your gossip design aspects and then maybe it will become clear.{quote} I can elaborate and it'll be clear why I want to sign: * The task that the gossip layer needs to do is: given K endorsers for the same transaction, you want to disseminate K secret Wset sets * Each such a set, can be batched into a message, identified by the TxId and the peer that endorsed this. * When a peer in the channel receives such a message, it needs to know whether this message indeed came out of the endorser, or that some byzantine peer tricked you, and for example- changed some value, or omitted a Wset from the batch, etc. etc. * These problems above can only be discovered later on, after it passes gossip to the validation layer of the peer, therefore- making it hard to protect against, and fix. * If we sign the batches with the endorsers, the only possibility of attack is having the endorser itself byzantine- but, there is no reason for it to even send the message in the first place.   ></body> </Action>
<Action id="22023" issue="13484" author="elli-androulaki" type="comment" created="2017-04-10 11:30:42.0" updateauthor="elli-androulaki" updated="2017-04-10 11:31:38.0"> <body><! CDATA Hi,  ~denyeart   ~yacovm   So a few questions/comments on the deck: - you mention that the relationship between the data stored on the side db and the data stored on the blockchain (e.g., hash, keyed-hash, ciphertexts / encryption keys) may vary. For some of these scenarios you may need to access the data from the sideDB directly, i.e., without having some evidence or commitment being stored on the blockchain state db. For this, we would need to extend the db access API to allow for direct access to the sideDB, no? - given the above point, it may make sense to work on libraries that would leverage this sideDB for these three cases at least:  1. Hashes of state values go to the blockchain, pre-images to the sideDB 2. Keyed-hashes of state values go to the blockchain, pre-images and hash key go to the sideDB 3. Ciphertexts of state values go to the blockchain, keys are stored to the sideDB 4. Hashes of ciphertexts of the data go to the blockchain, ciphertexts, and decryption keys stored to the sideDB - proposals referring to queries to the sideDB could also merit special access control mechanisms  - confidentiality of sideDB content; from what I understand it may be that not all peers participating in a channel should have the same content within their sideDB. However peers who see a tx on the blockchain should be able to tell whether there is sideDB content associated to this tx that the peers should receive, and peers who have received an update should be able to verify such an update, and filter out which peers it should be sending it too. For this there can be an additional policy defined at chaincode instantiation time, defining the set of entities (peers or clients) that should be able to receive sideDB updates referring to a chaincode. Gossip propagation mechanism of sideDB content could consult such policies.  Adding  ~marko.vukolic , ~ales , ~adc .   ></body> </Action>
<Action id="22057" issue="13484" author="yacovm" type="comment" created="2017-04-10 20:31:10.0" updateauthor="yacovm" updated="2017-04-10 20:31:10.0"> <body><! CDATA {quote}and peers who have received an update should be able to verify such an update, and filter out which peers it should be sending it to{quote} You mean- to know which peers, out of the peers they know- are eligible of receiving such updates?  {quote} For this there can be an additional policy defined at chaincode instantiation time, defining the set of entities (peers or clients) that should be able to receive sideDB updates referring to a chaincode. Gossip propagation mechanism of sideDB content could consult such policies.{quote} My only concern here is that all your policy frameworks, work with signature verification. That means, that (unless optimizations of memoizations are employed) gossip would need to verify signatures when they do these routing decisions.  Currently we have similar things for channels, but only for blocks.  Now, when you increase the granularity for chaincodes- that makes it much more signature verifications, no?  ></body> </Action>
<Action id="23832" issue="13484" author="baohua" type="comment" created="2017-05-13 02:19:00.0" updateauthor="baohua" updated="2017-05-13 02:19:00.0"> <body><! CDATA This design will help protect data leakage at the orderer side, and also enhance the protection in peer side.  At the sdk sides, we need support of adding an option to specify the tx confidence level.  e.g., raw to use normal db, while hash, encrypted to use other types of db.  ></body> </Action>
<Action id="24307" issue="13484" author="denyeart" type="comment" created="2017-05-25 11:34:07.0" updateauthor="denyeart" updated="2017-05-25 11:34:07.0"> <body><! CDATA  ~C0rWin   Manish has created a repository to collaborate on the Side DB work: https://github.com/manish-sethi/fabric-sidedb This repo has three branches 1) master 2) sidedb-dev 3) manish-sidedb-dev  Following is the plan: - We will not submit anything to the master branch and will keep this in sync with hyperledger master. - We would submit the pull requests to sidedb-dev branch and will merge after review - manish-sidedb-dev is a personal branch for Manish  Others would need to do the following: - create a fork from the above repo - delete the branch manish-sidedb-dev from your fork - push your changes to sidedb-dev in your fork - create a PR on sidedb-dev in the above repo in my area  ></body> </Action>
<Action id="26051" issue="13484" author="pvrbharg" type="comment" created="2017-06-12 18:29:39.0" updateauthor="pvrbharg" updated="2017-06-12 18:29:39.0"> <body><! CDATA This is bvperepa@us.ibm.com - an IBMer @ customer giving voice to customer requirements. We believe this capability to be of interest to my customer use case today. I need the following assumptions and understandings clarified:  A)  The above capability enables Peer N and Peer N+1 for any arbitrary N value to engage in a private conversation on the side that can not be understood by any other peers in the network other than Peer N and Peer N+1. At the same time, in the same scope/context of Ledger/Channel/Peer Node Visibility/policies, other peers can engage in private side conversations in parallel and concurrently - such as Peer N+1 & Peer N+2, with this conversations  not accessible to Peer N (non-transitive). The private conversations are taking place in parallel and concurrently - in the context of ledger/channel/peer members on channel/ledger/policies. If so - we have a need for this capability with my customer use case today.  B)  This concept of Side DB - Private Channel Data has some context and overlap with Quorum's private transactions??   https://github.com/jpmorganchase/quorum/wiki/QuorumChain-Consensus      Any clarifications or explanations are welcome. Thanks.  ></body> </Action>
<Action id="26107" issue="13484" author="baohua" type="comment" created="2017-06-13 02:57:47.0" updateauthor="baohua" updated="2017-06-13 02:57:47.0"> <body><! CDATA bhargav, thanks for the feedback from customers.  This side db design is actually to help protect the tx content from orderers, which only require tx id info to offer the ordering result.  Similar design idea was seen (even in bitcoin network) to only put encrypted data on chain, instead of everything.  ></body> </Action>
<Action id="27389" issue="13484" author="vdods" type="comment" created="2017-06-26 20:23:07.0" updateauthor="vdods" updated="2017-06-26 20:37:34.0"> <body><! CDATA It seems like there are two independent concerns here:  1) privacy of ledger keystore values  2) external storage of data (using a hash of said data for data provenance/validation as described in the design doc)     In this proposal, it seems like they're coupled, but they don't need to be – I would suggest decoupling them, as there are use cases where one might want each possible combination:  Neither 1 nor 2) This is what we have now, and should obviously be kept available.  1 but not 2) Storage of private data but that must be kept in the blockchain, say for later decryption, or for regulatory audit.  My company is personally interested in this specific configuration.  2 but not 1) Storage of non-sensitive data that's deemed too large to be kept within the chain itself, but still needs to be verified via the hashing scheme.  My company is personally interested in this specific configuration.  1 and 2) Storage of sensitive data such that no "adversarial" peers have access to it, even though it's encrypted – this is what is being proposed in the design document, as far as I understand.  My company is personally interested in this specific configuration.     Thus there would be two independent configuration flags for storing/retrieving/deleting data:  1) private (i.e. encrypted)  2) external     ></body> </Action>
<Action id="29496" issue="13484" author="christopherferris" type="comment" body="This has the requisite 5 maintainer votes and can proceed." created="2017-08-07 16:36:04.0" updateauthor="christopherferris" updated="2017-08-07 16:36:04.0"/>
<Action id="29516" issue="13484" author="andrasfe" type="comment" created="2017-08-07 23:48:06.0" updateauthor="andrasfe" updated="2017-08-07 23:48:06.0"> <body><! CDATA  ~baohua  , you mentioned in your comment to Bhargav that the goal is strictly to protect info from orderers. My understanding is that it does not only protect data from orderers, but also from subset peers. Also sensitive data is not present on the blockchain.      Please correct me if I'm wrong.     thanks!!  ></body> </Action>
<Action id="29517" issue="13484" author="andrasfe" type="comment" body="Also, it appears that Quorum offers a higher level of granularity, as transaction visibility can be set at the time of smart contract invocation, by specifying select nodes that would have access. What would be the proposed solution for such need?" created="2017-08-07 23:56:59.0" updateauthor="andrasfe" updated="2017-08-07 23:56:59.0"/>
<Action id="29978" issue="13484" author="denyeart" type="comment" created="2017-08-17 23:52:28.0" updateauthor="denyeart" updated="2017-08-17 23:52:28.0"> <body><! CDATA Collaboration on the design has been ongoing here:   https://docs.google.com/document/d/1ShrgrYPWLznZSZrl5cnvmFq9LtLJ3tYUxjv9GN6rxuI/edit# |https://docs.google.com/document/d/1ShrgrYPWLznZSZrl5cnvmFq9LtLJ3tYUxjv9GN6rxuI/edit    Due to the evolution of collaboration the document itself has become somewhat messy.  I intend to draft a shorter more cohesive document now that the design is stabilizing.        ></body> </Action>
<Action id="41356" issue="13484" author="denyeart" type="comment" created="2018-03-08 12:18:23.0" updateauthor="denyeart" updated="2018-03-08 12:18:23.0"> <body><! CDATA Marking as Done as experimental feature in 1.1.  Promoting to a production feature will be tracked in FAB-8718.  ></body> </Action>
