<Action id="45522" issue="30879" author="srh666666" type="comment" body="Yeah,I also meet this question.  It should be a  fabric bug.  Any suggestions?" created="2018-06-05 09:28:20.0" updateauthor="srh666666" updated="2018-06-05 09:28:20.0"/>
<Action id="45546" issue="30879" author="denyeart" type="comment" body=" ~manish-sethi  Could you take a look?" created="2018-06-05 20:37:51.0" updateauthor="denyeart" updated="2018-06-05 20:37:51.0"/>
<Action id="45559" issue="30879" author="manish-sethi" type="comment" body=" ~luoguohui ,  ~srh666666 ,  ~denyeart  - yes, I confirmed in the code and this is a bug in the interactions of call path of qscc and commit path. I&apos;ll think of a solution and submit a fix to both 1.1 and 1.2 branches. It may take a couple of days though." created="2018-06-06 03:40:23.0" updateauthor="manish-sethi" updated="2018-06-06 03:40:23.0"/>
<Action id="45617" issue="30879" author="manish-sethi" type="comment" created="2018-06-06 21:45:51.0" updateauthor="manish-sethi" updated="2018-06-06 21:54:34.0"> <body><! CDATA To add more details to it...  Ledger exposes two set of APIs one set of APIs relate to state reads and manipulation and the other set of APIs relate to querying the blockchain status (such as `{color:#000000}GetBlockByNumber` and `{color}{color:#000000}GetTransactionByID`). The first set of APIs are exposed via transaction simulator and (are meant for a chaincode to use during transaction simulation) and the second set of API are exposed as a direct APIs in the ledger interface (and are meant for clients to know the ledger status).{color}  {color:#000000} Keeping the above in mind, a tacit assumption in the ledger design has been that a single gorouting limits it's usage to one of the above set of APIs exclusively. A chaincode limits itself to state related APIs and a ledger status querying client would not need to create a simulator.{color}  {color:#000000}However, on the higher layers, since the ledger status related APIs are exposed via chaincode (`qscc`, to be specific), the above assumption is broken. The execution path for answering the ledger status queries obtains a transaction simulator before it reaches the qscc code (which has no use in fact, of the transaction simulator).{color}  {color:#000000}More specifically, an additional constraint on these two sets of APIs relates to the fact that two independent external calls to any of the ledger API should give a perceived notion of atomic commit to the block storage and the state. For instance, this should not happen that a client queries the API `{color}{color:#000000}GetBlockchainInfo` and finds out that block number 10 is committed but when he submits a subsequent state query, the query returns the state as of block 9 (because, the state update for block 10 are still pending). This is implemented by a pair of locks One lock syncs the state between simulation and statedb commit and another syncs the ledger status related calls with the overall commit. This is done for achieving better performance by halting the simulation to a minimum (only when the updates are actually been dumped to the disk) at the cost of ledger status related queries. Because, the qscc takes a transaction simulator, the above mentioned interaction leads to the reported deadlock. I believe that going forward, one of the suggestions was to expose these ledger status related APIs via grpc interface which will fix this issue. However, I list below three options for completeness...{color} * {color:#000000}qscc path not to take hold of a transaction simulator (which is desired otherwise also, as the transaction simulator is an expensive resource as it takes a read lock on the statedb to sync with commit and hence should be taken only for transaction simulations).{color} * {color:#000000}An alternate fix could be to implement the above mentioned perceived notion of atomic commit to the block storage and the state by a coarser level single lock but that will impact the throughput an not a desired solution.{color} * {color:#000000}Implement the perceived notion of atomic commit yet differently.. which requires some significant work in the interaction between ledger storage and the statedb. In nut shell, exposing the ledger storage a two phase commit. In first step, we append the block and then in the second step, update the BlockchainInfo and blockindexes sunchronized with statedb updates.{color}  {color:#000000}Given, the above, since the first one is anyway desired, my suggestion would be fix that for 1.1 and 1.2. {color}  {color:#000000}Though, the third option can be taken up post 1.2. However, to take a note specifically, the third option won't add much value as such other than the fact that the wrong usage of APIs (such as the transaction simulator in the qscc) will not lead to deadlock situation.. which I am not sure is a good thing or bad (as unintended usage go undetected){color}  ></body> </Action>
<Action id="45619" issue="30879" author="manish-sethi" type="comment" body="Removing myself from the assignee till we decide on the potential fix... including  ~sykesm  in loop for his comments on chaincode related aspect" created="2018-06-06 22:04:35.0" updateauthor="manish-sethi" updated="2018-06-06 22:39:39.0"/>
<Action id="45623" issue="30879" author="denyeart" type="comment" created="2018-06-07 03:47:16.0" updateauthor="denyeart" updated="2018-06-07 03:47:16.0"> <body><! CDATA I would tend to agree that there is no reason for QSCC to be implemented as chaincode, since it doesn't interact with chaincode state data. It does seem more appropriate for the block and transaction APIs to be simple peer grpc APIs rather than chaincode.  The complete refactoring of QSCC would be a larger change, perhaps for v2.0.  For v1.x releases, would it be possible for the system chaincodes that don't interact with chaincode state to not get a handle to transaction simulator, since it doesn't use it anyway?   ~sykesm  , since you have been taking on peer/chaincode refactoring, what do you think?  ></body> </Action>
<Action id="45742" issue="30879" author="sykesm" type="comment" created="2018-06-08 21:50:55.0" updateauthor="sykesm" updated="2018-06-08 21:50:55.0"> <body><! CDATA {quote}since you have been taking on peer/chaincode refactoring{quote}  To be clear, I have not taken on any real refactoring; I have not been given that opportunity due to other requirements (eg. test) and lack of resources (no team). The only refactoring that has occurred is in chaincode support - which has nothing to do with how the ledger is managed or the locking that's done.  {quote}what do you think?{quote}  I believe that the current design of system chaincode is problematic. It makes little sense to treat all core pieces of the system as "chaincode" but that has been the design goal for much of the history of fabric. To that end, I agree that replacing qscc with a grpc service is not going to happen without significant planning and on a release boundary.  {quote}would it be possible for the system chaincodes that don't interact with chaincode state to not get a handle to transaction simulator, since it doesn't use it anyway?{quote}  Probably. The simulators are created in the endorser and just flow through the chaincode layer. (Even though it seems like a bad idea, the endorser already has special cases for lscc and deployment.) Most of the references to the simulator look conditional so it might work without any changes.  Regardless, this is something someone familiar with the endorser should be looking through. As far as I can tell, all of the locking that's taking place is between the ledger and endorser.  It's also interesting the the RLock being acquired out of GetTransactionByID was recently added in commit #f17d1d934c /  FAB-7595  at the end of the 1.1 cycle to address a race. So, where there was one lock (in the tx manager), now there are two. This is recent.   ~manish-sethi  ~denyeart  Seems like an offline discussion is needed on this as that would be much more effective than assigning to various people to comment on.  ></body> </Action>
<Action id="45744" issue="30879" author="sykesm" type="comment" body="Setup 15 minute discussion for Monday." created="2018-06-08 22:00:42.0" updateauthor="sykesm" updated="2018-06-08 22:00:42.0"/>
<Action id="45789" issue="30879" author="manish-sethi" type="comment" body="After the offline discussion with  ~sykesm , its decided that  ~yacovm  /  ~muralisr  may like to take a call on this." created="2018-06-11 15:31:53.0" updateauthor="manish-sethi" updated="2018-06-11 15:31:53.0"/>
<Action id="45792" issue="30879" author="sykesm" type="comment" body="To be clear, option 1 (skip acquisition of tx simulator for qscc) seems the most straightforward tactical approach but I&apos;m wary of unintended side effects; someone with more context should weigh in." created="2018-06-11 15:41:03.0" updateauthor="sykesm" updated="2018-06-11 15:41:03.0"/>
<Action id="45799" issue="30879" author="yacovm" type="comment" created="2018-06-11 19:45:27.0" updateauthor="yacovm" updated="2018-06-11 20:10:12.0"> <body><! CDATA So  ~manish-sethi  basically the scenario is: # *T1*: Block is committed and *A* is locked for *write* # *T2*: QSCC "transaction" arrives, *B* is locked for *read* # *T2*: QSCC fails to obtain *read* lock on *A* since it's held by *T1* # *T1*: State updates can't start because they wait for *write* lock on *B* which is held by *T2*  ? {quote}but I'm wary of unintended side effects; someone with more context should weigh in. {quote} I can't say I have more context, but I think that what  ~denyeart  said is pretty much accurate: {quote}system chaincodes that don't interact with chaincode state {quote} We have 2 of these - QSCC and CSCC (ESCC and VSCC are.... "not invokable" ;) so we're safe) From a quick glance on QSCC - it just interacts with the ledger and CSCC just writes or reads references to the peer, but it can be nice if  ~jyellick  can also take a look since he implemented some of the stuff that CSCC invokes transitively.  So I think that if we not grab the tx simulator at the endorser for cscc and qscc we should be good.    ~denyeart  : {quote}I would tend to agree that there is no reason for QSCC to be implemented as chaincode, since it doesn't interact with chaincode state data. It does seem more appropriate for the block and transaction APIs to be simple peer grpc APIs rather than chaincode. {quote} You mean a gRPC service like  the one we almost had|https://gerrit.hyperledger.org/r/#/c/15107/ ? ;)  ></body> </Action>
<Action id="45800" issue="30879" author="yacovm" type="comment" created="2018-06-11 19:49:44.0" updateauthor="yacovm" updated="2018-06-11 19:49:44.0"> <body><! CDATA oh... and - last but not least...  ~denyeart  this incident seems to me like a perfect addition to SVT suite - invoke all SCCs during heavy block commit, so we have cases like this covered.  + We might also want to do a similar thing with private data, no? Induce a heavy commit load and do endorsements of private data at the same time (but not send them to the orderer, to not prolong the commit time and thus increase the lock/unlock rate)     wdyt?  ></body> </Action>
<Action id="45802" issue="30879" author="manish-sethi" type="comment" created="2018-06-11 19:52:51.0" updateauthor="manish-sethi" updated="2018-06-11 20:03:35.0"> <body><! CDATA {quote} # *T1*: Block is committed and *A* is locked for *write* # *T2*: QSCC "transaction" arrives, *B* is locked for *read* # *T2*: QSCC fails to obtain *read* lock on *A* since it's held by *T1* # *T1*: State updates can't start because they wait for *write* lock on *B* which is held by *T2*  {quote}  yes  ~yacovm  - this is correct and as you said further, the (2) above is unnecessary.  ></body> </Action>
<Action id="45803" issue="30879" author="yacovm" type="comment" body=" ~luoguohui  - very nice catch and thank you very much for the find. " created="2018-06-11 20:03:15.0" updateauthor="yacovm" updated="2018-06-11 20:03:15.0"/>
<Action id="45831" issue="30879" author="jyellick" type="comment" created="2018-06-12 14:19:57.0" updateauthor="jyellick" updated="2018-06-12 14:19:57.0"> <body><! CDATA > From a quick glance on QSCC - it just interacts with the ledger and CSCC just writes or reads references to the peer, but it can be nice if Jason Yellick can also take a look since he implemented some of the stuff that CSCC invokes transitively.  All of the channel config stuff is immutable and updated without locks, so no issues with the 'transitively invoked' stuff.  ></body> </Action>
<Action id="45846" issue="30879" author="clayton sims" type="comment" body=" ~yacovm    does ownership of fixing this go to Yacov?   " created="2018-06-12 18:52:19.0" updateauthor="clayton sims" updated="2018-06-12 18:52:19.0"/>
<Action id="45847" issue="30879" author="yacovm" type="comment" body="It does *not*, and it should be a pretty straight forward *fix*. Anyone can do it..." created="2018-06-12 19:04:19.0" updateauthor="yacovm" updated="2018-06-12 19:04:19.0"/>
<Action id="45874" issue="30879" author="clayton sims" type="comment" body="ok lets make sure we have someone fixing it.   what component is the fix" created="2018-06-13 13:58:17.0" updateauthor="clayton sims" updated="2018-06-13 13:58:17.0"/>
<Action id="45904" issue="30879" author="sykesm" type="comment" body="https://gerrit.hyperledger.org/r/c/23039/" created="2018-06-13 19:47:41.0" updateauthor="sykesm" updated="2018-06-13 19:47:41.0"/>
<Action id="45940" issue="30879" author="jyellick" type="comment" body="The fix has been merged for v1.2, leaving open to track the needed fix for v1.1.1" created="2018-06-14 17:20:31.0" updateauthor="jyellick" updated="2018-06-14 17:20:31.0"/>
<Action id="46021" issue="30879" author="denyeart" type="comment" body=" https://gerrit.hyperledger.org/r/#/c/23043/  is the CR for v1.1.1." created="2018-06-16 14:12:59.0" updateauthor="denyeart" updated="2018-06-16 14:12:59.0"/>
<Action id="46026" issue="30879" author="denyeart" type="comment" body="Merged in master (v1.2) and release-1.1." created="2018-06-16 17:45:34.0" updateauthor="denyeart" updated="2018-06-16 17:45:34.0"/>
<Action id="49271" issue="30879" author="zerppen" type="comment" body=" ~sykesm   It maybe result in another bug,please check and test." created="2018-08-23 02:21:49.0" updateauthor="zerppen" updated="2018-08-23 02:21:49.0"/>
<Action id="49277" issue="30879" author="sykesm" type="comment" created="2018-08-23 09:27:31.0" updateauthor="sykesm" updated="2018-08-23 09:27:31.0"> <body><! CDATA > It maybe result in another bug  I agree. As such, please open a separate issue instead of reopening one that has been resolved and includes a test.  Thanks.  ></body> </Action>
