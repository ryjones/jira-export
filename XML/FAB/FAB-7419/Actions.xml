<Action id="36601" issue="25112" author="jeffgarratt" type="comment" created="2017-12-11 22:40:20.0" updateauthor="jeffgarratt" updated="2017-12-11 22:48:43.0"> <body><! CDATA  David Enyeart|https://jira.hyperledger.org/secure/ViewProfile.jspa?name=denyeart , I disagree with your additions to the pro's list as follows:    * From client perspective, consistent with new block Deliver API interaction pattern (consumability)     I would disagree.  Per the con, the parameter supplied is not consistent with the orderer deliver API.  Someone who submits the same request to the orderer and the peer will NOT get the same expected results.  We will need to document this difference and explain why, which I believe will be difficult to justify.    * Built-in peer API support for typical client tx pattern (async tx submission and listen for tx validation/invalidation status).     This functionality is pre-existing per the already merged deliver functionality.  If however you mean just the TX and status, then this is encapsulated in the first PRO bullet point of "If the current Eventhub subscription model....", in which case this would be redundant as a PRO.    * No external components/applications need to be bolted on for typical client tx pattern - reduces complexity/risk; improves performance/testability/maintainability.     Non of the pro's or cons in the original description form as a comparison with any alternative solution.  They were made within the context of this design.  I would also disagree with you on almost every aspect of your qualitative assessments.  How does this reduce complexity?  How is risk reduced?  How is maintainability improved? How is testability improved? Performance I will not debate, but I can not with certainty tell you one option will be more performant than the other.  ></body> </Action>
<Action id="36606" issue="25112" author="c0rwin" type="comment" created="2017-12-12 07:48:02.0" updateauthor="c0rwin" updated="2017-12-12 07:53:59.0"> <body><! CDATA This is sounds ok to me as pretty aligned with the comments inside initial proposal FAB-7069, which I think should linked and mention here in description.   {quote} No audit trail in ledger of filtered messages delivered to clients {quote}  I do not think this is listed as a requirement, hence not a cons at all, moreover I do not think this is good idea to store filtered messages trace inside the ledger, looks like an overhead, so I would state that not having audit trail is rather a pros in that sense.  {quote} supports control of ACL and selection of preexisting (hard-coded) filters, but filters cannot be edited nor can new filters be defined through configuration {quote}  Again, proposed approach is fully aligned with current implementation and if you think we should support editing or insertion of new filters, IMO it's worth open additional JIRA item and discuss it there as completely separate feature request.   {quote} I would disagree.  Per the con, the parameter supplied is not consistent with the orderer deliver API.  Someone who submits the same request to the orderer and the peer will NOT get the same expected results.  We will need to document this difference and explain why, which I believe will be difficult to justify. {quote}  This is incorrect, if you submit same request to the orderer or to the peer will experience exactly the same behavior. Unless I'm missing something, but if you think there are differences could you please elaborate? The only difference I could imagine is with respect to the filtered content which no one expect to be supported by ordering service and therefore I liked  ~kchristidis  proposal outlined in comments for FAB-7069 that mitigates this difference by wrapping around original delivery API.  ></body> </Action>
<Action id="36607" issue="25112" author="yacovm" type="comment" body="Why do we need an audit trail in the peer side? What are we trying to accomplish? There is no way to prove that the client received a message without the client signing it (or recprding the TLS traffic, right?) anyway. If the peer is not byzantine we dont need an audit trail because it is honest, and if the peer is byzantine then it may just write there whatever it wants without the client having a say in it" created="2017-12-12 08:01:52.0" updateauthor="yacovm" updated="2017-12-12 08:01:52.0"/>
<Action id="36618" issue="25112" author="christopherferris" type="comment" created="2017-12-12 11:44:48.0" updateauthor="christopherferris" updated="2017-12-12 11:44:48.0"> <body><! CDATA Why are we voting on an argument? Why are we voting at all? To the best of my understanding, there are still open switches, for starters.   Just to be clear, I am fine if we have an open discussion about design decisions... I just don't think that we should be voting... we should be coming to consensus. Then, barring that, we should be asking those on both sides if they can live with a proposal, or what it would take to get them to live with it (agree to disagree and move on).   ></body> </Action>
<Action id="36619" issue="25112" author="denyeart" type="comment" body=" ~jeffgarratt  If the logic is entirely encapsulated in a peer API, rather than spread across peer API and bolted-on applications, there are less moving parts to coordinate and synchronize, which in my opinion reduces complexity/risk, and improves performance/testability/maintainability. I&apos;ve clarified description.  I didn&apos;t think that would be a controversial assertion, but people are free to disagree." created="2017-12-12 11:51:09.0" updateauthor="denyeart" updated="2017-12-12 11:53:34.0"/>
<Action id="36620" issue="25112" author="denyeart" type="comment" body=" ~ChristopherFerris  The intent is to come to consensus on general approach (API vs external application) and then depending on the general approach complete the more detailed design (e.g. use Block proto or a more streamlined proto for txid / status).  Comments are the best way to provide feedback and build consensus, an upvote is just an easy way to indicate agreement." created="2017-12-12 12:18:10.0" updateauthor="denyeart" updated="2017-12-12 12:18:10.0"/>
<Action id="36628" issue="25112" author="jeffgarratt" type="comment" created="2017-12-12 14:29:05.0" updateauthor="jeffgarratt" updated="2017-12-12 14:30:54.0"> <body><! CDATA  ~C0rWin   """This is incorrect, if you submit same request to the orderer or to the peer will experience exactly the same behavior. Unless I'm missing something, """     You will not.  The orderer will NOT send you the filtered version of blocks.    ></body> </Action>
<Action id="36629" issue="25112" author="jeffgarratt" type="comment" created="2017-12-12 14:33:13.0" updateauthor="jeffgarratt" updated="2017-12-12 14:33:13.0"> <body><! CDATA  ~C0rWin        """I do not think this is listed as a requirement, hence not a cons at all,"""     This changes the current behavior of deliver in that we have an audit trail of all messages delivered to the client in the channel.  ></body> </Action>
<Action id="36630" issue="25112" author="c0rwin" type="comment" created="2017-12-12 14:41:38.0" updateauthor="c0rwin" updated="2017-12-12 14:41:38.0"> <body><! CDATA {quote} """This is incorrect, if you submit same request to the orderer or to the peer will experience exactly the same behavior. Unless I'm missing something, """  You will not.  The orderer will NOT send you the filtered version of blocks.   {quote}  What I meant to say is that is you will send same message as it defined right now it will be supported out of box, of course new filtering capabilities will not, this is why I think  ~kchristidis  proposal is the best option which combines two proposed solutions.   {quote} """I do not think this is listed as a requirement, hence not a cons at all,"""  This changes the current behavior of deliver in that we have an audit trail of all messages delivered to the client in the channel. {quote}  I must be missing that part, but what audit trail do we currently have? Can you give an example?  ></body> </Action>
<Action id="36701" issue="25112" author="jeffgarratt" type="comment" body=" ~C0rWin  our deliver is tantamount to Amazon&apos;s deliver operation, that is to say, Amazon would never take a package as it is going out the door and remove some items (without log) then send it as they would have no way to verify what was delivered." created="2017-12-12 15:43:59.0" updateauthor="jeffgarratt" updated="2017-12-12 15:43:59.0"/>
<Action id="36803" issue="25112" author="jeffgarratt" type="comment" created="2017-12-12 17:16:12.0" updateauthor="jeffgarratt" updated="2017-12-12 17:16:12.0"> <body><! CDATA I am concerned that the current design does not meet the requirements as currently documented in  https://jira.hyperledger.org/browse/FAB-7088  Will add comments here asap.  ></body> </Action>
<Action id="37010" issue="25112" author="jeffgarratt" type="comment" created="2017-12-12 22:27:52.0" updateauthor="jeffgarratt" updated="2017-12-12 23:16:22.0"> <body><! CDATA With respect to https://jira.hyperledger.org/browse/FAB-7419  Considering the context of the feature as defined in https://jira.hyperledger.org/browse/FAB-7088     A) If there are multiple organizations in the channel (a pre condition not currently defined), then I believe the feature cannot be satisfied as written using the solution proposed here.  The config admin of channel 'A' can NOT individually configure the filter assuming a majority style admin policy, as they would need a signature of at least one of the other members. The only remedy I can conceive of is to redefine the feature, which would cause me pause as the adjustment of requirements per the design is troubling.     B) It appears possible that in the situation of multiple organizations in a channel with a chaincode with a endorsement policy of ALL orgs, that  the majority could decide to create/redefine the filter and still acquire endorsement from all organizations, while changing what the uninvolved member's clients would receive (a filtered block) without notice possibly causing their applications to fail, while additional transactions can continue to be added with their peer's endorsement.  The only current remedy I could conceive is to detect this state, and then remove oneself from the channel or proactively shut down the peer.     Issue B in my mind would force me to question my desire to involve myself as a member organization of the network.  ></body> </Action>
<Action id="37023" issue="25112" author="denyeart" type="comment" created="2017-12-13 05:57:29.0" updateauthor="denyeart" updated="2017-12-13 05:57:29.0"> <body><! CDATA  ~jeffgarratt  I do not believe that FAB-7088 as written is the gospel, nor FAB-5481 that came before it, as these were simply re-interpretations of the original requirement.  The original requirement that triggered all these ideas was captured in FAB-3134, and it doesn't specify anything about how the requirement would be implemented or how the configuration would be governed.  The exact mechanics of the proposed API ACL approach have not been ironed out, but from the FAB-7069 discussion it sounded like the general framework would be as follows:  ACL for channel-scoped APIs would be managed on resource config tree for the channel, implying a configurable mod_policy for each resource's access control. Different levels of filtered content within channel-scoped APIs could be modeled as different resources.  Access control changes for a given resource would require a config transaction meeting the mod_policy for that resource. When a specific level of filtered content was requested via an API call at runtime, it would be checked against the access control for that resource and fail if not met, returning an error rather than dynamically altering the response as B suggests.  I believe the concerns A and B would be addressed via the modification policy.   ~jyellick  and  ~ales  , please keep me honest with respect to API ACL configuration on resource config tree and modification policies. We've discussed that API ACL (FAB-3621) in general needs to be finalized/documented, now that the resource config tree is available. I believe that needs to be done for API ACL in general, regardless of the current event filtering design discussion.     ></body> </Action>
<Action id="37046" issue="25112" author="jeffgarratt" type="comment" created="2017-12-13 13:55:04.0" updateauthor="jeffgarratt" updated="2017-12-13 13:55:04.0"> <body><! CDATA  ~denyeart  from https://jira.hyperledger.org/browse/FAB-3134 -> """This is required for fabric deployers that require confidentiality such that the ledger is restricted to the peers."""     How do I accomplish this in the context of multiple organizations in the channel?  ></body> </Action>
<Action id="37048" issue="25112" author="denyeart" type="comment" body=" ~jeffgarratt  The ACL policies can reference organizations, OUs, role types (clients vs peers vs orderers as of FAB-5664), and individual identities.  And then the mod policy for the ACL dictates which combination of organizations/roles is required to change the ACL.  This is consistent with all the other API ACLs that are already in place.   To answer the specific question, if you want peers to have full access to ledger but want clients to have restricted access, you would issue clients certs with &apos;client&apos; OUs and then restrict &apos;client&apos; OUs in the resource ACLs.  I&apos;m not an expert in this space though, we&apos;d need to talk to   ~adc  /  ~ales  if you&apos;d like to go deeper." created="2017-12-13 14:16:29.0" updateauthor="denyeart" updated="2017-12-13 14:17:07.0"/>
<Action id="37059" issue="25112" author="kchristidis" type="comment" created="2017-12-13 15:35:08.0" updateauthor="kchristidis" updated="2017-12-13 15:35:08.0"> <body><! CDATA Assume channel {{foo}} with member orgs {{Org1}}, {{Org2}}, {{Org3}} in its {{Admins}} group. Member org {{Org4}} is not an administrator but has full read/write access (I.e. belongs to the channel's {{Readers}} and {{Writers}} group).  Who is the client that receives the filtered events here?  We take FAB-3134 as our starting point and want to generalize as possible.  Here are all the options I see: # It's one of the member orgs with full read/write access. # It's a client org ({{Org5}}) that's tied to the hip with one of the orgs with full read/write access to the channel. {{Org5}} is not trusted to read {{foo}}. # As above but client {{Org5}} is not tied to the hip with any of the orgs and distrusts all of them equally.  (The latter two options are related to FAB-3621.)  Any other option I'm missing?  For all the options above, can we identify what could constitute a sensible default for: # the recipient policy, and # the {{mod_policy}} for the {{DeliverWithFilter}} API.  (Put differently: express in terms of policies who can invoke the API, and how this rule can be modified.)  If the recipient is a member org with full read access, any {{mod_policy}} that doesn't include the explicit approval of said member org makes this API useless. This is what Jeff is touching on with the example in point B.  If it's option 2, why don't we let the member org that enjoys the full trust of client {{Org5}} set up their own filter in a separate channel, as FAB-7367 suggests, and invite client {{Org5}} over? (There are potential drawbacks to FAB-7367, as there are in this very proposal that I co-authored right here, and I'll get to those but let's take it one step at a time.)  If it's option 3: * How does FAB-7367 play out? Does {{Org5}} hope that a quorum of member orgs in {{foo}} set up their own notification/filter channels and invite {{Org5}} over? (And then {{Org5}} needs to monitor them all for fear of censorship?) * How does this proposal here play out? The {{mod_policy}} for the API is set to {{foo}}'s {{Admins}}, and the API can be invoked by a set that includes {{Org5}}? Does this sound right? But if it does, how does this affect my trust issues? (I'm {{Org5}}.) The member org's peer I'm connected to (for the {{DeliverWithFilter}} API call) can easily censor an event. Which means I either issue this API request to one peer and hope for the best (i.e. I "trust" this member org and fall back to Option 2), or I issue this API request to multiple member orgs, which is exactly what one would do in FAB-7367.  So if I'm getting this right, there's no scenario in which this proposal has an edge over FAB-7367. (The one undeniable drawback of the application-based approach is latency.)  ></body> </Action>
<Action id="37063" issue="25112" author="jeffgarratt" type="comment" created="2017-12-13 16:25:10.0" updateauthor="jeffgarratt" updated="2017-12-13 16:25:10.0"> <body><! CDATA  ~denyeart  , you say...   {quote}I do not believe that FAB-7088 as written is the gospel, nor FAB-5481 that came before it, as these were simply re-interpretations of the original requirement.  The original requirement that triggered all these ideas was captured in FAB-3134, and it doesn't specify anything about how the requirement would be implemented or how the configuration would be governed.{quote}   Could you explain to me in which way FAB-7088 does NOT fully encapsulate the stated requirement from FAB-3134         """There needs to be a mechanism to restrict block events and block events with RW sets to a subset of clients and/or disable."""   or in which way it expands it in which you disagree?  ></body> </Action>
<Action id="37068" issue="25112" author="denyeart" type="comment" created="2017-12-13 17:50:54.0" updateauthor="denyeart" updated="2017-12-13 18:32:27.0"> <body><! CDATA  ~kchristidis  Thanks for the detailed analysis.  Now that I understand where you (and  ~jeffgarratt ) are coming from, it seems that you are fundamentally against peer API ACLs in general that limit client access.  That is, you disagree with the underlying feature:  {{FAB-3621 As a member of a network who runs a peer, I want to be able to support clients who transact with the network with a limited scope of permissions}}  For example, I assume you would make the same argument that GetBlockByNumber API should not be access controlled in peer, but rather in an application in front of peer.  I think you have valid debate points against FAB-3621, but ones which were already considered earlier in the release.  FAB-3621 was debated, approved, developed, and demonstrated earlier in 1.1 release.  With that understanding, FAB-7419 proposed to utilize similar access control mechanism for Deliver content.  It would be inconsistent to have access control in peer for some APIs, but in external applications for other APIs.  If you want to re-visit the decision about limiting client access in peer APIs, I think the place to bring that up would be in FAB-3621.  Kostas wrote:  >>Any other option I'm missing?   Yes, you are missing from the analysis organizations that have different types of identities within the org.  For example an organization that maintains a peer in a secured environment (e.g. a hosting service), but has client applications and/or organizational units with more restricted access.  This is the pattern that drives user enrollments in CA, OU support, client vs peer vs orderer identities (FAB-5664), and FAB-3621 (taken together, major release themes for 1.1).      ~jeffgarratt  My problems with FAB-7088 are: * It is redundant with FAB-3621 in general. * It is specifically redundant with FAB-3134. * It is missing information about the core use case (submitting a transaction asynchronously and wanting to send back transaction status only) * It is phrased from the perspective of a channel admin, disregarding the existing resource config tree and governance provided by modification policy.     ></body> </Action>
<Action id="37078" issue="25112" author="jyellick" type="comment" created="2017-12-13 23:04:04.0" updateauthor="jyellick" updated="2017-12-13 23:04:04.0"> <body><! CDATA  ~denyeart  {quote}Jason Yellick and Alessandro Sorniotti , please keep me honest with respect to API ACL configuration on resource config tree and modification policies. We've discussed that API ACL (FAB-3621) in general needs to be finalized/documented, now that the resource config tree is available. I believe that needs to be done for API ACL in general, regardless of the current event filtering design discussion. {quote} Without attempting to take any stance on the issue at hand, I thought I would quickly try to chime in with respect to the resources tree.   To steal a comment from FAB-6147 (unrelated to this issue), the resources config is a good place to store information if: # The configuration is needed by all peers # The configuration may be jointly administered # The configuration is channel scoped # The configuration requires total order relative to other transactions  For ACLs, (1)/(3)/(4) are fairly obviously satisfied. All peers have these functions which should be protected (1), the ACLs are scoped by channel (3), and the current state of the channel (such as its membership) is important (4).  The biggest question is (2), should ACLs be jointly administered? Should an org require permission from the entire network to modify ACLs for its clients? If not, how does the network have assurances that the org only modifies the policy for its clients and not for the whole network? This is very much the question which was asked by the channel configuration for the orderer {{Broadcast}} and {{Deliver}} interfaces. Each org should usually be able to determine which of its clients are authorized to use these services, but no org should be able to lock the others out by itself. To satisfy these requirements, the channel config defines a hierarchy of policies, such that the {{/Channel/Readers}} is the union of {{/Channel/Orderer/Readers}} and {{/Channel/Application/Readers}}, which are in turn unions of the {{Readers}} policies for the respective orgs. In this way each org may always modify its subset of the union, while not being able to harm other orgs.  For the resources tree, the individual ACL API entries are simply references to policies defined elsewhere in the tree. And, the default values for these references are the default policies in the channel config. For a network which wishes to implement more fine grained ACLs, they will likely need to construct a policy hierarchy similar to the channel config which meets their needs. At some point, we may wish to supply a default hierarchy, but this has not been discussed.  So, to quickly summarize. Policies in the resources tree can be configured in such a way that some higher threshold is required to modify the base policy, with individual orgs being able to independently manage subsets of policy. Today there are no defaults, and this hierarchical policy style must be implemented manually, unless you utilize the defaults in the channel config. Perhaps in the resources tree, it would make more sense to require that _all_ admins agree to set the base policy (rather than a majority) so that in order to break an org's ACLs, the org must effectively be ejected from the network.  ></body> </Action>
<Action id="37608" issue="25112" author="muralisr" type="comment" created="2017-12-18 23:19:38.0" updateauthor="muralisr" updated="2017-12-18 23:19:38.0"> <body><! CDATA Seems to me the biggest concerns around embedding filtered events in fabric were around ACL support. Let me try to clarify this with an example (pretty much using the above comment from  ~jyellick  as basis).  Currently there are predefined resources such as PROPOSAL (who can send proposals to create TXs). These have 1.0 defaults based on ChannelReaders and ChannelWriters but can be modified by sending a config tx using configtxlator and some manual JSON editing.  We will add a new DELIVER_BLOCK and DELIVER_FILTERED_BLOCK resources for this item.  Lets say user defines the following policies Policy Name - TRANSACTORS, Maps to - Org1.Admin || Org2.Admin  || Org1.Member || Org2.Member Policy Name - BLOCK_NOTIFICATION, Maps to - Org1.Admin || Org2.Admin  Transaction and transaction notification use TRANSACTORS policy {code:java} DELIVER_FILTERED_BLOCK,PROPOSAL ===>  TRANSACTORS {code}  Block events use BLOCK_NOTIFICATION policy {code:java} DELIVER_BLOCK, QSCC.GetBlockByNumber, QSCC.GetBlockByHash, QSCC.GetTransactionByID, QSCC.GetBlockByTxID ====> BLOCK_NOTIFICATION {code} The idea is that one can easily create conceptual policies (TRANSACTORS, etc) that all resources for that concept to satisfy. In particular, those who create TXs should be able to read those TXs.   The above address how the resources and policies can be used to control broad ACL requirements.  *If we are saying "other channel orgs should not control what my peer can read", it seems to me the argument is actually much more general than for "filter events". I can easily see it apply to any "reads". ie, "this is my peer, why should the channel impose restrictions via ChannelReaders ? I can understand we need to control what goes in via ChannelWriters but I own the data on my peer and I control who I give it to... ie, we should not apply any channel based ACL on ANY read operations".  So if we are making that argument, that's got to be taken to a level higher than "filtered events" to any sort of "read".*   *(Of course the prima facie counter to that is the read policies control to all peers in the channel, not just "my" peer.)*  *The above seems to be close to what*  ~denyeart  *wrote "If you want to re-visit the decision about limiting client access in peer APIs, I think the place to bring that up would be in* FAB-3621*." ... but is actually stronger than that, as it basically says any read ACLs should then be completely outside channel, ie, not even the pre 3621 ChannelReaders policies exercised around reads.*   ~jeffgarratt   ~kchristidis   (and  ~jyellick  based on the previous comment) do let me know if I'm missing something or if I got everything completely wrong :) ?  ></body> </Action>
<Action id="37611" issue="25112" author="denyeart" type="comment" created="2017-12-19 03:42:54.0" updateauthor="denyeart" updated="2017-12-19 03:42:54.0"> <body><! CDATA As it looks like the approach in Description here is consistent with approved/implemented feature FAB-3621, work will proceed here to implement event filtering in peer on top of Deliver API.   ~C0rWin  has kicked things off with  https://gerrit.hyperledger.org/r/#/c/16179/  .  ></body> </Action>
<Action id="37632" issue="25112" author="c0rwin" type="comment" created="2017-12-19 15:05:15.0" updateauthor="c0rwin" updated="2017-12-19 15:05:39.0"> <body><! CDATA Implementing required functionality I've realized that adding a new {{DeliverWithFilter}} API to handle {{FilteredBlock}} events, makes me to repeat most of the code which already exist and tested within {{Deliver}} API, therefore in my CR  ~denyeart  mentioned above I'm suggesting much simpler solution with extension of {{SeekInfo}} proto message to differ between whenever we should be returning a normal block versus filtered blocks. After all there are only about 10 lines of code added into {{Handle}} message to take care of this.   While this is diverges from the details in description I think this allows to leverage existing code, since I believe this was main motivation of moving events producer to reuse deliverer code. Feedback/thoughts are welcome:  ~jyellick ,  ~kchristidis ,  ~denyeart ,  ~yacovm ,  ~mastersingh24 .  ></body> </Action>
<Action id="37906" issue="25112" author="c0rwin" type="comment" created="2018-01-02 20:27:35.0" updateauthor="c0rwin" updated="2018-01-02 20:29:41.0"> <body><! CDATA Since I've proposed the CR to address the current ticket, https://gerrit.hyperledger.org/r/#/c/16179/, while implemented an alternative approach which I'd describe in more details so we can make any further progress.  The main motivation behind FAB-7069, was to enable code reuse since there are common logic between delivery protocol of {{AtomicBroadcast}} service and the events producer. In order to facilitate reuse there was a atomic broadcast implementation was introduced for peer side, e.g.:  {code} type server struct { 	dh deliver.Handler }  // Broadcast is not implemented/supported on a peer func (s *server) Broadcast(srv ab.AtomicBroadcast_BroadcastServer) error { 	return srv.Send(&ab.BroadcastResponse{ 		Status: common.Status_NOT_IMPLEMENTED, 	}) }  // Deliver sends a stream of blocks to a client after commitment func (s *server) Deliver(srv ab.AtomicBroadcast_DeliverServer) error { 	logger.Debugf("Starting new Deliver handler") 	defer func() { 		if r := recover(); r != nil { 			logger.Criticalf("Deliver client triggered panic: %s\n%s", r, debug.Stack()) 		} 		logger.Debugf("Closing Deliver stream") 	}() 	return s.dh.Handle(srv) }  // NewAtomicBroadcastServer creates an ab.AtomicBroadcastServer based on the // ledger Reader. Broadcast is not implemented/supported on the peer. func NewAtomicBroadcastServer(timeWindow time.Duration, mutualTLS bool) ab.AtomicBroadcastServer { 	s := &server{ 		dh: deliver.NewHandlerImpl(DeliverSupportManager{}, policies.ChannelReaders, timeWindow, mutualTLS), 	} 	return s } {code}   where there deliver handler is a core component which is being reused:  {code} 	s := &server{ 		dh: deliver.NewHandlerImpl(DeliverSupportManager{}, policies.ChannelReaders, timeWindow, mutualTLS), 	} {code}   which is also used for ordering service as well. Now the only difference between the delivering blocks and delivering filtered blocks is the following:  {code} 		if err := sendBlockReply(srv, block); err != nil { 			logger.Warningf(" channel: %s  Error sending to %s: %s", chdr.ChannelId, addr, err) 			return err 		} {code}  while for {{FilteredBlock}} we need to replace this by something like following:  {code} 		if err := sendFilteredBlockReply(srv, block); err != nil { 			logger.Warningf(" channel: %s  Error sending to %s: %s", chdr.ChannelId, addr, err) 			return err 		} {code}  in order to differentiate whenever we need to deliver block and filtered we just need to extend {{SeekInfo}} with enum to differ type of information we would like to receive at deliver. The above turns to be less intrusive than  adding separate API which seems to re-implement most of the already existing logic this also important considering client side which will only need to add support to handle the new enum field of {{SeekInfo}} message.  ></body> </Action>
<Action id="37907" issue="25112" author="c0rwin" type="comment" body="In addition to support this change I&apos;ve opened following FAB-7521, since we need to differentiate how we treat policy lookup at peer and orderer side. Since at peer side we need to use resource name to lookup policy name based on it and then binary policy itself, while on ordering service there is no notion of resources and we simply need to use policy name to lookup binary policy rule. Here is the CR which implements required change to support correct policy lookup based on whenever we are using delivery API on peer vs ordering service. https://gerrit.hyperledger.org/r/#/c/16341/" created="2018-01-02 20:33:24.0" updateauthor="c0rwin" updated="2018-01-02 20:33:24.0"/>
<Action id="37908" issue="25112" author="yacovm" type="comment" created="2018-01-02 22:21:25.0" updateauthor="yacovm" updated="2018-01-02 22:21:25.0"> <body><! CDATA {quote}While this is diverges from the details in description I think this allows to leverage existing code, since I believe this was main motivation of moving events producer to reuse deliverer code. Feedback/thoughts are welcome: Jason Yellick, Kostas Christidis, David Enyeart, Yacov Manevich, Gari Singh.{quote}  My opinion is that sending back to the client a regular common.Block that has only the filtered data, and doesn't have the rest of the data (i.e RWSets) is: # Awkward: The peer needs to unwrap the marshaled bytes, filter out the fields, then wrap it all back up, and then the client needs to unwrap each transaction again.  # Risky in terms of "security" bugs- What if we miss a field? What if the filtering has a bug? If we just send a data structure that only has the filtered fields in the first place, the compiler ensures that there is no information leakage.    ></body> </Action>
<Action id="37917" issue="25112" author="denyeart" type="comment" body="I agree with Artem&apos;s and Yacov&apos;s comments.  Reusing the API with a different SeekInfo for FilteredBlocks is a good compromise for maximum code reuse, which as Artem pointed out was the ultimate objective here.  And having a streamlined FilteredBlock proto (already merged) for just the filtered information will be more intuitive and usable for clients that just need the filtered information.  I am in support of CR  https://gerrit.hyperledger.org/r/#/c/16179/  approach." created="2018-01-03 11:58:42.0" updateauthor="denyeart" updated="2018-01-03 11:58:42.0"/>
<Action id="37920" issue="25112" author="kchristidis" type="comment" created="2018-01-03 14:45:15.0" updateauthor="kchristidis" updated="2018-01-03 14:45:36.0"> <body><! CDATA {quote}Reusing the API with a different SeekInfo for FilteredBlocks is a good compromise for maximum code reuse, which as Artem pointed out was the ultimate objective here.{quote}  The objective was to maximize code reuse while preventing any peer-specific information from leaking into the orderer. I do not get why we deviate from the design that we suggested when this issue was written up. The accompanying sketch is:  https://user-images.githubusercontent.com/14876848/33777738-f75a2ee2-dc13-11e7-88ba-09ed6d200be4.png   ></body> </Action>
<Action id="37975" issue="25112" author="c0rwin" type="comment" created="2018-01-03 22:54:30.0" updateauthor="c0rwin" updated="2018-01-03 22:54:30.0"> <body><! CDATA Well, that it's easy, simply because once you will follow scketch design most of the logic to handle incoming request to hold filtered event will re-do, almost most of the code which already exist inside {{deliver.NewHandlerImpl(...)}}. Also once this code being abstracted out and moved outside scope of the ordering service I do not see why you call it as leaking peer specific into orderer as now this is a common package which is capable to treat both the peer side and the orderer side. For example with current approach with Blocks delivery on peer vs ordering service, you still have to differentiate how you lookup the policy inside the peer versus how you do it for orderer, since for the peer you need to use resource name to lookup the policy name and then the policy itself, while on the orderer you just using the policy name. And this could be solved by a abstraction of policy name provider versus bringing a new RPC API to handle peer side block delivery.  BTW, I can redo the whole CR according to your sketch while I think this is a bit redundant as it will produce unnecessary portion of code, which could be simply reused since 99% already there and required feature could be implemented by small and non intrusive addition which closes the deal.  ></body> </Action>
<Action id="37978" issue="25112" author="kchristidis" type="comment" created="2018-01-04 00:06:07.0" updateauthor="kchristidis" updated="2018-01-04 00:06:07.0"> <body><! CDATA {quote}I do not see why you call it as leaking peer specific into orderer as now this is a common package which is capable to treat both the peer side and the orderer side. {quote} I say this because the ordering service does not do events/filters.  This solution will involve more code, but this is exactly the trade-off for maintaining the separation of concerns between the two binaries. We were (or at least, I was) aware of this from the get-go. (In fact, this is why I was asked to chime in on FAB-7069.)  Just for reference (though I know you don't need it), I whipped up a quick proof of concept for the sketch above:  https://github.com/kchristidis/nested   {{    common}}:{{orderer}} :: {{extended}}:{{events}}  So, by following the proposal put forth in this JIRA item, we build all of our custom processing logic in {{extended}}, and leave {{common}} as is.  ></body> </Action>
<Action id="37979" issue="25112" author="yacovm" type="comment" created="2018-01-04 00:16:56.0" updateauthor="yacovm" updated="2018-01-04 00:32:04.0"> <body><! CDATA What if we have 2 different protobuf definitions:  # The regular orderer service definition, which only delivers blocks # The peer service definition, which is what the peer has now in Artem's change set  If we have this, can't we still reuse code that is now in common? We would preserve the orderer API and the peer would be able to send blocks and events.  The only thing duplicated here is the proto schema, which is pretty cheap to duplicate, and the pb.go is machine-generated anyway.   ~kchristidis ,  ~C0rWin  wdyt?   Note - I do not mean here the translation approach that Kostas advocates, but simply taking the code in common and putting it in 2 different server-side method somehow  ></body> </Action>
<Action id="37989" issue="25112" author="c0rwin" type="comment" body=" ~yacovm  let me evaluate it and I will try to refactor based on your suggestion, will post here the update." created="2018-01-04 08:20:48.0" updateauthor="c0rwin" updated="2018-01-04 08:20:48.0"/>
<Action id="38004" issue="25112" author="rickr" type="comment" body="Is there a gerrit CS for this in progress ?  Can it be _cherrypicked_ and run against _(relatively complete)_ ?  If not, any ETA when it can be ?" created="2018-01-04 16:42:45.0" updateauthor="rickr" updated="2018-01-04 16:42:45.0"/>
<Action id="38005" issue="25112" author="rickr" type="comment" created="2018-01-04 16:46:16.0" updateauthor="rickr" updated="2018-01-04 16:46:16.0"> <body><! CDATA  https://gerrit.hyperledger.org/r/#/c/16179/  ?  SDK's start looking at ?  ></body> </Action>
<Action id="38259" issue="25112" author="c0rwin" type="comment" created="2018-01-08 00:07:40.0" updateauthor="c0rwin" updated="2018-01-08 00:08:21.0"> <body><! CDATA updated CR which keeps orderer code clean of leaking peer abstraction inside: https://gerrit.hyperledger.org/r/#/c/16645/  there is still UT which need to be added, will update once WIP will be removed.  ></body> </Action>
<Action id="38313" issue="25112" author="kchristidis" type="comment" created="2018-01-08 20:30:20.0" updateauthor="kchristidis" updated="2018-01-08 20:30:20.0"> <body><! CDATA Had a look at the latest changeset.  Is the underlying claim here that the sum of these two new changesets (https://gerrit.hyperledger.org/r/c/16569/ and https://gerrit.hyperledger.org/r/c/16645/) is both (a) a simpler approach, and (b) less LOC than the "nested server" approach that we originally put out?  I think I'm questioning (a) for one.The dancing we have to do in https://gerrit.hyperledger.org/r/c/16569/8/orderer/common/server/server.go for instance in order to accommodate a generalized Deliver API is giving me pause.  ></body> </Action>
<Action id="38315" issue="25112" author="rickr" type="comment" created="2018-01-08 20:37:38.0" updateauthor="rickr" updated="2018-01-08 20:37:38.0"> <body><! CDATA Not sure about the other SDKs but for Java grpc generates two streaming services for this. Making it rather painful.  Also with this there is no way the application to request Block or FilterBlock  and get Block if they're authorized and FilterBlock if they're not.      ></body> </Action>
<Action id="38319" issue="25112" author="c0rwin" type="comment" created="2018-01-08 21:31:33.0" updateauthor="c0rwin" updated="2018-01-08 21:31:33.0"> <body><! CDATA  ~kchristidis  {quote} Is the underlying claim here that the sum of these two new changesets (https://gerrit.hyperledger.org/r/c/16569/ and https://gerrit.hyperledger.org/r/c/16645/) is both (a) a simpler approach, and (b) less LOC than the "nested server" approach that we originally put out? {quote}  That is not the claim, they key point from my perspective is to being able (a) to enable proper code reuse for common parts, (b) provide clear abstraction and separation of concerns which I think was a main motivation behind the "nested server" approach. Currently I'm able to achieve both these points, deliver handler could be reused both to deliver a block events as well as the filtered events, while no peer abstraction is leaking into orderer code (same is also true for orderering code leaking into peer).  {quote} I think I'm questioning (a) for one.The dancing we have to do in https://gerrit.hyperledger.org/r/c/16569/8/orderer/common/server/server.go for instance in order to accommodate a generalized Deliver API is giving me pause. {quote}  The generalization of Deliver API enables us to reuse most of these code and separate the peer deliver abstraction from the orderer, which IMO more clear and open for future extensions, since peer related code for deliver could be extended w/o influencing the orderer side.  ></body> </Action>
