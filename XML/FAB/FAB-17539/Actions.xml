<Action id="68439" issue="44420" author="denyeart" type="comment" body=" ~yacovm  What&apos;s your opinion?" created="2020-03-19 04:47:54.0" updateauthor="denyeart" updated="2020-03-19 04:47:54.0"/>
<Action id="68445" issue="44420" author="yacovm" type="comment" created="2020-03-19 08:20:41.0" updateauthor="yacovm" updated="2020-03-19 08:20:41.0"> <body><! CDATA We could certainly export the 120 to be configurable, however this also has issues because unless you put something insanely high, it's hard to predict period of time to be disconnected.  As of 1.4.x (for some x i don't remember), peers no longer forget bootstrap peers, however this is pretty useless since what we really need gossip for, is inter-org communication, so we should have really done it for anchor peers ;)  This is the reason Leonid's peers gets isolated from one another.  I think the *best fix* would be to simply make the  Connect()|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery.go#L138  method which is used for both  anchor|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/gossip/gossip_impl.go#L258  peers and  bootstrap|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/gossip/gossip_impl.go#L1166  peers, add an endpoint to a set, which gossip will then check against when it decides to purge dead peers from memory or not.  ></body> </Action>
<Action id="68447" issue="44420" author="c0rwin" type="comment" created="2020-03-19 09:22:21.0" updateauthor="c0rwin" updated="2020-03-19 09:22:21.0"> <body><! CDATA > I think the best fix would be to simply make the Connect() method which is used for both anchor peers and bootstrap peers, add an endpoint to a set, which gossip will then check against when it decides to purge dead peers from memory or not.   This definitely make sense, so essentially you suggest to have list of non expendable peers which is never purged. I.e. each time we connect to an anchor or bootstrap we add them to that list, while during  ConfigUpdate where anchors are updated we also maintain that list accordingly.   I also do think that regardless this 120 should be externalized to configuration and might be use some exponential back off.  ></body> </Action>
<Action id="68449" issue="44420" author="yacovm" type="comment" created="2020-03-19 13:34:20.0" updateauthor="yacovm" updated="2020-03-19 13:34:45.0"> <body><! CDATA Yes, something along these lines.  Currently, peers are purged from the membership if they are dead for too long, to stop connecting to them.  If the peers are bootstrap peers, they are  not|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery_impl.go#L1055  purged.  I propose to replace this check, with a check of some set *continuousEndpoints* which will be expanded when this *Connect()* method is called.  In more details: The Connect() method is used for two types of peers: * Bootstrap peers: This is used  once|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/gossip/gossip_impl.go#L1166 , at the startup of the peer. * Anchor peers: This is used upon a config block update: The *GossipService* in *gossip/service* calls  JoinChan|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/service/gossip_service.go#L419  on the underlying *GossipImpl* in *gossip/gossip* which in turn calls  learnAnchorPeers|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/gossip/gossip_impl.go#L209  that  Connect()|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/gossip/gossip_impl.go#L258  on the discovery package. The discovery package itself tries to  connect|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery_impl.go#L139  to the said endpoint according to some criteria. Unlike the bootstrap peers, the anchor peers can be dynamically removed and added upon demand, so we would need to maintain the set of *continousEndpoints* at runtime, throughout the lifetime of the peer. To do what, I propose to add a new method to the  discovery interface|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery.go#L138 : *Disconnect(endpoint ... string)* which will be called with the old endpoints which are no longer in use as parameters. The old endpoints that are no longer in use, will be maintained per channel in the *GossipService* in *gossip/service* package. This will keep the discovery package channel-ignorant as it is now. Since several channels can point to the same anchor peer, and since we can have bootstrap peers that intersect with anchor peers, we can use simple reference counting- *Connect()* ing an endpoint will increase the count of the said endpoint by 1, and calling **Disconnect()* on it will decrease this counter (and if the number reaches zero then it will be removed from *continuousEndpoints*).     ></body> </Action>
<Action id="69478" issue="44420" author="yacovm" type="comment" created="2020-06-16 12:40:36.0" updateauthor="yacovm" updated="2020-06-16 12:40:36.0"> <body><! CDATA Another alternative option is to just maintain a set of *continousEndpoints* in the *gossip/service* struct since it has access to all  anchor peer updates|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/service/gossip_service.go#L397-L419 , and make this set to be the union of all endpoints across all channels.  This set will be exposed to the the membership layer via an interface *IsContinuous(endpoint string)* which the membership layer will just use to see if it should  purge the dead endpoint or not|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery_impl.go#L1055 .  ></body> </Action>
<Action id="69479" issue="44420" author="yacovm" type="comment" body="Also we&apos;d want to export  const msgExpirationFactor = 20|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/gossip/discovery/discovery_impl.go#L30  to be configurable while we&apos;re at it " created="2020-06-16 12:56:49.0" updateauthor="yacovm" updated="2020-06-16 12:56:49.0"/>
<Action id="69500" issue="44420" author="wenjian" type="comment" body="PR:  https://github.com/hyperledger/fabric/pull/1422 " created="2020-06-19 03:05:50.0" updateauthor="wenjian" updated="2020-06-19 03:05:50.0"/>
<Action id="70044" issue="44420" author="lmars" type="comment" created="2020-08-25 06:56:14.0" updateauthor="lmars" updated="2020-08-25 06:56:14.0"> <body><! CDATA Excuse me,  ~wenjian   ~yacovm  could you tell me how this PR fixes this bug?  I checked this PR and found that {{MaxConnectionAttempts = 120}} was preserved, so peer still stops the reconnection process after a few attempts?  ></body> </Action>
<Action id="70047" issue="44420" author="yacovm" type="comment" created="2020-08-25 09:32:56.0" updateauthor="yacovm" updated="2020-08-25 09:32:56.0"> <body><! CDATA Anchor peers are no longer pruned from memory, so a peer will never stop attempting to connect to an anchor peer.  By transitivity of gossip membership propagation + the fact that all peers know the same anchor peers they will re-establish membership once the network partition heals.   ></body> </Action>
<Action id="70048" issue="44420" author="lmars" type="comment" created="2020-08-25 09:59:40.0" updateauthor="lmars" updated="2020-08-25 09:59:40.0"> <body><! CDATA {quote}Anchor peers are no longer pruned from memory, {quote} Yes. Good. I found this change in this PR. :+1: {quote}so a peer will never stop attempting to connect to an anchor peer. {quote} Unfortunately, I couldn't found this. I checked {{Connect}} function, it is still finite. Could you point me, where is this function witch never stops connecting?!  ></body> </Action>
<Action id="70049" issue="44420" author="yacovm" type="comment" created="2020-08-25 10:23:04.0" updateauthor="yacovm" updated="2020-08-25 10:23:04.0"> <body><! CDATA The connect function is only invoked when the peer restarts / gets a config update.  If the anchor peer is unreachable then for more than the finite amount of attempts, then it won't connect.  However, if you managed to connect, then the peer can go offline and online indefinitely and you will still reconnect to it.  ></body> </Action>
<Action id="70051" issue="44420" author="lmars" type="comment" created="2020-08-25 15:09:52.0" updateauthor="lmars" updated="2020-08-25 15:09:52.0"> <body><! CDATA Thanks for explanation. Good fix ;)   The last question :): are there any plans to backport this change to 1.4.x branch?  ></body> </Action>
<Action id="70052" issue="44420" author="yacovm" type="comment" body="I&apos;m fine with backporting this, I think that  ~wenjian  intended to do it." created="2020-08-25 15:32:30.0" updateauthor="yacovm" updated="2020-08-25 15:32:30.0"/>
<Action id="70061" issue="44420" author="denyeart" type="comment" body="Yeah,  ~wenjian  is looking into backport for v1.4.x, I&apos;ve re-opened..." created="2020-08-26 14:25:33.0" updateauthor="denyeart" updated="2020-08-26 14:25:33.0"/>
<Action id="70065" issue="44420" author="wenjian" type="comment" body="Backported to release-1.4. PR:  https://github.com/hyperledger/fabric/pull/1815 " created="2020-08-26 16:16:43.0" updateauthor="wenjian" updated="2020-08-27 03:02:06.0"/>
