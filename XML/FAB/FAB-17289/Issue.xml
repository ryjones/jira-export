<Issue id="43781" key="FAB-17289" number="17289" project="10002" reporter="shitaibin" assignee="shitaibin" creator="shitaibin" type="10004" summary="A memory leak in gossip/comm" priority="2" resolution="10000" status="6" created="2019-12-20 07:56:06.0" updated="2020-01-23 21:36:50.0" resolutiondate="2019-12-22 16:30:13.0" votes="0" watches="3" workflowId="57634"> <description><! CDATA h2. Problem     After each stress test, the memory occupied by each peer is increased compared to the memory occupied after the last performance test result:     !image-2019-12-20-15-44-42-806.png!  Each peak in the above figure is a stress test. After each test, the memory of peer1.org1 and peer1.org2 increases significantly.  Before the fourth stress test, the heap profile on peer1.org1 was obtained, as follows:  !http://192.168.9.251/hyperledger/fabric/uploads/621c4f0475aebe7ea0e1878531dabd1a/image-20191219091104570.png!  (clear version at attachment)     !http://192.168.9.251/hyperledger/fabric/uploads/7ab0ccde050f9f937d66f964d69305dc/image.png!  protobuf occupies more than 500MB of memory and is related to `readFromStream`.  After analyzing the goroutine profile, `readFromStream` has 17 goroutines, but its caller` serviceConnection` has only 3, indicating that a goroutine leak may have occurred. The following two pictures are evidence:  !http://192.168.9.251/hyperledger/fabric/uploads/e74c70aedd74942291ea32614b869eb4/image-20191219091155441.png!    !http://192.168.9.251/hyperledger/fabric/uploads/b77f3ad41073ecb3d505b77778cbd9f5/image-20191219091256371.png!     In addition, the following figure shows that the goroutine of a `readFromStream` is blocked on line 376, which has been blocked for 1118 minutes.    !http://192.168.9.251/hyperledger/fabric/uploads/2343cb13819b5eb7dd51e5aa7413ac31/image-20191219091620959.png!  The 4th stress test was performed to confirm whether this is the problem. From the following two pictures, we can know that the number of `readFromStream` has increased to 23, while the` serviceConnection` is still only 3:    !http://192.168.9.251/hyperledger/fabric/uploads/0a9884fad272a134edc97fd143b678c6/image-20191219104814380.png!    !http://192.168.9.251/hyperledger/fabric/uploads/74dee3836c8b1b14c49d1f7871c70d33/image-20191219104904321.png!  It was confirmed that this was a goroutine leak, which caused a memory leak. h2. Root cause  `serviceConnection` will create 2 goroutines:` readFromStream` and `writeToStream`, read data from` <-conn.stopChan`, and write data to `<-conn.stopChan`, which will not let` readFromStream`, because `readFromStream` does not read` <-conn.stopChan`, but reads from the `quit` channel, but` serviceConnection` does not write data to `quit`, which causes` readFromStream` not to exit when `serviceConnection` exits.    {code:java} func (conn *connection) serviceConnection() error { errChan := make(chan error, 1) msgChan := make(chan *proto.SignedGossipMessage, conn.recvBuffSize) quit := make(chan struct{}) // Call stream.Recv() asynchronously in readFromStream(), // and wait for either the Recv() call to end, // or a signal to close the connection, which exits // the method and makes the Recv() call to fail in the // readFromStream() method go conn.readFromStream(errChan, quit, msgChan)  go conn.writeToStream()  for !conn.toDie() { select { case stop := <-conn.stopChan: conn.logger.Debug("Closing reading from stream") conn.stopChan <- stop return nil case err := <-errChan: return err case msg := <-msgChan: conn.handler(msg) } } return nil }  func (conn *connection) readFromStream(errChan chan error, quit chan struct{}, msgChan chan *proto.SignedGossipMessage) { for !conn.toDie() { stream := conn.getStream() if stream == nil { conn.logger.Error(conn.pkiID, "Stream is nil, aborting!") errChan <- fmt.Errorf("Stream is nil") return } envelope, err := stream.Recv() if conn.toDie() { conn.logger.Debug(conn.pkiID, "canceling read because closing") return } if err != nil { errChan <- err conn.logger.Debugf("Got error, aborting: %v", err) return } conn.metrics.ReceivedMessages.Add(1) msg, err := envelope.ToGossipMessage() if err != nil { errChan <- err conn.logger.Warningf("Got error, aborting: %v", err) } select {  // <---------- block here case msgChan <- msg: case <-quit: return } } } {code} h2.  Fix  Although `serviceConnection` writes data to` quit`, which can cause `readFromStream` to exit, this is not a good way.  The best way is to close `conn.stopChan`, so that any goroutine that reads` conn.stopChan` will exit without the need for each goroutine to read data from `conn.stopChan`, and write another data to notify other goroutines drop out.     It already fixed in fabric 2.0. Charry picking some commits can fix it, but will change a lot code for these commit also modified some other codes.      If needs minor change, see this PR in github.  ></description> </Issue>
