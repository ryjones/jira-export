<Action id="33277" issue="22854" author="c0rwin" type="comment" body="-100 on moving forward with this since we are not going to add public API for just in case or as a temporal solution. Work on FAB-5451 is in progress and we need to wait until it will be release rather than hacking into APIs." created="2017-10-26 21:29:01.0" updateauthor="c0rwin" updated="2017-10-26 21:29:01.0"/>
<Action id="33288" issue="22854" author="mastersingh24" type="comment" body="100% agree with Artem.  It would also have been helpful if you described the use case / what you are trying to accomplish rather than just creating a JIRA for a &quot;solution&quot;." created="2017-10-27 10:37:16.0" updateauthor="mastersingh24" updated="2017-10-27 10:37:16.0"/>
<Action id="33308" issue="22854" author="aleksandar.likic" type="comment" created="2017-10-27 14:59:20.0" updateauthor="aleksandar.likic" updated="2017-10-27 14:59:20.0"> <body><! CDATA On technical merit, I agree 100% too.  Here is the context. We posted  https://docs.google.com/document/d/1837l3wpYDiCsyy24DnCL3LwQPzj20NHRqdQ70XURAh8/edit#heading=h.3l7k56ino66j  back in mid July, before the Discovery Service was proposed. In a nutshell, if we apply small changes to current Fabric, we could build a system CC that provides lightweight Discovery functionality now. We need this functionality asap (1.1 timeline), and are trying to find the best way to have it now, without having to fork, as we cannot wait for 1.2. I think we all agree that the functionality is important, otherwise we wouldn’t be building the Discovery Service.   To us, exposing getOrgOfPeer() seems to be the simplest and the least painful solution, albeit intrusive from the interface point of view. Can you think of any other way of unlocking this information in 1.1?     ></body> </Action>
<Action id="33309" issue="22854" author="c0rwin" type="comment" body="As far as I know the content for v1.1 already closed, honestly I do not think this change or any other acceptable workarounds will make it to be part of v1.1. " created="2017-10-27 15:15:57.0" updateauthor="c0rwin" updated="2017-10-27 15:15:57.0"/>
<Action id="33313" issue="22854" author="yacovm" type="comment" created="2017-10-27 15:47:28.0" updateauthor="yacovm" updated="2017-10-27 16:24:06.0"> <body><! CDATA {quote}we could build a system CC that provides lightweight Discovery functionality now. We need this functionality asap (1.1 timeline), and are trying to find the best way to have it now, without having to fork, as we cannot wait for 1.2. I think we all agree that the functionality is important, otherwise we wouldn’t be building the Discovery Service. {quote}  *The discovery service in fabric, is not going to be a system chaincode.*  FAB-5451 was voted on by 7 maintainers and 12 people in total and was also reviewed extensively and is the right way to go. We need to think long term and not short term or we just end up with technical debt.  {quote}Can you think of any other way of unlocking this information in 1.1? {quote} Yes. You can do something of the following and it even works in v1.0: # The same API that you attempted to modify has a method: {code:java} PeersOfChannel(common.ChainID)   discovery.NetworkMember {code}  # You can then create a no-op chaincode and deploy it all all peers, and that chaincode returns a signed proposal which has the peer's e-cert and you can extract the MSP-ID and compute the PKI-ID from the e-cert. # Create a mapping at the client side from PKI-ID to MSP-ID # Profit  ></body> </Action>
<Action id="33317" issue="22854" author="yacovm" type="comment" created="2017-10-27 16:18:22.0" updateauthor="yacovm" updated="2017-10-27 16:19:13.0"> <body><! CDATA Actually, here is another idea, also works in v1.0: You can tap into gossip's communication layer and inspect all identity synchronization messages with the following snippet: {code:java} 	_, identityMsgs := service.GetGossipService().Accept(func(o interface{}) bool { 		m := o.(gossip.ReceivedMessage).GetGossipMessage() 		if ! m.IsPullMsg() || m.GetPullMsgType() != gossip.PullMsgType_IDENTITY_MSG { 			return false 		} 		return m.IsDataUpdate() 	}, true)  	go func() { 		fmt.Println(">>>> starting identity listener...") 		for msg := range identityMsgs { 			m := msg.GetGossipMessage() 			fmt.Println(">>>>> Learned of the following mappings:") 			for _, envelope := range m.GetDataUpdate().Data { 				msg, _ := envelope.ToGossipMessage() 				pIdentity := msg.GetPeerIdentity() 				sId := &msp2.SerializedIdentity{} 				proto.Unmarshal(pIdentity.Cert, sId) 				fmt.Println(">>>>>> pkiID:", pIdentity.PkiId, "-->", sId.Mspid) 			} 		} 	}() {code} I ran it and it works: {quote}>>>>> Learned of the following mappings: >>>>>> pkiID:  197 55 15 138 44 98 170 100 168 56 58 85 141 117 47 191 166 82 24 60 59 181 122 6 238 106 190 250 139 239 112 141  --> Org2MSP >>>>> Learned of the following mappings: >>>>>> pkiID:  75 177 37 111 104 180 97 202 187 78 214 88 237 191 76 81 194 173 88 124 251 208 238 149 253 186 137 53 165 10 255 2  --> Org2MSP >>>>>> pkiID:  56 127 138 147 160 11 185 232 247 7 252 196 153 203 191 18 179 9 124 237 26 143 7 133 197 120 88 232 182 184 72 131  --> Org1MSP {quote}  ></body> </Action>
<Action id="33318" issue="22854" author="aleksandar.likic" type="comment" created="2017-10-27 16:44:29.0" updateauthor="aleksandar.likic" updated="2017-10-27 16:44:29.0"> <body><! CDATA  ~yacovm  Great, we'll try it.  BTW, I am all for FAB-5451, but we need something now. This snippet looks like something that will meet our needs.  Thanks a lot!  ></body> </Action>
