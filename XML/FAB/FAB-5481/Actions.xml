<Action id="29166" issue="19504" author="yacovm" type="comment" created="2017-07-29 10:11:47.0" updateauthor="yacovm" updated="2017-07-29 10:13:25.0"> <body><! CDATA I don't see how this solves the problem of FAB-3134. If we create another event type and clients can subscribe for both event types - isn't that a problem?  Furthermore - I don't see the merit in having a custom crafted event.  * If we want to make the life of the SDK code easier - can just encode the required block events as JSON strings, no? * If we want to make the life of the peer easier - we can just copy the block aside, and delete its un-needed fields before it is sent to the subscribers.  FAB-2679 states that they want the ability to see RW sets - to be toggle-able.   What do you guys think of the following idea? * We keep the original event structure, so SDKs won't be need to write code to adjust * We have 2 implementations in the peer of a function that does filtering on the block - it would filter out the fields that are confidential. ** a no-op method for those deployments that want to see the RWsets in blocks ** a special logic that would filter out those fields for those deployments where they don't want this to be visible to clients. * At runtime, the "right" implementation would be loaded via reflection and would be used.  Thoughts?  ~binhn   ~mastersingh24   ~muralisr   ~wlahti   ~troyronda   PS : the pluggable SCC work I'm doing would make this a no-brainer to use - the code for plugging it into the events would be something like: {code} filterSCC := registry.Lookup("eventsFilter") block = filterSCC.Filter(block) return block {code}  and the implementation of the filterSCC would be chosen at peer startup via a config file. I expect to have this infrastructure in place by middle of this week.   ></body> </Action>
<Action id="29169" issue="19504" author="muralisr" type="comment" created="2017-07-29 14:55:04.0" updateauthor="muralisr" updated="2017-07-29 14:55:04.0"> <body><! CDATA  ~yacovm  The problem with Block-event-only is it's all or nothing. With two events and ACL on Event types, orgs can control who can get what.  ie, orgs can put strict ACL on BlockEvent (or even DENY ALL) and different ACL on FilteredBlockEvent. Thus the peer can send events only to the authorized clients.   We did consider reusing the Block as payload with all fields except benign ones nilled out.  Given the horrendous nested structure before we can get to these fields, a straightforward FilteredBlock with is more usable even if there's some initial pains for the SDK. We can revisit this if everyone thinks its better to just use Block as the payload type.    ></body> </Action>
<Action id="29171" issue="19504" author="yacovm" type="comment" created="2017-07-29 16:49:46.0" updateauthor="yacovm" updated="2017-07-29 16:54:52.0"> <body><! CDATA {quote}With two events and ACL on Event types, orgs can control who can get what. ie, orgs can put strict ACL on BlockEvent (or even DENY ALL) and different ACL on FilteredBlockEvent. Thus the peer can send events only to the authorized clients. {quote}  All right, ACL on selecting what fields of the block are allowed to be sent is also a way of achieving both the goals of FAB-2679 and FAB-3134. The JIRA description didn't mention this (or - have I just misread?) As long as the decision takes place in the peer and not in the client (and a non authorized client cannot affect this decision), that preserves security.  However - if we go to the ACL way (which I think is also fine) in order to preserve security a channel admin would need to configure the channel after its creation in any case, won't he/she? This is additional management overhead. * If by default the policy would be that RWsets are not sent - some admins would need to configure the channel to enable inclusion of them in the Block events. * If by default the policy would be that RWsets are sent - this poses as a security concern too, because if one forgets to change it - the event hub would leak RWsets.  ></body> </Action>
<Action id="29204" issue="19504" author="muralisr" type="comment" created="2017-07-30 01:55:10.0" updateauthor="muralisr" updated="2017-07-30 01:55:10.0"> <body><! CDATA  ~yacovm   This JIRA is created for FAB-3621 which is basically about restricting what users can see. For that purpose, not sending RW sets with block events (current behavior) is a good thing.  FAB-2679 (requirement to send RW sets with the block event) is not a requirement for FAB-3621 (quite the opposite). This would not be hard to add once the ACL framework is in place. One simple way would be to treat BlockEvent's RWSet as a resource and define an ACL policy for it. When we send the block out we would set the RWSet for those clients satisfying the policy. Let us not mix FAB-2679 with FAB-3621 but treat it separately.  _a channel admin would need to configure the channel after its creation in any case, won't he/she?_ Yes, by sending invokes Â to RSCC. This is the general mechanism to update policies for the channel described in the doc. Note that we are also considering a one time initialization of RSCC from the channel config at join time. If this goes through, clients can avoid that overhead. Details for that to be ironed out (with help from  ~jyellick ).  ></body> </Action>
<Action id="33402" issue="19504" author="rickr" type="comment" created="2017-10-31 02:51:21.0" updateauthor="rickr" updated="2017-10-31 02:59:51.0"> <body><! CDATA Why the need to nil out the ccevent payload ? This is just the what the chaincode put in the event message. If the chaincode didn't want it made available it could not put anything in there in the first place.  If we're not going to include all then why not just nil out ccevent for filtered blocks? Seems all are nothing rather than just part there. Not sure what value there is to an application not getting what the CC actually sent with the event would be.   ></body> </Action>
<Action id="38411" issue="19504" author="clayton sims" type="comment" body="removing 1.1 label, tracked under 7419" created="2018-01-10 23:32:24.0" updateauthor="clayton sims" updated="2018-01-10 23:32:24.0"/>
