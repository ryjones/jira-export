<Action id="31934" issue="21352" author="kchristidis" type="comment" body="As I had noted in https://gerrit.hyperledger.org/r/c/4061/ I think this would be handy, so I&apos;m onboard." created="2017-10-09 15:12:06.0" updateauthor="kchristidis" updated="2017-10-09 15:12:06.0"/>
<Action id="31935" issue="21352" author="jimthematrix@gmail.com" type="comment" body="Agree with Kostas, the code here is a good way for peer owners to ensure that everything in the ledger is in good order, as a sanity check after for instance disk archiving/restore, or showing proof of integrity to an audit. I think as an example a command like &quot;peer ledger checkintegrity&quot; could be very useful to a peer admin" created="2017-10-09 15:47:18.0" updateauthor="jimthematrix@gmail.com" updated="2017-10-09 15:47:18.0"/>
<Action id="32030" issue="21352" author="denyeart" type="comment" created="2017-10-12 09:30:17.0" updateauthor="denyeart" updated="2017-10-12 09:36:36.0"> <body><! CDATA I agree that we need the verify function.  I think as a first CR it should simply do VerifyChain(), have a command line like Jim suggested to start it "peer ledger checkintegrity", and log the results to peer log.  Then, in follow on CRs you could introduce the automatic integrity check based on configurable times (core.yaml).  The reason I suggest splitting the CRs, is that I think we could get the command line option merged quickly into next release, while the automatic integrity check may have more debate.  Go ahead and push CRs to gerrit and we can do detailed reviews and discussion there.     The automatic fix will be more tricky, since after retrieving the fixed block from neighbors we have to consider state database.  We won't know if state database was also corrupted and we can't simply apply state changes from middle of chain.  We would want to rebuild entire state database if the blocks were corrupted. Therefore I suggest the repair should not be automatic but an administrator driven action to take the peer offline and repair.   ~manish-sethi  Could you add comments and vote if you agree?  ></body> </Action>
<Action id="32032" issue="21352" author="denyeart" type="comment" body="As a first step, we should also check with  ~balaji.viswanathan  if he wants to revive his VerifyChain() via FAB-609, and then  ~qizhang87  adds the additional services on top (command line and automatic checks)." created="2017-10-12 09:47:47.0" updateauthor="denyeart" updated="2017-10-12 09:47:47.0"/>
<Action id="32042" issue="21352" author="qizhang87" type="comment" body="Agree with David. I have updated the VerifyChain() function so that it works with Fabric v1.0.3.  ~balaji.viswanathan  could double check from the code patch attached to this thread." created="2017-10-12 14:23:09.0" updateauthor="qizhang87" updated="2017-10-12 14:23:53.0"/>
<Action id="32048" issue="21352" author="balaji.viswanathan" type="comment" body="Agree, i will take a look at the Qi Zhang&apos;s patch and push an updated CR for this" created="2017-10-12 15:08:31.0" updateauthor="balaji.viswanathan" updated="2017-10-12 15:08:31.0"/>
<Action id="32520" issue="21352" author="manish-sethi" type="comment" created="2017-10-16 15:28:41.0" updateauthor="manish-sethi" updated="2017-10-16 15:31:41.0"> <body><! CDATA Yes, I agree that we should have some utility for verifying the blocks data. However, I think that we should be clear about it's scope and guarantees it provides. I'll categorize the scope in two broad categories. 1) Data corruption due to hardware or transmission errors (e.g., disk got bad sectors or manually copying ledger data from one peer to another) 2) Intentional tempering with ledger data  I believe that the second category is what is highlighted in the attached charts. Since, this is related to security, I think that we should clearly mention the scope. This is because, just a positive return from the verifying code would not guarantee that everything is fine. We are assuming that the tempering has happened at the filesystem level. The tempering could involve the tempering of verifying code/utility itself as well to return a fake positive response. So, potentially the scope of verification will be limited to some tempering and we need to specify that clearly (better to take an opinion from security folks here I feel).  Further, only matching hashes may not be sufficient. Some more checks should be performed that we do during regular validation (at least for the last block) which includes verified for the valid signatures from the orderer and proper channel name in the block (else another tempering could replace whole block chain). Theoretically, we can repass every block from the `validate` function but that may be overkill - for instance, it may not be worth for checking for signatures from orderer for each block.  Coming back to the first category, Though a positive outcome of this utility would guarantee the absence of hardware issues but we need to think about the negative outcome that could give hint in a more meaningful way. If there is some disk failures, this utility would simply throw some error (Not sure what this could be because, we did not include the disk failure scenarios yet and in fact, in boundary cases it could mislead to the scenarios of first category) I wanted to highlight this category because, there could be different approaches that suits this category better. For instance, the easiest could be to simply add file level checksums when we close a ledger file. That way, anytime one runs a tool for checking the hardware failures, we would always tell the block file#xyz needs another copy - The same could be some at much smaller granularity as well (e.g., a fixed size data frame within the block file - as typically most of the dbs do but that requires more involved efforts)  Thoughts?  ></body> </Action>
<Action id="32525" issue="21352" author="denyeart" type="comment" body=" ~elli-androulaki   ~adc   ~ales  Could crypto team provide their opinion on this one.  To what extent could a VerifyChain() function on the peer provide an integrity guarantee on the chain by checking block hashes and orderer signature on blocks?  As  ~manish-sethi  points out, if somebody has access to the file system to tamper with the block storage, they could potentially also tamper with the peer code to always return a positive result.  Thoughts?" created="2017-10-16 16:29:21.0" updateauthor="denyeart" updated="2017-10-16 16:29:21.0"/>
<Action id="32957" issue="21352" author="qizhang87" type="comment" body=" ~manish-sethi  Can we put the verifying code in some secure hardware, such as the hardware secure module, to prevent it from being tampered?" created="2017-10-21 02:41:28.0" updateauthor="qizhang87" updated="2017-10-21 02:41:28.0"/>
<Action id="32958" issue="21352" author="qizhang87" type="comment" created="2017-10-21 03:42:03.0" updateauthor="qizhang87" updated="2017-10-21 03:57:04.0"> <body><! CDATA  ~manish-sethi  As our current approach is more focusing on the first category of problem, can we have this solution done first, and then consider the solution for the second category?   To solve the problem that the whole blockchain could be tampered,  ~balaji.viswanathan  suggested some cross-peer ledger comparison, which means for a peer, it not only verifies its own ledger, but also compare its ledger with other peers' ledgers. But this may cause massive data exchange through the network, since in order to achieve Byzantine fault tolerance, a peer needs to compare its ledger with many other peers' ledgers in the same channel.   I suggest that we first implement the verifying code as validating signatures for each block in addition to matching the hashes, and see how much overhead it will introduce. Since this ledger verifying process does not happen quite often, even some overhead could be acceptable.   BTW, I am not quite clear how ''valid signatures from the orderer and proper channel name in the block" can detect the whole blockchain from being tampered. Can you provide more details  ~manish-sethi ? Thanks!  Looking forward for your thoughts and comments. Thanks again!  ></body> </Action>
<Action id="33197" issue="21352" author="jimthematrix" type="comment" created="2017-10-25 21:32:03.0" updateauthor="jimthematrix" updated="2017-10-25 21:32:03.0"> <body><! CDATA  ~denyeart  regarding your question on the peer command itself being tampered with, presumably the admin could follow a more secure procedure such that the binary is downloaded from a trusted source (hyperledger.org) with hash check to ensure its authenticity. I would think this should be among the normal precautions a competent org admin follows?  Another possibility is to run the peer command remotely from a machine that the org admin has exclusive rights to (and known to have integrity).  ></body> </Action>
<Action id="33665" issue="21352" author="yacovm" type="comment" created="2017-11-01 07:07:14.0" updateauthor="yacovm" updated="2017-11-01 07:07:14.0"> <body><! CDATA {quote}  Provide an approach that allows a peer to periodically checks the integrity of its ledger by walking through the blockchain. If some block is found as broken, the peer will ask its neighbors for a correct block to replace the broken one.{quote}   The proposal of verifying the chain periodically seems a bit odd to me: * The blocks are signed by the orderer (and the orderer is *trusted *in HLF's adversary model) and when they are commited, the signature is verified. * In our adversary model, if the orderer sends a block to some peer, it sends the same block to all peers. What is the use of requesting a block from other peers? it will be the same.  * Why do we need periodical verification? If we commit a block and check that the hash matches the previous hash, and if it doesn't match - we either panic or stop processing the chain, isn't that enough?  ** This is enough to protect you from a bug in the orderer in case it doesn't create blocks that have correct previous hashes ** This isn't enough to protect you from a file system corruption, but I don't think it is fabric's goal to guard against such abnormalities.   ></body> </Action>
<Action id="33669" issue="21352" author="c0rwin" type="comment" created="2017-11-01 09:29:07.0" updateauthor="c0rwin" updated="2017-11-01 09:29:07.0"> <body><! CDATA {quote}  If some block is found as broken, the peer will ask its neighbors for a correct block to replace the broken one. {quote}  To support committing corrupted block from the past Ledger API has to be changed or at least the commit logic as is for now, ledger won't accept block with sequence number say 10, while current ledger height is 10000.  Moreover I do no think that such functionality should reside in peer code, but rather some external monitoring component, graphs in attached pptx clearly presents linear in number of blocks overhead of doing such check, hence eventually it will take too many resources and time.  {quote} if somebody has access to the file system to tamper with the block storage, they could potentially also tamper with the peer code to always return a positive result. {quote}  In that case can tamper the peer code, it will be able to turn off any checks we can put into it. Tempering data eventually will lead to the state divergence and therefore proper endorsement policies supposed to mitigated the effect of this.    ></body> </Action>
<Action id="34404" issue="21352" author="baohua" type="comment" created="2017-11-07 06:32:54.0" updateauthor="baohua" updated="2017-11-07 06:32:54.0"> <body><! CDATA Maybe can follow this scenario:  1) Users trigger verification on peer storage manually through some API. 2) Peer returned the result. If sth is broken, return the index. 3 Users ask peer to fix the given block by pulling from other peer nodes.   Besides, in order to accelerate the verification, is it possible to use data structures like merkle tree among those blocks?  ></body> </Action>
<Action id="34407" issue="21352" author="c0rwin" type="comment" created="2017-11-07 07:22:58.0" updateauthor="c0rwin" updated="2017-11-07 07:22:58.0"> <body><! CDATA {quote} 1) Users trigger verification on peer storage manually through some API. 2) Peer returned the result. If sth is broken, return the index. {quote}  So I think this should not be an additional API but rather additional tool which will take care to monitor integrity of the blocks.  ></body> </Action>
<Action id="41445" issue="21352" author="denyeart" type="comment" body="Removing v1.2 tag, this item will be prioritized alongside others in the fabric-ledger backlog." created="2018-03-12 07:01:16.0" updateauthor="denyeart" updated="2018-03-12 07:01:16.0"/>
<Action id="48162" issue="21352" author="c0rwin" type="comment" body="There is a standalone tool which can scan the ledger to check offline its integrity, work still in progress, available here: https://github.com/C0rWin/ledgerfsck" created="2018-07-31 07:39:47.0" updateauthor="c0rwin" updated="2018-07-31 07:39:47.0"/>
<Action id="67148" issue="21352" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:09:52.0" updateauthor="sykesm" updated="2020-01-22 22:09:52.0"/>
<Action id="69387" issue="21352" author="denyeart" type="comment" body="I agree  https://github.com/C0rWin/ledgerfsck  is a good starting point." created="2020-06-03 11:55:12.0" updateauthor="denyeart" updated="2020-06-03 11:55:12.0"/>
<Action id="69389" issue="21352" author="baohua" type="comment" created="2020-06-03 16:49:26.0" updateauthor="baohua" updated="2020-06-03 16:49:26.0"> <body><! CDATA And I found  https://github.com/hyperledger-labs/blockchain-verifier.|https://github.com/hyperledger-labs/blockchain-verifier   It might be helpful, too.  ></body> </Action>
<Action id="71410" issue="21352" author="denyeart" type="comment" body="We will leverage the new snapshot functionality along with ledger troubleshooting utilities mentioned in FAB-18425 and FAB-18429." created="2021-02-22 14:57:07.0" updateauthor="denyeart" updated="2021-02-22 14:57:07.0"/>
