<Issue id="33806" key="FAB-12016" number="12016" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10003" summary="Adding a new orderer node to an ordering cluster - discussion" priority="3" resolution="10000" status="6" created="2018-09-16 10:16:58.0" updated="2019-01-21 23:19:50.0" resolutiondate="2019-01-21 23:19:50.0" votes="0" watches="7" workflowId="46314"> <description><! CDATA Currently, in the kafka orderer type, adding a new OSN (ordering service node) is straight forward - just configure it to point to the right kafka cluster, and it'll pull transactions from kafka, and cut the blocks as needed.  With the introduction of the etcdraft ordering node type, we have a new type of setup of ordering nodes - a clustered ordering service:  * Ordering service nodes now communicate among themselves, and authenticate each other with mutual TLS. * Ordering nodes can join, and leave the cluster via channel configuration transactions that modify the consenter membership set.  The 2 facts above, combined with the fact below - make introduction of new OSNs to an existing cluster somewhat challenging: * Ordering nodes are all given a genesis block containing the initial configuration of the system channel.  An OSN that joins the cluster, may not be able to authenticate any of the remaining cluster members, because their certificates may have completely changed (consider a cluster in which each OSN's company rotates its certificate on a timely basis, say - once every 3 months, and the certificate expires after 100 days. ) and thus it cannot replicate the blocks in the consensus algorithm way, and needs some support to get to the latest config block which authorizes the cluster members, and also - it needs to know in which channels it is a member of, assuming we dont want all OSNs to contain all chains.   I see 3 approaches to this: # Have the joining node start in a special "boot from net" mode in which it pulls all the blocks of the system channel from genesis until the last block, and then inspects the channels that exist in the system channel, and afterwards - pulls all the blocks from genesis to the latest config block for each channel, and then start servicing requests and connect to the cluster. In order to safely authenticate the cluster members, the node would need the latest TLS CA certificates of the cluster members, and their IP addresses (as these can change too with time), as well as the enrollment CAs of the cluster, to verify the signature on the block (if the TLS CAs are completely unrelated to enrollment CAs). # Have the joining node *start from the last configuration of the system channel*, the IP addresses of the ordering nodes, and possibly - root TLS CAs of the ordering nodes (since they can change via channel updates), and the enrollment CAs of the ordering nodes, in case the system channel last config is outdated and the channel CAs have changed, and then: Pull all blocks from genesis to the last config block for each channel, and afterwards start servicing requests and connect to the cluster. # Have the newly joined OSN receive a file system snapshot of the ledger data containing either all chains it needs (  ~manish-sethi  - I don't think this is doable - is it? because the index of the ledger contains references to all the chains, right?) or all the chains, and then it can immediately serve requests after its launch. To create such a snapshot, we'll need to either shut down an existing OSN instance, copy aside the files, and then boot it up again, or have some admin API which snapshots its index folder and starts from a new "block" file for all chains (  ~manish-sethi  - how hard is it to do that? ).  Approaches 1 and 2 are very similar, with the only difference being that in approach 2 - we don't need to pull the entire system channel as we don't need it, however - I'm unsure to what extend t current bootstrap-related code is flexible and can support such a change. On the other hand - once we have archive and pruning, we can't use approach 1 at all, unless we decide to never prune the system channel (which might appear like it makes sense, however - this exposes the consortium's history of past business relations forever)     Approaches 1 and 2 both seem to me like having 1 very big downside: Pulling all the channels is simply inefficient and very, very slow.  If a chain has accumulated a large amount of data, pulling the blocks would take a very long time, and during that time - the OSN is not serviceable.   I believe that it is a reasonable assumption that: * Most data a block transactions is PEM encoded certificates * Most data in transactions is text, or hashed text  And therefore - if we take an entire tarball of a ledger of an OSN, and then compress it with gzip - it will be significantly cheaper to download out of band, than to send the blocks 1 by 1 via the Deliver API.      In the  design google doc|https://docs.google.com/document/d/138Brlx2BiYJm5bzFk_B0csuEUKYdXXr7Za9V7C76dwo/edit#  it is said we'll use the first approach, and I have a tendency to think that it's too early to introduce the maintenance overhead of the 3rd approach to most users, but *we should anyway strive to implement the 3rd approach as well*, as I'm sure that advanced users would prefer to use it over the 1st/2nd approaches because of the reduced time, and also - the first 2 approaches involve a considerable amount of logic and testing, and this endangers the release of the Raft OSN feature.    I shall list here how I think the flow of the 1st approach should work:  The prerequisite to add a new OSN, is to first update all channels it belongs to, with a new consenter, so that: * The other nodes would be ready to connect to it once it is ready * The new node will know which channels it is part of.  I believe this is needed, because although an ordering service node belongs to some organization, it doesn't mean that all ordering service nodes of that organization, serve all channels. Therefore, we can have a single organization that participates in 100 channels but in practice has 5 ordering service nodes each servicing 20 channels.  If it wants to add a new OSN, it doesn't mean that OSN should pull blocks from 100 channels. * Genesis method: *cluster* There are currently 2 ways to bootstrap an OSN: ** Provisional: The OSN creates a genesis block out of the  configtx.yaml|https://github.com/hyperledger/fabric/blob/release-1.2/sampleconfig/configtx.yaml  file. ** File: using a genesis block. This is used for production, and just means we bootstrap out of an existing genesis block.  We shall introduce a new genesis method which would be similar to the file method, with an addition of metadata: {code:java} # Genesis file: The file containing the genesis block to use when # initializing the orderer system channel and GenesisMethod is set to # "file". Ignored if GenesisMethod is set to "provisional". GenesisFile: genesisblock  # GenesisMetadata defines additional metadata to be used by a genesis method which isn't "provisional" or "file" GenesisMetadata: netboot.yaml {code}    The layout of the *netboot.yaml*  file will have the following properties: * OSN1: ** Endpoint: osn1.org1.com ** TLS Certificate, or TLS CA certificate ** Optionally, enrollment CA certificate * ... * OSN_n: ...  When the newly joined OSN boots, if the bootstrap method will be *cluster*, it will: #  Reach out to a majority of OSNs and figure out the latest system channel height and some OSN that possesses it. # Pull the system channel from that OSN via a Deliver client, independent of consensus implementation. # For all channels (retrieved from the system channel): ## Attempt to retrieve the last config block from some OSN in the cluster. ## If it gets an access denied, it means its organization isn't in the channel. ## If it gets a "not found" - it means the current OSN it is trying, isn't in the channel, so it should try a different OSN. ## Else, it retrieves it and then checks if its TLS certificate is in the consenters set. (*) ## If it is in the consenter set of the given channel, it knows it should pull all the blocks of the channel, starting from the genesis block.  *(*)* This is a consensus specific operation, but I think its a necessary evil because we encode the metadata in a consensus oblivious way.     Opinions?      ~jyellick   ~kchristidis   ~C0rWin   ~mastersingh24   ~sykesm   ~guoger   ></description> </Issue>
