<Issue id="36132" key="FAB-13264" number="13264" project="10002" reporter="tock" assignee="tock" creator="tock" type="10003" summary=" kafka-to-raft migration: Green path #1" priority="3" resolution="10000" status="6" created="2018-12-13 11:53:42.0" updated="2019-03-28 13:48:11.0" resolutiondate="2019-01-30 16:39:42.0" votes="0" watches="2" workflowId="47649"> <description><! CDATA This is the first of four (*1/4*) sub-tasks that focus on the "green" path of consensus-type migration from Kafka to Raft.   By "green" we mean that there are no failures or aborts along the way. The flow of the green path and the changes made in these 4 tasks are described below. The 4 sub-tasks are staged in a way that minimizes dependencies between them.  In this sub-task we introduce changes to the *orderer/common/bootstrap* package (see details in bold below). In essence, Just before the last config block of the system channel (COMMIT) is written to the ledger, the bootstrap file (a.k.a "genesis.block", do not confuse with the first block of the ledger) is swapped with the last block of the system channel. This sub-task extends package *orderer/common/bootstrap* to support this functionality.     The "green" path for migration is the following: # Start with a Kafka-based ordering service  # Send a config update tx (START-TX) on the system channel that: ## Has ConsensusType.MigrationState=START ## This will disable the creation of new channels ## This will disable the processing of normal (standard channel) transactions # Wait until the START-TX is committed and get the block height H of that tx # Send a config update tx (CONTEXT-TX) on each of the standard channels that: ## Has ConsensusType.MigrationState=CONTEXT ## Has ConsensusType.MigrationContext=H ## Has ConsensusType.Type="etcdraft" ## Has ConsensusType.Metadata=<a marshaled etcdraft metadata: Consenters, Options, etc> ## Note: take special care that the metadata is valid! ## Note: all the channels should be supplied with the same metadata (same consenters, same options) ## Note: The consenter set should be composed of the live orderers that are currently connected to Kafka # Send a config update tx (COMMIT-TX) on the system channel that:  ## Has ConsensusType.MigrationState=COMMIT ## Has ConsensusType.MigrationContext=H ## Has ConsensusType.Type="etcdraft" ## Has ConsensusType.Metadata=<a marshaled etcdraft metadata: Consenters, Options, etc> ## The metadata should be the same as for the standard channels, with the same precautions (this will be enforced in a later task). ## If committed successfully, no further configuration will be possible # Restart each orderer ## The orderer will bootstrap into an etcdraft mode ## Each channel will form a cluster ## Normal transactions can resume now  # In order to configure the channels (system or standard), make sure that the first config update tx (on any given channel) after migration has: ## Has ConsensusType.MigrationState=NONE ## Has ConsensusType.MigrationS=NONE ## In addition to other changes to the channel's config.     In previous CR's the MigrationState and MigrationContext fields were introduced onto the protos and OrdererConfig (see  link FAB-12984 and link FAB-13265)  To implement the green path the following changes were made (not a full list) * Change the message processing in the kafka broadcast phase (before Kafka ordering) to accept and pass on config-update-tx(s), with the following: ** Have a consensus-type change (currently prohibited) ** Carry migration commands via the  "MigrationState" field in the config-update-tx(s) ** Carry migration context via the  "MigrationContext" field in the config-update-tx(s) ** Validate that the state transitions of "Migration State" are approximately correct (in the bundle.ValidateNew) * Introduce a "Migration Status" into each chain ** Status is the state and context of each chain ** Allows to get/set the status of migration in each chain ** Can be exposed to Kafka broadcast phase (before ordering), commit phase (after a message is consumed from Kafka), and Registrar ** Expose whether a chain is system or standard channel * Extend the Registrar to function as "migration consensus controller". The registrar has access to all chains, and can therefore ** Coordinate and detect when migration has started (by START-TX) ** When migration is ready to be committed (all standard channels have CONTEXT-TX, system channel START-TX) ** When migration was committed on system channel (COMMIT-TX) * In the Kafka commit phase (after messages are consumed) the state machine of migration is enforced ** Illegal transitions that are triggered by the user cause the message to be dropped ** Unexpected transitions that are due to a bug cause panic ** Events on the system channel (START, COMMIT) cause coordination via the registrar to ensure that conditions are met ** Events on the standard channel (CONTEXT) are processes locally, referring to its local MigrationStatus * *Just before the last config block of the system channel (COMMIT) is written to the ledger, the bootstrap file (a.k.a "genesis.block", do not confuse with the first block of the ledger) is swapped:* ** *the original file with Type="kafka" is backed up* ** *the original file is overwritten with the last config block of the system channel, with Type="etcdraft" and Metadata=<raft-metadata>.* ** *this will allow the orderer to boot onto raft when it is restarted.* * After the orderer is restarted, it creates consenters of type "etcdraft" ** Some changes where made to prevent the booting etcdraft chain/consenter from accessing the block metatdata, which in the COMMIT-TX still carries Kafka indices etc. ** Some changes where introduced to allow the etcdraft chain/consenter to detect that is is not experiencing a failed reconfiguration, but rather starting a new raft chain   * Most of the code above is guarded by the Kafka2RaftMigration() capability     Note: this CR chain passed integration test that was written specifically for migration. The test is introduced by https://jira.hyperledger.org/browse/FAB-12991        ></description> </Issue>
