<Issue id="36145" key="FAB-13272" number="13272" project="10002" reporter="yuki-kon" creator="yuki-kon" type="10004" summary="Private data reconciliation - A new peer fails to get the missing private data which has not been purged by Block-To-Live." priority="2" resolution="10203" status="6" created="2018-12-13 21:06:58.0" updated="2018-12-14 00:59:35.0" resolutiondate="2018-12-14 00:59:35.0" votes="0" watches="3" workflowId="47662"> <description><! CDATA A new peer joining the fabric network later fails to get the missing private data which has not been purged by Block-To-Live. Integration test has the following test case: - verifies private data is purged after BTL has passed and new peer doesn't pull private data that was purged  However, there is no test case: - verifies private data is NOT purged BEFORE BTL has passed and new peer can get private data that has not been purged.  To check this test case, I had a test manually and found a problem. h2. Steps to reproduce  I used a chaincode and collection configuration in the private data tutorial ( http://hyperledger-fabric.readthedocs.io/en/latest/private_data_tutorial.html ). The sample has the collection configuration below. {noformat} { "name": "collectionMarblePrivateDetails", "policy": "OR('Org1MSP.member')", "requiredPeerCount": 0, "maxPeerCount": 3, "blockToLive":3, "memberOnlyRead": true } {noformat} I followed the same steps described in the tutorial without stopping a peer1.org1 and restarting it to fetch the missing private data. 1. Launch fabric network and install/instantiate chaincode. 2. Stop a peer “peer1.org1.example.com”. peer0.org1 is still working. $ cd (fabric-samples)/first-network $ docker-compose -f docker-compose-cli.yaml stop peer1.org1.example.com 3. Store private data “marble1”. 4. Store private data “marble2”. 5. Purge private data “marble1” by putting some transactions. 6. Query “marble1” @peer0.org1 and confirm that it doesn’t exist because Block-to-live has passed. 7. Query “marble2” @peer0.org1 and confirm that it still exists because Block-to-live has NOT passed. 8. Restart a peer “peer1.org1.example.com”. $ docker-compose -f docker-compose-cli.yaml start peer1.org1.example.com 9. Confirm peer1.org1 fetched the missing private data from other peer. $ docker logs peer1.org1.example.com 2>&1 | grep -i -a -E 'private|pvt|privdata' 10. Query the purged data “marble1” @peer1.org1 and confirm that it doesn’t exist.  11. Query the data “marble2” @peer1.org1 and confirm that it still exist. h2. Expected Results  A new peer “peer1.org1” added to the network can fetch the missing private data and read it according to the steps above. h2. Actual Results  A new peer “peer1.org1” added to the network can fetch the missing private data. However, peer1.org1 fails to read the private data still available (i.e. Block-to-live has not passed). - Log messages in step 9 (docker logs peer1.org1.example.com 2>&1 | grep -i -a -E 'private|pvt|privdata') {noformat} 2018-12-13 18:21:08.997 UTC  gossip.privdata  StoreBlock -> INFO 035  mychannel  Received block  6  from buffer 2018-12-13 18:21:09.002 UTC  gossip.privdata  fetchFromPeers -> WARN 037 Missing key because was purged or will soon be purged, continue block commit without  {txID:d12b2c40545d43dbb9119709c59614988c06702daded8045bba138dda94700b6 seqInBlock:0 namespace:marblesp collection:collectionMarblePrivateDetails hash:5df64b386e1af066177edf6f6ddf321a19726a1792a74a14b68270c02b6248cd}  in private rwset 2018-12-13 18:21:09.002 UTC  gossip.privdata  StoreBlock -> INFO 038  mychannel  Fetched all missing collection private write sets from remote peers for block  6  (0ms) 2018-12-13 18:21:09.016 UTC  kvledger  CommitWithPvtData -> INFO 039  mychannel  Committed block  6  with 1 transaction(s) in 14ms (state_validation=0ms block_commit=8ms state_commit=3ms) (snip) 2018-12-13 18:21:09.078 UTC  gossip.privdata  StoreBlock -> INFO 049  mychannel  Received block  10  from buffer 2018-12-13 18:21:09.084 UTC  gossip.privdata  fetchFromPeers -> WARN 04b Missing key because was purged or will soon be purged, continue block commit without  {txID:ef6a48dcf3b69c9c295d9bf39a61333872bc7331867a7e37998167056c0a5e4a seqInBlock:0 namespace:marblesp collection:collectionMarblePrivateDetails hash:43f0b252cb6615c82fda29fdefa91d8d5477a8edf531e43ce64163552fc01bbe}  in private rwset 2018-12-13 18:21:09.084 UTC  gossip.privdata  StoreBlock -> INFO 04c  mychannel  Fetched all missing collection private write sets from remote peers for block  10  (3ms) 2018-12-13 18:21:09.098 UTC  kvledger  CommitWithPvtData -> INFO 04d  mychannel  Committed block  10  with 1 transaction(s) in 13ms (state_validation=0ms block_commit=7ms state_commit=4ms) {noformat}  - Log messages in step 10 and 11 {noformat} root@410ddb1900b7:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarblePrivateDetails","marble1" }' Error: endorsement failure during query. response: status:500 message:"{\"Error\":\"Marble private details does not exist: marble1\"}" root@410ddb1900b7:/opt/gopath/src/github.com/hyperledger/fabric/peer# peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarblePrivateDetails","marble2" }' Error: endorsement failure during query. response: status:500 message:"{\"Error\":\"Failed to get private details for marble2: GET_STATE failed: transaction ID: 7c49421c781e69793851a2d11769abf149ef1d7d038013ad18125cf860b8e1ff: private data matching public hash version is not available. Public hash version = &version.Height{BlockNum:0x7, TxNum:0x0}, Private data version = (*version.Height)(nil)\"}" {noformat}  ></description> </Issue>
