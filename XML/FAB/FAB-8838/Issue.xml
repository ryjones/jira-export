<Issue id="28471" key="FAB-8838" number="8838" project="10002" reporter="elli-androulaki" creator="elli-androulaki" type="10002" summary="Define a policy evaluation system chaincode leveraging channel MSPs to perform the policy evaluation" priority="3" resolution="10001" status="6" created="2018-03-13 12:15:01.0" updated="2020-01-22 22:32:34.0" resolutiondate="2020-01-22 22:32:34.0" votes="0" watches="1" workflowId="35612"> <description><! CDATA This issue aims at defining a component (in terms of interfaces) that would be exposed to a chaincode allowing the latter to perform policy evaluation using channel MSPs. In the following we assume the following terminology: * _Identity Issuer_: Entity authorised to grant a certain type of attributes to users. It can be represented by an msp.IdentityIdentifier, or msp.OwnerIdentifier (see,  here|https://docs.google.com/document/d/1FyvjMlBFasdFlOpjcaurNG8jYipHE8ENXfdbY122mdA/edit?usp=sharing  for more details on these fields). * _User_: Entity that owns one or more identities (e.g., during identity renewal), and may be granted one or more attributes. * _Attribute Issuer_: Entity authorised to grant attributes to users. It can be represented by an msp.IdentityIdentifier or msp.OwnerIdentifier. * _Attribute_: A property that a user may own, can be sufficiently well be represented by a pair:  <attribute type, attribute value> * _Verifier_: An entity that wishes to know if a certain identity is in possession of a specific attribute, i.e., combination of <Attribute, Attribute Issuer>  TBD after discussion in this JIRA if this component makes sense to be exposed via the chiancode SHIM or via a system chaincode available to all peers of a channel. Current approaches move towards the implementation of a system chaincode that exposes the attribute attestation component interface as well as basic channel msp identities validation functions.    ----------  We define an attribute to consist of an issuing authority  and a key-value pair.    {code:java}   message Attribute {     // identity or reference to an identity responsible for granting attributes   AttributeEntity issuerRef = 1;     // actual attribute's content   AttributeContent content = 2; } {code}    Attribute authority is represented in the interface as AttributeEntity, and as such contains a type and value. In case of an MSP-based issuer (i.e., where the MSP itself certifies the attribute possession only to its issuers), the value field contains the MSP identifier.   {code:java} message AttributeEntity {   // can be by identity-, or by long-term owner identifier, or mspid?   int32 type = 1;   // actual issuer representation (depending on type)   bytes value = 2; } {code}    Attribute is represented by AttributeContent structure. Here, key would denote the attribute type, and the attribute value the actual content of the attribute. E.g., an attribute key-value could be \{“age”, “30”}. Definition of the issuing authority can be either identity-based (i.e., IdentityIdentifier) or owner-based (i.e., OwnerIdentifier).  {code:java} message AttributeContent {   // identifier of the attribute type   bytes type = 1;   // value of the attribute   bytes value = 2; } {code}       Attribute Attestation exposes functions to validate the possession of an attribute by a specific (validated) identity. More specifically the component is set up by a set of MSP objects that can represent the MSPs residing in a certain channel. {code:java} type AttributeAttestation interface { Setup (msps   MSP) error ValidateAttributePossession(sid SerializedIdentity, attributes   Attribute, proof     byte, opts   byte ) error } {code}    Attribute attestation component would expose a function to validate attribute possession by the provided identity. Attributes are passed to the function in the form of an array of attributes indicating the attribute-issuer authority each time.Proof of attribute possession in its simplest form would consist of two parts: * A serialised identity that is (afterwards deserialized and validated) and its ValidatedIdentity version aims to be consistent to the respective attribute’s issuing authority identifier * A list of attributes that are to be verified to be possessed by an entity in the system * Proofs of possession of attributes by the serialised identity * Optional information passed to the identity prior to performing the policy evaluation     An simple way to implement proof object is the following one: {code:java} message SimpleAttributeProof {   // reference to the attribute-owner (can be identity-based, or user-based)   AttributeEntity owner = 1;   // attribute ownership claim   Attribute attribute = 2;   // attestor identity   SerialisedIdentity attestor = 2;   // signature by the attestor on the rest of the fields of SimpleAttributeProof   bytes signature = 2; }   {code} Here our simple proof includes an identifier to the claimed owner of the attribute, the actual attribute (or a short commitment to it), the identity of the attestor of the proof, and a signature on all the above fields generated by the secret key matching attestor’s identity.     Now let a call to: {code:java} ValidateAttributePossession(sid SerializedIdentity, attributes   Attribute, proofs     byte, opts   byte ) error{code}    Checks that are to take place here iterate across all attributes in the input, and ensure that for each of them there is a proof in proofs, such that * proof.attribute equals the attribute * proof.owner is consistent to sid * proof.signature matches the proof.Attribute * proof.attestor matches proof.Attribute.issuer     Additional secret information can be passed on to the attribute possession function via opts.     ></description> </Issue>
