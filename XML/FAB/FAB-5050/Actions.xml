<Action id="27535" issue="18742" author="christopherferris" type="comment" body="Ok, this has reched the needed 5+ maintainers voting, so the policy will be implemented." created="2017-06-28 16:32:00.0" updateauthor="christopherferris" updated="2017-06-28 16:32:00.0"/>
<Action id="27538" issue="18742" author="christopherferris" type="comment" body="I assigned this to Gari as I will be out.  ~mastersingh24  and  ~JonathanLevi  can work out when the right time to create the release branch(es) (from HEAD of master) is and then we&apos;ll need to have  ~ryjones  or  ~jwagantall  change the GH settings on the various repositories changed such that the &apos;release&apos; branch is the *default* branch." created="2017-06-28 17:18:13.0" updateauthor="christopherferris" updated="2017-06-28 17:18:13.0"/>
<Action id="27542" issue="18742" author="dhuseby" type="comment" created="2017-06-28 17:44:43.0" updateauthor="dhuseby" updated="2017-06-28 17:45:15.0"> <body><! CDATA I'll jump in here just to have a paper trail.  This proposal doesn't address where new feature work and other works-in-progress will be done.  If there is only two branches–master(dev) and release–and the intent is to always FF merge from master to release, then the new feature work can't be done directly on master or release will receive half-baked, untested, undocumented code when the FF merge is done.  If you want to go with just two main branches then this proposal should also contain a requirement that all new feature work be done in short-lived feature branches that get merged into master once they are feature complete, covered with tests, and documented–that merge should be gated on maintainer approval.  The alternative is to have three main branches–master(dev), beta, release–where all new feature work is done directly on master(dev) and when features are feature complete, covered in tests, and documented, it will be cherry picked from master to beta–again, gated on maintainer approval.  If this system is used, then FF merges from beta to master to release would be the way the merges happen.  It doesn't matter which way is chosen, but FF merges are the requirement, then there has to be a branch that is always "release candidate ready" and only contains feature complete, tested, and documented code.  As it stands, I'm -1 on this proposal.   ></body> </Action>
<Action id="27543" issue="18742" author="dhuseby" type="comment" body="Having two main branches master (dev) and release is the basis of  Gitflow|http://nvie.com/posts/a-successful-git-branching-model/  but this current proposal doesn&apos;t include the supporting branches needed to aid parallel development and controlled releases." created="2017-06-28 17:51:49.0" updateauthor="dhuseby" updated="2017-06-28 17:51:49.0"/>
<Action id="28190" issue="18742" author="dhuseby" type="comment" body="Where are we at on this?" created="2017-07-11 22:51:43.0" updateauthor="dhuseby" updated="2017-07-11 22:51:43.0"/>
<Action id="28406" issue="18742" author="christopherferris" type="comment" body="&quot;release&quot; branch created for fabric, fabric-ca, fabric-sdk-node and fabric-samples. fabric-sdk-java needs to be finalized by Rick" created="2017-07-14 15:11:07.0" updateauthor="christopherferris" updated="2017-07-14 15:11:07.0"/>
<Action id="28409" issue="18742" author="jyellick" type="comment" created="2017-07-14 15:48:17.0" updateauthor="jyellick" updated="2017-07-14 15:48:17.0"> <body><! CDATA Concretely, we have cut v1.0.0.  Likely the next release will be v1.0.1, but many people will be working on features intended for v1.1.0.  For code which someone wishes to include in v1.0.1, is a CR submitted against master? against release? against both?  For code which someone wishes to include in v1.1.0 but not in v1.0.1, is the CR submitted against master? Does the CR need to somehow disable the code path by default in case of a v1.0.1 FF merge?  ></body> </Action>
<Action id="28410" issue="18742" author="muralisr" type="comment" created="2017-07-14 15:49:40.0" updateauthor="muralisr" updated="2017-07-14 15:49:40.0"> <body><! CDATA  ~ChristopherFerris   ~JonathanLevi   ~ryjones   ~mastersingh24    This is what I currently do for fabric dev (likely others use variations of these steps) {code:java} git checkout master git pull origin git checkout <your branch> ...make changes and commit ... git push origin HEAD:refs/for/master {code} Would be helpful to have cheatsheets/processes for some typical workflows * new features into master * bug fixes into release and master  ></body> </Action>
<Action id="28411" issue="18742" author="denyeart" type="comment" body="{color:#444444}Will there be a new release branch per release? e.g. once 1.1 is released will it still be possible to provide fixes on top of 1.0?{color}" created="2017-07-14 15:51:38.0" updateauthor="denyeart" updated="2017-07-14 15:51:38.0"/>
<Action id="28577" issue="18742" author="jimthematrix" type="comment" created="2017-07-18 13:52:57.0" updateauthor="jimthematrix" updated="2017-07-18 18:37:16.0"> <body><! CDATA for hotfixes on existing branches that can't wait until the next point release, we'll need to create a dedicated branch just for the hotfixes and tightly control what goes into it. The control is needed to minimize human errors because every fix that goes into these branches must also be (likely manually) put into the master (dev) branch. these hotfix branches should be kept to a minimum and only be created under the most extraordinary circumstances (serious security holes, crashes, data loss etc.)  the fabric-sdk-node has had one of these already ('v1.0.0-alpha.x') and luckily only one so far.  ></body> </Action>
<Action id="28579" issue="18742" author="christopherferris" type="comment" created="2017-07-18 14:15:05.0" updateauthor="christopherferris" updated="2017-07-18 14:15:05.0"> <body><! CDATA Ok, let's take a breath.  I see no reason to move off of the cadence of releases we were on (roughly 2 weeks). Hence, I see no reason to be going around hot patching individual branches.   For NEW FEATURES, all development should be done behind a feature flag, in parallel with existing code until such time as it is ready to be "released" fully supported with docs tests samples etc etc etc.  For refactors, we just need to be careful that we aren't making API/ABI changes, otherwise that needs more scrutiny and buy-in  ></body> </Action>
<Action id="30525" issue="18742" author="dhuseby" type="comment" created="2017-09-05 17:59:57.0" updateauthor="dhuseby" updated="2017-09-05 18:00:46.0"> <body><! CDATA What is wrong with feature branches?  Having feature flags is error prone and creates security issues.  The only way to prevent the security issues related to works in progress being checked into the main branch is if the work in progress code is conditionally compiled out.  If any WIP code gets compiled into the release, even if "behind a feature flag" it can be used in an exploit.  A lot–maybe most–exploits today use the combination of several smaller vulnerabilities to bootstrap into a full break-in.  Having half-finished code compiled into the released binary is dangerous because things like heap sprays and ROP attacks can leverage the half finished code to get even more control.  The only way to ensure that WIP code doesn't increase the attack surface of the software is to never include WIP code in the compiled binaries. One easy way to do that is to use feature branches for WIP code.  The other is to use conditional compilation.  If the argument is that feature branching is messy on Gerrit, we should switch to Github.  Countless other open source projects successfully use the Gitflow branching model that I proposed.  It's not a radical proposal.  ></body> </Action>
<Action id="30576" issue="18742" author="jonathanlevi" type="comment" created="2017-09-06 18:15:48.0" updateauthor="jonathanlevi" updated="2017-09-06 18:47:15.0"> <body><! CDATA p.s. I have temporarily de-assigned myself from this JIRA item, following our recent discussions that one would pick and self-assign a JIRA item when one (he/she) is ready to work on it.  Let's first try to reach a consensus here. I may re-assign myself once/if we have converged/concluded on the way to go about it.  ></body> </Action>
<Action id="30577" issue="18742" author="jonathanlevi" type="comment" created="2017-09-06 18:21:18.0" updateauthor="jonathanlevi" updated="2017-09-06 18:46:22.0"> <body><! CDATA Now, WRT that last note/paragraph of  ~dhuseby  above... Especially now with their recently added Developer Certificate of Origin (DCO) capability, where do we stand in terms/the context of the discussion around the re-evaluation of returning to Github, for Hyperledger Fabric?   ~ChristopherFerris ,  ~mastersingh24 ,  ~lehors ,  ~binhn ,  ~greg.haskins , ...  ></body> </Action>
<Action id="30580" issue="18742" author="dhuseby" type="comment" body="I see no reason to stay with Gerrit if it is the reason we can&apos;t use a better branching model.  Other HL projects are on Github and are meeting requirements." created="2017-09-06 20:21:55.0" updateauthor="dhuseby" updated="2017-09-06 20:21:55.0"/>
<Action id="30609" issue="18742" author="lehors" type="comment" created="2017-09-07 11:42:23.0" updateauthor="lehors" updated="2017-09-07 11:42:23.0"> <body><! CDATA  ~JonathanLevi  Now that Chris is back we'll see if the discussion resumes but as far as I can tell the discussion isn't really going anywhere. I think the reason is that there aren't many technical limitations or capabilities that give one system over the other a real edge.  The main issue (I think) - DCO - has been addressed and there are ways to work around the others. So the discussion becomes mostly a question of personal preference and trade-offs one is willing to make.  It's clear that people have strong opinions about this topic but although it's not my preference, I think it's fair to say that although some people prefer Gerrit over GitHub they/we seem to be the minority. The majority of projects use GitHub and have no intention of switching to Gerrit, and among the projects that do use Gerrit there are people who wish the project would move to GitHub. That makes Gerrit the odd ball.     ></body> </Action>
<Action id="30610" issue="18742" author="jonathanlevi" type="comment" created="2017-09-07 11:58:08.0" updateauthor="jonathanlevi" updated="2017-09-07 11:58:08.0"> <body><! CDATA Thank you  ~dhuseby  and  ~lehors . Yes, I am getting a very similar vibe from the gist of the exchanges around this too.  Other than the work/overhead/leg-work required for migrating back back to GitHub... e.g., updating the documentation, how to contribute, and some of the CI jobs - one can argue that the lower barrier to entry, the popularity of GitHub and the consistency of the development lifecycle amongst the rest of the current Hyperledger projects, and making it possible to potentially embrace, in full or in part,  ~dhuseby  's branching scheme proposal(s) - may worth the migration.  In an attempt to be more proactive about it, let's try to phrase this differently: *Is there anyone around who still feels strongly against us moving Hyperledger Fabric's main/core development workflow from Gerrit back to GitHub? If so, what are the reasons against doing so - and sticking with Gerrit?* I'm mostly/mainly trying to gauge how off we are, from being able to converge here. Thank you.  ></body> </Action>
<Action id="30613" issue="18742" author="lehors" type="comment" created="2017-09-07 12:52:04.0" updateauthor="lehors" updated="2017-09-07 12:52:04.0"> <body><! CDATA  ~JonathanLevi  Indeed, this may be a more practical way of moving forward. I would simply ask: how can GitHub be used to do the equivalent of what's being done today with Gerrit.  The email exchange provided some answers to that. Some things (DCO, 2+2) seem pretty simple, others (workflow) may require bigger changes in how things are done.  We could build a list of those things which would provide us with a practical list of things to consider as the cost of switching and, if we switch, as a handbook/guide on how things change.  Maybe this is actually what  ~ChristopherFerris  had in mind for the task force but I think the way it was set up was maybe too broad. The above approach would avoid getting into a discussion on which system is better and I would think the GitHub fans would be eager to show/explain to the Gerrit supporters how GitHub can be used to achieve the same.  ></body> </Action>
<Action id="30614" issue="18742" author="christopherferris" type="comment" created="2017-09-07 13:10:57.0" updateauthor="christopherferris" updated="2017-09-07 13:10:57.0"> <body><! CDATA Catching up and dealing with hurricane prep.  ~dhuseby  - you are making a rather bold claim that "feature-flags" are error prone and create security issues. Care to back that up with evidence? Any code can be sloppily implemented and result in security issues.   As for compiling out incomplete features for a release, that is one of the proposals on the table from Gari, especially for new modules.  I do NOT think it advisable to make radical changes to our process at this stage. There is a separate thread that I had started to look at (not to make changes) GitHub support and what best practices were for its use, ensuring DCO, issue tracking, enforcing multiple or NACR reviews, etc.   Feature branches are JUST as complex and given the state of entanglement of the code base, I just don't see it as a workable approach to development as there is too much potential for collision of changes.        ></body> </Action>
<Action id="30735" issue="18742" author="dhuseby" type="comment" created="2017-09-11 18:48:04.0" updateauthor="dhuseby" updated="2017-09-11 18:50:24.0"> <body><! CDATA Hi Chris,  I hope all is well down there post-storm.  Feature flags are error prone and cause security issues.  Any time you add one more thing to the checklist of things a developer has to remember–and that thing cannot be automated--you're increasing the chances of human error.  Having unfinished code in a binary does cause security issues, especially when the code processes untrusted data from the Internet.  If unfinished code never makes it into a released binary then it can never be exploited.  If unifinished code is shipped in a binary, even behind a feature flag, it can potentially be used by an attacker.  It increases the surface area for an attack.  My experience with browser security taught me that unfinished code is exploitable even when disabled by default.  Heap sprays that caused pointer jumps into PoC code that wasn't doing full security enforcement allowed for privilege escalation attacks.  I've seen it happen in the wild.  In the end the only way to avoid this kind of thing is to never ship unfinished code in a release binary.  Since feature flags can't be enforced with CI checks, the only way to prevent this entirely is to use feature branching and carefully manage what code gets merged into the release branch from which release binaries are built.  The gitflow branching model isn't my invention.  It is an accepted best practice that is used by many open source projects, including some of the most security sensitive projects such as bitcoin-core and tor.  Frankly I don't understand your resistance.  The only objection before was that Gerrit doesn't do feature branching well.  Now that we can seriously consider moving to Github, that's no longer an issue.  So is it Gerrit, or something else?  Sawtooth, Indy, Burrow, Composer, and Iroha all use Github and feature branching without any problems.  Iroha is a particularly spectacular example of good code management using branches.  They namespace feature branches under "features" and bug fixes under "fixes" making the building of a solid release branch trivial.  I did notice that Fabric, Cello, and Blockchain Explorer–the three projects using Gerrit–do not use feature branching so I suspect the problem lies with Gerrit.  I think we should seriously consider moving to Github and changing to a more security conscious branching strategy.  Github is the de facto standard for open source project collaboration and most developers know how to use Github even if they don't know command line git very well.  It would seem like a good move to minimize the barrier to entry for new contributors and to reduce the chances of human error causing security issues in the future.  ></body> </Action>
<Action id="30742" issue="18742" author="christopherferris" type="comment" created="2017-09-11 20:44:20.0" updateauthor="christopherferris" updated="2017-09-11 20:44:20.0"> <body><! CDATA Still rather hand-wavy. As noted, we are intending to leverage compile flags so that we can exclude experimental code from the build. Of course, that isn't always possible. However, it does address your concern. However, my concern extends beyond just whether I like some workflow.   For starters, migrating the project from Gerrit to GitHub is not an undertaking to be taken lightly. It is more than just the DCO though originally that was one of the overriding requirements. We also have a 2+2 review policy which AFAIK can only be manually implemented. It isn't clear that we can even implement NACR. AFAIK 2+2 cannot be automated without some extension. Also, migrating all of the CI, and integrating into the status updates for a PR is also no small feat. Setting up CI for feature branches is also no simple task. It means that we have to manage multiple branches of testing as well. Hence, while we possibly could move to GH that isn't necessarily in the cards and we as a project haven't agreed.   I did set up the GH task force to explore best practices so that we could compare and make an informed decision collectively, and then plan the transition. You make it seem as if there isn't a transition cost that would take cycles away from development. It is no small feat.   Then, there is the matter of the fact that our code base does not lend itself easily to feature branch development. There is far too much entangled shared code. I would be concerned that merging feature branches into the master/development would be complicated endeavors.  ></body> </Action>
<Action id="30783" issue="18742" author="dhuseby" type="comment" created="2017-09-12 23:51:04.0" updateauthor="dhuseby" updated="2017-09-12 23:51:04.0"> <body><! CDATA I'm sorry if I seemed like I didn't appreciate the transition cost.  I recognize that it would be a big deal to move from Gerrit to Github.  Also, using conditional compilation to prevent unfinished code from being shipped does satisfy my concerns about that.  As for 2+2, I don't think you need any extensions.  Feature branches will live in the github repo and the discussion threads for the PR on GH will include the review comments and the +1's from the maintainers.  Once it has the requisite approvals, then a maintainer can click the button to merge the branch into the "next release" branch–sometimes called the "beta" branch in my earlier slides and in the online literature.  I really only care about keeping unfinished code out of release binaries.  If your team has a solid way of doing that, then I'm OK with whatever you came up with.  ></body> </Action>
<Action id="34787" issue="18742" author="dhuseby" type="comment" body="It looks like we&apos;ll  have budget money in 2018 for hiring a consultant to help with the JIRA and our process in general. Hopefully we can revisit this then." created="2017-11-20 19:14:40.0" updateauthor="dhuseby" updated="2017-11-20 19:14:40.0"/>
<Action id="34791" issue="18742" author="christopherferris" type="comment" body="I thought we were actively looking? " created="2017-11-20 20:04:54.0" updateauthor="christopherferris" updated="2017-11-20 20:04:54.0"/>
<Action id="34794" issue="18742" author="dhuseby" type="comment" body="AFAIK, I need to wait until I have the budget to spend.  I could be wrong.  Let me check with Todd." created="2017-11-20 20:57:31.0" updateauthor="dhuseby" updated="2017-11-20 20:57:31.0"/>
<Action id="41685" issue="18742" author="christopherferris" type="comment" body="This is complete as of 1.1 release. We now have a branch specific to a minor release (for cutting patch releases) and master for development." created="2018-03-15 15:30:00.0" updateauthor="christopherferris" updated="2018-03-15 15:30:00.0"/>
