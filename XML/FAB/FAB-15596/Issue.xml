<Issue id="40250" key="FAB-15596" number="15596" project="10002" reporter="ales" creator="ales" type="10003" summary="QueryInstalledChaincodes should return aggregate info from old and new lifecycle" priority="3" status="10000" created="2019-05-31 14:44:47.0" updated="2020-06-11 15:31:06.0" votes="0" watches="1" workflowId="53156"> <description><! CDATA The new version of the query should basically aggregate the results from the current version of the query and LSCC.GETINSTALLEDCHAINCODES. One issue with this is that the current results of the query contain {code:java} type QueryInstalledChaincodesResult_InstalledChaincode struct { 	PackageId            string   `protobuf:"bytes,1,opt,name=package_id,json=packageId,proto3" json:"package_id,omitempty"` 	Label                string   `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"` 	XXX_NoUnkeyedLiteral struct{} `json:"-"` 	XXX_unrecognized       byte   `json:"-"` 	XXX_sizecache        int32    `json:"-"` } {code}  but the legacy chaincode returns  {code:java} type ChaincodeInfo struct { 	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` 	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"` 	// the path as specified by the install/instantiate transaction 	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"` 	// the chaincode function upon instantiation and its arguments. This will be 	// blank if the query is returning information about installed chaincodes. 	Input string `protobuf:"bytes,4,opt,name=input,proto3" json:"input,omitempty"` 	// the name of the ESCC for this chaincode. This will be 	// blank if the query is returning information about installed chaincodes. 	Escc string `protobuf:"bytes,5,opt,name=escc,proto3" json:"escc,omitempty"` 	// the name of the VSCC for this chaincode. This will be 	// blank if the query is returning information about installed chaincodes. 	Vscc string `protobuf:"bytes,6,opt,name=vscc,proto3" json:"vscc,omitempty"` 	// the chaincode unique id. 	// computed as: H( 	//                H(name || version) || 	//                H(CodePackage) 	//              ) 	Id                     byte   `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"` 	XXX_NoUnkeyedLiteral struct{} `json:"-"` 	XXX_unrecognized       byte   `json:"-"` 	XXX_sizecache        int32    `json:"-"` } {code} where Input, Escc and Vscc are not filled.  We might have to change protobufs, but we shouldn't add fields from the legacy lifecycle to the new protobufs returns. We might solve it with an array of oneofs (which isn't allowed actually, so we might need an intermediate type).  We need to apply appropriate shadowing rules so that if a chaincode is present on both lifecycles, information from the new lifecycle shadows that from the legacy.  We also need a flag to tell which of the chaincode is currently defined in the new or the legacy lifecycle.  ></description> </Issue>
