<Action id="29523" issue="19176" author="guoger" type="comment" created="2017-08-08 07:16:31.0" updateauthor="guoger" updated="2017-08-08 07:16:31.0"> <body><! CDATA For solo orderer, message needs to be revalidated in consenter, *iff*: 1. {{ConfigUpdate}} received at broadcast and validated 2. broadcast sends {{ConfigUpdate}} to consenter, and block waiting for it being consumed 3. consenter consumes {{ConfigUpdate}}, unblocks broadcast 4. {{NormalMsg}} received at broadcast and validated 5. {{ConfigUpdate}} is applied, causing _ConfigSeq_ to be advanced 6. broadcast sends {{NormalMsg}} to consenter 7. Since _ConfigSeq_ is advanced, {{NormalMsg}} is *revalidated*  In another word, the reason of message being valid at broadcast but invalid at consenter, is that *Config being applied asynchronously*.  Is this correct? Is there any other case where messages need to be revalidated? Also, could you point me to a test case for this? thx  ~jyellick   ></body> </Action>
<Action id="29542" issue="19176" author="jyellick" type="comment" created="2017-08-08 14:20:46.0" updateauthor="jyellick" updated="2017-08-08 14:20:46.0"> <body><! CDATA  ~guoger  Yes, the flow you suggest is correct.  Essentially, the many parallel go routines may validate messages concurrently in the context of the current configuration.  So long as this configuration does not change, we may assume that the validation will not change between the ingress validation, and ordering.  We detect that the configuration has changed by including a sequence number along with the validation.  If the configuration's sequence advances between validation and commit time, then the messages must be revalidated before commit.  I took a quick glance at the solo code, and I do not think there are any tests for this yet, which is definitely a deficiency.  I'm creating a task to add them.  Feel free to assign to yourself or I will get around to it eventually.  ></body> </Action>
