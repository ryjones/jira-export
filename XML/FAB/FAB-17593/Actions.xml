<Action id="68252" issue="44522" author="wenjian" type="comment" body="CI build: https://dev.azure.com/Hyperledger/Fabric/_build/results?buildId=9281&amp;view=logs&amp;j=a11cdf60-0d11-5130-c801-1b4953009464" created="2020-03-06 20:58:58.0" updateauthor="wenjian" updated="2020-03-06 20:58:58.0"/>
<Action id="68428" issue="44522" author="sykesm" type="comment" created="2020-03-18 23:33:07.0" updateauthor="sykesm" updated="2020-03-18 23:45:43.0"> <body><! CDATA The failure is likely due to concurrency issues. A callback function is supposed to fire the metric with two arguments but that callback didn't run. There *may* be some info in the log that explains why but I can't find the needle in the haystack.  There are also block of code like this on the path {code} 	_, err = stream.operateWithTimeout(f) {code} where we get an error bug do nothing with it that make me scratch my head - especially as the caller can't return the error. Looks like we use a side-effect reference the error in a deferred function to "debug" log it. Gah... We have a synchronous call yet we rely on defer. We have an error yet we simply debug log it.  There is an error logged {code} 2020-03-05T03:31:34.8237036Z  33m2020-03-05 03:30:52.157 UTC  orderer.common.cluster.step  Recv -> WARN 0ea 0m Stream 1 to (127.0.0.1:34503) was forcibly terminated because timeout (1s) expired {code} but it's hard to correlate that with anything. If it was related to the test that failed, then that might mean we're stuck in this block: {code} 	select { 	case r := <-responseChan: 		if r.err != nil { 			stream.Cancel(r.err) 		} 		return r.res, r.err 	case <-timer.C: 		stream.Logger.Warningf("Stream %d to %s(%s) was forcibly terminated because timeout (%v) expired", 			stream.ID, stream.NodeName, stream.Endpoint, stream.Timeout) 		stream.Cancel(errTimeout) 		// Wait for the operation goroutine to end 		operationEnded.Wait() 		return nil, errTimeout 	} {code} where operationEnded.Wait is waiting for the go routine created to "invoke" the function responsible for updating the metric to complete. Â   ></body> </Action>
<Action id="68451" issue="44522" author="yacovm" type="comment" created="2020-03-19 21:55:48.0" updateauthor="yacovm" updated="2020-03-19 21:55:48.0"> <body><! CDATA {quote}2020-03-05T03:31:34.8237036Z  33m2020-03-05 03:30:52.157 UTC  orderer.common.cluster.step  Recv -> WARN 0ea 0m Stream 1 to (127.0.0.1:34503) was forcibly terminated because timeout (1s) expired {quote} Â   This wasn't logged in this test. This test has a timeout of an hour, and also the *Configure()* method only receives a single node as input, while in the log it received two, so it belongs to another test.  It is printed from *TestAbortRPC*.  Â   ></body> </Action>
<Action id="68452" issue="44522" author="yacovm" type="comment" created="2020-03-19 22:01:47.0" updateauthor="yacovm" updated="2020-03-19 22:01:47.0"> <body><! CDATA {quote}where we get an error bug do nothing with it that make me scratch my head - especially as the caller can't return the error. Looks like we use a side-effect reference the error in a deferred function to "debug" log it. Gah... We have a synchronous call yet we rely on defer. We have an error yet we simply debug log it. {quote} Â   The caller doesn't return the error, but this error actually propagates to another place in the code where it is returned in future calls to *Send()* on the *Stream*.  ></body> </Action>
