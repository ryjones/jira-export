<Action id="69204" issue="45035" author="manish-sethi" type="comment" created="2020-05-11 16:25:50.0" updateauthor="manish-sethi" updated="2020-05-11 18:22:39.0"> <body><! CDATA  ~tock  - Yes, as a feature this makes sense. However, at the implementation level, just removing the folder in the block storage may be half job done. We would need to clean up the data from block storage index as well. We have been thinking of implementing the similar function at the peer level. This would include the code for the ledger at the order as well. FAB-17801 is the jira for this. So, I think that we can follow one of the following strategy - Wait for FAB-17801 and it would cover the most of the code for this Jira. - If you want to take up the ledger code at the orderer, we can split FAB-17801 and you can take up this portion. So, the intent is to avoid duplicate effort and delete the data thoroughly.  ></body> </Action>
<Action id="69210" issue="45035" author="tock" type="comment" created="2020-05-12 06:11:00.0" updateauthor="tock" updated="2020-05-12 07:10:33.0"> <body><! CDATA  ~manish-sethi  - Thanks for taking note to the duplication. Certainly, we want to avoid duplicate efforts and coordinate our actions on this one.  I browsed the set of tasks below FAB-17801, and most of them seem specific to the peer except this one: FAB-17802 (which is a sub-task of FAB-17787) which deals with deleting the blocks and the block indexes.   I admit that the definition here is limited to the use-case in the orderer... It seems we'll get everything we need at the orderer if we just implement  FAB-17802, is that right?  What is the timeline of the FAB-17802 story? That will affect the decision whether to wait or not. (  ~wlahti   ~caod  ).  ></body> </Action>
<Action id="69218" issue="45035" author="manish-sethi" type="comment" created="2020-05-12 14:50:06.0" updateauthor="manish-sethi" updated="2020-05-12 15:02:04.0"> <body><! CDATA  ~tock  Yes, FAB-17802 is the correct sub-task and it is under the broader story of peer, because the code in fabric/common/ledger is shared between the peer and the orderer. Only difference is that the index configurations that are passed to this code differ for the peer component from the orderer component, the peer configurations being a super-set of the orderer configurations.  In a way, if we implement for the peer, keeping all index entries in mind, this would cover for the orderer as well - except the specific, higher level API/command line.  On the timelines, I'll discuss with the team and update you here and based on that we can take a call. In the meanwhile, can you share your timelines for this dependency?   ></body> </Action>
<Action id="69705" issue="45035" author="wlahti" type="comment" body="PR for remove: https://github.com/hyperledger/fabric/pull/1609" created="2020-07-16 14:08:28.0" updateauthor="wlahti" updated="2020-07-16 14:08:43.0"/>
<Action id="69868" issue="45035" author="tock" type="comment" created="2020-08-06 08:48:26.0" updateauthor="tock" updated="2020-08-06 08:48:26.0"> <body><! CDATA The "*archive*" flavor is removed from this task (edited out of the description).  Here are the arguments.     This archiving part of the story is pretty low priority. I am not convinced that we need it. Especially since a "backup" exists at other orderers, and "restore" is automatic when rejoining a channel. Moving the ledger to a side location is just a half measure - as recovery would have to manual by the admin - the admin will copy files to the right location and will have to restart the orderer.     There are more appealing alternatives: Just `{{stop`}} the runtime resources, mark the channel somehow - say by adding a marker file in the file repo, e.g. ".stopped" - and simply keeping the ledger content where it is. The channel would be removed from the channels list and ignored on restart (moved to a list of "stopped" chains). The admin would be able to restart the channel with a respective `{{start`}} command or {{`rejoin}}` ({{update}}) by supplying a new join block. If the join block is further along the chain, the orderer will onboard the missing blocks and continue as usual i.e. as member or follower. The admin would also be able `{{remove}}` it completely.There are some tricky issues to sort out, however, the main idea is to back-off archiving for the first release of this API, and possibly extend it with `{{stop`}} , `{{start`}} and `{{update}}/{{rejoin}}` in the future.   ></body> </Action>
