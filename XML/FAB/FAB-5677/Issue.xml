<Issue id="20063" key="FAB-5677" number="5677" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10003" summary="Extract gossip service adapter and message crypto service into single mediation interface" priority="3" resolution="10000" status="6" created="2017-08-09 12:33:43.0" updated="2018-07-20 14:14:02.0" resolutiondate="2017-08-14 07:58:20.0" votes="0" watches="1" workflowId="39678"> <description><! CDATA Currently there are two external services required for state transfer:  1. Gossip service 2. Message Crypto service  In order to use them state transfer module depends directly on the definitions of those interfaces and requires to pass them into constructor function  {code} func NewGossipStateProvider(chainID string, g GossipAdapter, committer committer.Committer, mcs api.MessageCryptoService) GossipStateProvider {code}  Later this needed to be extended to include also identity mapper capabilities, to be able to identify from whom to request specific private collection. Therefore instead of adding new parameter into state constructor function, it will be much convenient to capture needed capabilities into intermediate struct which will serve as an adapter for required APIs allowing more powerful and fine grained control. For example:  {code} // GossipAdapter defines gossip/communication required interface for state provider type GossipAdapter interface { 	// Send sends a message to remote peers 	Send(msg *proto.GossipMessage, peers ...*comm.RemotePeer)  	// Accept returns a dedicated read-only channel for messages sent by other nodes that match a certain predicate. 	// If passThrough is false, the messages are processed by the gossip layer beforehand. 	// If passThrough is true, the gossip layer doesn't intervene and the messages 	// can be used to send a reply back to the sender 	Accept(acceptor common2.MessageAcceptor, passThrough bool) (<-chan *proto.GossipMessage, <-chan proto.ReceivedMessage)  	// UpdateChannelMetadata updates the self metadata the peer 	// publishes to other peers about its channel-related state 	UpdateChannelMetadata(metadata   byte, chainID common2.ChainID)  	// PeersOfChannel returns the NetworkMembers considered alive 	// and also subscribed to the channel given 	PeersOfChannel(common2.ChainID)   discovery.NetworkMember }  // MCSAdapter adapter of message crypto service interface to bound // specific APIs required by state transfer service type MCSAdapter interface { 	// VerifyBlock returns nil if the block is properly signed, and the claimed seqNum is the 	// sequence number that the block's header contains. 	// else returns error 	VerifyBlock(chainID common2.ChainID, seqNum uint64, signedBlock   byte) error  	// VerifyByChannel checks that signature is a valid signature of message 	// under a peer's verification key, but also in the context of a specific channel. 	// If the verification succeeded, Verify returns nil meaning no error occurred. 	// If peerIdentity is nil, then the verification fails. 	VerifyByChannel(chainID common2.ChainID, peerIdentity api.PeerIdentityType, signature, message   byte) error }  // ServicesMediator aggregated adapter to compound all mediator // required by state transfer into single struct type ServicesMediator struct { 	GossipAdapter 	MCSAdapter } {code}   Which will allow to change signature of the constructor to  {code} func NewGossipCoordinatedStateProvider(chainID string, services *ServicesMediator, coordinator Coordinator) GossipStateProvider  {code}  and use it in following way:  {code} 	servicesAdapater := &state.ServicesMediator{GossipAdapter: g, MCSAdapter: g.mcs} 	stateProvider := state.NewGossipStateProvider(chainID, servicesAdapater, committer) {code}  ></description> </Issue>
