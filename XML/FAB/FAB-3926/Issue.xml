<Issue id="16734" key="FAB-3926" number="3926" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Add UT to CSCC to validate incorrect input" priority="3" resolution="10000" status="6" created="2017-05-15 11:53:40.0" updated="2018-07-20 14:12:47.0" resolutiondate="2017-05-23 20:25:06.0" votes="0" watches="1" workflowId="38526"> <description><! CDATA Currently there is a place in the CSCC, e.g. {{configure.go}} code which validates correctness of input while not being tested with unit-test, hence not covered.  For example:   {code} 	if len(args) < 1 { 		return shim.Error(fmt.Sprintf("Incorrect number of arguments, %d", len(args))) 	} {code}  and   {code} 		if err = e.policyChecker.CheckPolicyNoChannel(mgmt.Members, sp); err != nil { 			return shim.Error(fmt.Sprintf("\"GetChannels\" request failed authorization check:  %s ", err)) 		} {code}  Additionally there is places with duplicate code such as:  {code} // joinChain will join the specified chain in the configuration block. // Since it is the first block, it is the genesis block containing configuration // for this chain, so we want to update the Chain object with this info func joinChain(blockBytes   byte) pb.Response { 	if blockBytes == nil { 		return shim.Error("Genesis block must not be nil.") 	}  	block, err := utils.GetBlockFromBlockBytes(blockBytes) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to reconstruct the genesis block, %s", err)) 	}  	if err = peer.CreateChainFromBlock(block); err != nil { 		return shim.Error(err.Error()) 	}  	chainID, err := utils.GetChainIDFromBlock(block) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to get the chain ID from the configuration block, %s", err)) 	}  	peer.InitChain(chainID)  	if err := producer.SendProducerBlockEvent(block); err != nil { 		cnflogger.Errorf("Error sending block event %s", err) 	}  	return shim.Success(nil) } {code}  and   {code} func updateConfigBlock(blockBytes   byte) pb.Response { 	if blockBytes == nil { 		return shim.Error("Configuration block must not be nil.") 	} 	block, err := utils.GetBlockFromBlockBytes(blockBytes) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to reconstruct the configuration block, %s", err)) 	} 	chainID, err := utils.GetChainIDFromBlock(block) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to get the chain ID from the configuration block, %s", err)) 	}  	if err := peer.SetCurrConfigBlock(block, chainID); err != nil {  		return shim.Error(err.Error()) 	}  	return shim.Success(nil) } {code}  where code which is repeated and could be extracted into separate function is  {code} 	if blockBytes == nil { 		return shim.Error("Configuration block must not be nil.") 	} 	block, err := utils.GetBlockFromBlockBytes(blockBytes) {code}  ></description> </Issue>
