<Issue id="13925" key="FAB-1516" number="1516" project="10002" reporter="muralisr" assignee="jiangyaoguo" creator="muralisr" type="10002" summary="committer side upgrade processing" priority="3" resolution="10000" status="6" created="2017-01-04 19:05:07.0" updated="2018-07-20 14:11:07.0" resolutiondate="2017-04-26 14:00:35.0" votes="0" watches="1" workflowId="36949"> <description><! CDATA The admin does the following from SDK or CLI * install the chaincode to be upgraded - nothing special need to be done to differentiate the "upgrade" from "instantiate". The install process is same for both cases * upgrade the chaincode on a channel ** from CLI this is {{peer chaincode upgrade -n <name of the chaincode> -v <version to be upgraded to> -p <path to the chaincode> -c <init paramers to call on the upgrade> -C <channel name>}}  The following tasks complete the endorser side of upgrade * FAB-1238 implement "upgrade" command in Life Cycle System Chaincode (lccc.go) * FAB-1237 new "upgrade" command to CLI * FAB-1318 use version to disambiguate running version from upgraded version * FAB-1357 introduced version into the chaincode context in preparation for upgrade processing  This task focuses on the committer side where an upgrade task needs to do the following. When processing a block of transactions, the following algorithm will ensure the upgrade is correct. * collect all the transactions that target "lccc" whose verb is "upgrade" * invalidate all transactions which are "invokes" to upgraded chaincodes in that block * process block once again to ignore the invalidated transactions  The rationale for the above   {code:java} The scenario - many proposals are happening on the chaincode on channel x at the time of upgrade of a chaincode. Some of them end up as transactions before the block on which upgrade turns up, others after and a few on the same block.  For consistency and determinism, enforcing the following rules will be sufficient  - invokes will be stamped not only with chainID but also version. This will thus be part of the MVCC rw-set. (see ChaincodeHeaderExtension.chaincode_id) - at commit time, all transactions for the chaincode will be invalidated on the block on which there's an upgrade (those transactions cannot be on the commited version and we don't want the upgrade to fail due to collision with a previous transaction in the block). - at commit time, all transactions for the chaincode on previous block will follow normal processing. - at commit time, all transactions for the chaincode will be checked for version match and will fail if they were based off a previous chaincode version {code}  The code to be refactored is mainly {{func (v *txValidator) Validate(block *common.Block) error}} in {{core/committer/txvalidator/validator.go}}     	   ></description> </Issue>
