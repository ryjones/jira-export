<Action id="19750" issue="13329" author="kchristidis" type="comment" created="2016-11-13 16:09:01.0" updateauthor="kchristidis" updated="2016-11-14 00:10:39.0"> <body><! CDATA Let's try to come up with some sensible defaults for the message that this client will send out. I'm looking at the enclosed ConfigurationItem message in particular.  # Is the ConfigurationType Chain or Orderer? # Do we agree that the ChainHeader of both the Payload and the ConfigurationItem should reference the "private", internal-to-the-ordering-service chainID? # Do we choose the same ModificationPolicy as for the static bootstrapper to begin with? # New chain ID value: Looking at Elli's deck, the new chain ID value should be the hash of a message that includes a nonce, and a bunch of certificate chains and signatures. Concretely, for this minimum test client, given that it won't use signatures or certificates, what do we generate this hash over? Should it be the hash of the nonce in the SignatureHeader, the nonce itself, or something else? # Assuming the assumption in #2 is correct, we still need a way to express that we want a new channel to be created, so this is where the Key and Value fields presumably come in. Key="chainID" and Value=new-chain-ID-value-goes-here? # Finally, let's agree down on how the epoch number is generated.  ></body> </Action>
<Action id="19753" issue="13329" author="jyellick" type="comment" created="2016-11-14 14:30:55.0" updateauthor="jyellick" updated="2016-11-14 14:30:55.0"> <body><! CDATA > 1. Is the ConfigurationType Chain or Orderer?  In general, for a valid configuration, the {{ConfigurationItem}} items will be of mixed type.  I'm not sure what this is asking?  > 2. Do we agree that the ChainHeader of both the Payload and the ConfigurationItem should reference the "private", internal-to-the-ordering-service chainID?  I would actually say no, this is flipped.  The ChainID should be the new ID of the new chain.  There should be a config item which specifies the 'ordering internal chain' id.  > 3. Do we choose the same ModificationPolicy as for the static bootstrapper to begin with?  You'll notice that the modification policy that the static bootstrapper puts in place today essentially makes all modification impossible (1 out of 0 sigs required).  Without a real crypto stack implemented or certificate material to work with, the modification policies are of questionable value (beyond allowing all modification or none).  For the purposes of the test client, I would think to create a new modification policy which is entirely permissive (0 out of 0 sigs required) and utilize this.  > 4. New chain ID value: Looking at Elli's deck, the new chain ID value should be the hash of a message that includes a nonce, and a bunch of certificate chains and signatures. Concretely, for this minimum test client, given that it won't use signatures or certificates, what do we generate this hash over? Should it be the hash of the nonce in the SignatureHeader, the nonce itself, or something else?  I'd like to talk a little with you and Elli about this, but is it particularly important for this test client? Once the logic is hammered out, we'll need to implement a filter or other mechanism to enforce it, but for the time being use a hash of the current time or something?  > 5. Assuming the assumption in #2 is correct, we still need a way to express that we want a new channel to be created, so this is where the Key and Value fields presumably come in. Key="chainID" and Value=new-chain-ID-value-goes-here?  As mentioned in (2), I saw this flipped, where the config specifies the parent chain ID and the new chain ID is specified in the header.  > 6. Finally, let's agree down on how the epoch number is generated.  All I've really been told is that it is 'based on the block number'.  My naive assumption would be that this should be 'the block number through which I want this signature to be accepted" so that the client can pick epochs based on the current network volume, but Elli might have a better response.  ></body> </Action>
<Action id="19754" issue="13329" author="jyellick" type="comment" created="2016-11-14 15:27:16.0" updateauthor="jyellick" updated="2016-11-14 15:27:16.0"> <body><! CDATA Just to elaborate on why I think the configuration transaction must have the target chain ID in the header, this transaction will form the genesis block for the new chain, and all transactions in a chain should have the same chainID.  If the transaction were bound for the ordering specific chain, then the ordering service would somehow need to transform it to form the genesis block, and it would be tricky to keep the non-repudiation about how requested the new channel.  I do however see this channel creation request being wrapped by the ingress orderer and sent on an ORDERING_TRANSACTION type message to the ordering specific chain (as dictated by the config parameter).  Fundamentally, the chain creation stuff is really an 'orderer application', so it makes sense to me that it would be an orderer who submits the ORDERER_TRANSACTION transaction request to create a chain embedding that CONFIGURATION_TRANSACTION.  ></body> </Action>
<Action id="19755" issue="13329" author="kchristidis" type="comment" created="2016-11-14 21:46:33.0" updateauthor="kchristidis" updated="2016-11-15 00:30:24.0"> <body><! CDATA For #2, if we do flip the chains as you suggest, then I'd note that the epoch (#5) should reference the block height of the new chain, otherwise we're inconsistent. Then, a new-chain transaction is basically a configuration transaction that references a new-chain-id and has an epoch of 0.  (This was written before we discussed this in person. We both agree with the approach, just posting it here for reference.)  ></body> </Action>
<Action id="19757" issue="13329" author="kchristidis" type="comment" created="2016-11-15 01:44:32.0" updateauthor="kchristidis" updated="2016-11-15 01:45:16.0"> <body><! CDATA > For the purposes of the test client, I would think to create a new modification policy which is entirely permissive (0 out of 0 sigs required) and utilize this.  Isn't this what the {{AcceptAllPolicy}} in the {{cauthdsl}} package is for?  ></body> </Action>
<Action id="19758" issue="13329" author="jyellick" type="comment" created="2016-11-15 04:06:40.0" updateauthor="jyellick" updated="2016-11-15 04:06:40.0"> <body><! CDATA > Isn't this what the AcceptAllPolicy in the cauthdsl package is for?  Correct  ></body> </Action>
<Action id="19762" issue="13329" author="kchristidis" type="comment" body="WIP changeset here: https://gerrit.hyperledger.org/r/#/c/2483/" created="2016-11-15 13:23:11.0" updateauthor="kchristidis" updated="2016-11-15 13:23:11.0"/>
