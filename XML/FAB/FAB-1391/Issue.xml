<Issue id="13800" key="FAB-1391" number="1391" project="10002" reporter="yacovm" assignee="gennadyl" creator="yacovm" type="10002" summary="Expire peers dead for a long time in gossip membership module" priority="3" resolution="10000" status="6" created="2016-12-14 11:12:58.0" updated="2019-10-09 10:42:31.0" resolutiondate="2017-06-07 15:46:18.0" votes="0" watches="1" workflowId="36884"> <description><! CDATA The gossip membership module marks nodes that haven't sent an AliveMessage for a long time as dead. This might cause a problem in the long run when peers are either shut down for good, or their certificates are revoked (and then, their identity changes because the public key changes and then the PKI-ID which is derived from the public key, also changes).  We need to add an expiration period after which all peers that are dead for longer than that period, are cleaned from the memory structures.  There is a corner case that needs to be handled with care: Let peers *p0* and *p1* be alive, and let *p2* be dead for a long time.  Lets say *p0* deletes *p2* at time *T0* and *p1* deletes *p2* at time *T1>T0*. The following never-ending scenario is possible:  T0: *p0* deletes *p2* T0+(T1-T0)/2: *p1* gossips about  *p2*  to *p0*. Now *p0* starts the countdown for *p2* from 0. T1: *p1* deletes *p2*  T2: *p0* gossips to *p1* about *p2* And this can go on and on for ever, and *p2* will jump from *p0*'s in-memory structures to *p1*'s in-memory structures for ever.   This can be solved in 2 different approaches: # After *p0* deletes *p2* from its memory structures, it will refuse to learn about *p2* unless the signed timestamp on the last AliveMessage (that's how it learns about a dead peer) is not too far in the past. This assumes that the local clock in *p2* is not in the future, else it will fail. # Let's define *T* as the timeout period after which a peer is considered dead unless it sent an AliveMessage. Let *T\*k* for some natural constant *k* be the period after which a dead peer is not gossiped to other peers, and let *T\*k\*2* be the period after which a peer is cleaned from the memory structures. The scenario outlined above cannot happen since if *p0* deleted *p2* from its memory structures, that means that at least *T\*k* time has passed, and that also means that *p1* will not gossip *p2*'s existence to *p2* again.   I personally think that the 2nd method is better since it doesn't assume anything on maxium clock skew.  Any opinions?  ></description> </Issue>
