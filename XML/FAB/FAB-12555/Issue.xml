<Issue id="34813" key="FAB-12555" number="12555" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10001" summary="As a Fabric OSN administrator, I need a mechanism that allows my newly-onboarded OSN to participate in consensus" priority="3" resolution="10000" status="6" created="2018-10-21 21:30:22.0" updated="2019-01-21 23:21:18.0" resolutiondate="2019-01-21 23:21:18.0" votes="0" watches="3" workflowId="46278"> <description><! CDATA Given a system channel config block, we need a mechanism that: * Figures out the channels the cluster node participates in * Reaches out to the existing orderer nodes in these channels, and pulls the blocks.  First, we need to implement functionality that pulls blocks from a Raft node. (This will also be used to pull blocks from an OSN for snapshots.) Ideally, the functionality would figure out the heights of all orderer nodes: i.e - h0, h1, h2, h3 and then connect to a random one, but one that has the needed blocks. This ensures that we don't always connect to the leader, but also that we don't connect to an OSN that is too far behind and it might be one that is catching up on its own. In addition, we need to add block verification functionality in this client, and optionally use backward hash validation in chunks - pull some blocks up to a maximum configurable size (say, 10MB by default) and then verify the last block's signature and verify the rest via looking in the previous hash.  Then, the synchronization component will work as follows. Given a config block with a number *N*, the component is going to: * Pull the entire system chain starting from genesis, and ending in block *N*, and do hash chain validation during pulling, and make sure the given bootstrapping block *N* has a prev hash that is equal to the pulled block of *N-1* , and so on, down to the genesis block. * During that pull, all channel names are going to be collected and returned. * For each channel, we're going to connect to all orderer endpoints that are in the system channel in parallel, in order to find some orderer that services that channel. That orderer is going to be used to pull blocks from genesis, up to the last block. * Now that we know which orderer endpoints service the channels, we're going to iteratively (for each channel) - pull the chain and commit the blocks in the ledger. * Finally, the system channel itself is going to be pulled (once again!), and it would be committed up to the last block.  ></description> </Issue>
