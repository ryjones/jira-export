<Action id="48374" issue="31897" author="kchristidis" type="comment" created="2018-08-03 14:33:56.0" updateauthor="kchristidis" updated="2018-08-03 14:33:56.0"> <body><! CDATA Clarifying statements/questions:  # The channel-based API is the {{Step}}/{{Submit}} set of RPCs introduced in FAB-11142. # What does the comm layer use as its input? Presumably it's the struct carrying the cluster membership — the mapping of IDs to client/server TLS certificates and endpoints that you refer to in your 3rd bullet point. # A message is received by the comm layer and we can resolve its ID in the corresponding cluster successfully. How does the comm layer communicate this ID upstream? # What does reconfiguration (3rd bullet point) entail, and why is the responsibility of the comm layer?  ></body> </Action>
<Action id="48408" issue="31897" author="yacovm" type="comment" created="2018-08-03 21:02:29.0" updateauthor="yacovm" updated="2018-08-03 21:04:13.0"> <body><! CDATA # yes # at initialization - nothing. at config (for a channel) - the entire cluster membership in the form of a slice of structs each containing TLS server+client certificates in DER encoding, endpoint, and id. The mapping is computed on the fly. # it simply passes it as an argument when it invokes the method which passes the message. # I meant reconfiguraiton of the communication layer. It mutates the internal data structures of the comm layer (i.e - mapping of certs to (connections, IDs)),  and ensures that connections that point to stale TLS certificates are closed, and logical gRPC "connections" (i.e - streams) are connected to the TLS server certificate denoted in the new config (and if not - makes them reconnect again with the expectation of encountering the new server TLS cert. )  ></body> </Action>
<Action id="48470" issue="31897" author="kchristidis" type="comment" body="(Converted to Story and renamed to be inline with the plan in the spreadsheet. The scope of this work remains untouched. TODO for me: define acceptance criteria.)" created="2018-08-06 23:28:15.0" updateauthor="kchristidis" updated="2018-08-07 14:13:05.0"/>
<Action id="52472" issue="31897" author="kchristidis" type="comment" body=" ~C0rWin : Added a scenario for Type B. We&apos;ll need an additional one where we change leaders right after the Fabric update is ordered, but before the corresponding Raft update is — this will allow us to check that the handoff is taking place correctly. I suspect that this is difficult to test with what we have in place under the top-level {{integration}} package. What do you think? How can we be certain that what we have out there works as prescribed? A test case for  FAB-12518|https://jira.hyperledger.org/browse/FAB-12518 ?" created="2018-10-20 15:04:20.0" updateauthor="kchristidis" updated="2018-10-20 15:04:20.0"/>
