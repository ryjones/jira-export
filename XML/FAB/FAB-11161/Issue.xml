<Issue id="31897" key="FAB-11161" number="11161" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10001" summary="As a Fabric user, I want my barebones etcd/raft-based ordering service to support more than one Raft node" priority="3" resolution="10000" status="6" created="2018-07-15 11:21:44.0" updated="2019-01-20 15:42:13.0" resolutiondate="2019-01-20 15:42:13.0" votes="0" watches="2" workflowId="35956"> <description><! CDATA We need 3 things to make this work:  1. A communication layer that allows the replicas in a cluster to communicate with each other.  The communication layer shall expose a channel-based API (every operation is in the context of a specific channel) to do the following: * Establish a secure, authenticated (via  TLS certificate pinning|https://security.stackexchange.com/a/29990 ) connection given a node ID, and use the connection to send transactions or raft messages to remote cluster nodes. * Receive messages from cluster nodes and identify their corresponding IDs based on the TLS client certificate of the remote cluster node. * Reconfigure the cluster membership (mapping of IDs to client/server TLS certificates and endpoints).  The actual gRPC connections are going to be shared among all the gRPC logical channel-based streams/RPCs, and every outgoing connection is going to be dedicated for a specific TLS server certificate and endpoint.  2. Full Type B configuration support. This requires extending FAB-12015 to allow us to expand the consenter set. This also requires adding the logic described  in the design doc|https://docs.google.com/document/d/138Brlx2BiYJm5bzFk_B0csuEUKYdXXr7Za9V7C76dwo/edit#heading=h.sn7gul2qszyp , where a new leader checks to make sure that such a Fabric configuration update is not sitting at the tip of the chain; if it is, the leader needs to make sure that the corresponding Raft config update is committed before any other transaction.  3. Onboarding a new orderer node to an existing cluster ( FAB-12016|https://jira.hyperledger.org/browse/FAB-12016 ).  h2. Acceptance Criteria  h3. Scenario 1 (check that the comms layer works as expected)  # User edits {{configtx.yaml}} so as to have a network with a 3-node etcd/raft-based ordering service and a system channel that is also an application channel. Assume {{BatchSize}} is set to 1. # User launches the multi-node etcd/raft-based ordering service. # User invokes the Broadcast RPC to send transaction {{foo-1}} to the 1st node in the service. Repeat for {{foo-2}} and the 2nd node, and {{foo-3}} and the 3rd node. # User invokes the Deliver RPC. They should receive 3 blocks, each containing one of the transactions sent above. The order does not have to be the same.  h3. Scenario 2 (check that Type B config support works as expected)  # User edits {{configtx.yaml}} so as to have a network with a 5-node etcd/raft-based ordering service and a system channel that is also an application channel. # User launches multi-node etcd/raft-based ordering service. # User invokes the Broadcast RPC to send a Type B configuration that removes the node-5 from the consenter set. # User invokes the Deliver RPC targeting one of the remaining 4 nodes. Ensure that the configuration update sent in the step above has been ordered and committed. # User invokes the Broadcast RPC to order transaction {{foo}} targeting one of the remaining 4 nodes in the cluster. # User invokes the Deliver RPC targeting one of the remaining 4 nodes. Ensure that a block containing the transaction above is received. # Repeat step above, targeting node-5. The node should be unable to return the block containing transaction {{foo}}.  ></description> </Issue>
