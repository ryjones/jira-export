<Issue id="46473" key="FAB-18393" number="18393" project="10002" reporter="sykesm" creator="sykesm" type="10000" summary="Credential token based authorization for the participation API" priority="3" status="10100" created="2021-01-08 16:04:44.0" updated="2021-01-08 18:46:31.0" votes="0" watches="2" workflowId="60414" archived="N"> <description><! CDATA The participation API exposed by the orderer currently relies on Mutual TLS for authentication and authorization. While sufficient, it’s cumbersome in practice and introduces patterns where the orderer’s local MSP is not involved in the authorization decisions.  This goal of this epic is to adopt the minimal subset of OAuth2 required to perform client authentication using the `private_key_jwt` defined in OpenID Connect. Using this pattern, the client can assert its own identity by signing a JWT that contains its public key certificate, present it to the orderer, and request an access token for future interactions.  The initial work will target the participation API but this pattern can be extended to support the requirements of FAB-16855 for the peer.  — {code} # Authentication and Authorization  ## Summary  The channel participation API currently uses TLS mutual authentication to authenticate and authorize channel administration operations. There are two minor issues with this approach.  1. The client CA certificate used to control access to the channel participation API is disconnected from the orderer's local MSP. 2. It's difficult for web applications to establish connections to the orderer using TLS mutual authentication.  This goal of this proposal is to describe an authentication flow based on  RFC7523  RFC7523 . This flow can be used to obtain an access token for the channel participation API from a certificate representing an MSP identity.  ## OpenID Connect Authentication  OpenID Connect is an identity layer that sits on top of the OAuth 2.0 protocol. It enables clients to verify the identify of an end-user by authenticating with an authorization server. In addition to end user authentication, the spec also defines methods for client authentication.  The  `private_key_jwt`  private_key_jwt  client authentication method allows a client to use a private key associated with a registered public key to sign an authentication token and assert its own identity. This `client_assertion` can then be used to acquire an `access_token` from the resource server's `/token` endpoint.  ### Building the Authentication Token  The token used for authentication is a `client_assertion` JWT and consists of three sections: the JOSE Header, Claims, and the JWS Signature.  #### JOSE Header  The JWT constructed by a client includes a JOSE header with the `typ`  set to `JWT`, the `alg` set to `ES256` for ECDSA-P256 certificates (the only type we'll support initially), and `x5c` set to the certificate or certificate chain of the client in the form described by  RFC7517  RFC7517 .  #### Claims  The JWT claims must include include the following fields:  - `iss` - the `client_id` associated with the certificate. - `sub` - the `client_id` associated with the certificate. - `aud` - the intended "audience" for the claim and should be the URL of the of the token endpoint. - `jti` - a unique token identifier that helps prevent replay attacks. - `exp` - the token expiration time represented as the number of seconds since the Unix Epoch. - `iat` - the time the assertion was created represented as the number of seconds since the Unix Epoch.  The `iss` and `sub` fields must contain the same value. The `client_id` should be the _MSPID_ that issued the certificate. This allows us to validate the certificate against the correct MSP.  The `aud` value provided by the client must match the URL of the token endpoint. Because of proxying, the expected value(s) may need to be configured on the server.  The `jti` is generated by the client and is intended to act as a nonce to prevent replays. Prior to returning an `access_token` to the client, the server should save a reference to the `jti` value in memory until the token expires at `exp`. If a `client_assertion` is received with a previously observed `jti`, the assertion token must not be accepted.  The `exp` time in the token should be checked against the local clock. If the expiry is in the past, the assertion must not be accepted. If the expiry time is more than some threshold in the future, the assertion must not be accepted.  The `iat` time in the token should be checked against the local clock. If the token was issued more than some threshold in the past, the assertion must not be accepted. The window between `iat` and `exp` should represent a reasonable window of time for authentication - typically less than a minute or two.  #### JWS Signature  After creating the header and claims objects, a signature needs to be generated over the two objects. This is done by base64 URL encoding the UTF-8 representation of the header and claims, joining them by a period (`.`), generating a signature using the algorithms defined in  RFC7518  RFC7518 , and base64 URL encoding the resulting signature. The complete token is formed by joining the encoded header, claims, and signature with a period (`.`).  The algorithm claimed in the header must be appropriate for the certificate included in the header and must be the one used to generate the signature. The only algorithm we will support initially will be `ES256` using for ECDSA-P256 private keys.  ### Authenticating  Section  4.2  RFC7521-4.2  of  RFC7521  RFC7521  defines how to present `client_assertion` tokens to an OAuth token endpoint and section  2.2  RFC7523-2.2  of  RFC7523  RFC7523  defines the required parameters.  At a high level, authenticating  involves a `POST` request to the token endpoint with a number of `application/x-www-form-urlencoded` parameters. The parameters are:  - `grant_type` - the value `client_credentials` - `client_assertion_type` - the value `urn:ietf:params:oauth:client-assertion-type:jwt-bearer` - `client_assertion` - the value of the authentication token  Our token endpoint implementation must must require the use of TLS connections. When requests are received, we must examine the parameters and reject any requests that arrive for grant types other than `client_credentials` or assertion types other than the JWT bearer URN with `400 Bad Request`.  #### Validating the `client_assertion` Token  A number of libraries exist in `go` to process JWT tokens so there's little reason to roll our own. For example, the  `go-jose.v2`  go-jose  package implemented by square looks to be of high quality, supports `x5c` certificate chains, and has an active community.  After using a library to verify that a token is well formed and valid, the claims can be evaluated. This is where we check that the `aud` claim matches our token endpoint, that `iss` and `sub` are equal and contain a known MSP identifier, and that the MSP considers the certificate (or chain) valid. Finally, we need to ensure that the `jti` has not already been observed by this server.  Once these checks have been performed, we should be convinced that the certificate is valid, that the token is valid, and that this assertion will only be honored once in the window between `iat` and `exp`.  #### Issuing the `access_token`  In response to a successful `client_assertion`, the token endpoint generates an OAuth2 compatible JSON response that contains an `access_token`, `token_type`, and `expires_in` properties. The response should not include a `refresh_token` as the client can self-refresh by re-asserting its identity.  Since we only require our tokens to be valid for the current server, we don't need to use a JWT for the `access_token`. For the sake of simplicity, we can use a base64 encoded token that is 32 bytes of random data and equivalent to a session ID.  The `token_type` should be set to `bearer` and the `expires_in` value should be some small, configurable duration that defaults to 300 seconds or less.  This generated token needs to be stored in memory and mapped to the certificate extracted from the `client_assertion`, the MSP ID from the `client_id`, and the expiration time of the `access_token`. An asynchronous task should be scheduled to reap expired tokens on a regular basis.  ## Authorization  When a protected endpoint is accessed by a client, `http.Handler` middleware will intercept the request to perform authorization. First, the middleware will check for a bearer token in the `Authorization` header. If the header does not contain a token, the request will be rejected with a `401 Unauthorized`.  Once we have the token, the we will look in the `access_token` map for the certificate and expiry information associated with the token. If the entry is not found, the request will be rejected with a `403 Forbidden`. If the `access_token` is found but has expired, the request will be rejected with a `403 Forbidden`.  At this point we should have the certificate associated with the client and the MSP responsible for validating it. With these two bits of information, we can check if the identity represented by the `access_token` is authorized to perform the requested operation.  ## Additional Comments  Building on OpenID Connect and OAuth should make REST client development a relatively straightforward task, allows us to use existing libraries, and prevents us from rolling our own crypto. This proposal adopts just enough of OAuth  to solve the problems we have today but allows us to grow the solution in the future by adopting JWT access tokens that include access control scopes and additional `aud` definitions. The OAuth2 `access_token` is also usable in gRPC clients by using the`google.golang.org/grpc/credentials/oauth` package. This allows us to introduce gRPC services that require authorization without the need for enveloping and signing the messages.   private_key_jwt : https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication  RFC7517 : https://tools.ietf.org/html/rfc7517  RFC7518 : https://tools.ietf.org/html/rfc7518  RFC7521 : https://tools.ietf.org/html/rfc7521  RFC7521-4.2 : https://tools.ietf.org/html/rfc7521#section-4.2  RFC7523 : https://tools.ietf.org/html/rfc7523  RFC7523-2.2 : https://tools.ietf.org/html/rfc7523#section-2.2  go-jose : https://gopkg.in/square/go-jose.v2/jwt  {code}  ></description> </Issue>
