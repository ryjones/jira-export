<Action id="37400" issue="25900" author="yacovm" type="comment" created="2017-12-15 08:18:10.0" updateauthor="yacovm" updated="2017-12-15 16:21:04.0"> <body><! CDATA The biggest problem I see with this proposal, is that with careless use it might lead to big problems: Consider a channel with 3 organizations- A,B,C and that B and C have a chaincode (*CC1*), and A agrees that the transaction will be valid if it is endorsed by both B and C because it doesn't have the chaincode (org A is a user organization, it doesn't have any peers).  Now, B and C don't trust each other fully, so they don't use the majority policy - because if they had, A could collude with either B or C and endorse a transaction artificially.  So, they create a new policy type in the resource config and call it "B_and_C" and instantiate the chaincode to reference it.  After a few weeks they (B and C) decide to deploy a new chaincode (*CC2*) to be used only by them, and this chaincode is "secret" and they will refuse to share it with anyone else. Since they have the already defined policy: B_and_C, they use it when the chaincode is deployed.  Afterwards, new organizations joins the channel, org D and org E. Org D and org E are 2 organizations that trust each other and are much similar to org B and org C , and naturally they don't trust org B and org C so they ask that 1 of them would be needed to endorse a transaction from *CC1*.   Now, we can't change the policy B_and_C because then it would break *CC2*, but if we don't change the policy, orgs D and E would refuse to participate in the channel.  This leads me to think, that the most safe thing that a chaincode instantiator should *always* do is just define a policy per chaincode, because you never know what the future holds. And if we defined a policy per chaincode, that's basically mimicking the original resource config based approach.     I think that though the stop-gap solution is "good enough until v1.2" we should also consider the impact on users of having the chaincode lifecycle changed *every version*, and if we could just do this change *once and for all* it is much better than having a stop-gap solution for v1.1 and then at v1.2 have yet another change that would impact users again.  Another argument against this solution is that it has additional development overhead than the full-fledged lifecycle approach has (since its development has been completed). For the stop-gap solution to be effective, we need to develop additional tooling and it comes with its own cost.     So to summarize, I think that we should go for the fully fledged resource config approach, and for the plurality concern raised in FAB-7444: {quote}_Duplicating the same information in the resource tree and LSCC adds complexity that may lead to security bugs if the synchronization is not done properly or does not happen in an atomic fashion,_ {quote} We can then just not duplicate the information, and only use LSCC as an enabler for the init() but have it read the information from the resource config sub-tree.  And for the signature collection being out-of-band concern, we can adopt the solution proposed in FAB-7114 (use LSCC or some other chaincode as a registry for signature collection).  1 more thing - I think that the main problem with FAB-7444 is that the peer constructs the write-set for the client, and ideally - the client is the one that should do that since the client needs to give the consent on what to put in LSCC and not the peer.  This is exactly what the resource config does. So, I think that FAB-7444 with a variation where the client first queries LSCC to obtain the channel information it lacks, and then constructs the transaction himself (of course, using the SDK code), and endorses it himself with his own certificate is also a valid solution in my opinion.   ~mastersingh24  ,  ~elli-androulaki  ,  ~jyellick  wdyt?  ></body> </Action>
<Action id="44374" issue="25900" author="denyeart" type="comment" body="Superseded by FAB-8724" created="2018-05-14 21:34:47.0" updateauthor="denyeart" updated="2018-05-14 21:34:47.0"/>
