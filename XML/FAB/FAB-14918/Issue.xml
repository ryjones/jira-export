<Issue id="38901" key="FAB-14918" number="14918" project="10002" reporter="ales" creator="ales" type="10001" summary="State-based endorsement proper use of ApplicationPolicies" priority="3" status="10100" created="2019-04-01 08:46:55.0" updated="2019-04-04 13:27:06.0" votes="0" watches="1" workflowId="51757"> <description><! CDATA There are 2 types of chaincode shims (2.0 shim that produces SBEP as ApplicationPolicy, and <2.0 shim that produces SBEP as SignaturePolicyEnvelope) that might interact with 2 different peers (a 2.0 peer on a 2.0 channel and a 2.0 peer on a 1.4 channel). 1) 1.4 shim <-> 2.0 channel: the 1.4 shim will set a SignaturePolicyEnvelope to the MetaDataKeys_VALIDATION_PARAMETER key of the metadata; the 2.0 validator will perform the translation as expected - all good 2) 2.0 shim <-> 2.0 channel: the 2.0 shim will set an ApplicationPolicy to the MetaDataKeys_VALIDATION_PARAMETER_V2 key of the metadata; the 2.0 validator will perform no translation for policies set in the metakey - all good 3) 1.4 shim <-> 1.4 channel: the 1.4 shim will set a SignaturePolicyEnvelope to the MetaDataKeys_VALIDATION_PARAMETER key of the metadata; the 1.4 validator anyway expects SignaturePolicyEnvelope - all good 4) 2.0 shim <-> 1.4 channel: the 2.0 shim will set an ApplicationPolicy to the MetaDataKeys_VALIDATION_PARAMETER_V2 key of the metadata; the problem is that the 1.4 validator won't look at this meta key and so will think that there is no state-based endorsement policy; one might argue this is WAD. If this is not acceptable, we might be forced to introduce an additional capability check here https://github.com/hyperledger/fabric/blob/master/core/chaincode/handler.go#L1065-L1098 to ensure that if the channel is still at 1.4 we won't allow setting the MetaDataKeys_VALIDATION_PARAMETER_V2 metakey  Further, there's an even more complex problem on the chaincode side between the two types of shim (1.4 that uses the MetaDataKeys_VALIDATION_PARAMETER meta key and 2.0 that uses the MetaDataKeys_VALIDATION_PARAMETER_V2) and the two types of convenience libraries (1.4 that produces SignaturePolicyEnvelope and 2.0 that produces ApplicationPolicy): 1) 1.4 library <-> 1.4 shim: the 1.4 library will produce SignaturePolicyEnvelope that the 1.4 shim will correctly set to the MetaDataKeys_VALIDATION_PARAMETER meta key 2) 1.4 library <-> 2.0 shim: the 1.4 library will produce SignaturePolicyEnvelope that the 2.0 shim will mistakenly set to the MetaDataKeys_VALIDATION_PARAMETER_V2 meta key 3) 2.0 library <-> 1.4 shim: the 2.0 library will produce ApplicationPolicy that the 1.4 shim will mistakenly set to the MetaDataKeys_VALIDATION_PARAMETER meta key 4) 2.0 library <-> 2.0 shim: the 2.0 library will produce ApplicationPolicy that the 2.0 shim will correctly set to the MetaDataKeys_VALIDATION_PARAMETER_V2 meta key  Cases 2 and 3 are problematic: one possible solution would be for  * in case 2) the 2.0 shim may use reflection to detect that it is linked to the old 1.4 library and use the old metakey * in case 3) the 2.0 library may use reflection to detect that it is linked to the old 1.4 shim and return old policies This may work but it's a tad brittle and inelegant.  Other solutions might be to yet again change the shim interface (https://github.com/hyperledger/fabric/blob/master/core/chaincode/shim/interfaces.go#L99-L105) adding the possibility to set "new" validation parameters (and deprecate and eventually remove the old one). This seems by far the cleanest option, but I have a feeling people will not like new changes to the shim interface.  ></description> </Issue>
