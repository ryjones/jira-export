<Issue id="33923" key="FAB-12060" number="12060" project="10002" reporter="troyronda" assignee="c0rwin" creator="troyronda" type="10004" summary="Payload buffer can report Ready when no payloads are available -- creating extra goroutines  -- due to interleaved push/pop)" priority="3" resolution="10000" status="6" created="2018-09-19 20:26:17.0" updated="2019-03-14 02:58:24.0" resolutiondate="2018-09-22 14:48:45.0" votes="0" watches="4" workflowId="45239"> <description><! CDATA PayloadsBufferImpl can produce extra Ready signals (and goroutines).  This could occur if the consumer is still draining the buffer while, at the same time, new payloads are being pushed in. In this case, the consumer loop picks up the new payload but doesn't drain the Ready chan. This would be expected for a peer that is not keeping up with block processing.  The additional Ready() chans & goroutines would be expected to drain once the peer catches up.   If the peer falls behind for a long time, you would expect many goroutines to be created and then many no-op-ish iterations of Ready() being called once the peer catches up.  The attached test outputs the following: === RUN   TestPayloadsBufferImpl_Interleave --- PASS: TestPayloadsBufferImpl_Interleave (1.01s) 	payloads_buffer_test.go:205: buffer ready (1) -- should be error 	payloads_buffer_test.go:210: payload: <nil> 	payloads_buffer_test.go:217: buffer ready (2) -- should be error 	payloads_buffer_test.go:222: payload: <nil> 	payloads_buffer_test.go:228: buffer not ready (3) -- good PASS   ></description> </Issue>
