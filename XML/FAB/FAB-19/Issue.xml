<Issue id="12317" key="FAB-19" number="19" project="10002" reporter="clayton sims" creator="clayton sims" type="10001" summary="Certain hashes should be reliably decomposable and introspectable #748" priority="3" resolution="10200" status="6" created="2016-08-11 15:35:25.0" updated="2019-04-30 17:32:24.0" resolutiondate="2019-04-30 17:32:24.0" votes="0" watches="1" workflowId="42857"> <description><! CDATA Copied from https://github.com/hyperledger/fabric/issues/748.  Summary: Previous discussions have resulted in a decent foundation for providing trust in a network of chaincode. For instance, chaincode IDs are formed, in part, by hashing the underlying code. While this notion is critically important for certain use cases, it only becomes fully useful if the resulting hash can actually be traced back to the source for parties that may be interested in actually verifying an endpoint. In order to do that, there needs to be a few things:  1) a formal specification for how the chaincodeID is composed. 2) a query interface to allow an interested party to optionally ask for the decomposition.  Today, we form a chaincodeID by taking a few things such as the chaincode path, the ctor args, and a hash of the code, and hashing them together as a binary tuple. Technically, we could formally specify this schema to satisfy (1). However, it is suggested that something that provides schema management be used instead such that applications may pick and chose which fields they care about, ignore the ones they don't, and yet still be able to verify a hash.  Example: If we used a JSON document rather than the binary tuple, the specification could simply be chaincodeID=sha3(json), where json={"chaincode-hash":XXXXX, "path":YYYY, "ctor-args":ZZZZ, ... }, and a call like HTTP GET /chaincode/$id/decomposition could return the json. An application could then do validation on the fields they care about (probably primary "chaincode-hash") and yet still verify that the resulting chaincodeID is related by hashing the json document themselves.  I am partial to protobufs over raw JSON as far as schema declarations are concerned, but I am flexible as long as the basic criteria outlined above could be met.    ></description> </Issue>
