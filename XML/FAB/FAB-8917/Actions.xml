<Action id="41733" issue="28589" author="odowdaibm" type="comment" body="Varun Raj – it would be great if you can add some thoughts here:" created="2018-03-16 07:53:50.0" updateauthor="odowdaibm" updated="2018-03-16 07:53:50.0"/>
<Action id="41734" issue="28589" author="odowdaibm" type="comment" created="2018-03-16 07:56:47.0" updateauthor="odowdaibm" updated="2018-03-16 07:56:47.0"> <body><! CDATA This was raised based on this discussion  https://chat.hyperledger.org/channel/fabric-documentation?msg=5Ap97qek58TMLyisE    ~odowdaibm  and  ~varun-raj   Please add your thoughts     ></body> </Action>
<Action id="41735" issue="28589" author="varun-raj" type="comment" created="2018-03-16 08:15:31.0" updateauthor="varun-raj" updated="2018-03-16 08:16:05.0"> <body><! CDATA Thanks for creating a topic for this  ~odowdaibm  .  There are a lot of ways to write a client application with help for  Fabric NodeSDK|https://github.com/hyperledger/fabric-sdk-node  and I'd like to share the one that we followed which also helps you build role-based authentication and multi-user capabilities.   *The Approach* * **We created a simple ExpressJS server to build a RESTFul server for our web app and mobile application. * We've used fabric ca client to generate users and also their certificates. thus when a user is created we'll be generating the certs and private key and zip into a card format and will email them the same without storing anything on the nodejs server. * When they log in, they upload the card to validate their account, we then extract the certs and private key and move it to the crypto store, validate the username with fabric ca. Once it's validated, we create a JWT token with the user enrollment id and timeout.  * And we use this token for future authentication as the key are present in the crypto store.  * When they logout we'll be deleting the keys, leaving no traces of the user's keys, by which we can create more security to the nodejs.  *For Role-Based Approach* * When we create the user, we define the roles in the attributes and then when we access the network, we check the role of the attributes in the chain code and validate the transaction flow accordingly. * If we want to promote or depromote the user, we issue the new enrolment certificate and revoke the current one. Thus the chain code remains unchanged.  ></body> </Action>
<Action id="41743" issue="28589" author="sjirnijssen" type="comment" body="I like to propose to add a business requirements set and illustrate these requirements with visual examples" created="2018-03-16 12:01:20.0" updateauthor="sjirnijssen" updated="2018-03-16 12:01:20.0"/>
<Action id="41779" issue="28589" author="sjirnijssen" type="comment" created="2018-03-18 09:47:22.0" updateauthor="sjirnijssen" updated="2018-03-18 09:47:22.0"> <body><! CDATA Hi Varun,  I read your paper Hyperledger Fabric Architecture: Explained in detail (version CET 2018-03-1045-1045) I believe the diagram is useful as it shows clearly that peers have to be contributed by an organization to the HLF network and that a CA is under the control of an organzation.  I believe we may have some misunderstanding on the orderers. In my opinio, it is a two-dimensional problem. Orderers are not under the command of a single organization, but an orderer must be contributed to the HLF network by an organization. I believe a diagram that would represent these two dimensions would be helpful. Could you agree or do I miss something?  Regards   ></body> </Action>
<Action id="41791" issue="28589" author="varun-raj" type="comment" created="2018-03-19 06:35:36.0" updateauthor="varun-raj" updated="2018-03-19 06:35:36.0"> <body><! CDATA Hi Sjir,  Actually, even in my article, it says that the orderer is under a domain and will be common for all the organizations. Also, you can have multiple orderers with help of kafka.   ></body> </Action>
<Action id="67439" issue="28589" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:32:32.0" updateauthor="sykesm" updated="2020-01-22 22:32:32.0"/>
