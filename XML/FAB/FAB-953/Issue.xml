<Issue id="13284" key="FAB-953" number="953" project="10002" reporter="bcbrock" creator="bcbrock" type="10001" summary="Kafka orderer: Hot-idle loop issues" priority="4" resolution="10000" status="6" created="2016-11-04 00:02:26.0" updated="2018-07-20 18:54:44.0" resolutiondate="2017-08-11 04:01:24.0" votes="0" watches="5" workflowId="36614"> <description><! CDATA In the Kafka orderer, the routine sendBlocks() in client_deliver.go is implemented as a "hot idle" loop. Every client that connects to the orderer for delivery service will spawn a goroutine that executes this loop, and as long as the client has "push tokens", this loop will never terminate. I've attached a screenshot of "top" showing that an "idle" Kafka orderer - that is, one that is not actually delivering any blocks - is consuming 11.24 HW thread-equivalents on this POWER8 system when serving 100 delivery clients.  Also interesting is that 47.8% of the CPU is reported as "waiting" by the OS. This is why we are not seeing even higher CPU utilization here, and is also pointing to a potential problem. The problem is that each delivery client shares a common `cd.deadChan`. When Go executes a `select`, it operates in a critical section that begins by locking every channel named in the select.  What is happening here is that every goroutine is simultaneously competing for the lock on `cd.deadChan`. Unable to immediately get the lock, the goroutines block (sleep) until it is their turn, and the OS is marking this sleep as I/O wait time. If the `cd.deadChan` case is commented out, CPU utilization can go as high as 100% of the entire machine if enough clients are connected (even though no actual work is being done).  I've attached a proposed patch idea for the first problem. Go allows `select` cases to be NIL. So instead of the 2-level scheme currently used, we can simply select on a variable that is NIL when the client has no tokens, and is set to the Kafka message channel when the client has tokens.  I have not yet looked for evidence of the global lock being an issue if this loop is event-driven. It's something to be aware of though, especially given the way that the Go runtime implements `select`.  ></description> </Issue>
