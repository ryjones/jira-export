<Issue id="27803" key="FAB-8342" number="8342" project="10002" reporter="callanhp" creator="callanhp" type="10001" summary="Allow querying inequalities for CompositeKeys with GetStateByRange" priority="3" resolution="10002" status="6" created="2018-02-16 17:54:53.0" updated="2018-08-20 11:35:23.0" resolutiondate="2018-08-20 11:35:23.0" votes="0" watches="1" workflowId="35560"> <description><! CDATA GetStateByPartialCompositeKey only allows for exact matching of key attribute values, it does not allow for comparisons. This is an issue when working with objects such as timestamps, where an exact match is far less valuable than a less than or greater than comparison.  This can be handled by allowing GetStateByRange to query both the composite and simple key namespaces, though obviously querying both at the same time is likely to cause issues.  This could be achieved by replacing the current validateSimpleKeys check with a namespacing check, i.e.  {{// GetStateByRange documentation can be found in interfaces.go}} {{func (stub *ChaincodeStub) GetStateByRange(startKey, endKey string) (StateQueryIteratorInterface, error) \{}} {{    if startKey == "" \{}} {{        startKey = emptyKeySubstitute}} {{    }}} {{    if keyInCompositeNamespace(startKey) != keyInCompositeNamespace(endKey) \{}} {{        return nil, fmt.Errorf("Range queries cannot mix simple and composite keys.")}} {{    }}} {{    return stub.handleGetStateByRange(startKey, endKey)}} {{}}}  Where {{keyInCompositeNamespace}} is something like the follows:  {{//Check if a given key is in the composite namespace}} {{func keyInCompositeNamespace(key string) bool \{}} {{    return len(key) != 0 && key 0  == compositeKeyNamespace 0 }} {{}}}     ></description> </Issue>
