<Action id="19219" issue="12967" author="tuand" type="comment" created="2016-10-12 20:21:19.0" updateauthor="tuand" updated="2016-10-12 20:21:19.0"> <body><! CDATA from the bootstrap feature file in FAB-359, the contents of the genesis block :  @given(u'the bootstrapAdmin creates the genesis block') def step_impl(context): ''' Gets the ordererOrgs CA certs gets the peer orgs CA certs Chain Policies: Orderer Org modificatio policy # Specifies what is required in order to modify the orderer org membership Peer org modififcation policy  # Specifies what is required in order to modify the peer org membership the orderer Node configurations: Node cert   # From orderer admins address   # IP:port from orderer admin Consensus Config:  # Chosen by chainBootstrapAdmin  ></body> </Action>
<Action id="19334" issue="12967" author="tuand" type="comment" created="2016-10-21 13:03:00.0" updateauthor="tuand" updated="2016-10-21 13:03:00.0"> <body><! CDATA While I wait for the convergence->master merge ...  here's what the workflow looks like right now:  - Admin gathers certs for all orderers, CA certs for all entities, ingress/egress policies. - Admin puts all data into a json file using this format : { "policies": { "ordererorgmodificationpolicy": "???", "peerorgmodificationpolicy": "???" }, "orderers":  { "cert": "./02certfile" }, { "cert": "./03certfile" }  , "ordererconfiguration": { "protocol": "ttd", "config": "./somepath/config.file" }, "entities":   { "cacert": "./peer/1certfile", }, { "cacert": "./peer/2certfile" }   }  - Tool parses this json file and creates a genesis block following the definitions drafted in https://gerrit.hyperledger.org/r/#/c/1795/ and in https://gerrit.hyperledger.org/r/#/c/1817 - Tool serializes this block to a file - Ordered reads this serialized genesis block from its file system and starts  ></body> </Action>
<Action id="19345" issue="12967" author="tuand" type="comment" body="move to sprint 4 as I need to pick up a couple of jason&apos;s changesets and wait for completion of convergence-&gt;master" created="2016-10-21 13:31:18.0" updateauthor="tuand" updated="2016-10-21 13:31:18.0"/>
<Action id="19366" issue="12967" author="kchristidis" type="comment" created="2016-10-22 02:48:48.0" updateauthor="kchristidis" updated="2016-10-22 02:48:48.0"> <body><! CDATA Thanks for writing this up. Two questions:  # In the sample JSON file that you list above, should these be "certs" for the orderers, or "cacerts"? Jeff's impl.py refers to "ordererOrgs CA certs". # Not sure why the merging of convergence to master is affecting you?  ></body> </Action>
<Action id="19444" issue="12967" author="kchristidis" type="comment" body="Let&apos;s make sure we document the process as  ~sanchezl  suggests here: https://jira.hyperledger.org/browse/FAB-662?focusedCommentId=19436&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-19436" created="2016-10-24 21:41:46.0" updateauthor="kchristidis" updated="2016-10-24 21:41:46.0"/>
<Action id="19477" issue="12967" author="smithbk" type="comment" created="2016-10-25 19:25:37.0" updateauthor="smithbk" updated="2016-10-25 19:26:58.0"> <body><! CDATA Tuan and I just discussed the following.  A certificate config update will be:  1) ID = "cert"? 2) Type = Chain 3) Data = CertList   where  message CertList { enum CertListType { peer, orderer, crl } repeated bytes Certs }  There will be 3 lists of certs: peers, orderers, and a CRL list. When adding/removing an entry from the CRL list, I think we need to ensure that the config update has a signature of: 1) the certificate being revoked (so someone can revoke their own certificate) 2) one of the issuers of the certificate The current language is not flexible enough to handle this, but I think we could add some methods to check this on the COP CertMgr.  ></body> </Action>
<Action id="19806" issue="12967" author="kchristidis" type="comment" created="2016-11-19 20:57:19.0" updateauthor="kchristidis" updated="2016-11-19 21:05:12.0"> <body><! CDATA I've seen the Gerrit changeset but have not reviewed it myself: https://gerrit.hyperledger.org/r/#/c/2259/  Can we please post an update on where we stand on this?  How far away would we say we are from completion?  ></body> </Action>
<Action id="19816" issue="12967" author="tuand" type="comment" created="2016-11-21 14:03:35.0" updateauthor="tuand" updated="2016-11-21 14:03:35.0"> <body><! CDATA With the 2259 and 2605 change set,  the genesis creation and ingestion flow is pretty much done.  What's left is the actual content of the genesis block which I believe is still going through changes via the MSP discussions. Worth separating out into a separate task ?  ></body> </Action>
<Action id="19818" issue="12967" author="kchristidis" type="comment" body="Got it, thank you. No need to add a task (as we&apos;ll be dealing with changes for some time to come I guess), but let&apos;s keep an eye on it and make sure that the block outputted by the tool stays current." created="2016-11-21 14:19:32.0" updateauthor="kchristidis" updated="2016-11-21 14:19:32.0"/>
<Action id="19870" issue="12967" author="tuand" type="comment" created="2016-11-28 17:41:14.0" updateauthor="tuand" updated="2016-11-28 17:41:14.0"> <body><! CDATA  ~jeffgarratt   ~binhn  just a pointer to our hallway talk ...   also changesets https://gerrit.hyperledger.org/r/#/c/2259/ and https://gerrit.hyperledger.org/r/#/c/2605/  ></body> </Action>
<Action id="19900" issue="12967" author="tuand" type="comment" body="working with  ~ellaki  and team to integrate FAB-634 MSP config with this tool" created="2016-11-30 13:59:02.0" updateauthor="tuand" updated="2016-11-30 13:59:02.0"/>
<Action id="19911" issue="12967" author="tuand" type="comment" created="2016-11-30 19:10:27.0" updateauthor="tuand" updated="2016-11-30 19:10:27.0"> <body><! CDATA  ~ellaki   ~adecaro   ~ales   ~binhn   ~jeffgarratt    Here's how I see the tool working :  input is a file containing the following :  ^template.json  The tool parses the input file and creates a genesis block with the following ConfigurationItems: # configurationItem { type: orderer, Key: ordererlist, Value:     byte{each byte array is the content of an orderer cert listed in the input} # configurationIItem { type: orderer, Key: localconfig, Value:   byte(local config data written out as bytes) # configurationItem { type:orderer, Key: consensusconfig, Value:   byte(content of consensus config file) # configurationItem {type: orderer, Key: mspconfig, Value:   byte(content of msp config file)  When the orderer reads the genesis block,  it will see the configurationItem with Key: mspconfig  and call MSPManager. MSPManager can parse the Value   byte array however it wishes  This way,  the tool ( and by extension the admin ) does not need to understand the syntax of the different configs and we leave the parsing and processing of the config data to the component that needs to handle it.   ></body> </Action>
<Action id="19914" issue="12967" author="jyellick" type="comment" created="2016-11-30 19:50:05.0" updateauthor="jyellick" updated="2016-11-30 19:51:39.0"> <body><! CDATA > 1. configurationItem { type: orderer, Key: ordererlist, Value:     byte {each byte array is the content of an orderer cert listed in the input}  This seems somewhat consensus dependent? In the Kafka case, for instance, it might not be that every orderer (shim) need to be enumerated in the genesis block, instead, there would simply be the orderer org definition, and the policy would be that there must be a valid chain to the orderer CA.  I also wonder if we don't need to tie addresses to these certs.  I'm also not convinced this belongs as the 'Orderer' type, as in general, the contents of the 'Orderer' configuration should be largely opaque to the network.    > 2. configurationIItem { type: orderer, Key: localconfig, Value:   byte(local config data written out as bytes)  Local configuration is just that, local, it may vary node to node, so this definitely does not belong in the genesis block.  > 3. configurationItem { type:orderer, Key: consensusconfig, Value:   byte(content of consensus config file)  Since this configuration always derives from the network, it doesn't make sense to specify this as a configuration item.  Further, because per consensus item we might wish to have different modification policies, I think this needs to be split across config items.  > 4. configurationItem {type: orderer, Key: mspconfig, Value:   byte(content of msp config file)  I thought we had agreed that we were going to introduce two new top level config item types "MSP" and "GroupIdentity" or something similar.  The MSPs would be encoded as type MSP, and named, while the "GroupIdentity" would allow for the MSP groups like "org0admin" to be defined in a generic way (which can be used in policies).  > This way, the tool ( and by extension the admin ) does not need to understand the syntax of the different configs and we leave the parsing and processing of the config data to the component that needs to handle it.  I'm not sure I agree with this approach generally.  This assumes that each configuration item is consumed by only one component, and further assumes that the entire configuration for a component is modified under the same policy.  I don't think either of these assumptions are generally valid.  In specific cases, like the MSP where it's intended to be an embedded component used across the stack, we can get away with encoding large chunks of data together, but consider something as simple as the orderer addresses.  This is something that the SDK will need to read, that the peer will need to read, that the orderers will need to read, and encoding this as something like yaml just pushes the burden of decoding it into each component.  If all components must be able to speak proto, this points to proto being the natural encoding to me.  Really, I think we are way ahead of ourselves here.  We simply don't know enough to do this properly.  We should start much smaller.  Do we have the peer working with an MSP such that the sdk sends a transaction to ordering, and the peer is able to validate the transaction after?  If not, let's do that, if so, what's the bare minimum that we need to put into the genesis block so that the orderer can also verify the signature on broadcast?  ></body> </Action>
<Action id="19915" issue="12967" author="ales" type="comment" created="2016-11-30 19:55:59.0" updateauthor="ales" updated="2016-11-30 19:55:59.0"> <body><! CDATA Thanks  ~tuand . Note that there is some overlap between  https://gerrit.hyperledger.org/r/#/c/2677/18/config-files/chain-genesis-block-test-result.json and https://gerrit.hyperledger.org/r/#/c/2677/18/config-files/peer-init-config-test-result.json with respect to MSP configuration (I'm referring to "msp-config"). So if your tool picks up chain-genesis-block-test-result.json it will also pick up the "msp-config" section which is also present in the peer-init-config json file.  Should we remove the "msp-config" entry from the peer-init-config json file? ( ~ellaki  please also weigh in)  ></body> </Action>
<Action id="19922" issue="12967" author="elli-androulaki" type="comment" created="2016-12-01 13:15:40.0" updateauthor="elli-androulaki" updated="2016-12-01 13:15:40.0"> <body><! CDATA Hi,  Thanks  ~tuand .   So is this for the orderer node or system channel configuration?  >> configurationItem {type: orderer, Key: mspconfig, Value:   byte(content of msp config file) In this case, as Jason mentioned we could set the type to be "msp" and have such config items by default processed by everyone (orderers/peers).  After that, we would need some configuration items associated to (system) chain configuration. For example we can have readers, writers, chain admins all included in a single config item of type chain (that can be set or unset by chain admins).   ~jyellick :  ~ales  has already worked the simple circle that you mentioned, and is missing the part where the peer dynamically loads the CA(s) certificates from a config file. In parallel we discuss MSP configuration as it is relevant to peer setup/signing identity and needs to be consistent to what is advertised through the blockchain. Hence  the chat of which parts of it ought to be part of the genesis config-file, in what form, and which configuration items would make sense to have in the context of MSPs. To this end, the simpler approach is to put everything associated to an MSP as a single config item, and split it differently later as we think approprietly. This is anyway a question to ask the wider community/ companies that would be willing to use that or bring their own MSP along.   ></body> </Action>
<Action id="19925" issue="12967" author="jeffgarratt" type="comment" body="I would ask for the simplest possible config we see as functional viable.  Then we can layer complexity as desired." created="2016-12-01 16:00:00.0" updateauthor="jeffgarratt" updated="2016-12-01 16:00:00.0"/>
<Action id="19926" issue="12967" author="tuand" type="comment" created="2016-12-01 16:38:23.0" updateauthor="tuand" updated="2016-12-01 18:06:20.0"> <body><! CDATA @elli,  for now, it's the genesis block for the system channel.  It can be extended pretty easily to create any config block. _ > 1. configurationItem { type: orderer, Key: ordererlist, Value:     byte {each byte array is the content of an orderer cert listed in the input}_ I think that regardless of consensus protocol,  every set of orderers will need to recognize/authenticate each other so we should at least have the list available.  This could actually be replaced by an MSP configuration as well.   Should we change type to "fabric" or something else ?  _> 2. configurationIItem { type: orderer, Key: localconfig, Value:   byte(local config data written out as bytes)_ I should have used something like "genericOrdererConfig" rather than localConfig.  There was a mention of configuration values that pertain to all orderers but not to any specific consensus protocol  _> 3. configurationItem { type:orderer, Key: consensusconfig, Value:   byte(content of consensus config file) Since this configuration always derives from the network, it doesn't make sense to specify this as a configuration item. Further, because per consensus item we might wish to have different modification policies, I think this needs to be split across config items_ I thought the genesis block would contain the original configuration for the network ?   I wanted to start simple and not have the tool needing to understand configuration values and policies since it is just an assembler. Semantics and policy management should be on the orderer side, not user side ?  _> 4. configurationItem {type: orderer, Key: mspconfig, Value:   byte(content of msp config file)_ I thought we had agreed that we were going to introduce two new top level config item types "MSP" an I haven't been reading Gerrit fast enough !  Everyone, let me know what values I should use for "type" and "key"  _I'm not sure I agree with this approach generally. This assumes that each configuration item is consumed by only one component, and further assumes that the entire configuration for a component is modified under the same policy._ I think  ~ellaki  commented on this earlier as well . I'm trying to keep things simple for the admin who has to manually gather all the content. And I don't think we've decided everything regarding use of policies ( ~binhn ?)  So far, most everything in the genesis block is a chunk to be processed by a component. For things like orderer list,  agree that we should keep in protobuf     ></body> </Action>
<Action id="19927" issue="12967" author="jyellick" type="comment" created="2016-12-01 17:48:50.0" updateauthor="jyellick" updated="2016-12-01 17:48:50.0"> <body><! CDATA   ~jeffgarratt   > I would ask for the simplest possible config we see as functional viable. Then we can layer complexity as desired.  +1 to this   ~tuand  > regardless of consensus protocol, every set of orderers will need to recognize/authenticate each other I disagree, consider the Kafka case.  No shim talks to any other shim, in fact, they don't even need to know that the others exist.  They need to know the brokers, but that is an implementation detail and quite Kafka specific.  > I should have used something like "genericOrdererConfig" rather than localConfig. There was a mention of configuration values that pertain to all orderers but not to any specific consensus protocol  This makes more sense.  I would still advocate to add these config values as they are needed, not to do so monolithically.  Consider for instance the consensus type, and the batch size, both common configuration parameters to all orderers, but they must have different modification policies.  The consensus type should probably be locked with no modifications ever allowed, while the batch size might require a simple majority.  > I thought the genesis block would contain the original configuration for the network? I'm not sure I follow.  The genesis block does contain the network configuration, What I meant to say, is that there is no "shared consensus configuration config file" to embed here.  Early on we did cheat and encode some of this information in the yaml, but that was just a matter of convenience.  Since those values will no longer be encoded in that yaml file (because configuration comes from the genesis block) it's odd to encode a yaml file into the genesis block.  Essentially, we're adding a second layer of encoding on top of the genesis encoding, and I'm not sure why?  > I wanted to start simple and not have the tool needing to understand configuration values and policies since it is just an assembler. Semantics and policy management should be on the orderer side, not user side? The tool needs to take something that users can understand, and convert it to something that the fabric can understand.  The fabric must understand {cb.ConfigurationItem} encodings, because that is the block representation.  The fabric absolutely does not (and in my opinion should not) have to understand the user consumable format, because the tool should encode it to the more basic format.  As I see it, there are essentially two options:  1. User encodes data into user readable form, tool packages user readable form directly into genesis block, every consumer of the genesis block needs to understand the user encoding 2. User encodes data into user readable form, tool converts this to fabric consumable form and encodes it into the genesis block, consumers of the genesis block need only to know how to read the base data format.  Since in option 1 it pushes the decoding responsibility into multiple components, whereas in option 2 the decoding is only done in the tool, option 2 seems like the winner to me.  ></body> </Action>
<Action id="19956" issue="12967" author="tuand" type="comment" created="2016-12-05 19:12:41.0" updateauthor="tuand" updated="2016-12-05 19:12:41.0"> <body><! CDATA Following discussions from last week,  the configuration data for peer and orderer bootstrap is now defined in https://docs.google.com/document/d/1Qg7ZEccOIsrShSHSNl4kBHOFvLYRhQ3903srJ6c_AZE/edit# and in changeset https://gerrit.hyperledger.org/r/#/c/2925/  The genesisBlockCreate tools will read in this config data and map into configurationItems to create a genesis block.  ></body> </Action>
<Action id="20007" issue="12967" author="tuand" type="comment" created="2016-12-06 22:06:26.0" updateauthor="tuand" updated="2016-12-06 22:06:26.0"> <body><! CDATA After talking with teams on #fabric-consensus-dev, we decide to start with creating a block that only contains MSP configuration so that Alex and Angelo can get their MSP code going. https://gerrit.hyperledger.org/r/#/c/3037  Elli is continuing to firm up the confguration block content in https://gerrit.hyperledger.org/r/#/c/3015 and I will continue to add the other configuration items to the tool as soon as we get the MSP portion running.    ></body> </Action>
