<Action id="58959" issue="38459" author="mhbauer" type="comment" created="2019-04-04 21:32:29.0" updateauthor="mhbauer" updated="2019-04-04 21:32:29.0"> <body><! CDATA Summary  1. Caching only useful to transfer blocks between stages - looking at the validation code, it appears to only unmarshal things once. - haven't seen the following commit code, and only some of the 2. Should establish Block-ish and Transaction-ish types, that transparently can do the lookup or caching - blocks appear to be look-up-able by number, thus transferring a block around by pointer or number achieves the same result as all blocks have their number in them. - hides the proto handling. Reusable. Non-proto backends could be made available. 3. Cache design, the bit-twiddling is probably too clever - Must be one per peer to take advantage of work between stages on a peer. - Memory vs CPU tradeoff. Could be a tunable. - cache size MUST be larger than # of transactions in blocks 4. Did not have a clear understanding of how to test this beyond an entire fabric setup. Individual performance gains should be visible at a lower level.  Recommendations 1. Instrument all proto unmarshalling to print the identifier of what is being unmarshalled. (Block Number/Hash, Transaction ID/Hash, etc). Then count up the number of times you see each call happen per ID. 2. Replace *common.Block with BlockInterface that has functions to do unmarshal or lookup in background. Same for Transactions and below objects. 3. Use an established cache algorithm. Assertion on startup about size of cache vs size of block. Tunables flags to allow configuration.  4. Micro benchmarks for areas less than a complete end-to-end test run. Adapt existing tests if possible.  Â   ></body> </Action>
