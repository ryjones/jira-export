<Issue id="12470" key="FAB-171" number="171" project="10002" reporter="smithbk" creator="smithbk" type="10001" summary="As a developer, I need a system clock for a blockchain which all peers agree on" priority="5" resolution="10001" status="6" created="2016-08-18 15:32:50.0" updated="2020-01-22 18:37:49.0" resolutiondate="2020-01-22 18:37:49.0" votes="0" watches="6" workflowId="34983"> <description><! CDATA There are many reasons for needing a system clock which returns a consistent time across all peers and in all chaincode.  The design proposal for implementing this is to implement this as a system chaincode called *clockSCC* as follows.  clockSCC has the following functions: * init - simply calls private tick() * query getTime() - simply returns the value of the $time variable * invoke setTime(time) - described below * private tick() - issues an invoke transaction of setTime(time.Now()) against itself  The *setTime(time)* function does the following: {code:java} // The 'time' argument is the current time from the submitting peer's clock  // Reject this update if the time is not moving forward according to the submitting peer's clock globalTime = stub.GetValue("time")  if (time <= globalTime) return  // Reject this update if the difference between the submitting peer's clock and the local peer's clock is too large // PROBLEM: This is going to be non-deterministic delta = time - time.Now() if (math.Abs(delta) > MAX_DELTA) return  // Update the time  stub.SetValue("time",time)  // Reset the timer  Cancel current timer if set Set a timer to invoke *tick()* in a random time within a range (e.g. between 60 and 70 secs) This randomness prevents all peers from submitting transactions at the same time {code}  Time can never go backwards with this chaincode and a peer with an invalid time, out of the acceptable range of other peers, will be rejected  Another architectural design which may fit better than using system chaincode is to build it into consensus.  This seems to be the case with swirlds (http://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf).  Or a 3rd design is to support a chaincode API which allows all chaincodes to compute their own value for something but the resulting value which is actually stored is some deterministic function across all values (e.g. average).  ></description> </Issue>
