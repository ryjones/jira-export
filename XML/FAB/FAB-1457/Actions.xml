<Action id="20187" issue="13866" author="muralisr" type="comment" created="2016-12-23 15:29:16.0" updateauthor="muralisr" updated="2016-12-23 15:40:14.0"> <body><! CDATA It might be best to use the Response message defined in  protos/peer/fabric_proposal_response.proto directly in the shim. So the interface would look like  {quote}type Chaincode interface Init(stub ChaincodeStubInterface) *pb.Response* Invoke(stub ChaincodeStubInterface) *pb.Response* {quote}  Though this means we have to import protos into each chaincode, I think that's ok (we have other fabric import dependencies as the "shim" anyway). As Response is the object we want in the end, using this directly in the chaincode will avoid mappings.  If that sounds the right thing to do, we would then have to do one of  * add a Response field to "message ChaincodeMessage" which will be set on Invoke and Init OR * replace the "payload" field in "message ChaincodeMessage" with Response OR * serialize Response into payload (which will have to be deserialized back)  on Invoke and Init in the shim  The last appears to be a good way to go about this I think ? * as it won't disturb the usage of payload in other peer-chaincode communication involving ChaincodeMessage * keep the ChaincodeMessage simple (avoid 2 field for "output")  One drawback would be the serialization/deserilization overheads.  ></body> </Action>
<Action id="20273" issue="13866" author="binhn" type="comment" created="2017-01-05 23:42:09.0" updateauthor="binhn" updated="2017-01-05 23:42:09.0"> <body><! CDATA I don't really follow the return codes interpretation ``` retCode == 0 || retCode == 200 => success and payload will be interpreted as response retCode > 500 => error, payload will be interpreted as error but will proceed to endorsement 0 < retCode <= 500 => error, payload will be interpreted as error and endorsement will fail ``` Why wouldn't we follow HTTP? * Informational 1xx * Successful 2xx * Redirection 3xx * Client Error 4xx * Server Error 5xx So endorsement fails if the return code is 4xx, but otherwise, the we process as normal.  ></body> </Action>
<Action id="20274" issue="13866" author="muralisr" type="comment" created="2017-01-05 23:59:19.0" updateauthor="muralisr" updated="2017-01-06 00:00:02.0"> <body><! CDATA We have to be able to treat the default value (0). Per convention 0 is OK... hence the {quote}retCode == 0 || retCode == 200{quote}.   How about this ? Keep it simple * any value  <  500 will be endorsed * any value >= 500 will be considered an error and rejected.  In particular, fabric errors during endorsement will result in 500.  ></body> </Action>
<Action id="20276" issue="13866" author="binhn" type="comment" body="Ok, we should keep it simple, so &gt;= 500 is rejected with error" created="2017-01-06 02:36:25.0" updateauthor="binhn" updated="2017-01-06 02:36:25.0"/>
<Action id="20281" issue="13866" author="binhn" type="comment" body=" ~mastersingh24   ~ChristopherFerris  Please comment by end of today 1/06/2017 so that we can complete this item for the current sprint (end of next week).  Thanks." created="2017-01-06 14:45:02.0" updateauthor="binhn" updated="2017-01-06 14:45:02.0"/>
<Action id="20291" issue="13866" author="mastersingh24" type="comment" created="2017-01-07 11:22:33.0" updateauthor="mastersingh24" updated="2017-01-07 11:27:45.0"> <body><! CDATA I think I've stated this before, but personally I would rather NOT entirely change the method signature / response type.  I would rather define a custom error type (e.g. https://golang.org/src/net/net.go?s=11570:11691#L350 ) because then our existing code will still work but we can leverage the additional error fields as we see fit.   That's my personal take here given we've broken these interface too many times in the past and there's a ton of other work to do.   {code} type ChaincodeError interface { error RetCode() int ... (any other fields we think are needed) } {code}  Given almost all our code uses stuff like  {code} retValue, err := ..... if err!= nil { ... } {code}  this should really end up being a minor change IMHO  ></body> </Action>
<Action id="20294" issue="13866" author="muralisr" type="comment" created="2017-01-07 18:52:30.0" updateauthor="muralisr" updated="2017-01-07 18:56:16.0"> <body><! CDATA So  ~mastersingh24  suggestion details...  Shim exposes a new interface called  {code:java}  type ChaincodeError interface { error RetCode() int }  //and provides a default implementation. We would use this internally //but users could use this default implementation if they like type ChaincodeErrImpl struct { code int }  //needed for this to be a ChaincodeError func (e *ChaincodeErrImpl) RetCode() int { return e.code }  //needed for this to be an error func (e *ChaincodeErrImpl) Error() string { return fmt.Sprintf("Error code is %d", e.code) }  {code}   Chaincode continues to expose   {code:java} Init (args    byte) (  byte, error) Invoke (args    byte) (  byte, error) {code}  Chaincode developers can return any error ... but the recommendation is to implement the ChaincodeError interface. They can use ChaincodeErrImpl or implement their own error as follows  {code:java}  type MyCCError struct { //anything the chaincode dev wants }  //needed for this to be a ChaincodeError func (e *MyCCError) RetCode() int { var code int //get code return  code }  //needed for this to be an error func (e *MyCCError) Error() string { return fmt.Sprintf("return some string") } {code}  Shim would look for ChaincodeError  {code:java} payload, err := shim.Invoke(args) var ccerr ChaincodeErr //did we get an error ? if err != nil { //is this a ChaincodeError ccerr, _ = err.(ChaincodeError) if ccerr == nil { ccerr = &ChaincodeErrImpl{500} //if user didnt specify an error assume the worst and return 500 } } //at this point if there was an error, we'll have a ChaincodeErr in hands to pass downstream.... {code}   This will work and will result in minimal changes. In particular chaincode_example02 and friends can continue to return random error that will not implement ChaincodeErr interface and all tests will continue to work (all errors in the tests WILL be 500 errors and WILL have to be discarded, which is what they do now anyway).  The only downside is we will still be returning 2 arguments (  byte, error) which would have been nice to have cleaned up to make it uniform for Java. And we allow users to make unintentional mistake in chaincode (buggy chaincode returns random error when the intention was to return ChaincodeErr). If we want to return a fixed Response, this is the chance.  What do you think  ~jiangyaoguo  ? You have spent considerable effort with the original design and implementation :-( but to me this does sound a good approach given what we get back in return. In fact we gain something by allowing users to implement any error they want.  I'll go by with whatever everyone wants but I prefer the new approach.  ></body> </Action>
<Action id="20295" issue="13866" author="mastersingh24" type="comment" body="I&apos;ll go along with whatever folks feel is best.  If we are going to do this, now is the time as I think we&apos;ll have one shot to change the shim and after that people will be really upset as they will have started doing real work on V1 " created="2017-01-07 18:57:10.0" updateauthor="mastersingh24" updated="2017-01-07 18:57:10.0"/>
<Action id="20316" issue="13866" author="jiangyaoguo" type="comment" created="2017-01-10 03:46:39.0" updateauthor="jiangyaoguo" updated="2017-01-10 03:46:39.0"> <body><! CDATA   ~muralisr  I agree that the new approach is more compatible and make minimal changes. I prefer  ~mastersingh24 's approch too. This also give us more space to send extra info to endorser while there's error. So now we could have errorCode/errMsg/MoreInfo(anything you want to get or anylise). I'll update https://gerrit.hyperledger.org/r/#/c/3535/ to follow  ~mastersingh24 's approach.  ></body> </Action>
<Action id="20322" issue="13866" author="jiangyaoguo" type="comment" created="2017-01-10 13:29:35.0" updateauthor="jiangyaoguo" updated="2017-01-10 13:29:35.0"> <body><! CDATA There's one problem about new ChaincodeError. We need marshal   byte and ChaincodeError to payload of ChaincodeMessage at shim side and unmarshal them at endorser side.  As a golang interface, ChaincodeError is difficult to be serialized bacause there're different implements. For fabric build-in error type, we can do marshal and unmarshal(add a error dict and select type to unmarshal according to ErrCode). But for user custom error type, we can't unmarshal it at peer-side. We can only get ChaincodeErrImpl type and fabric build-in error type at endorser side. So cc developer can only use ChaincodeErrImpl type as error returned. We still can't  allowing users to implement custom error type. New ChaincodeErrImpl will like this {code:java}  type ChaincodeErrImpl struct { Code int Message string // should be set by user explicitly, maybe   byte more flexible. }  //needed for this to be an error func (e *ChaincodeErrImpl) Error() string { return e.Message } {code} Or we can keep ChaincodeErrImpl definition and return ErrMessage in   byte.  Any good idea about this problem? ~muralisr  ~mastersingh24  ~binhn    ></body> </Action>
<Action id="20325" issue="13866" author="muralisr" type="comment" body=" ~jiangyaoguo  I was thinking we use the best of both worlds. (1) Expose  (  byte, error) interface for chaincode developer as detailed above but (2) use pb.Response internally from the shim to the peer. So the ChaincodeError itself won&apos;t be needed or used in the peer side and we&apos;d have converted to pb.Response internally right at the beginning in the chaincode layer. What do you think ?" created="2017-01-10 18:34:32.0" updateauthor="muralisr" updated="2017-01-10 18:34:32.0"/>
<Action id="20327" issue="13866" author="binhn" type="comment" created="2017-01-10 21:26:16.0" updateauthor="binhn" updated="2017-01-10 21:26:55.0"> <body><! CDATA This sounds like convoluted massage would be needed to cover a not well-thought out interface. Let's do the simple thing because now is the time.  I want to go back to the original design of a response proto message, and make it simple so that other language implementations may easily follow. We are not only making it work, but we should make it simple and elegant for years to come.  Our original objective is to have a return status (like HTTP status line) where we can express status code and message. HTTP status  is well-thought out and well-designed that we should just follow. The status codes are not necessarily just error codes. There are successful cases that we would want to tell the caller (200 OK, 201 CREATED, 206 PARTIAL CONTENT). In fact, I am implementing a query function on a chaincode now that I could use status 206 to tell the caller that there's more content (pagination).  This is our last chance to change, then it's going to be very hard to change the interface -- not impossible, but a lot more work to change. And I believe we need to do this right and forget the past.   ></body> </Action>
<Action id="20328" issue="13866" author="muralisr" type="comment" created="2017-01-10 22:24:14.0" updateauthor="muralisr" updated="2017-01-10 22:24:14.0"> <body><! CDATA  ~binhn  to be clear bother approaches will use error codes. And in both cases error code >= 500 means it won't be endorsed.   The only difference is how we get the error code. If we use pb.Response, the error code will come directly from pb.Response. If we use (  byte, error)  we will get the error code from ChaincodeErr interface - if the user returns that type. Otherwise we default to 500 on error and 0 (or 200) on success.  If we want to make minimal changes (as in less code to change) and not affect existing chaincode then (  byte,error) is the way to go.  On the other hand, pb.Response approach is cleaner.  ></body> </Action>
<Action id="20329" issue="13866" author="jiangyaoguo" type="comment" body=" ~muralisr The problem is if we want to return status code, the interface name &quot;error&quot; is not suitable. We could make Response to implement error interface directly or define an new type like ChaincodeResultImpl(replace ChaincodeErrImpl bacause it contains not only errors but successful case). This will keep old chaincode compatible. But using the error interface to return successful status code is not elegant and may confuse cc developers in future. Considering that we&apos;re developing new arch/spec v1.0, we should reduce the priority of compatibility and take the pain early. " created="2017-01-11 06:20:23.0" updateauthor="jiangyaoguo" updated="2017-01-11 06:34:56.0"/>
<Action id="20342" issue="13866" author="muralisr" type="comment" created="2017-01-12 22:46:52.0" updateauthor="muralisr" updated="2017-01-12 22:46:52.0"> <body><! CDATA  ~jiangyaoguo  agreed. Its not really elegant. Note that even returning "ChaincodeResultImpl" as a "error" parameter is bound to cause confusion. (If I want to return 200, should I return ChaincodeResultImpl(200) as an "error" ?)  The only elegant way is to use pb.Response return code. We have to decide between ease of implementation/less disruption vs long time goodness.  Seems we are trending back to original design to return pb.Response ? I change my vote back to pb.Response.   What do you think  ~mastersingh24  ?     ></body> </Action>
<Action id="20509" issue="13866" author="mastersingh24" type="comment" created="2017-01-22 11:52:05.0" updateauthor="mastersingh24" updated="2017-01-22 11:52:05.0"> <body><! CDATA I missed my opportunity to comment earlier so I'll just add a few remarks after the fact:  1) I really don't like once again breaking this interface 2) On the plus side, this stuff is only run during endorsement so I do like the fact that customers can set / handle their own response codes    ></body> </Action>
<Action id="20510" issue="13866" author="mastersingh24" type="comment" body="https://gerrit.hyperledger.org/r/#/c/3535/" created="2017-01-22 11:52:10.0" updateauthor="mastersingh24" updated="2017-01-22 11:52:10.0"/>
