<Action id="19713" issue="13377" author="ales" type="comment" created="2016-11-10 10:24:53.0" updateauthor="ales" updated="2016-11-10 10:24:53.0"> <body><! CDATA Hi Yacov, thanks for sharing. Let me ask you a one question that should help me understand the scenario a bit better: why are PKI-IDs still needed? If you the remote peer always initiates a TLS connection and they always present a TLS certificate (which is automatically validated for you by the TLS layer). what is the use of the PKI-ID?  Also, the TLS provider needs some work - its CA list should be updated as the config is updated (both locally for the peer only - e.g. rekeying) or globally through the ledger (e.g. cert. expiration). Do you know whether this is already in place? If not (or if you don't know), could you please let me know who's taking care of that?  Thanks! Ale  ></body> </Action>
<Action id="19715" issue="13377" author="yacovm" type="comment" created="2016-11-10 11:21:49.0" updateauthor="yacovm" updated="2016-11-10 11:22:00.0"> <body><! CDATA {quote}why are PKI-IDs still needed{quote} we need them to identify a peer. We periodically send messages with the peer's identity. I don't want to send the whole certificate each time, so I'd rather send the hash of it, or any other   byte that deterministically and collision-free identifies the peer's cert.  {quote}If you the remote peer always initiates a TLS connection and they always present a TLS certificate (which is automatically validated for you by the TLS layer). what is the use of the PKI-ID?{quote} That assumption is wrong. The gossip layer doesn't assume anything of this kind. We're doing a challenge-response handshake in the application layer using the certificate.  The PKI-ID is used for the peer to identify itself to a different peer.   {quote}Also, the TLS provider needs some work - its CA list should be updated as the config is updated (both locally for the peer only - e.g. rekeying) or globally through the ledger (e.g.  cert. expiration). Do you know whether this is already in place? If not (or if you don't know), could you please let me know who's taking care of that?{quote} You should read the follow-up on slack: https://hyperledgerproject.slack.com/archives/fabric-crypto/p1478623733002108 TLDR- this is how this is going to work: When I connect to remote peer I send him my certificate and my PKI-ID. He translates the certificate to the PKI-ID based on the function you'll provide (I assume it'll simply hash fields of the certificate) and will put this certificate into a local in-memory cache. Whenever the peer gets a message with a PKI-ID it doesn't know, it attempts to reach that peer and to handshake with it too, resulting in the peer's certificate added to its cache.     ></body> </Action>
<Action id="19729" issue="13377" author="elli-androulaki" type="comment" created="2016-11-10 18:29:55.0" updateauthor="elli-androulaki" updated="2016-11-10 18:29:55.0"> <body><! CDATA Hi, thanks Yacov for sharing.   So, is there a reason why you chose the hash of the certificate as its identifier and not something else? E.g., some identity that is guaranteed inside the certificate to be unique? Also, how do you get the list of certificates of the rest of the gossip peers? Is it through genesis block that you are given the list of available gossip peer certificates?  In general I see how the gossip peer network could have its own MSP as the one defined here MSP interface  https://gerrit.hyperledger.org/r/#/c/2385/. Here there is the notion of "identity" that maps to the one of a certificate, and setup takes this orignal list of gossip peer certificates (fed by the genesis block). Then "decerializeIdentity(byte serializedcerthash)" would return one of the pre-inserted certificates if it maps to one of these, and error otherwise. But this would be up to the internal implementation of the gossip network MSP. Do you think this would suffice?  Also adding @keithsmith here as it falls under the area of membership service provider.   ></body> </Action>
<Action id="19730" issue="13377" author="yacovm" type="comment" created="2016-11-10 19:04:52.0" updateauthor="yacovm" updated="2016-11-10 19:04:52.0"> <body><! CDATA Hi Elli.  {quote}So, is there a reason why you chose the hash of the certificate as its identifier and not something else? E.g., some identity that is guaranteed inside the certificate to be unique?{quote} I actually don't know what the hash of the certificate means. I assumed if I say that you'd think I meant the hash of the public key, isn't that unique?  When I talked with *adc *and *aso * on the phone I suggested having the encryption algorithm's string casted into bytes, and concatenated with the public key hash. But I really don't know, I think you guys know much better than me these sort of things.  {quote}Also, how do you get the list of certificates of the rest of the gossip peers? Is it through genesis block that you are given the list of available gossip peer certificates?{quote} Well, the code currently doesn't do that because I didn't know the security provider can't fetch the certificate itself, but now that I know- I'm going the have the peer send its certificate to the other peer as part of the gossip handshake. Whenever a the gossip layer of your peer "senses" a peer it's not familiar with, it'll connect to it and will obtain its certificate (or fail if something goes wrong).  {quote}In general I see how the gossip peer network could have its own MSP{quote} that was the plan all along and I even had a code inside that was an assertion of a needed "contract" from the security layer of the peer and I asked on slack and I was promised that the methods in the following link would be preserved: https://github.com/hyperledger/fabric/blob/master/gossip/api/api.go#L59 But alas- the floor underneath the gossip layer has been shattered so I'm trying to adapt to the new conditions (which I think is a good thing, because previously I required a stronger ability from the crypto layer- to be able to fetch the certificate itself, and now my new requirements of it are very modest).  what is: {quote}decerializeIdentity{quote}? did you mean de-serialized identity?   {quote} Then "decerializeIdentity(byte serializedcerthash)" would return one of the pre-inserted certificates if it maps to one of these, and error otherwise. But this would be up to the internal implementation of the gossip network MSP.{quote} I'm sorry but I don't understand what this means. where is this method (don't see something like this in msp.go) and why would I want a certificate from you? I just need you to implement the needed methods in the commit https://gerrit.hyperledger.org/r/#/c/2353/   ></body> </Action>
<Action id="19736" issue="13377" author="elli-androulaki" type="comment" created="2016-11-11 10:43:31.0" updateauthor="elli-androulaki" updated="2016-11-11 10:44:20.0"> <body><! CDATA Ok, thanks. Here are some more questions:   _"When I connect to remote peer I send him my certificate and my PKI-ID. He translates the certificate to the PKI-ID based on the function you'll provide (I assume it'll simply hash fields of the certificate) and will put this certificate into a local in-memory cache."_   So, my question was after you send that peer your certificate, how would you trust the certificate? Isn't there a chain of trust? Is this part that is provided by the genesis block?  Also, if the PKI-ID is the hash of the PK included in the certificate why would one send that along with the certificate?  The translation function that you refer to is a function resolving the mapping between a PKI-ID and a certificate, assuming that the certificate you had already received from a previous connection?   For the function i referred to, sorry for the typo :-) It is indeed de-serialization function called "deserializeIdentity(idbytes bytes)". Aims to essentially give you back the instance of an Identity/Certificate given a series of bytes. At the same time, we can extend the interface with a lookup mechanism for "trusted" identities, though not sure this is strictly speaking a membership service provider operation ...  ~ales  ~adc  what do you think?  For the APIs that you refer to here https://github.com/hyperledger/fabric/blob/master/gossip/api/api.go#L59 and here https://gerrit.hyperledger.org/r/#/c/2353/, can be implemented with code that is included in our tests (listed here https://gerrit.hyperledger.org/r/#/c/2385/6/msp/peermsp-test.go):  - VerifyBlock => using Block as message and using code included in function "peer_signature_verification" - Sign => usign code included in function "escc_signature_test" -  Verify => using code included in function "peer_signature_verification" - GetPKIidOfCert => using the implementation of "Identity.Identifier()" of https://gerrit.hyperledger.org/r/#/c/2385/6/msp/msp.go. Also notice that there are two files associated to the MSP interface. The msp.go, and peermsp.go.  Also,  ~ales  mentioned that you use bindings for your TLS enabled connections between gossip peers. Is there a reason for you to do that?      ></body> </Action>
<Action id="19737" issue="13377" author="yacovm" type="comment" created="2016-11-11 13:32:26.0" updateauthor="yacovm" updated="2016-11-11 13:32:26.0"> <body><! CDATA {quote}So, my question was after you send that peer your certificate, how would you trust the certificate?{quote} I was under the impression that if I call a method provided by you -  {code:java} verify(certificate, signature, plaintext)  {code} I would get an error if the certificate is considered invalid. Isn't that a reasonable assumption? (I'm not being sarcastic, I'm asking to understand. I know that you may invoke simply the encryption algorithm of the public key but I assumed that if I pass a *certificate* then you would also check if you trust the certificate). {quote}Isn't there a chain of trust?{quote} I assume that's how you validate it. I thought you guys provide these capabilities for all the other squads. {quote}Is this part that is provided by the genesis block? {quote} Our layer is ignorant of the genesis blocks in this aspect. I assume that your layer is initialized before our component initializes and that all calls provided by you can be invoked by our layer at any time during the program's life. {quote}Also, if the PKI-ID is the hash of the PK included in the certificate why would one send that along with the certificate? {quote} I would prefer to treat the certificate as a byte slice, and not to know the inner and outs of it, because I have no use in using the data inside the certificate. I only need it to pass it to your methods as a parameter, that's all.  Another reason is: this provides more flexibility. If in the future you wanted the PKI-ID to be computed in a different way without changing the certificate structure, you could do it easily by providing a different function that computes the PKI-ID from the cert.  {quote}The translation function that you refer to is a function resolving the mapping between a PKI-ID and a certificate, assuming that the certificate you had already received from a previous connection? {quote}  Yes. I'll build an in-memory map of PKI-ID ---> certificate, and will populate it by having your function that maps certificate to PKI-ID applied on the certificate and used as a key to the map and the certificate as the value.  {quote}For the function i referred to, sorry for the typo It is indeed de-serialization function called "deserializeIdentity(idbytes bytes)". Aims to essentially give you back the instance of an Identity/Certificate given a series of bytes. At the same time, we can extend the interface with a lookup mechanism for "trusted" identities, though not sure this is strictly speaking a membership service provider operation ... Alessandro SorniottiAngelo De Caro what do you think?{quote} I'm starting to lose you here. Can we discuss this in a more real-time manner?  {quote}For the APIs that you refer to here https://github.com/hyperledger/fabric/blob/master/gossip/api/api.go#L59 and here https://gerrit.hyperledger.org/r/#/c/2353/, can be implemented with code that is included in our tests (listed here https://gerrit.hyperledger.org/r/#/c/2385/6/msp/peermsp-test.go): {quote} Did the other squads also implement their needed crypto capabilities themselves?  {quote}Also, Alessandro Sorniotti mentioned that you use bindings for your TLS enabled connections between gossip peers. Is there a reason for you to do that? {quote} Of course. When I designed and coded the communication layer I was told that: * We may use different pub/priv key pairs for the SSL layer and for the application layer, so if this is the situation and a peer connects to me, I can't infer his identity from the gRPC layer only. * We may use self-signed certificates in the SSL layer, so in order to combat that I used what is suggested in https://mitls.org/pages/attacks/3SHAKE . I hope I didn't get that wrong but I understand that: - The TLS Unique value is pseudo-random from session to session (therefore can be used as a NONCE) - It is transferred after the encyption layer of the SSL kicks in, so it is transferred securely - It is the same on both sides of the SSL session, hence it can be used to detect a MITM. So I use the TLS-Unique as a challenge plaintext that I expect to be signed by the other side, therefore proving its identity. * In testing, I want to simulate the environment as close as possible to production, so in my communication tests I generate self-signed certificates for all peers and use that.  I don't want to use pre-prepared certificates, and I don't know how to make them authentic and signed by a CA. * This is probably a stupid reason, but- when I played around with fabric 0.5 to explore authentication I initialized the peers with SSL via adding the pem files to the file system and enabling the SSL in the core.yaml, and I printed the AuthInfo struct that is extracted from the server-side gRPC stream, and I didn't see there a certificate, only the TLS-Unique. Therefore I concluded that there must be a code flaw in grpc-go and the certificate can't be extracted....     ></body> </Action>
<Action id="19772" issue="13377" author="yacovm" type="comment" created="2016-11-17 12:22:33.0" updateauthor="yacovm" updated="2016-11-17 12:22:33.0"> <body><! CDATA Thanks  ~elli-androulaki  and  ~adc  for https://gerrit.hyperledger.org/r/#/c/2353/, I'm working now on using this api in the gossip comm layer to implement the needed capabilities of https://github.com/hyperledger/fabric/blob/master/gossip/comm/comm.go#L69-L82. Now, can you guys provide with an object that implements all methods in https://github.com/hyperledger/fabric/blob/master/gossip/api/crypto.go#L25-L42 Except from the following method {code:java} VerifyBlock(signedBlock SignedBlock) error {code} Which will be implemented by someone else?  ></body> </Action>
<Action id="19858" issue="13377" author="yacovm" type="comment" created="2016-11-26 06:43:12.0" updateauthor="yacovm" updated="2016-11-26 06:43:33.0"> <body><! CDATA {quote}Whenever the gossip layer of a peer learns of a peer it doesn't have a certificate of, it'll initiate a handshake with it to learn about it.{quote}  Actually, this might give a malicious peer its own private DDOS army, not a good idea. I think that a better way of making peer learn of remote peer certificates is simply via gossiping the certificates, that way they can verify them because they are signed by CAs.  ></body> </Action>
