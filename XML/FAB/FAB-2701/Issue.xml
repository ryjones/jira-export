<Issue id="15269" key="FAB-2701" number="2701" project="10002" reporter="kletkeman" assignee="wlahti" creator="kletkeman" type="10004" summary="stub.GetTxTimestamp() returns nil" priority="2" resolution="10000" status="6" created="2017-03-08 18:43:51.0" updated="2018-07-20 14:11:57.0" resolutiondate="2017-03-30 15:58:59.0" votes="0" watches="4" workflowId="37736"> <description><! CDATA A fix was made to the v0.5 Fabric many months ago so that IoT contracts would be able to get access to the stable and accurate transaction timestamp. This is critical to the functioning of IoT contracts as we need to be able to securely tie an asset's world state to the blockchain entry that created it.  In v1, this function inexplicably returns nil, nil -- losing a key function for IoT smart contracts.  There is a lot of work going into broadcast networks for timestamping of keys (although it is not obvious to the uninitiated that this will create identical timestamps on every peer as would the use of the original transaction timestamp being set once).  What we need is a stable and accurate timestamp that is available at endorsement time so that the entire read/write set is timestamped with this value and so that we can store the time in our asset states.  We are hamstrung until we have this facility.  Clarification: We would like: 1: chaincode can get timestamp and store it in world state for future use (since r/w set created by endorser, timestamp would need to be assigned prior to or during endorsement by whichever agent was responsible for defining the tx timestamp)  2: corollary is that timestamp matches transaction timestamp as stored in block  Discussions: We've had discussion on the rocketchat chaincode-dev and fabric-sdk-node groups and a possible stopgap was discussed where the SDK could set a timestamp and that could be propagated for now as the TX timestamp. This works well even if / when we go to sending parallel endorsements without an anchor. However, the flaw is that clients cannot be counted on to have decent accuracy and synchronization.   The ideal solution is to have a time service set the timestamp for any TXID, thus allowing each peer to ask for it by TXID and getting the same value. This requires access to a time server, but does not require any level of time synchronization between peers (unless logs are to be synchronized).  ></description> </Issue>
