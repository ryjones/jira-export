<Issue id="28420" key="FAB-8795" number="8795" project="10002" reporter="elli-androulaki" creator="elli-androulaki" type="10004" summary=" Improve TransactionIdentifier processing logic" priority="3" status="10000" created="2018-03-12 13:47:55.0" updated="2020-11-23 14:50:42.0" votes="0" watches="9" workflowId="46341" security="10000"> <description><! CDATA h1. 1. Background  Transaction identifiers are used as a way to detect duplicates of transactions and not include them to the ledger.  *Transaction identifiers construction.* Transaction identifiers derive by the combination of the transaction’s creator, and a randomly generated nonce inserted in the transaction header.  *Security guarantees of Transaction id.* There can be no two well formed transactions with the same transaction identifier, under the assumption that the nonce is properly (randomly) generated at transaction creator side. In particular, it is the case that as long as the transaction creator is honest, no two transactions of its have the same txid: if two transactions of his have the same id, these two transactions are identical.  This means that two different transactions can have the same transaction identifier if * The user is intentionally causing it, i.e., creating two transactions with the same identity and nonce, * The user does not have a properly operating random number generator  Well formed transaction (from orderer’s perspective): A transaction where its creator matches the transaction’s signature.  *Use of Transaction IDs.* Transaction identifiers are used as replay attack counter-measure on the committing peer side. More specifically, at validation time transactions are passed to a database that rejects transactions with the same transaction identifier.  Transactions are referenced using their transaction identifier in the database to allow for queries that request the state of a certain transaction. That is to accommodate a GetTransactionByID call. This function would return *exactly one transaction* with matching transaction identifier. h1. 2. Problem  Transaction validation is not considered when the database where transactions are stored reserve a specific transaction identifier.  This means that a transaction with a signature matching the transaction’s creator identity, but whose transaction identifier is not consistent to the creator’s identity, would be invalidated at the committing peer side, but its (invalid) transaction identifier would be reserved. Subsequent (otherwise) valid transaction that carries the same transaction identifier, with matching creator and nonce, would be rejected for having the same identifier with the invalid one that was preceded.  This opens the door to denial of service attacks as follows: * Alice prepares a transaction with transaction identifier txidA correctly computed. * Bob who has seen Alice’s transaction and wants to forbid it from being validated, creates a transaction that he knows in advance would be rejected with the same transaction identifier txidA. Clearly txidA matches Alice’s identity and would not match Bob’s transaction’s details. * Bob manages to have his transaction enter the chain first. * Committing peers process Bob’s transaction and reject it, but reserve txidA. * Alice’s transaction passes the validation phase, and is rejected when the results are to be committed to the peer as duplicate of Bob’s transaction.  h1. 3. Solution  Adding an additional check at the orderers side for validity of transaction identifier would prevent attacks as the ones presented above. That is orderers currently perform some pre filtering of transactions by validating the client (creator) signature on the transaction. Given this, if they computed the expected transaction identifier and checked that it matches the one included in the transaction, Bob would not be able to submit a transaction with an identifier that matches Alice’s.  However, even in this case we suffer from malicious clients input. A malicious client could try to create two different transactions with the same identifier. One of the two transactions will fail due to duplication of transaction identifier, and the other one would succeed. However the status of the second transaction would never appear in the GetTransactionByID query, which violates the semantics of this  function. h1.    4. Other things to consider  *Other (extreme) attacks.* A malicious user may attempt to find ways of having a txid that is generated using Cer1, and nonce nonce1, match his identity Cert2, and another nonce nonce2. This scenario is described in FAB-7547 and although this is very difficult to spawn (to the level of impossible) we can enhance the code to avoid such a case altogether.  *Attacker model - malicious transaction creator.*  The solution proposed above works satisfactorily in the assumption that the creator of the transaction is not malicious, not trying to DoS the system. However, we would like to enhance the system with resistance to this type of adversaries. Notice that there are no clear semantics on the responses of ledger queries for GetTransactionByID when two transactions have the same identifier. This could cause issues to an application relying on this to make decisions on next steps.  *Impact to sideDB.* Side effects of two transactions with the same transaction identifier on tempDB entries need to be investigated/discussed with the sideDB team.     This item was discussed already with  ~ales ,  ~angelo.decaro ,  ~jyellick ,  ~denyeart .           ></description> </Issue>
