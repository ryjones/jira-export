<Issue id="43648" key="FAB-17228" number="17228" project="10002" reporter="sykesm" assignee="wlahti" creator="sykesm" type="10004" summary="A consistent model should be used for external chaincode clients and servers" priority="2" resolution="10000" status="6" created="2019-12-09 18:34:00.0" updated="2019-12-17 16:04:44.0" resolutiondate="2019-12-17 16:04:44.0" votes="0" watches="2" workflowId="57497"> <description><! CDATA The {{chaincode.json}} provided to external builder `run` implementations uses fields containing PEM encoded certificates and key material that needs to find its way to the launched chaincode instance.  For example, our binary run implementation includes the following: {code:java} export CORE_CHAINCODE_ID_NAME="$(jq -r .chaincode_id "$ARTIFACTS/chaincode.json")" export CORE_PEER_TLS_ENABLED="true" export CORE_TLS_CLIENT_CERT_FILE="$ARTIFACTS/client.crt" export CORE_TLS_CLIENT_KEY_FILE="$ARTIFACTS/client.key" export CORE_PEER_TLS_ROOTCERT_FILE="$ARTIFACTS/root.crt"  jq -r .client_cert "$ARTIFACTS/chaincode.json" > "$CORE_TLS_CLIENT_CERT_FILE" jq -r .client_key  "$ARTIFACTS/chaincode.json" > "$CORE_TLS_CLIENT_KEY_FILE" jq -r .root_cert   "$ARTIFACTS/chaincode.json" > "$CORE_PEER_TLS_ROOTCERT_FILE" {code} The {{chaincode/server/connection.json}} file provided by an external {{release}} implementation the peer, however, includes fields with *paths* to files containing the PEM encoded keys and certificates. An example of this can be found in {{container/externalbuilder/instance_test.go}}: {code:java} 			//initiaze with a well-formed, all fields set, connection.json file 			ccdata := `{"address": "ccaddress:12345", "tls_required": true, "dial_timeout": "10s", "client_auth_required": true, "key_path": "key.pem", "cert_path": "cert.pem", "root_cert_path": "root.pem"}` 			err = ioutil.WriteFile(filepath.Join(instance.ChaincodeServerReleaseDir(), "connection.json"),   byte(ccdata), 0600) 			Expect(err).NotTo(HaveOccurred()) 			err = ioutil.WriteFile(filepath.Join(instance.ChaincodeServerReleaseDir(), "key.pem"),   byte("fake-key"), 0600) 			Expect(err).NotTo(HaveOccurred()) 			err = ioutil.WriteFile(filepath.Join(instance.ChaincodeServerReleaseDir(), "cert.pem"),   byte("fake-cert"), 0600) 			Expect(err).NotTo(HaveOccurred()) 			err = ioutil.WriteFile(filepath.Join(instance.ChaincodeServerReleaseDir(), "root.pem"),   byte("fake-root-cert"), 0600) 			Expect(err).NotTo(HaveOccurred()) {code} Instead of having two flavors, we want to have one with a preference for a self-contained, portable asset over a collection of assets.  That said, we need to change the {{chaincode/server/connection.json}} to contain the PEM encoded data instead of paths. {code:java} // ChaincodeServerUserData holds "connection.json" information type ChaincodeServerUserData struct { Address            string   `json:"address"` DialTimeout        Duration `json:"dial_timeout"` TLSRequired        bool     `json:"tls_required"` ClientAuthRequired bool     `json:"client_auth_required"` KeyPath            string   `json:"key_path"` CertPath           string   `json:"cert_path"` RootCertPath       string   `json:"root_cert_path"` } {code} should be rendered as {code:java} // ChaincodeServerUserData holds "connection.json" information type ChaincodeServerUserData struct { Address            string   `json:"address"` DialTimeout        Duration `json:"dial_timeout"` TlsRequired        bool     `json:"tls_required"` ClientAuthRequired bool     `json:"client_auth_required"` ClientKey          string   `json:"client_key"` ClientCert         string   `json:"client_cert"` RootCert           string   `json:"root_cert"` } {code} This keeps the keys consistent between client and server and maintains a single artifact for connection data.  ></description> </Issue>
