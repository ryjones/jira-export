<Action id="53351" issue="35111" author="kchristidis" type="comment" created="2018-11-12 17:29:06.0" updateauthor="kchristidis" updated="2018-11-12 17:33:03.0"> <body><! CDATA  ~yacovm : Thanks for writing this up.  # How do we prevent a fork on the system chain if certain OSNs skip {{WriteConfigBlock}}? # I also did not get this: "It won't know the addition of itself through the system channel, because the transaction would point to the application channel."  What do others think?  ></body> </Action>
<Action id="53353" issue="35111" author="yacovm" type="comment" created="2018-11-12 18:20:11.0" updateauthor="yacovm" updated="2018-11-12 18:20:11.0"> <body><! CDATA 1. We just call WriteBlock instead manually inside the chain.  2. So, the channel is created and some blocks have been committed. Later on there is a config update. The config update doesn't reach the system chain, it reaches the application channel. the orderer that is outside of the channel is not aware of the update that makes it a part of the channel.  ></body> </Action>
<Action id="53354" issue="35111" author="kchristidis" type="comment" body="Thanks for clarifying. I do get that it&apos;s ridiculously crude, but if we were to restart that node, would it not be able to pick up its membership in that application channel, following the plan outlined in FAB-12555?" created="2018-11-12 18:26:22.0" updateauthor="kchristidis" updated="2018-11-12 18:26:22.0"/>
<Action id="53357" issue="35111" author="yacovm" type="comment" created="2018-11-12 19:18:39.0" updateauthor="yacovm" updated="2018-11-12 19:31:56.0"> <body><! CDATA Currently - no, unless you delete all chains in the orderer (because the deletion of the chains is the trigger for onboarding code that is to be launched at boot). Since the OSN can be crash during the onboarding, I made the system channel be pulled last, so once a successful onboarding process has been completed without any interruptions, the system chain sequence in the ledge reaches the sequence the OSN is bootstrapped with, and this makes the OSN skip onboarding in the next reboot / after a crash. Had it been in the opposite order, the OSN would need to persist some checkpoint information for each chain, and I wanted to keep things simple.  The code from FAB-12555 itself can certainly be reused to do what you ask.  However - I think that we should carefully weigh whether we want restarts to be drivers of channel addition, and if we were to do that we'd need to change some semantics in the orderer. # Restarts disrupt clients. To the best of my knowledge, not all SDKs do retries for transaction submission, and that means restarts would effect customers.  # Bootstrapping (chicken and egg) problem - Let's assume that we are an OSN and we were just rebooted.  We have several chains - A, B, C and S (system chain) in our ledger. Some of the chains might be so behind from the cluster that a chain object cannot be started, and we (the OSN) need to pull blocks from some orderer before it can start the chain. That means that the OSN should probe the system channels and the application channels before it starts a new chain, figure out if it is in the channel, and if it is in the channel but it is too far away - pull the blocks and then start the chain object, or just start the chain if there is no need to pull anything, right?  But, what if *all orderers* are now after a reboot, and they all try to probe the orderers of the system channel for (w.l.o.g) chain A. There won't be a single orderer that will succeed to pull any block, because none of the chains have started, and every orderer would return: "Rejecting deliver request because of consenter error", because the chain hasn't started yet, and we would reach a livelock.  We can, of course - change the semantics of the orderer to have the deliver decoupled from the chain (*) but I have a feeling this calls for a deeper discussion ;)   Now, we could start the chain, and then somehow figuring out that the chain is "in a bad state", but that's a bit complex in my opinion, and therefore I suggest we defer this to a later time where we just add some admin API to the orderer that would make it add itself to a chain without needing a restart and would know to pull the blocks on its own before starting the chain object.  (*) Honestly i never understood that semantic... why would you care of transaction creation if all you want is to pull blocks? I guess it was built for Kafka to signal peers to find other orderers to connect to, as an orderer that cannot relay transactions also cannot pull them, but - I argue this decision should be revisited in the future.   ></body> </Action>
<Action id="53360" issue="35111" author="kchristidis" type="comment" created="2018-11-12 19:35:41.0" updateauthor="kchristidis" updated="2018-11-12 19:35:41.0"> <body><! CDATA Right. I knew I was punting when I was wondering whether a restart would pick it up. Wasn't looking to that as a long-term solution. I get the problem. I'll think a bit about this.  In the meantime, expand on this?  {quote}We can, of course - change the semantics of the orderer to have the deliver decoupled from the chain.{quote}  ></body> </Action>
<Action id="53361" issue="35111" author="yacovm" type="comment" created="2018-11-12 19:49:29.0" updateauthor="yacovm" updated="2018-11-12 19:52:14.0"> <body><! CDATA If you agree that an OSN needs to first figure out whether it is too far from the cluster in terms of blocks before it starts the chain, it means that all orderers are live-locked when the entire cluster is rebooted.  However, if we assume that once an orderer sees itself "in the ledger" at boot time, it means it is not too far from the rest of the cluster and doesn't need to pull blocks before it starts the chain - we can get around the problem. However, it's not that easy as it seems and there can be corner cases where you are re-added to the cluster, and you will see yourself in the chain but you won't be able to connect to anyone, because the TLS certificates of the other nodes in the chain might have diverged too far from your current (last) chain.  Therefore I suggest we defer this item for now :)    ~jyellick  what's your take on this?  ></body> </Action>
<Action id="53363" issue="35111" author="kchristidis" type="comment" body="Sorry for being slow, but I really don&apos;t get what &quot;some of the chains might be so behind from the cluster that a chain object cannot be started, and we (the OSN) need to pull blocks from some orderer before it can start the chain&quot; means." created="2018-11-12 21:28:15.0" updateauthor="kchristidis" updated="2018-11-12 21:28:15.0"/>
<Action id="53364" issue="35111" author="yacovm" type="comment" created="2018-11-12 22:47:46.0" updateauthor="yacovm" updated="2018-11-12 22:47:46.0"> <body><! CDATA so, when you start up an OSN you might have 3 types of chains: # Chains you are in sync with and all is good # Chains you started to sync via the onboarding infrastructure, but you crashed and now you are resuming # Chains you are not aware of yet, and you should pull.  You may be removed from a channel and then re-added again, and then how do you distinguish type 1 from type 2? You need to distinguish in order to know whether to start a chain, or to pull the blocks before starting a chain. Now, that means that you need anyway to reach out to another OSN and see what's good. But - if the entire cluster has been restarted - you get into a livelock because all OSNs will reject the deliver requests.  I think that we should not support this case for the time being, and say that if you want to join an existing node that is already part of some chains, to another chain - you need to just wipe out the chains on that node so it will re-sync from a clean slate state. It may sound bad, but - since orderers don't validate transactions, as long as you pull fast enough you should be good.  In a future version we should add an API that enables you to remove a channel from a node, and to signal a node to start syncing, and then we could have the admins easily invoke that API which would kickstart the code from FAB-12555 and things will be good.   ></body> </Action>
<Action id="53365" issue="35111" author="jyellick" type="comment" created="2018-11-13 00:35:27.0" updateauthor="jyellick" updated="2018-11-13 00:35:27.0"> <body><! CDATA  ~yacovm  So, here is my two cents:  First, one minor point: {quote}Every chain knows its own name (ID) and the consenter has the conf *localconfig.TopLevel reference, which contains the system channel name. {quote} This is actually not really true. The system channel name is only used _if_ the orderer has not already been bootstrapped and the orderer is bootstrapping itself on the fly (really only suitable for testing). Otherwise, the orderer detects the orderer system channel by looking at the current channel config for all the channels its aware of and picking the one which has a consortiums group defined, which may differ from the value defined in the *localconfig.TopLevel. {quote}Therefore, I propose to add logic in the etcdraft chain implementation to skip calling support.WriteConfigBlock (which triggers the creation of the genesis block of a new channel) in case the OSN isn't in the consenter set (via a certificate lookup). {quote} As I see it, this is a non-starter, deriving from what  ~kchristidis  began to explore. {quote}How do we prevent a fork on the system chain if certain OSNs skip WriteConfigBlock? {quote} Consider 4 OSNs, OSN0, OSN1, OSN2, OSN3, spinning up channels with subsets of three. So, a user sends a request to OSN0 requesting that channel {{Foo}} be created with OSN0, OSN1, and OSN2. This is processed correctly, and there is now a new channel {{Foo}} but OSN3 skips writing it as a config block (not triggering the channel creation code). Now, another (or the same) user sends a request to OSN3 requesting that it create channel {{Foo}}. OSN3 deliberately skipped writing the config block, so, it has no idea that {{Foo}} exists, so, it says the tx is valid and orders it. We are now in a situation where OSN3 believes the tx is valid, while OSN\{0,1,2} believe it's invalid. The orderers may now choose to fork, or crash. ---- So, I would propose a different scheme. All orderers track the creation of all channels and create the genesis block for each channel. _However_, each orderer also performs a check of the latest config block before starting a consenter for a channel to see if that node is a consenter for that channel, and if not, skips it. Similarly in the Broadcast and Deliver paths, the OSN checks that it is a member of the consenting set for the channel before accepting requests, and if it is not returns something reasonable.  I don't believe this would be terribly much work to do at all.  We now have to tackle the same problem you were discussing about onboarding an OSN.  To me it seems easiest to me to tackle as an API or configuration to force the node to sync to a point in the configuration where it is aware of its membership in the consenter set. If we stick to the logic of always being up to date in the orderer system channel, and using the set of nodes there to pull blocks during catchup, I think it works reasonable as well.  ></body> </Action>
<Action id="53373" issue="35111" author="yacovm" type="comment" created="2018-11-13 07:27:49.0" updateauthor="yacovm" updated="2018-11-13 07:27:49.0"> <body><! CDATA Thanks for your comment Jason. It hadn't occurred to me that the channel admins would try and create a channel with the same name twice :)  I'm not really sure why the blockchain is forked, though - all OSNs are going to write the config block as a regular block in any case, so there is no real blockchain fork, or am I missing something? {quote}However, each orderer also performs a check of the latest config block before starting a consenter for a channel to see if that node is a consenter for that channel, and if not, skips it{quote}  That's what I was trying to avoid. Checking whether you are in the channel is consensus specific, and starting a new chain is done in the common code. That would involve expanding the Consenter API with a method that checks if the node is in the channel, no?  ></body> </Action>
<Action id="53388" issue="35111" author="jyellick" type="comment" created="2018-11-13 14:58:09.0" updateauthor="jyellick" updated="2018-11-13 14:58:09.0"> <body><! CDATA {quote}I'm not really sure why the blockchain is forked, though - all OSNs are going to write the config block as a regular block in any case, so there is no real blockchain fork, or am I missing something? {quote} Depends on the approach I suppose.  I would say perhaps that it is not a 'blockchain fork' but a 'state fork', where the set of channels is part of the small set of state that an orderer maintains.  We might be able to get away with it for the CFT case, but it seems easy to get ourselves into a bad situation in the BFT case.  Network of 8 nodes (f=2), subsets of 4.  If 4 nodes believe the channel exists and 4 do not, then the network will be evenly split about the validity of the tx, and deadlock failing to reach 2f+1.  Maybe that's a far-fetched case, but regardless, having two different orderers with different versions of the same channel is likely to cause real problems for the peers.  Depending on the "BlockValidationPolicy" for instance, a peer could get a 'valid' block with a mismatched hash and panic during commit.  It just feels to me like we open ourselves up to all sorts of problems by having some orderers simply ignore the channel creation. {quote}That's what I was trying to avoid. Checking whether you are in the channel is consensus specific, and starting a new chain is done in the common code. That would involve expanding the Consenter API with a method that checks if the node is in the channel, no? {quote} Yes, when I had penned my original response, I was thinking of the naive case where the OSNs and the consenters were 1-1.  And the multichannel code could simply iterate over the addresses of the OSNs to decide if it was a channel member or not.  But, I think there are a couple other options which does not significantly grow the consenter API but gives us what we need. # We could simply add a new error type to be returned by {{WaitReady}}{{Errored}}.  Today these indicate to {{Broadcast}}/{{Deliver}} that the consenter is not yet ready (but that the client should try back later).  This new error could be indicate "Not yet ready and never will be, I don't serve this channel". # We could extend the {{HandleChain}} call to return a specific error as well (and not panic when it is returned).  Or really, I don't think it would be so bad to simply add an {{IsMember() bool}} function or similar to the consenter interface.  ></body> </Action>
<Action id="53393" issue="35111" author="yacovm" type="comment" created="2018-11-13 16:04:41.0" updateauthor="yacovm" updated="2018-11-13 16:04:41.0"> <body><! CDATA All right, then I think I'm going to add a new method to the consenter API that returns an error in case the OSN isn't in the channel, and nil otherwise.   ~kchristidis   ~jyellick  what do you say?  ></body> </Action>
<Action id="53397" issue="35111" author="kchristidis" type="comment" body="I like the {{IsMember}} method idea; I say we go for it." created="2018-11-13 17:20:15.0" updateauthor="kchristidis" updated="2018-11-13 17:20:41.0"/>
<Action id="53398" issue="35111" author="jyellick" type="comment" body="Works for me." created="2018-11-13 17:41:44.0" updateauthor="jyellick" updated="2018-11-13 17:41:44.0"/>
<Action id="54440" issue="35111" author="kchristidis" type="comment" body="(Heads up: I took this last couple of paragraphs talking about the administrative API and the ability to have an OSN from the system channel join an _existing_ application channel, and moved them to FAB-13180.)" created="2018-12-06 13:31:48.0" updateauthor="kchristidis" updated="2018-12-06 13:31:48.0"/>
<Action id="54676" issue="35111" author="yacovm" type="comment" body="https://gerrit.hyperledger.org/r/#/c/28046/" created="2018-12-11 15:58:30.0" updateauthor="yacovm" updated="2018-12-11 15:58:30.0"/>
<Action id="54677" issue="35111" author="yacovm" type="comment" created="2018-12-11 16:00:21.0" updateauthor="yacovm" updated="2018-12-11 16:00:21.0"> <body><! CDATA I decided to go for an approach which is similar to what  ~jyellick  suggested - I made a new chain type that is an "inactive chain", which is returned from HandleChain of etcdraft consenters in case the certificate of the node is not in the channel.      ></body> </Action>
