<Action id="18936" issue="12660" author="christopherferris" type="comment" body="https://gerrit.hyperledger.org/r/#/c/1121/" created="2016-09-19 12:42:21.0" updateauthor="christopherferris" updated="2016-09-19 12:42:21.0"/>
<Action id="18953" issue="12660" author="markparz" type="comment" body="I want to verify that after the yaml file is updated, it requires a manual reboot, is there any notification to the members that there was a change?" created="2016-09-20 18:22:11.0" updateauthor="markparz" updated="2016-09-20 18:22:11.0"/>
<Action id="18981" issue="12660" author="christopherferris" type="comment" created="2016-09-24 12:30:13.0" updateauthor="christopherferris" updated="2016-09-24 12:30:13.0"> <body><! CDATA So, reviewing this more closely, this is a rather clumsy design. Picking the peer id out of yaml scales operationally, how? You really want to have something that will be unique to each peer that is NOT dependent on someone knowing all the other names (which in a truly decentralized network you would not know, and for a system such as this, should not need to know.   hashids is a means of generating unique ids, has implementations galore including js, java and go, all that is needed is some salt, an alphabet and a number or array of numbers. The salt could be a phrase, or company name, whatever. The alphabet we can choose, and the number we could have delivered from some sort of decentralized registrar (one per network member). It could be baked into the membership services and returned to a peer when it registers for an ecert, saved to a file and used hence-forth by that peer just as the ecert is used. http://hashids.org/  This gives us unique names for the peers without needing to know a priori the other names in the network. Hard coding names in config is fine for a toy, but seriously, the design above cannot be what we envisage as MVP for v1.  We really need to be considering operational aspects in our design, or else we'll build something that no one can meaningfully deploy.  ></body> </Action>
<Action id="18983" issue="12660" author="smithbk" type="comment" body=" ~ibmmark  Mark, the yaml file is not updated.  It contains the peer ID and is not changed.  The file that is created is a json file containing the public certificates to trust.  The files in the trust directory are for bootstrapping only.  After bootstrapping and it is able to connect to the system ledger, this trust information is taken from the system ledger.  When it is updated, it does not require a peer restart." created="2016-09-24 18:59:32.0" updateauthor="smithbk" updated="2016-09-24 18:59:32.0"/>
<Action id="18986" issue="12660" author="smithbk" type="comment" body=" ~ChristopherFerris  Chris, this is for bootstrapping a network which requires some out-of-band communication.  There is an assumed agreement among all company&apos;s who want to join, so they would each know one another&apos;s company name.  The peer IDs would be prefixed by the company&apos;s name and would be unique assuming each company doesn&apos;t reuse peer IDs, which doesn&apos;t seem unmanageable/unscalable to me.  That said, if it is a big deal, we could dynamically assign a peer ID when enrolling the peer with MS.  For customers using their own CA, it would still be up to them to manually configure a unique peer ID." created="2016-09-24 20:14:44.0" updateauthor="smithbk" updated="2016-09-24 20:14:44.0"/>
<Action id="19073" issue="12660" author="jeffgarratt" type="comment" body=" ~keithsmith   I worry that we are not taking into consideration the impact of multi-chains wrt to orderers and boostrap.  I have attempted to walk through the bootstrap perspective from the peer wrt to the orderer, and it seems to me that we cannot exclude the orderer from the concept of boostrap (https://jira.hyperledger.org/browse/FAB-426).  " created="2016-09-30 15:30:54.0" updateauthor="jeffgarratt" updated="2016-09-30 15:30:54.0"/>
<Action id="19094" issue="12660" author="jyellick" type="comment" created="2016-10-03 15:54:45.0" updateauthor="jyellick" updated="2016-10-03 15:54:45.0"> <body><! CDATA  ~keithsmith ,  ~jeffgarratt  pointed me to this issue and I'm also concerned that the ordering service is not mentioned in this bootstrapping process.  I'll comment further, in FAB-360, but it seems to me that we should not have two different paths for configuration of peer membership unless it is absolutely necessary.  I'm certain I am missing some things, but what would be the problem with the following flow?  1. Start MS1, MS2 2. Create and start ordering service (see notes) 2. Start P1-P4 3. Each peer submits a registration transaction because they are joining the network 4. Each peer receives the stream of blocks, informing them of what peers are registered  This glosses over the issue of how the ordering service knows which clients to accept transactions from, but, this is an issue which needs to be solved regardless, and eliminates any and all manual distribution of key material.  A few notes:  When starting the ordering service it will need some initial configuration to generate the genesis block, likely things like CA certificates for MS1/MS2.  When creating the service, the contents and hash of the genesis block could be returned, and the peers could be configured to verify the genesis block against this hash, to prevent the orderer from falsifying trust.  How are clients required to authenticate to the ordering service? Are all members readers and writers? Can a client invoking the broadcast API submit a transaction with someone else's signature? How do the peers validate the TLS integrity of their connection to the orderer?  How does the orderer learn of changes in peer membership? How does all of this change with multiple channels?  I think these questions need to be settled soon.  ></body> </Action>
<Action id="19097" issue="12660" author="jyellick" type="comment" created="2016-10-03 20:19:18.0" updateauthor="jyellick" updated="2016-10-03 20:19:18.0"> <body><! CDATA So, just finished a long chat over the phone with Keith about this, and wanted to summarize here.  A few key points:  1. Referenced above are Peers 1,2,3,4.  These are not peers, these are orderers. 2. Because this is for the orderer network, the number of orderers involved is likely to be small, and the manual distribution of key material is something that is likely unavoidable for bootstrap 3. Because the orderers are not peers, they cannot be expected to support peer API calls or chaincodes, they also do not know how to apply MVCC data, so some other format is required 4. Orderers do not need CA certificates, each orderer has a unique ID, so a list of orderer certificates is all that is required  Some proposed solutions:  1. Configuration should be encoded as a special transaction which is much simpler than the MVCC model.  This should hopefully be a proposed configuration, and signatures of agreement from the interested parties.  No simulation result, or changeset, instead the entire config should be embedded.  We are looking for help from the crypto team on this. 2. Configuration should be partitioned by function (ie, the set of orderer certificates should be different from the set of peer CAs) 3. The bootstrapping should be either an ordered list of transactions (or equivalently, a block) which contains the special configuration transactions 4. Peers (not orderers) can connect to the ordering service for bootstrapping and do _not_ need the manual key distribution function 5. The COP function can be pulled into a tool for creating the configuration proposal, endorsing/signing the configuration proposal, and submitting the proposal.  Some other thoughts:  1. We should be careful to define the configuration structure to also embed its policy for modification.  IE, do all peer CAs need to sign in order to add, or is one sufficient? 2. We should think about what happens if we ever need to violate the configuration and update, IE, what if we require all peer CAs to sign, and one of the CAs goes out of business / needs to be kicked out of the network.  This would likely require a sort of 're-bootstrapping', but ideally in a way which allows the current chain to continue.  ></body> </Action>
<Action id="19101" issue="12660" author="tuand" type="comment" body="added links to other stories related to bootstrapping" created="2016-10-04 13:19:26.0" updateauthor="tuand" updated="2016-10-04 13:19:26.0"/>
<Action id="19102" issue="12660" author="tuand" type="comment" created="2016-10-04 13:22:06.0" updateauthor="tuand" updated="2016-10-04 13:22:06.0"> <body><! CDATA I don't see how the discussion switched from peer to orderer ?  Could you add a flow diagram so that we can have a clearer view of the interactions between person/peer/orderer ?  ></body> </Action>
<Action id="19106" issue="12660" author="smithbk" type="comment" created="2016-10-04 15:50:36.0" updateauthor="smithbk" updated="2016-10-04 15:50:36.0"> <body><! CDATA See my comments in {color:#d04437}<keith></keith>{color} related to Jason's previous comments ...  A few key points:  1. Referenced above are Peers 1,2,3,4. These are not peers, these are orderers. {color:red}{color:#d04437}<keith> I initially implemented this FAB to work with v0.6 which is why I said peers instead of orderers, but the code was written generically so it could be applied to a group of orderers in the same way.  </keith>{color}{color}  2. Because this is for the orderer network, the number of orderers involved is likely to be small, and the manual distribution of key material is something that is likely unavoidable for bootstrap {color:#d04437}<keith> It is unavoidable unless you use a single CA for all orderers.  See the 1st use case in section 3 of https://docs.google.com/document/d/1TRYHcaT8yMn8MZlDtreqzkDcXx0WI50AV2JpAcvAM5w/edit#heading=h.5e6ytu5dk9vv  The 2nd use case using multiple CAs does require this manual distribution.  </keith>{color}   3. Because the orderers are not peers, they cannot be expected to support peer API calls or chaincodes, they also do not know how to apply MVCC data, so some other format is required {color:#d04437}<keith> If we don't have MVCC (or some simplified version of this), then it assumes the config update operations do not depend upon the current state of the config.  For example, we couldn't have a single "update config" but would have to have more specific operations like "add CA cert" and "remove CA cert", etc.  I think this is more complex and less extensible.  I think it would be simpler to have a single "update config" but to maintain a simple counter of the current version of the config.  Each "update config" operation must have the version which is being updated and fails if it doesn't match.  This avoids the race condition. </keith>{color}   4. Orderers do not need CA certificates, each orderer has a unique ID, so a list of orderer certificates is all that is required {color:#d04437}<keith> By "CA certificates" I assume you mean it doesn't have to be a cert issued by a real CA that runs outside of the orderer process.  If this is what you mean, I would say the orderers do not *require* a CA certificate but a CA certificate *may* be used.  I'll use the term "trusted root certificate" which can be any cert.  So assuming each orderer has it's own trusted root cert (which it could get in any number of ways, i.e. cop, openssl, etc), cop will then provide a way of turning the list of certs into a deterministic, ordered list of transactions to be injected into the genesis block during bootstrap. </keith>{color}   Some proposed solutions:  1. Configuration should be encoded as a special transaction which is much simpler than the MVCC model. This should hopefully be a proposed configuration, and signatures of agreement from the interested parties. No simulation result, or changeset, instead the entire config should be embedded. We are looking for help from the crypto team on this. {color:#d04437}<keith> As mentioned previously, I think this special transaction requires a simple version number to avoid race conditions. </keith>{color}   2. Configuration should be partitioned by function (ie, the set of orderer certificates should be different from the set of peer CAs) {color:#d04437}<keith> Agreed </keith>{color}  3. The bootstrapping should be either an ordered list of transactions (or equivalently, a block) which contains the special configuration transactions {color:#d04437}<keith> Agreed, was thinking of an ordered list of transactions as mentioned earlier </keith>{color}  4. Peers (not orderers) can connect to the ordering service for bootstrapping and do not need the manual key distribution function {color:#d04437}<keith> This is what FAB-360 discusses but I agree there is a gap.  The reason for the gap is that I was told that there would be a single system ledger shared by all peers *and orderers* and I was designing around this, but Jason says the only ledger the orderers know about is the raw ledger.  We need clarity on this. </keith>{color}  5. The COP function can be pulled into a tool for creating the configuration proposal, endorsing/signing the configuration proposal, and submitting the proposal. {color:#d04437}<keith> See section 1.3 of https://docs.google.com/document/d/1TRYHcaT8yMn8MZlDtreqzkDcXx0WI50AV2JpAcvAM5w/edit for the cop cli commands, but again in order to implement this, it was assuming a system chaincode and system ledger in orderers.  This definitely needs more discussion. </keith>{color}  Some other thoughts:  1. We should be careful to define the configuration structure to also embed its policy for modification. IE, do all peer CAs need to sign in order to add, or is one sufficient? {color:#d04437}<keith> The type of policy cop will provide is JSON-based and simple to start with similar to the following: { "percentage": 100 } which means in order to update, we need signatures associated with all current trusted root certs in order to add a new trusted root cert to the list.  Or { "names":  <DN1>,<DN2>  } which means in order to update, we need the signature associated with two distinquished names. </keith>{color}  2. We should think about what happens if we ever need to violate the configuration and update, IE, what if we require all peer CAs to sign, and one of the CAs goes out of business / needs to be kicked out of the network. This would likely require a sort of 're-bootstrapping', but ideally in a way which allows the current chain to continue. {color:#d04437}<keith> The removal policy might say something like "I can remove myself OR I can be removed if everyone else agrees that I should be removed". In other words, a CA may be voted off of the island by other CAs, if that is the desirable policy. But yes, it would be possible, however, to define a policy such that if a CA loses the private key, then you're in trouble. We would need to document how to evaluate risk. </keith>{color}   ></body> </Action>
<Action id="19107" issue="12660" author="sanchezl" type="comment" created="2016-10-04 17:51:17.0" updateauthor="sanchezl" updated="2016-10-04 17:51:17.0"> <body><! CDATA  ~tuand , as I understand it, this story does not involve the peers at all. I've posted a draft feature on gerrit (https://gerrit.hyperledger.org/r/#/c/1469/) that we can use as a starting point on our way to consensus.   After I get enough comments on the change set, we'll need to update the description of this story to match.  The fact that there are multiple membership services seems trivial, so I propose a new name for this story: * *As an administrator, I want to bootstrap a new raw chain.*  Next, we'll need a story about bootstrapping the peers with the genesis block (which contains the orderer config). I'll take a closer look at the existing stories, tasks and epics and propose a cleanup of all the bootstrap related items.   ></body> </Action>
<Action id="19108" issue="12660" author="kchristidis" type="comment" created="2016-10-04 18:09:23.0" updateauthor="kchristidis" updated="2016-10-04 18:09:23.0"> <body><! CDATA {quote}This is what FAB-360 discusses but I agree there is a gap. The reason for the gap is that I was told that there would be a single system ledger shared by all peers and orderers and I was designing around this, but Jason says the only ledger the orderers know about is the raw ledger. We need clarity on this.{quote}  Keith, the raw ledger that the orderers know about *+_is_+* this system ledger shared by all peers and orderers. Hopefully this eliminates any confusion.  ></body> </Action>
<Action id="19123" issue="12660" author="mastersingh24" type="comment" created="2016-10-05 11:39:50.0" updateauthor="mastersingh24" updated="2016-10-05 11:39:50.0"> <body><! CDATA Are we not getting about 500 miles ahead of ourselves here?  (sorry if this seems harsh).  While I understand trying to have a common set of libraries, mechanisms, etc, I am not sure how we can explicitly design anything at this point.  What do I mean?  The way I see it:  +*Ordering Service*+  1) We will have an ordering service (and possibly multiple implementations - e.g. Solo, PBFT, Kafka, etc) 2) Peer will connect to these ordering service(s) 3) Ordering services will likely need to provide access control for "peers" and "peers" will need to be able to trust "ordering services"  For 1), some of these ordering services will have the need for nodes to explicityly whitelist each other.  I will assert that we can't necessarily dictate how this is done except perhaps for ones which we build - e.g. the SBFT ordering service and the Kafka orderer  For now, let's start with the case of the sBFT orderer.  In this case, we know that each sBFT node must know the total number of nodes and the identities of each of those nodes.  This will require that nodes explicitly each provide some type of identity and that the other nodes will only connect to / allow connections from node identities which are part of some whitelist.  (note:  in the text below - "node" refers to an sBFT orderer node)  Questions:  1) Have we decided how nodes will identify each other?  Perhaps we assume will use cryptographic identities and that these will be extracted verified via digital digital signatures?   Perhaps we will require TLS (I would assert that we should just default to TLS and make sure we get it right ) and require that each node explicitly trust the TLS certificates of every other node?  2) Clearly if we choose either one (or both) of the options above, they have the same basic requirement - all nodes need to know the cryptographic "identities" of all nodes  3) Clearly for this to work, each node must be aware of the identities of all the nodes that will be part of the "ordering service" when it starts up   (we'll have to address dynamically adding / removing nodes in the future as well).  Then of course each node needs to provide / generate its cryptographic identity  Finally, we expect that clients of the ordering service will be required to "authenticate" with / be "authorized by" the ordering service before they can send/receive data from any channel in the ordering service (even if there is only one channel).  So again, my question is have we decided how we expect peers to provide their identity to an ordering service node?   Will we simply again be using digital signatures and trusting specific public keys (whether individual or some type of CA)  So have we even gotten this far?   Proving that a network of sBFT nodes can use a whitelist and only allow nodes from that whitelist to connect / participate?   If not, then how can we expect to know what type of "bootstrap" configuration to provide?  As an aside, assuming that we go down the TLS / PKIX for digitail signatures route, then we simply need to be able to load up the trusted certificates into a trust store - and Keith has showed how that could work.  He also has some code for nodes to generate their own identity which is useful for testing purposes.  +*"Peer Nodes"*+  We can go through the same thing in terms of any given peer attempting to connect to the ordering service.  There will likely be different information required by peers when working with different ordering services.   We do, however, more or less have the transport / API / interface(s) which the peer will use to send/receive data from the ordering service.  There is definitely *some* information that each peer will need to know about node(s) in the ordering service.  I will assert that this information will be different depending on the ordering service implementation.  I think just getting the sBFT  / orderer is a good enough start, so I'll stop here for now   ></body> </Action>
<Action id="19131" issue="12660" author="jyellick" type="comment" created="2016-10-05 21:39:15.0" updateauthor="jyellick" updated="2016-10-05 21:39:15.0"> <body><! CDATA > Keith, the raw ledger that the orderers know about is this system ledger shared by all peers and orderers. Hopefully this eliminates any confusion.  This is another case of our overloaded terminology biting us.  What  ~kchristidis  is referring to as  "raw ledger" might more appropriately be called "raw chain", because it is all of the blocks and block contents.  What  ~smithbk  is referring to is the KV store resulting from processing that "raw chain" as fabric transactions.  So yes, the orderer and the fabric have access to the same raw chain, but the orderer _does not_ run chaincode.  I am currently working with the crypto team in #fabric-crypto to try to get a much simplified transaction format that both the orderer and fabric can understand without bringing all of the complexity of the peer fabric side into the orderer.  Once we have this, then both the orderer and the peer can have the same view of some subset of what could be considered 'ledger state'.  In this case, that state should be extremely simple, and limited to expressing things like certificates and signature policies.  Because there was no clear fabric agnostic way to specify policy (this was embedded in the concept of system chaincode) I've written a fist pass https://gerrit.hyperledger.org/r/#/c/1487/ at a way specify this in a light and consumable way for both the fabric peer and the orderer.  > 1) Have we decided how nodes will identify each other? Perhaps we assume will use cryptographic identities and that these will be extracted verified via digital digital signatures? Perhaps we will require TLS (I would assert that we should just default to TLS and make sure we get it right ) and require that each node explicitly trust the TLS certificates of every other node?  The plan is to use TLS certificates.  For a system like SBFT, this will require every orderer node to generate a certficate and keypair, then embed the public piece into configuration which is distributed to all nodes before starting.  > 2) Clearly if we choose either one (or both) of the options above, they have the same basic requirement - all nodes need to know the cryptographic "identities" of all nodes  Agreed  > 3) Clearly for this to work, each node must be aware of the identities of all the nodes that will be part of the "ordering service" when it starts up (we'll have to address dynamically adding / removing nodes in the future as well).  Yes, I would prefer for the mechanism for bootstrapping and dynamic reconfiguration be the same, ie, to bootstrap, put a special transaction in the genesis block, to reconfigure inject a special transaction into the network (which goes into effect when it becomes part of a block)  >  So again, my question is have we decided how we expect peers to provide their identity to an ordering service node? Will we simply again be using digital signatures and trusting specific public keys (whether individual or some type of CA)  I've been told that knowing the peer CA certificates is sufficient (and to verify that the signature is from a cert signed by that CA).  >  Proving that a network of sBFT nodes can use a whitelist and only allow nodes from that whitelist to connect / participate? If not, then how can we expect to know what type of "bootstrap" configuration to provide?   ~corecode  proved this out months ago, but using some one-off configuration mechanisms.  This is clearly not technically very challenging, but making it user friendly probably is.  To me, the challenge is to express this configuration in a way that both the orderers and the peers can understand.  > There is definitely some information that each peer will need to know about node(s) in the ordering service. I will assert that this information will be different depending on the ordering service implementation.  I think the 'some information' can likely be distilled to either "The genesis block" or I think what would be much easier to consume, would be "Hash of the genesis block and address of the ordering service".  With the latter set of information, the peer can connect and retrieve the genesis block (with full confidence it is correct because of the hash) and then parse whatever additional more sophisticated information is needed to properly talk to the ordering service.  IE, is this a BFT ordering service? If so, what is f? Should I expect signatures on the blocks I get back and if so, what  set of signatures? etc.  At this point, I'm convinced it's not worth waiting for finalized transaction formats, so I am stubbing and mocking out structures for the pieces that I think will need to be there, and am going to try to plug these into the end to end flow that  ~muralisr  put together.  ></body> </Action>
<Action id="19132" issue="12660" author="smithbk" type="comment" created="2016-10-06 00:30:38.0" updateauthor="smithbk" updated="2016-10-06 00:30:38.0"> <body><! CDATA  ~mastersingh24   Gari, see my responses in {color:#d04437}<keith></keith>{color} below.  *Ordering Service*  1) We will have an ordering service (and possibly multiple implementations - e.g. Solo, PBFT, Kafka, etc) 2) Peer will connect to these ordering service(s) 3) Ordering services will likely need to provide access control for "peers" and "peers" will need to be able to trust "ordering services"  For 1), some of these ordering services will have the need for nodes to explicityly whitelist each other. I will assert that we can't necessarily dictate how this is done except perhaps for ones which we build - e.g. the SBFT ordering service and the Kafka orderer {color:#d04437}<keith>Right, how an ordering service nodes authenticate themselves to one another is hidden inside the ordering service implementation and not visible to it's clients.  But for the ordering services which we build, we should reuse code & processes as much as possible for orderer-to-orderer authentication.</keith>{color}  For now, let's start with the case of the sBFT orderer. In this case, we know that each sBFT node must know the total number of nodes and the identities of each of those nodes. This will require that nodes explicitly each provide some type of identity and that the other nodes will only connect to / allow connections from node identities which are part of some whitelist.  (note: in the text below - "node" refers to an sBFT orderer node)  Questions:  1) Have we decided how nodes will identify each other? Perhaps we assume will use cryptographic identities and that these will be extracted verified via digital digital signatures? Perhaps we will require TLS (I would assert that we should just default to TLS and make sure we get it right ) and require that each node explicitly trust the TLS certificates of every other node? {color:#d04437}<keith> Yes, I think that both orderers and peers should only be supported with mutual TLS.  This will force us to "get it right", to test fully, and to make it as easy to use as possible. </keith>{color}  2) Clearly if we choose either one (or both) of the options above, they have the same basic requirement - all nodes need to know the cryptographic "identities" of all nodes {color:#d04437}<keith>Yes, of course</keith>{color}  3) Clearly for this to work, each node must be aware of the identities of all the nodes that will be part of the "ordering service" when it starts up (we'll have to address dynamically adding / removing nodes in the future as well). {color:#d04437}<keith>Yes, I think something similar to the process in FAB-360 will work for the dynamic part, which I'll update later to discuss orderers.  But 1st want to finish bootstrapping.</keith>{color}  Then of course each node needs to provide / generate its cryptographic identity  Finally, we expect that clients of the ordering service will be required to "authenticate" with / be "authorized by" the ordering service before they can send/receive data from any channel in the ordering service (even if there is only one channel). So again, my question is have we decided how we expect peers to provide their identity to an ordering service node? Will we simply again be using digital signatures and trusting specific public keys (whether individual or some type of CA) {color:#d04437}<keith> I think it should work as follows ... The orderer accepts connections over a mutual TLS port from both orderers, peers, and SDK. The orderer (or COP w/in the orderer) maintains a list of orderer certs and a separate list of peer CA certs. The trust store of the orderer's TLS port contains certs from both lists.  After accepting the connection, the orderer gets the TLS client cert and checks against a orderer certs to determine if the connection is from an orderer or not.  If an orderer needs to distinguish between peer and SDK clients, we could build that in also though I don't think that is needed, right?   </keith>{color}  So have we even gotten this far? Proving that a network of sBFT nodes can use a whitelist and only allow nodes from that whitelist to connect / participate? If not, then how can we expect to know what type of "bootstrap" configuration to provide?  {color:#d04437}<keith>Not sure if you're asking me this question.  We've proven that we can bootstrap a group of v0.6 peers with multiple roots of trust.  For v1, we are reworking to use cfssl, and other than this, the only real difference will be keeping the orderer and peer certs separate.  We will then make the COP APIs available for the consensus team to use.</keith>{color}  As an aside, assuming that we go down the TLS / PKIX for digitail signatures route, then we simply need to be able to load up the trusted certificates into a trust store - and Keith has showed how that could work. He also has some code for nodes to generate their own identity which is useful for testing purposes. {color:#d04437}<keith> Even when customers provide their own certs, the COP CLI is still useful to bundle <cert, server type, host, port, etc> into a JSON format, and the COP library in the orderer be used to a) return the TLS cert pool and b) determine if a cert belongs to an order or peer.  When we start talking about dynamically adding/removing, it can also provide APIs to help.  </keith>{color}   *"Peer Nodes"*  We can go through the same thing in terms of any given peer attempting to connect to the ordering service. There will likely be different information required by peers when working with different ordering services. We do, however, more or less have the transport / API / interface(s) which the peer will use to send/receive data from the ordering service. There is definitely some information that each peer will need to know about node(s) in the ordering service. I will assert that this information will be different depending on the ordering service implementation. {color:#d04437}<keith> Could you expound on what other info may be required by a peer or by an orderer when working with a different ordering service?  I'm not sure how to design for it w/o understanding it better. </keith>{color}   I think just getting the sBFT / orderer is a good enough start, so I'll stop here for now   ></body> </Action>
<Action id="19134" issue="12660" author="smithbk" type="comment" created="2016-10-06 00:50:31.0" updateauthor="smithbk" updated="2016-10-06 00:50:31.0"> <body><! CDATA  ~jyellick  Jason, with regard to signature policy, as part of the COP library APIs, see section 2.1.3 of https://docs.google.com/document/d/1TRYHcaT8yMn8MZlDtreqzkDcXx0WI50AV2JpAcvAM5w which I've pasted below.  We were planning on providing a JSON-based language starting with the following primitives, with others added as needed:  {"percentage": 100}  - requires the signature of all current members of an arbitrary group.  See below.  This allows the policy to remain static as the size of the group changes.  {"approvers":  "participant1", "participant2" }  - requires signatures by participant 1 AND 2 ... a fixed policy for a bi-lateral contract  {"min": 2} - require at least 2 signatures out of a group  Here is the excerpt from the google doc  2.1.3 Create endorsement with policy and collect responses  // Create a group including 2 banks.  The names must be participant names. group, err := cop.NewGroup('bank1','bank2')  // Create a new group endorsement which requires at least 51 percent of participants // in this group to endorse the same response. endorsement, err := group.NewEndorsement('{"percentage":51}')  // As responses are received from individual servers, call Endorse with a // 'response' and 'signature' of type   byte and the serverName which provided // provided the response.  Verify the signature using the certificate associated // with server 'serverId'. complete, err := endorsement.Endorse( response, signature, serverId) if complete { // 51% of participants have agreed with this response. // Return all of the signatures that agreed with this server signatures := endorsement.getSignatures(serverId) }   ></body> </Action>
<Action id="19136" issue="12660" author="jyellick" type="comment" created="2016-10-06 14:03:51.0" updateauthor="jyellick" updated="2016-10-06 14:03:51.0"> <body><! CDATA > see section 2.1.3    ~keithsmith  The Google doc you linked does not contain this section, as best as I can tell.  I can see where I believe it was, so I added a comment within that it appears to be missing.  > We were planning on providing a JSON-based language starting with the following primitives  Especially since there is the DSL implementation I referenced in protobuf, a few comments.    I prefer the idea of defining the language in Protobuf, rather than JSON, as it easily gives us the definition of 'well formed' and allows the format to be encoded into whatever format is deemed most useful and can still be encoded to / decoded from JSON easily enough.  Secondly, I think heard similar concerns voiced by  ~marko.vukolic , but I think it's an incredibly bad idea to include percentage thresholds. A percentage is inherently based on network size, and therefore your rule inherently changes based based on membership.  Because of this dependency, it also makes auditing whether a policy was satisfied at a given time very difficult.  I'll give an example to illustrate why I think this is such a problem.  Example: A policy is defined as "Requires 60%" with a network of 10 banks, with the intent to require that 6 banks participate to form a majority, and then over time another 20 members join the network.  Now, the 'majority' actually requires 18 of the 30 participants must sign off (two more banks than are actually required for a majority).  The case could be made "When the membership changes, a new percentage should be agreed upon" but at that point, why not simply actually specify the actual number of signatures desired.  This also assumes that rules are _always_ written against membership counts which are controlled by the whole network.  The instant the rule "51% of peers are required" is in place, the system will be susceptible to basic Sybil attacks.  Finally, another push for the solution offered now in Gerrit, imagine wanting to express a rule of "(Bank A must sign, and 6 of 10 of its subsidiaries must sign), Or (Bank A and Regulator must sign)".  This is trivial using only the `NOutOf` construct, but I'm not sure how to describe this in the format from 2.1.3.  To my knowledge, the consensus squad did not know about any of this, have you discussed this with the endorsement team? I'd also be curious to hear what other use cases they have for endorsement.  ></body> </Action>
<Action id="19138" issue="12660" author="kchristidis" type="comment" created="2016-10-06 16:15:50.0" updateauthor="kchristidis" updated="2016-10-06 16:15:50.0"> <body><! CDATA Not picking a side on percentage-based policies, cause I think this specific point is largely irrelevant compared to the more immediate and practical concerns that we have, but since it was brought up --  (Everything below is conditional on the membership changes being posted on the chain.)  > Because of this dependency, it also makes auditing whether a policy was satisfied at a given time very difficult. I'll give an example to illustrate why I think this is such a problem.  If the auditor has trouble parsing the chain to identify when new members were added, or how many members are supposed to be present during the evaluation of block X, I think we have failed at a more fundamental level.  > The case could be made "When the membership changes, a new percentage should be agreed upon" but at that point, why not simply actually specify the actual number of signatures desired.  Actually, you can skip making that case if you want to have what that policy says: 60% of the banks to agree at any time. At any point you should be able to know how many members are in play, and calculate what 60% means. I don't see what makes auditing this "very difficult"?  > This also assumes that rules are always written against membership counts which are controlled by the whole network. The instant the rule "51% of peers are required" is in place, the system will be susceptible to basic Sybil attacks.  In a system where you cannot forge multiple identities, how can you have a Sybil attack?  ></body> </Action>
<Action id="19139" issue="12660" author="smithbk" type="comment" body="Yes, we need to focus this FAB on the immediate bootstrapping concerns.  So since this FAB was not originally written for v0.6, I&apos;ve rewritten it for v1.   Please re-read the description and comment only on how to bootstrap." created="2016-10-06 16:50:07.0" updateauthor="smithbk" updated="2016-10-06 16:50:07.0"/>
<Action id="19140" issue="12660" author="smithbk" type="comment" body="The code segment&apos;s are badly displayed.  Anyone know how to do code format in jira?" created="2016-10-06 16:57:09.0" updateauthor="smithbk" updated="2016-10-06 16:57:09.0"/>
<Action id="19141" issue="12660" author="smithbk" type="comment" body="nevermind, just found it" created="2016-10-06 17:00:14.0" updateauthor="smithbk" updated="2016-10-06 17:00:14.0"/>
<Action id="19142" issue="12660" author="jyellick" type="comment" created="2016-10-06 17:43:09.0" updateauthor="jyellick" updated="2016-10-06 17:43:09.0"> <body><! CDATA > Actually, you can skip making that case if you want to have what that policy says: 60% of the banks to agree at any time. At any point you should be able to know how many members are in play, and calculate what 60% means. I don't see what makes auditing this "very difficult"?  Perhaps "very difficult" is a bit harsh.  Obviously it can be computed, and any auditor should be able to compute it.  Still, I feel like it is much simpler to be able to look at a policy, and look at a transaction (or other object) and be able to get a true/false, rather than to have a policy, a transaction, and a third piece of information which determines how the policy is applied to the transaction.  > In a system where you cannot forge multiple identities, how can you have a Sybil attack?  I said 51% of the _peers_.  This story talks about multiple roots of trust.  You have two membership services, one presumably controlled by company 1, and one by company 2.  Each may join as many peers as they wish.  Hence, company 1 could create many bogus peers in order to increase its relative voting power.  Of course, if you go and say 51% of the entities/companies, whose membership is determined by all interested parties, then I agree, there is no Sybil attack.  ></body> </Action>
<Action id="19143" issue="12660" author="jyellick" type="comment" created="2016-10-06 18:01:06.0" updateauthor="jyellick" updated="2016-10-06 18:01:06.0"> <body><! CDATA With respect to the updated description.  > // 1) At start time, initialize cop as follows ... > if this is the first time starting the orderer or peer (i.e. there is no raw ledger) {  I maintain that the genesis block should be created _once_ by an out of band procedure, and distributed.  An administrator will likely wish to review the contents of this generated block (and we should provide the ability to inspect it in a human readable way).  At this point, the orderer service can be bootstrapped simply by giving this genesis block to each orderer (and following a similar process of loading the genesis block from the filesystem if there is no ledger dir) and starting the orderer nodes.  The peers likewise could be given the genesis block, or, for a slightly more friendly configuration option, the peers could be given the hash of the genesis block and be told to connect to the orderer service to retrieve the genesis block (which can be validated by hash).  Assuming we have some policy verification mechanism, such that given a message, a set of (identities and signatures) and a policy, then we should be able to apply the policy to those signatures for that message, and get a true/false result.  I'm not sure what else is required beyond this?  I'm a little wary of API calls like {{certHandler.IsType('orderer')}} because it is doing validation by type, not by policy.    ></body> </Action>
<Action id="19148" issue="12660" author="jyellick" type="comment" created="2016-10-06 21:22:28.0" updateauthor="jyellick" updated="2016-10-06 21:22:28.0"> <body><! CDATA After a long meeting via hangout in #fabric-consensus-dev today I think we have ironed out an agreed upon flow.  Present were  ~tuand   ~muralisr   ~jeffgarratt   ~sanchezl   ~keithsmith .  *Components:*  COP: As a membership services replacement, this will be responsible for creating and signing certificates, acting as a CLI, server, or client for managing certificates.  Bootstrap: This is a separate utility which takes sets of certificates (usually generated from COP), as well as some pieces of configuration for both the orderer and peer, especially an orderer ingress policy (which peer CA certs are authorized to transact on the network), an orderer egress policy (how orderer clients (peers) should validate the orderer output) and finally the specific orderer config (for pbft f/K/L/etc.) and peer policy (bootstrapping of assorted system chaincodes).  This utility then packages this information into a transaction or set of transactions (format to be determined) which defines this config and encodes it as a genesis block.  Policy: Because we will have many components which need to enforce signature policies (endorsement policies, orderer ingress/egress policies, and config modification policies etc.), we should abstract this out into a _lightweight_ library which can be plugged into components as needed.  The peer and orderer being the two to start with.  There is the initial {{SignaturePolicy}} from the Gerrit commit above which can be used for prototyping, and potentially production use, but the ultimate format is yet to be decided.  Potentially a policy wrapper with type config can be embedded, but whatever we develop must work independent of fabric specifics like MVCC.  Addition/Removal of Participants:  Ultimately, this will come down to a policy update being executed with the relevant signatures included.  The signatures required will be specified by the policy as described above.  To facilitate this for larger or more complicated networks, a chaincode application may be built which allows for a sponsor to request membership, alerting other members to a pending membership request.  This is however a process improvement, and is not technically required for reconfiguration.  *Bootstrapping process:*  1. A bootstrap admin collects all necessary details, including the generated certificates, addresses, config etc. necessary to run the bootstrapping tool. 2. Bootstrap admin runs the bootstrap tool outputting a genesis block 3. Bootstrap admin gives the genesis block to the orderer admins who inspect it, and given it is satisfactory, copy it the ordering nodes.  The ordering nodes can then start, and service requests.   4. When a peer wants to join, it requests a signed cert from the COP/membership services, as well as the hash of the genesis block (which the peer admin inspected and approved) and addresses of the ordering service. 5. The peer then calls {{Deliver}} on the ordering service to retrieve the genesis block (which it validates against the hash), then processes the config and policies embedded therein and is ready to participate in the network.  *Remaining points of contention:*  Policy specifications, and whether to have different policy modification rules by modification type.  On one hand, supporting different modification policies for adding or removal allows for more novel configurations, and might be especially useful for an entity which chooses to leave a network and does not wish permission to leave.  On the other hand, it introduces complexity into a shared component and risks cascading effects, such as other members being unaware that their membership thresholds have changed.  Policy specifications, whether to allow policy which relies on external state.  IE, whether to require all certs and explicit counts to be listed in the policy, or to allow this to be implicitly calculated based on a percentage or 'unanimous' etc.  Policy specifications, whether to encode updates incrementally, or require that complete policy be written after each modification.  Please feel free to chime in if anyone feels I have misinterpreted anything from the hangout.  ></body> </Action>
<Action id="19158" issue="12660" author="tuand" type="comment" created="2016-10-07 14:38:33.0" updateauthor="tuand" updated="2016-10-07 14:38:33.0"> <body><! CDATA To add to  ~jyellick 's comment above, this is a flow diagram of the proposed bootstrap process :  !bootstrap.png|thumbnail!   ^bootstrap.txt    And Jason's description of step 1 (Admin creates genesis block) : 1. Entities create CA certs for peer network 2. Entities create Self-signed certs for orderer network 3. Certs are sent to the bootstrap administrator 4. Bootstrap administrator uses bootstrapping tool to generate genesis block * Bootstrap administrator sets ordering ingress validation policy * Bootstrap administrator sets ordering egress validation policy * Bootstrap administrator sets ordering opaque config (for instance specifics of PBFT f/K/L/etc.) * Bootstrap administrator sets peer opaque config (VSCC policies, etc.) 9. Bootstrap administrator distributes the genesis block to other administrators 10. After inspection and approval, administrator installs block at orderer node and starts (orderer network now functional) 11. Admin supplies genesis hash and ordering service to peers, they connect and receive genesis block to bootstrap their configuration  ></body> </Action>
<Action id="19160" issue="12660" author="kchristidis" type="comment" created="2016-10-07 15:22:58.0" updateauthor="kchristidis" updated="2016-10-07 15:24:01.0"> <body><! CDATA Tuan, in the sequence diagram I believe that the peer should be requesting a _certificate_, right? Or, if my assumptions below are correct, it simply issues a "join" request that gives it back all the things that you list. (I would also update all references from ledger to chain to avoid confusion.)  Practically speaking, are there input arguments for the call that I, as a client wishing to participate in the ordering network, would pass in the function call in step 4 (from the bootstrapping process list)?  I would assume that the admin is configured to handle one ordering network + chain, so a simple join() call would return all the necessary info, same as Tuan shows in his sequence diagram. That implies that the only thing I need to know if I want to join the network is merely the URI of the bootstrap admin for that network. If that's not the case, let me know.  (By the way, on the Sybil attack issue above: "I said 51% of the _peers_." Yes but considering just the peers and not different orgs is nonsensical and prone to Sybil attacks no matter whether it's based on percentages or _actual numbers_. The original comment made it sound like policies specifying the actual number of signatures required would somehow be immune to this, which is not true and what raised my objection. That comment had started as a percentages versus actual numbers point, and then somehow brought peers versus orgs into the mix -- these two are orthogonal.)  ></body> </Action>
<Action id="19161" issue="12660" author="jyellick" type="comment" created="2016-10-07 15:51:58.0" updateauthor="jyellick" updated="2016-10-07 15:51:58.0"> <body><! CDATA > That comment had started as a percentages versus actual numbers point, and then somehow brought peers versus orgs into the mix – these two are orthogonal  I agree these two are orthogonal.  I only brought it up because I have most commonly heard references to percentage policies based on the number of peers.  If this is the use case for which percentages are being targeted, then we should re-examine it because any policy based on number of peers and not number of org level entities is dangerous.  ></body> </Action>
<Action id="19164" issue="12660" author="sanchezl" type="comment" created="2016-10-07 17:51:40.0" updateauthor="sanchezl" updated="2016-10-07 17:51:40.0"> <body><! CDATA  !Bootstrap.png|thumbnail!    ^Bootstrap.txt    I updated the diagram posted in  Tuan's comment|#comment-19158  to show more details.     ></body> </Action>
<Action id="19165" issue="12660" author="tuand" type="comment" created="2016-10-07 18:09:36.0" updateauthor="tuand" updated="2016-10-07 18:09:36.0"> <body><! CDATA  ~kchristidis  yes, I should've type "cert" instead of "key". ( ~sanchezl  is working up a more detailed flow diagram so I'm waiting for him to append before I see if I need to update mine )  We had not discussed as much how the admin goes about gathering/creating/disseminating the config data contained in the genesis block besides relying on the bootstrap tool mentioned in earlier comments. Nor did we dive into the peer/admin interaction but, I agree that that can be a join() call. We should probably decide on how the admin recognizes a request from an authorized entity or peer.  ></body> </Action>
<Action id="19168" issue="12660" author="smithbk" type="comment" created="2016-10-08 09:56:34.0" updateauthor="smithbk" updated="2016-10-08 09:56:34.0"> <body><! CDATA WRT bootstrap ... 1) The precise details of usage and packaging of the bootstrap cli tool needs to be specified.  Is the same tool used for both pbft and kafka and other orderer services?  Do we have one cli or multiple? 2) When the peer 1st connects to the orderer over TLS, where does it get the cert pool to use for that connection?  Are you assuming that the peer has the genesis block or just the hash?  If it has the actual genesis block, it could extract the orderer certs to build its cert pool to use for the connection.  If it has only the hash, then I'm not sure exactly how that would work.  WRT policy ... I just want to reiterate that I'm not at all convinced that a unanimous/percentage policy is a bad idea.  I think it is needed and makes things simpler.  I also want to clarify that I mean percentage-based *at the participant level, not the peer level*.  No sybil attack is possible because we are counting participants, not peers.  That said, I agree that we can have a policy engine which can change as we go forward, so it is not cast in stone. I know what you have is intended for config update policy, but when I think of endorsement policy, signature policy processing is in 2 phases: 1) signature validation - this is what you have ... that is, once all of the signatures have been collected, someone needs to check that they are valid 2) signature collection - this is gathering endorsements and signatures one at a time with 3 possible outcomes as each response is received: yes, no, and wait.  For example, suppose we have a 2 out of 3 policy and consider two scenarios. a)  We get back the 1st signature with response "a" and the answer is wait.  Then we get the 2nd signature with response "a", so the answer is yes with response of "a". b) We get back the 1st signature with response "a" and the answer is wait.  Then we get the 2nd signature with response "b", so the answer is wait.  We get back the 3 signature with response of "b", so the answer is "yes" with a response of "b" because two agreed with the same answer.    ></body> </Action>
<Action id="19181" issue="12660" author="jyellick" type="comment" created="2016-10-10 13:07:13.0" updateauthor="jyellick" updated="2016-10-10 13:07:13.0"> <body><! CDATA > 2) When the peer 1st connects to the orderer over TLS, where does it get the cert pool to use for that connection? Are you assuming that the peer has the genesis block or just the hash? If it has the actual genesis block, it could extract the orderer certs to build its cert pool to use for the connection. If it has only the hash, then I'm not sure exactly how that would work.  If the genesis block is distributed to the peers manually, then I think this is all a non-issue, as the genesis block should contain all the needed information, and it should be a 'normal' startup (after doing whatever is required to pull the genesis block in).  If instead the hash of the genesis block is distributed (which I think would be a nice option to support, as it is text instead of binary), then the peer could connect with a permissive trust policy and not care about who it is connecting to.  The reason why this would be acceptable is because the peer can validate the genesis block returned by the orderer against the block hash.  It's not possible for the orderer to inject bad configuration in, because it cannot forge a block with the correct hash.  Once the peer has the genesis block, it would then drop the network connection and re-authenticate based on the contents of the genesis block for further communications.  > signature policy processing is in 2 phases:  ed: validation and collection   These are separate issues in my head, but I agree they both need to be addressed.  However, I do think (2) is a good point because this implies the SDK will need to be able to evaluate the policies as well as the peer, which is a good argument for limiting complexity (since every SDK implementation will likely need to implement its own policy evaluation).  ></body> </Action>
<Action id="19207" issue="12660" author="jeffgarratt" type="comment" created="2016-10-11 21:11:23.0" updateauthor="jeffgarratt" updated="2016-10-11 21:11:23.0"> <body><! CDATA Attaching first draft of feature file for bootstrap.   ^bootstrap.feature    ></body> </Action>
<Action id="19223" issue="12660" author="tuand" type="comment" created="2016-10-13 13:12:44.0" updateauthor="tuand" updated="2016-10-13 13:12:44.0"> <body><! CDATA I'm starting to work on FAB-665 which is to gather all the orderer certs/policies/config and create a genesis block out of the data.   Who's working on the upstream tools as part pf FAB-359 to create the certs ?  I need to see if we have overlap and to tie the various tools together.  ></body> </Action>
