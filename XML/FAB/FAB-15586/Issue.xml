<Issue id="40221" key="FAB-15586" number="15586" project="10002" reporter="sykesm" creator="sykesm" type="10002" summary="Kill ledger/customtx package" priority="3" resolution="10002" status="6" created="2019-05-30 14:41:41.0" updated="2019-06-24 08:38:54.0" resolutiondate="2019-06-24 08:38:54.0" votes="0" watches="1" workflowId="53124"> <description><! CDATA This package is the definition of the "package as object" anti-pattern. It consists of the following:  {code} package customtx  import ( 	"sync"  	"github.com/hyperledger/fabric/protos/common" )  var processors Processors var once sync.Once  // Processors maintains the association between a custom transaction type to its corresponding tx processor type Processors map common.HeaderType Processor  // Initialize sets the custom processors. This function is expected to be invoked only during ledgermgmt.Initialize() function. func Initialize(customTxProcessors Processors) { 	once.Do(func() { 		initialize(customTxProcessors) 	}) }  func initialize(customTxProcessors Processors) { 	processors = customTxProcessors }  // GetProcessor returns a Processor associated with the txType func GetProcessor(txType common.HeaderType) Processor { 	return processors txType  } {code}  Translating code to words, we have a global singleton that can be read or set by anyone yet there's a public method to help ensure it's initialized exactly once (by someone, no guarantees who or when) and we export accessors into the global namespace so that anyone can get something.  The code that needs these processors should be explicitly provided a reference to the processors they need. Tell - don't ask.  ></description> </Issue>
