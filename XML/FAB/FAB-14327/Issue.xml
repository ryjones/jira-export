<Issue id="37947" key="FAB-14327" number="14327" project="10002" reporter="tock" assignee="tock" creator="tock" type="10004" summary="Race between go-routines in multichannel/blockwriter.go that corrupts Sequence()" priority="2" resolution="10000" status="6" created="2019-02-25 08:16:50.0" updated="2019-03-07 13:48:38.0" resolutiondate="2019-02-26 12:41:27.0" votes="0" watches="6" workflowId="49565"> <description><! CDATA h2. The problem  There is a race between the go-routine that submits a config-update block to the internal thread that writes the (previous) block asynchronously to the ledger.  The race may cause to back-to-back config-update transactions to have bad block metadata - in the first the LAST_CONFIG will be ok, but in the second the LAST_CONFIG will point to the first, rather then the second. This may happen independently in different ledgers, creating a *fork*. h2. The mechanism  The race manifests itself in the following manner.  Assume two config-updates TXs (t1 t2) that arrive back to back, and packed into blocks B1 B2. The go-routine (SUB) that submits B1 take a lock, spawns a go-routine (WR), and lets it write B1 to disk. see: {quote}func (bw *BlockWriter) WriteBlock(block *cb.Block, encodedMetadataValue   byte) {quote} As part of it work, go-routine WR will call    {code:java} func (bw *BlockWriter) addLastConfigSignature(block *cb.Block) {       configSeq := bw.support.Sequence() if configSeq > bw.lastConfigSeq {  ... bw.lastConfigBlockNum = block.Header.Number  bw.lastConfigSeq = configSeq  } ... } {code}  However, the go-routine SUB continues, and if it is fast enough,  will grab B2, and call     {code:java}  func (bw *BlockWriter) WriteConfigBlock(block *cb.Block, encodedMetadataValue   byte) {code} with it. In there, it will call {code:java} bw.support.Update(bundle) 	... bw.WriteBlock(block, encodedMetadataValue) {code} That is, it may update the StableBundle before the WR go-routine has a chance to read Sequence from it. The first block will be OK, as {quote}configSeq > bw.lastConfigSeq {quote} is still true, although (configSeq = bw.lastConfigSeq+2), rather then (configSeq = bw.lastConfigSeq+1).  In the second block, {quote}configSeq > bw.lastConfigSeq {quote} will NOT hold, and the LAST_CONFIG index will remain pointing to the first block, rather than the first.  This can create a fork between orderers:  O1 blocks: B1 B2 O1 lastConf: 1 2  O2 blocks: B1 B2 O2 lastConf: 1 1      Moreover, if a config block overruns a normal block, it can cause a normal block to point to itself as last-config. h2.  Proposed solutions  There are several possible solutions: # Cancel the "pipeline" and have go-routine SUB go all the way to disk. # Have the go-routine SUB wait for go-routine WR to finish before updating the Bundle. # Pass the seq := support.Sequence() to the go-routine WR as a parameter rather than let it access StableBundle      Solution (1) is the safest but has performance issues.  Solution (2) is easy: {code:java} // Avoid Bundle update before the go-routine in WriteBlock() finished writing the previous block. // Avoid Bundle update before the go-routine in WriteBlock() finished writing the previous block.  // We do this (in particular) to prevent bw.support.Sequence() from advancing before the go-routine read it.  // In general, this prevents the StableBundle from changing before the go-routine in WriteBlock() finishes.  bw.committingBlock.Lock()  bw.committingBlock.Unlock()  bw.support.Update(bundle)   {code} Thus will block go-routine SUB until go-routine WR finishes before updating the Bundle.  Solution (3) is ad-hoc in protecting just the sequence.  *Preferred short term solution: is (2)*  *In the peer:* it is also advisable to improve validation of the metadata in the peer: check that a config block's last-config always points to itself, check that a normal block's last-config never points to itself. h2. How to reproduce  Start two Kafka orderers O1 O2. Stop one of them, say O2. Run several config-txs back to back through O1. Now restart O2. The orderer O2 will consume the Txs from Kafka as fast as it can and will, with high probability, manifest this bug. Check the metadata of the ledger @O2:   * check that a config block's last-config always points to itself, * check that a normal block's last-config never points to itself.     In the logs - this will show like this: {code:java}  e  OrdererOrg.orderer3  2019-02-24 22:57:27.900 IST  orderer.consensus.kafka  processMigrationStep -> INFO 039  channel: systemchannel  Consensus-type migration: Processing confi g tx: type: kafka, state: MIG_STATE_ABORT, context: 3  e  OrdererOrg.orderer3  2019-02-24 22:57:27.977 IST  orderer.consensus.migration  stepSystem -> INFO 055 Consensus-type migration: Accepted ABORT Config tx on system channel chan nel=systemchannel  e  OrdererOrg.orderer3  2019-02-24 22:57:27.981 IST  orderer.consensus.kafka  processRegular -> INFO 057  channel: systemchannel  Committed config message with offset 6  e  OrdererOrg.orderer3  2019-02-24 22:57:27.992 IST  orderer.consensus.kafka  processMigrationStep -> INFO 05b  channel: systemchannel  Consensus-type migration: Processing confi g tx: type: kafka, state: MIG_STATE_START, context: 0  e  OrdererOrg.orderer3  2019-02-24 22:57:27.992 IST  orderer.consensus.migration  stepSystem -> INFO 05d Consensus-type migration: Accepted START Config tx on system channel; Sta tus: State=MIG_STATE_START, Context=5, Sys=true channel=systemchannel  e  OrdererOrg.orderer3  2019-02-24 22:57:27.984 IST  orderer.commmon.multichannel  addLastConfigSignature -> DEBU 058  channel: systemchannel  Detected lastConfigSeq transitionin g from 1 to 2, setting lastConfigBlockNum from 3 to 4  e  OrdererOrg.orderer3  2019-02-24 22:57:27.998 IST  orderer.commmon.multichannel  addLastConfigSignature -> DEBU 05f  channel: systemchannel  About to write block, setting its L AST_CONFIG to 4  e  OrdererOrg.orderer3  2019-02-24 22:57:28.017 IST  orderer.commmon.multichannel  commitBlock -> DEBU 06c  channel: systemchannel  Wrote block 4  e  OrdererOrg.orderer3  2019-02-24 22:57:28.017 IST  orderer.consensus.kafka  processRegular -> INFO 06d  channel: systemchannel  Committed config message with offset 7  e  OrdererOrg.orderer3  2019-02-24 22:57:28.020 IST  orderer.consensus.kafka  processMigrationStep -> INFO 06e  channel: systemchannel  Consensus-type migration: Processing config tx: type: etcdraft, state: MIG_STATE_COMMIT, context: 5  e  OrdererOrg.orderer3  2019-02-24 22:57:28.021 IST  orderer.consensus.migration  stepSystem -> INFO 070 Consensus-type migration: Accepted COMMIT Config tx on system channel; St atus: State=MIG_STATE_COMMIT, Context=5, Sys=true channel=systemchannel  e  OrdererOrg.orderer3  2019-02-24 22:57:28.021 IST  orderer.consensus.kafka  func2 -> INFO 071  channel: systemchannel  Consensus-type migration: Replaced bootstrap file: /tmp/e2e928641347/orderers/OrdererOrg.orderer3/systemchannel_block.pb; Status: State=MIG_STATE_COMMIT, Context=5, Sys=true  VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV   e  OrdererOrg.orderer3  2019-02-24 22:57:28.028 IST  orderer.commmon.multichannel  addLastConfigSignature -> DEBU 073  channel: systemchannel  Detected lastConfigSeq transitioning from 2 to 4, setting lastConfigBlockNum from 4 to 5  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   e  OrdererOrg.orderer3  2019-02-24 22:57:28.028 IST  orderer.commmon.multichannel  addLastConfigSignature -> DEBU 074  channel: systemchannel  About to write block, setting its LAST_CONFIG to 5 ^^^^^^^^^^^^^^^^    e  OrdererOrg.orderer3  2019-02-24 22:57:28.039 IST  orderer.commmon.multichannel  commitBlock -> DEBU 07a  channel: systemchannel  Wrote block 5  e  OrdererOrg.orderer3  2019-02-24 22:57:28.039 IST  orderer.consensus.kafka  processRegular -> INFO 07b  channel: systemchannel  Committed config message with offset 8  e  OrdererOrg.orderer3  2019-02-24 22:57:28.039 IST  orderer.commmon.multichannel  addLastConfigSignature -> DEBU 07c  channel: systemchannel  About to write block, setting its LAST_CONFIG to 5 ^^^^^^^^^^^^^^^^   e  OrdererOrg.orderer3  2019-02-24 22:57:28.056 IST  orderer.commmon.multichannel  commitBlock -> DEBU 07e  channel: systemchannel  Wrote block 6 {code}     Where block 5 and block 6 are two config transactions.  ></description> </Issue>
