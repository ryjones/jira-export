<Action id="20278" issue="13868" author="angelo.decaro" type="comment" created="2017-01-06 09:28:00.0" updateauthor="angelo.decaro" updated="2017-01-06 09:28:00.0"> <body><! CDATA Please, correct me if I'm wrong: It looks to me that we start from the assumption that peers in the same organization might have different MSPs (because they belong to different channels, possibly).   I want to understand if it is important to keep this separation for privacy reasons. Is it reasonable to think that inside the same organization, peers might be required to not be aware of which channels other peers belong to? If this is the case, then this MSP replication might represent a privacy violation.   I might be wrong here, please, help me in the understanding :)   ></body> </Action>
<Action id="20279" issue="13868" author="yacovm" type="comment" created="2017-01-06 10:54:36.0" updateauthor="yacovm" updated="2017-01-06 10:54:36.0"> <body><! CDATA {quote}Please, correct me if I'm wrong: It looks to me that we start from the assumption that peers in the same organization might have different MSPs (because they belong to different channels, possibly). {quote} Well, since there are 2 kinds of MSPs in the peer: local MSP that can only verify sigs from peers in the same org, and channel-based MSP that is derived from the ledger, peers in the same channel can have a different set of MSPs if they're not in the same channel(s).  {quote} Is it reasonable to think that inside the same organization, peers might be required to not be aware of which channels other peers belong to?{quote} We discussed this, and it is not so, and based on previous discussions, in gossip we disseminate the channel IDs and the ledger height of the peers in the channels inside the entire organization.   Please correct me,  ~binhn   if a new privacy concern was introduced.   ></body> </Action>
<Action id="20283" issue="13868" author="binhn" type="comment" created="2017-01-06 15:26:43.0" updateauthor="binhn" updated="2017-01-06 15:32:26.0"> <body><! CDATA bq. Periodically, the gossip layer queries the MSPs of the peer for their recent MSPDigest   I am a bit concerned of the timing here:  Since the leader of the org is connected to the ordering service, it might get a block for a channel that it doesn't belong before it can replicate the channel's MSP, so it would not be able to verify the block.  An alternative that I can think of is to have the peers push the MSP to the leader (all peers in an org must know its current leader) upon receiving the configuration transaction. The leader could also hold on to the block for a period for MSP replication to take place. However, I think push would be much better since MSP reconfiguration doesn't happen often.  ></body> </Action>
<Action id="20284" issue="13868" author="binhn" type="comment" body=" ~angelo.decaro   ~yacovm  Yes, that is our current working assumption." created="2017-01-06 15:27:49.0" updateauthor="binhn" updated="2017-01-06 15:27:49.0"/>
<Action id="20286" issue="13868" author="yacovm" type="comment" created="2017-01-06 17:27:48.0" updateauthor="yacovm" updated="2017-01-06 17:27:48.0"> <body><! CDATA Thanks for your feedback, Binh.  {quote}I am a bit concerned of the timing here: Since the leader of the org is connected to the ordering service, it might get a block for a channel that it doesn't belong before it can replicate the channel's MSP, so it would not be able to verify the block{quote} We can have a leader per channel *and* org, and this would solve this problem. I updated the JIRA post's body and deleted the leader part.  And from what I understood, there are additional items that exist in a configuration block (like hash algorithm, signature policy (k out of n sigs)) that are needed to be replicated besides the MSP, that would be needed for a peer to be call *Deliver* on a channel that he isn't in the channel itself. I believe  ~jyellick  can approve/disprove this. So, if we go along that path we would need to simply disseminate the configuration block instead.  Perhaps for V1 we should go for the leader-per-channel-and-org and tackle this if need arises later on.    ></body> </Action>
<Action id="20289" issue="13868" author="jyellick" type="comment" created="2017-01-06 20:55:11.0" updateauthor="jyellick" updated="2017-01-06 20:55:11.0"> <body><! CDATA > So, if we go along that path we would need to simply disseminate the configuration block instead.  I see this as rather unavoidable, and probably the simplest of the solutions.  By disseminating the configuration block, you get:  1. The block hashing parameters 2. The MSPs for the chain 3. The block signature metadata validation policy 4. The last configuration metadata validation policy  And finally, and perhaps most importantly, it's not possible to validate a new configuration block without having the entire previous configuration block.  In general, because there is only ordering within a chain, and not across chains, any logic which depends on global changes is suspect.  Not that it is impossible to implement correctly, but, my personal inclination would be to replicate too much, then narrow it down if it causes problems, than to try to be too clever out of the gate.  ></body> </Action>
<Action id="20290" issue="13868" author="yacovm" type="comment" created="2017-01-06 21:21:26.0" updateauthor="yacovm" updated="2017-01-06 21:21:26.0"> <body><! CDATA  ~jyellick  {quote}any logic which depends on global changes is suspect{quote} - care to elaborate?   ></body> </Action>
<Action id="20305" issue="13868" author="jyellick" type="comment" created="2017-01-09 14:57:03.0" updateauthor="jyellick" updated="2017-01-09 14:57:03.0"> <body><! CDATA >> any logic which depends on global changes is suspect > - care to elaborate?  In short, global changes are unordered, and without order it's extremely easy to introduce non-determinism.  To put it more verbosely, consider the following example:  Two peers, peer A and peer B Peer A is a member of chains foo and bar Peer B is a member of chain foo only Chain foo and chain bar each have a validation policy requiring both a signature from MSP 1 and MSP 2. Peer A has chain foo at block 20 and bar at block 10 Peer B has chain foo at block 25 There is an MSP reconfiguration on foo at block 23 There is the same MSP reconfiguration on bar at block 17  1. Peer A hears from peer B about blocks 21, 22, 23 from peer B 2. Peer A applies the MSP reconfiguration from foo at block 23 globally 3. Peer A now receives block 11 on chain bar 4. Peer A cannot validate block 11 because the signatures on block 11 are only valid under the old MSP 5. Peer A is now forever stuck unable to validate any more blocks on chain bar  The key here is that signature sets have context.  And you cannot expect that just because the MSPs are changing, that the signatures sets do too (in fact in general, they will not).  A set of signatures that was valid at a given point in the chain needs to stay valid at that point in the chain.  I'll include on more example of how this is a problem.  Consider a peer who is starting up and has only the genesis block for chain foo.  Chain foo is thousands of blocks long.   The MSPs have rotated several times If this peer _only_ has the current MSPs, how can it hope to validate the older blocks, like block 1?  The claim could be that this peer should be seeded with the 'most recent' configuration block, so that it can do backwards hash chain validation and ignore signatures (which is a fine idea), but the idea of 'most recent' is poorly defined.  A new configuration block and MSP change might happen the millisecond after the configuration block is supplied in which case we are back to the same problem.  ></body> </Action>
<Action id="20314" issue="13868" author="yacovm" type="comment" created="2017-01-09 23:42:13.0" updateauthor="yacovm" updated="2017-01-09 23:42:13.0"> <body><! CDATA I understand what you're saying Jason, and the problems that you bring are indeed sound and only give more reasons to move to the 2nd approach (at least for V1): * The peer that connects to the ordering service will be selected among peers in the channel in its own organization This would eliminate all the problems caused by wrong/outdated block validation policies because all peers would process blocks in-order and will not disseminate configuration blocks to peers that are not in the channel. * That peer would initiate block dissemination among the peers of its organization that publish to all peers their participation in the channel.  * We replicate channel MSP among the peers of a same organization, and this would enable peers in the same channel to *find* / *discover* peers of the same channel in different organizations via hearing about them from the anchor peers that are listed in the JoinChannel messages / configuration blocks.  ></body> </Action>
<Action id="20318" issue="13868" author="elli-androulaki" type="comment" created="2017-01-10 09:19:24.0" updateauthor="elli-androulaki" updated="2017-01-10 09:19:24.0"> <body><! CDATA So regarding the suggested MSPConfig, this may be confused with the MSPConfig that exists in protos/msp/mspconfig.proto/go.pb, Maybe rename this to GossipChannelMSPConfig or MSPConfigGossipMsg?  Replicating configuration blocks across peers of the same organization may not be that bad, as long as its guaranteed that the order in which these configuration blocks are received is preserved.   Now just to make sure I understood approach 2 correctly: You are saying there is one leader per organization per channel. How would the peers of an organization know which peer is the leader for a specific channel? I am guessing not through the JoinChannel, since in this case this information would only be available to the peers that have joined the channel.   Would it make sense to have a dedicated peer (per organization leader of leaders) that can be queried by same organization peers, to get the information of which is the organization leader of a channel? Too complex?    ></body> </Action>
<Action id="20319" issue="13868" author="yacovm" type="comment" created="2017-01-10 09:42:48.0" updateauthor="yacovm" updated="2017-01-10 09:42:48.0"> <body><! CDATA {quote}So regarding the suggested MSPConfig, this may be confused with the MSPConfig that exists in protos/msp/mspconfig.proto/go.pb, Maybe rename this to GossipChannelMSPConfig or MSPConfigGossipMsg?{quote} The only code that would reference this would be the gossip code, which will not reference the protos/msp one, so I think it's ok.   {quote}Replicating configuration blocks across peers of the same organization may not be that bad, as long as its guaranteed that the order in which these configuration blocks are received is preserved. {quote} Agreed.   {quote}Now just to make sure I understood approach 2 correctly: You are saying there is one leader per organization per channel. How would the peers of an organization know which peer is the leader for a specific channel? I am guessing not through the JoinChannel, since in this case this information would only be available to the peers that have joined the channel. {quote} You are guessing correct. The only peers that will need to know about the leader of the channel are of course, the peers of the channel in the organization.  We are developing a leader election mechanism that enables set of peers to elect a single peer from that set.  It would work in the following way: * Peers that join a channel begin gossiping information about their participation in the channel to all peers of the org. * This gives peers the ability to know which peers of the org are in the channel and which are not. * The peers of the channel in the org would elect a peer to connect to the ordering service on behalf of the peers of the channel (in the org). * That peer would first commit the blocks and *only then* disseminate them to the rest of the peers via gossip.  {quote}Would it make sense to have a dedicated peer (per organization leader of leaders) that can be queried by same organization peers, to get the information of which is the organization leader of a channel? Too complex?{quote} With our mechanism you don't need this.   ></body> </Action>
<Action id="20320" issue="13868" author="elli-androulaki" type="comment" created="2017-01-10 10:03:11.0" updateauthor="elli-androulaki" updated="2017-01-10 10:03:11.0"> <body><! CDATA Ok, that sounds good then. So the flow would be upon a peer (receipient) receiving a Gossip message from another peer (sender):  Check if the message comes from peer of the same organization using local MSP - If the sender is from the same organization, accept/process the message; this requires that local MSP is *updated by the administrator of that peer as needed*. - If the sender is not from the same organization, check if this is a channel specific message * If a channel specific message, then check if the channel exists locally, i.e., the recipient has joined the channel, or received that channels MSP updates - If the channel exists locally use that channel's MSP to authenticate the sender/message - If the channel does not exist locally, reject the message  * If not a channel specific message **what do we do**? Use all the MSPs across all channels the recipient has been notified for? For evaluating such messages, it could help if the system channel's MSP updates are propagated to peers and verification is done using that list; however, this would be tough given the ordering service would need to selectively reveal messages of the system channel, while at the same time, the peers still need to check if thee MSP of the sender is one their organization has an overlapping channel with (so can be trusted)...    ></body> </Action>
<Action id="20321" issue="13868" author="yacovm" type="comment" created="2017-01-10 11:19:15.0" updateauthor="yacovm" updated="2017-01-10 11:19:15.0"> <body><! CDATA {quote} this requires that local MSP is updated by the administrator of that peer as needed.{quote}  So, this needs to be implemented anyway regardless of gossip.  {quote}If the sender is not from the same organization, check if this is a channel specific message{quote} This isn't a good approach in my opinion, because in gossip we have membership messages and they are non-channel specific, but will have to be validated by the channel's MSP if the message is traveling between organizations.  These membership messages *have* to travel between peers not in the same org in order for peers in the same channel but in different orgs to be able to communicate, and some fabric clients have use cases that require this.  I recommend using the {quote}Use all the MSPs across all channels the recipient has been notified for?{quote} approach in any case the peer isn't in the same org. I think that if there exists an MSP among all channel MSPs that can verify the CA signature on the public key of the remote peer, it's safe to go on and verify the signature on the message itself.  This is because I think it would be logical to assume that the users won't make a root CA divergence situation in which in the same org, two channels would have different root CA sets. If we accept this idea, *any* channel MSP that can verify the signature is good enough and there will be no need of checking against *all* channel MSPs, right?   {quote} For evaluating such messages, it could help if the system channel's MSP updates are propagated to peers and verification is done using that list; however, this would be tough given the ordering service would need to selectively reveal messages of the system channel, while at the same time, the peers still need to check if thee MSP of the sender is one their organization has an overlapping channel with (so can be trusted)...{quote} Can you explain this please? From what I know, there is no system channel.    ></body> </Action>
<Action id="20394" issue="13868" author="yacovm" type="comment" created="2017-01-18 11:57:54.0" updateauthor="yacovm" updated="2017-01-18 11:57:54.0"> <body><! CDATA OK, so we talked and reached the conclusion that we need to replicate not just the MSP itself, but also the principals that are used by the MSP. The easiest way of doing it is simply replication the configuration blocks that contain changed versions of security-related configuration items.  What do you think?  ~ellaki  ,  ~jyellick   ></body> </Action>
<Action id="20395" issue="13868" author="elli-androulaki" type="comment" body="Actually we need to propagate the MSPs, ChannelReaders, and ChannelWriters of a chain / channel. Maybe simpler to propagate config blocks." created="2017-01-18 12:06:04.0" updateauthor="elli-androulaki" updated="2017-01-18 16:33:21.0"/>
<Action id="20396" issue="13868" author="yacovm" type="comment" created="2017-01-18 12:19:46.0" updateauthor="yacovm" updated="2017-01-18 12:19:46.0"> <body><! CDATA Yeah, that's what I said. But- we need to propagate only the configuration blocks that are doing a change in the relevant configuration items, don't you agree? If we have a configuration block that only changes orderer stuff, even though it contains all the info we need, it's a shame to propagate it (IMO).  Or, perhaps we could (for V1) just propagate all config blocks anyway and just selectively apply the changes in the peers if they are needed?  ></body> </Action>
<Action id="20398" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 14:15:34.0" updateauthor="elli-androulaki" updated="2017-01-18 14:17:19.0"> <body><! CDATA So, let me ask a question also to  ~jyellick : do orderers validate re-configuration blocks completely? That is, do they check that configuration items in there are properly signed, and contain valid information?   If so, then we have already a mechanism for authenticating config changes associated to channel MSP configurations. If not, then we would need to implement a txconfig handler for each chain that organization is a member of?   If we go for the gossip propagation mechanism of MSPConfig / policy objects (of channelReaders) then we would need to somehow trust the nodes they are sending this information along. In other words we should trust the gossip fellows of the peer whose MSP image is updated (of the same organization).  What do you think?  ~angelo.decaro ,  ~yacovm ,  ~mastersingh24 ,  ~binhn ?   ></body> </Action>
<Action id="20399" issue="13868" author="elli-androulaki" type="comment" body="And allow me to add if we do this, i.e., have a peer trust all peers that come from the same organization as it, then we may have issues when, e.g., a peer who is revoked, tries to make rest of peers think he is not revoked by transmitting them the wrong MSPConfig (that, e.g., does not include its certificate in CRL)..." created="2017-01-18 14:19:49.0" updateauthor="elli-androulaki" updated="2017-01-18 14:19:49.0"/>
<Action id="20400" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 14:21:48.0" updateauthor="elli-androulaki" updated="2017-01-18 14:21:48.0"> <body><! CDATA > But- we need to propagate only the configuration blocks that are doing a change in the relevant configuration items, don't you agree?  So if we do not have orderers filter out invalid configuration blocks is not clear if the advertised block includes a valid reconfiguration. No?  ></body> </Action>
<Action id="20403" issue="13868" author="yacovm" type="comment" body="hmm, If the peer has an up-to-date MSP, he should be able to verify a block signed by an ordering service, even though it&apos;s not in the channel, right?" created="2017-01-18 14:46:37.0" updateauthor="yacovm" updated="2017-01-18 14:46:37.0"/>
<Action id="20404" issue="13868" author="yacovm" type="comment" body="I recall  ~binhn  said that we shouldn&apos;t focus on byzantine tolerance in the same organization for V1, does this still hold?" created="2017-01-18 14:49:07.0" updateauthor="yacovm" updated="2017-01-18 14:49:07.0"/>
<Action id="20406" issue="13868" author="binhn" type="comment" created="2017-01-18 15:13:05.0" updateauthor="binhn" updated="2017-01-18 15:27:50.0"> <body><! CDATA  ~yacovm  Could you update the description to include what we have agreed so that we don't have to read all the comments.    ~ellaki  ~yacovm  As Jason pointed out, replication of the config block is necessary. Why are you still talking about MSPConfig replication? The config block contain the appropriate sig that no peers could fake, so let's stick with that.  ></body> </Action>
<Action id="20407" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 15:19:43.0" updateauthor="elli-androulaki" updated="2017-01-18 15:19:43.0"> <body><! CDATA So, the thing is that we are supposed to have already revocation in place, that are assumed to compensate for compromised peers. Are we supposed to consider revocation lists only for client certificates and consider peers always honest/non compromised?    ></body> </Action>
<Action id="20408" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 15:21:21.0" updateauthor="elli-androulaki" updated="2017-01-18 15:25:00.0"> <body><! CDATA > hmm, If the peer has an up-to-date MSP, he should be able to verify a block signed by an ordering service, even though it's not in the channel, right?  Well orderers MSPs are advertised as well in each channel as far as  ~jyellick  mentioned. Therefore to validate a channel block, we would need to have an updated (for that channel) version of that channel's MSPs. After this is up to speed then peers could validate blocks that come from that channel.   However, if the ordering service does not check the content of configuration blocks/validity of theirs it is possible that configuration blocks are added to the blockchain that are invalide, e.g., cause it includes outdated config items... There the fact that you have an updated MSP will not help.  ></body> </Action>
<Action id="20410" issue="13868" author="yacovm" type="comment" created="2017-01-18 16:15:06.0" updateauthor="yacovm" updated="2017-01-18 16:15:06.0"> <body><! CDATA  ~binhn  I updated the description in the JIRA story. Posting below anyway for convenience:   ... "Therefore, it makes sense to simply replicate with gossip the configuration block itself, between all peers in the organization. A possible drawback of that is that a peer that doesn't have a configuration block of a channel he is not part of, can't verify the signatures on the block, which are signed by the ordering service (of that channel).  We can simply assert that each peer trusts each peer in its own organization, and this decision would solve this problem. "  ></body> </Action>
<Action id="20411" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 16:26:18.0" updateauthor="elli-androulaki" updated="2017-01-18 16:26:18.0"> <body><! CDATA  ~binhn  correct.   The questions that we were discussing with  ~yacovm  related to : - a peer receives through gossip a config block that is actually a genesis block; would it trusted cause it is signed with the orderer keys that it takes from some other channel? - a peer receives a config block of a channel it has a genesis block of; can he trust that this config block is a valid one or he needs to redo the config block validation like committing peers do and for that receive all config blocks in the same order (using e.g., block sequence number).  ></body> </Action>
<Action id="20412" issue="13868" author="elli-androulaki" type="comment" created="2017-01-18 16:30:09.0" updateauthor="elli-androulaki" updated="2017-01-18 16:30:57.0"> <body><! CDATA And actually we had a longer discussion that relates to orderers and their certificates being possible to be revoked. In CFT systems one ordere signature is enough to validate a block. Thus assuming that we have an orderer who has compromised, till the moment when its identity is revoked/removed from the orderers set, that orderer is behaving byzantine, and  ~marko.vukolic  confirmed that that orderer during that time interval can compromise the system.   Shall we do assume that orderers cannot be compromised/their certificates never invalidated?   ></body> </Action>
<Action id="20414" issue="13868" author="yacovm" type="comment" created="2017-01-18 16:45:45.0" updateauthor="yacovm" updated="2017-01-18 16:45:45.0"> <body><! CDATA {quote}a peer receives a config block of a channel it has a genesis block of; can he trust that this config block is a valid one or he needs to redo the config block validation like committing peers do and for that receive all config blocks in the same order (using e.g., block sequence number).{quote}  We can't do that in gossip, it's impossible. That would require somehow obtaining the entire history of configuration blocks, and that requires persistence.  It's not possible to go in that direction, and it's not gossip-friendly. We can only disseminate the "last" configuration block at each time, and not the entire history of them.  ></body> </Action>
<Action id="20417" issue="13868" author="yacovm" type="comment" created="2017-01-18 16:54:57.0" updateauthor="yacovm" updated="2017-01-18 16:54:57.0"> <body><! CDATA {quote}Shall we do assume that orderers cannot be compromised/their certificates never invalidated? {quote} This is a fair point, and if we embrace this reality then it means that since we can trust the configuration items inside the genesis block (signed by the admin), we could verify the signatures of any other subsequent configuration blocks from the ordering service.  The question is... whether this is a reasonable assumption?  This however, leaves a corner case of concurrent configuration changes that can be invalidated in the peer if it's in the channel, but can't be validated in a peer that's not in the channel  ></body> </Action>
<Action id="20652" issue="13868" author="yacovm" type="comment" created="2017-02-01 19:13:57.0" updateauthor="yacovm" updated="2017-02-01 19:13:57.0"> <body><! CDATA We've decided that an anchor peer will be per channel, and not per organization. So this JIRA item isn't relevant anymore.  ></body> </Action>
