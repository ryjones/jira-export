<Issue id="13868" key="FAB-1459" number="1459" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10002" summary="MSP replication in the gossip layer" priority="3" resolution="10000" status="6" created="2016-12-21 12:49:13.0" updated="2018-07-20 14:11:05.0" resolutiondate="2017-02-01 19:14:00.0" votes="0" watches="5" workflowId="36924"> <description><! CDATA This is a follow-up of  FAB-1394|https://jira.hyperledger.org/browse/FAB-1394   This JIRA issue's task is to define *how* the the MSP is replicated between peers via the gossip.  Recap: In order for peers to validate signatures of peers from different organizations, they need to use channel-scoped MSPs. However, this imposes the following problem: Peers from different organizations that are not in the same channel cannot communicate even though the organizations these peers belong to are part of some common channel.  It was proposed to replicate the MSP between peers of the same organization, so that each 2 peers that are in different organizations could communicate if their organizations belong to some channel.  I proposed the idea below (*), but it's not good enough because we need to replicate not only MSP config, but also principals that are used by the MSP. Therefore, it makes sense to simply replicate with gossip the configuration block itself, between all peers in the organization. A possible drawback of that is that a peer that doesn't have a configuration block of a channel he is not part of, can't verify the signatures on the block, which are signed by the ordering service (of that channel).  We can simply assert that each peer trusts each peer in its own organization, and this decision would solve this problem.   (*)  The item that would be replicated is an item called an *MSPConfig*. It will be an item that would travel between peers in the same organizations, and between such peers *only*. This item is naturally updated when a peer receives a configuration transaction in its chain that updates the channel's MSP. When such an event occurs, the gossip layer inside a peer would know that the MSP has changed and peers that have an older version of that *MSPConfig* would get the newer version from the peers that have that version.  In order for the gossip layer to determine which *MSPConfig* is newer out of a pair of *MSPConfig* objects, the *MSPConfig* could compute an item called *MSPDigest* which is a unique representation of an *MSPConfig*, a *chainID*, and a comparable sequence number (the block sequence number, for example).   The code flow would be something as the following: Orderer--->sends configuration block to the peer and the peer updates the MSPs. Periodically, the gossip layer queries the MSPs of the peer for their recent *MSPDigest* and compares them to *MSPDigest*s of other peers, and if a different is found, it synchronizes the *MSPConfig* items for peers that have an outdated version of *MSPDigest* s. This mechanism already exists in the gossip layer, in order for it to be able to replicate MSPs we just need to define 2 types of messages (the *MSPDigest* and *MSPConfig*) and the mudularity of the code will take care of the rest.  So, I propose the following action: We'll extend https://github.com/hyperledger/fabric/blob/master/gossip/api/crypto.go#L25-L47 With the following things:  // MSPSupervisor governs all MSPConfigs of the peer type MSPSupervisor interface { 	// Deserialize returns an MSPConfig from bytes 	DeserializeMSPConfig(  byte) MSPConfig  	// DeserializeMSPDigest returns an MSPDigest from bytes 	DeserializeMSPDigest(  byte) MSPDigest  	// Verify verifies an MSPConfig. 	// Returns an error on failure, nil on success. 	Verify(MSPConfig) error  	// GetMSPConfig returns an MSPConfig given a channel, or nil 	// if such an MSPConfig isn't found 	GetMSPConfig(common.ChainID) MSPConfig  	// UpdateMSP updates an MSPConfig. 	// Returns an error on failure, nil or success. 	UpdateMSP(common.ChainID, MSPConfig) error }  type MSPConfig interface { 	// GetChannel returns the channel for this MSPConfig 	GetChannel() common.ChainID  	// ToBytes serializes this MSPConfig 	ToBytes()   byte  	// Digest returns a digest representation 	// of a MSPConfig 	Digest() MSPDigest  	// VerifyDigest verifies an MSPDigest. 	// Returns an error on failure, nil on success. 	VerifyDigest(MSPDigest) error }  // MSPDigest is a compact representation of an MSPConfig type MSPDigest interface { 	// ToBytes serializes this MSPDigest 	ToBytes()   byte  	// Returns: 	// n > 0  if given MSPDigest is outdated in comparison to this MSPConfig 	// n < 0  if given MSPDigest is newer than this MSPConfig 	// n = 0  if given MSPDigest is equivalent to this MSPConfig 	Compare(MSPDigest) int }   The gossip component inside the peer would have a single reference to the *MSPSupervisor* given at the initialization, and it'll use the interfaces in order to effectively replicate MSP configurations of various channels by having the peers query each other for digests and send each other *MSPConfig* s and thus update each other's channel MSPs.  These additions would allow the gossip layer to effectively replicate MSPs among peers of the same organization.     ></description> </Issue>
