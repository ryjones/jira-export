<Action id="35574" issue="20844" author="rickr" type="comment" body=" ~denyeart   ~chris.elder   Can you please provide an additional section in the Description on SDK impact?  What specific APIs  (protobuf)  are being altered or added for the SDK to implement ?  Some brief usage scenarios on those APIs ?" created="2017-11-28 16:31:07.0" updateauthor="rickr" updated="2017-11-28 16:31:07.0"/>
<Action id="35575" issue="20844" author="rickr" type="comment" created="2017-11-28 16:37:11.0" updateauthor="rickr" updated="2017-11-28 16:37:11.0"> <body><! CDATA Is the only impact here is when we deploy new CC we need to have the user supply some indices ?  ``` <StateDatabaseImpl>                  <CouchDB>                       <Indexes>                            (IndexName):\{                                  IndexDefinition                            } ```  ></body> </Action>
<Action id="35596" issue="20844" author="jyellick" type="comment" created="2017-11-28 21:33:17.0" updateauthor="jyellick" updated="2017-11-28 21:33:17.0"> <body><! CDATA -1 for the implementation as it stands, although I might be convinced to rescind it.  First, why do we think this is a good candidate for inclusion in the resources tree? I understand that it is scoped per chaincode, but for instance, why could the indices not be specified as part of chaincode installation?  Do we see cases where the indices would differ per channel?  If not, then a channel scoped configuration tree seems like the wrong place to me.  Second, why create 3 additional levels of nesting in groups? In general, groups should be created when there is an obvious change in the scope of management.  For instance, two orgs clearly have different administration requirements, as could two chaincodes, but why would one index be managed separately from another?  If we are convinced the resource tree is the right place for this information (which, I am not at present), I would have simply expected a single config value named {{StateDatabase}} which encodes a proto message with whatever information is required.  ></body> </Action>
<Action id="35603" issue="20844" author="denyeart" type="comment" created="2017-11-29 01:14:10.0" updateauthor="denyeart" updated="2017-11-29 01:14:10.0"> <body><! CDATA Thanks  ~jyellick .  In most cases the queries and corresponding indexes will be known at chaincode authoring time, in which case it would make sense to define the index as part of the chaincode installation (would need to figure out a way to package the index definitions with the chaincode, and a way to access these indexes and deploy them upon channel/chaincode define or instantiation steps).  However in some cases chaincodes will expose an open ended query function where clients (or other chaincodes) can pass in their own queries, which require new indexes to be created after chaincode installation time. Even without this pass-through query function pattern, new indexes that help with performance of known chaincode queries may be found after chaincode installation time.  In these cases there needs to be a way to create new indexes after a chaincode is in production, potentially on a channel by channel basis (but that would not be typical).  Given we now have a channel/chaincode configuration in the resource tree and a corresponding config transaction processor pattern, I thought ability to specify indexes under the channel/chaincode level would be the most flexible way to create indexes, either at chaincode definition/instantiation time, OR later times.   I am open to other ideas however. For example we could require chaincode upgrade each time a new index is required, in which case the indexes could be defined at chaincode installation time (again, would need to figure out a way to package the index definitions with the chaincode, and a way to access these indexes and deploy them upon channel/chaincode define or instantiation steps).   Considering the config groups, the CouchDB layer is there because there may be various state database types which each have different ‘metadata’ requirements (schemas, indexes, etc) that need to be managed during the chaincode lifecycle.  CouchDB indexes is just the first example but there may be other examples in the future (e.g. if we support relational data models, table DDL would need to be defined and managed during the lifecycle).  And under CouchDB group there may be N different indexes that get added at different points in time (per the first paragraph). This being said, I am not an expert on the config tree and if you see simpler ways to achieve these objectives I’d like to understand the options.  ></body> </Action>
<Action id="35636" issue="20844" author="yacovm" type="comment" created="2017-11-29 16:10:23.0" updateauthor="yacovm" updated="2017-11-29 16:11:40.0"> <body><! CDATA I don't think the place to store the indices should be in the config/resource tree(s).   # CouchDB indices are a specific to the peer and not to all peers in the channel, so it doesn't make sense to me that it is managed by the channel.  In the channel state we want to manage things that are common to all peers in the channel, and that relate to business logic metadata like chaincode, and not to infrastructure metadata. # A config transaction poses an overhead. Not sure why we would want to do that? What about organizations that don't have couchDB? They might need to participate in signing and this only makes the process more cumbersome.  # What prevents the peer to manage its indices autonomously? Do we really need human intervention for this? The ledger "sees" all the queries, so can't it somehow ask couchDB for metadata/statistics and order it to build indices according to that?  ></body> </Action>
<Action id="35641" issue="20844" author="denyeart" type="comment" created="2017-11-29 18:07:36.0" updateauthor="denyeart" updated="2017-11-29 18:07:36.0"> <body><! CDATA  ~yacovm   ~jyellick  I think both patterns are valuable and eventually we will want to support both: 1) Lifecycle driven automatic deployment of indexes to all channel members, since the most typical pattern is having well-defined indexes corresponding to a certain chaincode that gets invoked on all peers. 2) Ability to deploy indexes to individual peers - to support other scenarios such as queries that only get executed on a subset of peers.  After discussions with  ~mastersingh24  and  ~ptippett  about what most Fabric hosting services would want to do, the conclusion was that it was most important to have the channel-wide automatic deployment of indexes that could support the chaincode queries on all the peers, rather than having to individually manage indexes on each of the peers (and individually catch up new peers that join the channel in the future with the same indexes).  Option #2 was considered to be a large maintenance issue.  Therefore I wrote up the Jira assuming the lifecycle driven approach as first priority, and indicated that peer managed indexes could be a future work item.  Given that there is dissent, I think we'll want to solicit more feedback from  ~mastersingh24  and  ~ptippett  and others in the community on the relative priority of each approach.  The config tree driven approach has the benefit of no additional maintenance when the indexes are defined along with the chaincode (expected to be the most typical scenario), as well as the ability to add new indexes at a later point in time with a subsequent config transaction (with additional maintenance required on signing the config transaction as  ~yacovm  mentions, but still automatic management across the peers).  ></body> </Action>
<Action id="35661" issue="20844" author="jyellick" type="comment" created="2017-11-30 03:10:38.0" updateauthor="jyellick" updated="2017-11-30 03:10:38.0"> <body><! CDATA To my understanding, it seems like including indices in the resources tree chaincode definition is largely a matter of convenience, rather than correctness.  If there were a different mechanism for bulk peer administration, this proposal very well might have been against this other mechanism.  The resources tree is generally the right place for information if:  # The configuration is needed by all peers # The configuration may be jointly administered # The configuration is channel scoped # The configuration requires total order relative to other transactions  I don't think that db indices really tick any of those boxes.  That being said, I'm not sure where else this information would go, and the resources tree was introduced specifically to provide the same sort of function offered by the channel config tree, but without the overhead associated with it.  Assuming that the indices are typically known when the chaincode is defined for the channel, or at least change infrequently, it seems like this would not be much of a burden, especially if the design were revised to use a single config value, rather than groups nested in groups nested in groups.  One question: You mentioned that including the indices as part of a chaincode install could be possible, and this seemed like the obvious choice to me.  However, it seems that any peer without the chaincode installed would not benefit from the indices?  If the indices are actually only useful to peers with the chaincode, not even to all peers with Couch, then install seems like an even more natural place.  Although already solicited, I'd very much like to hear from  ~mastersingh24  and or  ~ptippett  to make sure that we're all understanding the needs and intent here.  ></body> </Action>
<Action id="35681" issue="20844" author="ptippett" type="comment" created="2017-11-30 17:15:26.0" updateauthor="ptippett" updated="2017-11-30 17:15:26.0"> <body><! CDATA After talking this over a bit with  ~denyeart  my strongest opinion is we should not leave it up to the user to install both the chaincode and the index on their peer because the risk and pain of forgetting to install the index is a big problem.  Any queries would either perform very slowly on that peer or fail altogether.  Given that, I agree that installing the index for them during chaincode instantiation is mainly a matter of convenience, but would be OK with that approach.  I think the main risk here is that a customer will get upset that something was installed on their peer without their consent/knowledge...which is why I believe we moved away from installing chaincode for them on instantiate.  However, I think this is a much lower concern when installing an index since we could choose to not install it if the peer wasn't using couch and it has no real impact, other than a bit of disk space on the peer, until the user installs the chaincode.  Which is still in their control.  Per the last question from   ~jyellick , would the flow here be that the index would not be installed until the user installed the appropriate chaincode on their peer, but would then be done automatically?  If so, this also seems ideal to me since it both gives them full control over when the index gets installed on the peer but also doesn't require them to perform a separate operation.  This would require that we're able to map the index/indices to the appropriate chaincode/version, but I expect we have to do that anyway.  ></body> </Action>
<Action id="35682" issue="20844" author="jyellick" type="comment" created="2017-11-30 17:48:08.0" updateauthor="jyellick" updated="2017-11-30 17:48:08.0"> <body><! CDATA  ~ptippett    {quote} After talking this over a bit with David Enyeart my strongest opinion is we should not leave it up to the user to install both the chaincode and the index on their peer because the risk and pain of forgetting to install the index is a big problem.  {quote}  So my proposal, would be that we make state-database parameters a part of the chaincode package.  In this way, by virtue of installing the chaincode, the peer would also create the DB indices for that chaincode.  No two steps required, and no possibility of forgetting to include them, as they are part of the chaincode package.  The primary drawback here is that:  # The indices must be known at chaincode install time # The indices must be the same for all channels  If we can live with that, it seems like the superior solution to me.  ></body> </Action>
<Action id="35684" issue="20844" author="varadatibm" type="comment" created="2017-11-30 18:54:33.0" updateauthor="varadatibm" updated="2017-11-30 18:54:33.0"> <body><! CDATA The nice thing with packaging the index with chaincode, is all users should/would use the same package and get the same index that matches the chaincode.   But if they forget to add index (or update index), would the user need to install and update the new chaincode on all affected channels? Is there any benefit in adding capability to update the index after the install/instantiate step so that the user doesn't have to go through the install/instantiate|update step on affected channels?  ></body> </Action>
<Action id="35720" issue="20844" author="denyeart" type="comment" created="2017-12-01 15:32:33.0" updateauthor="denyeart" updated="2017-12-01 15:38:31.0"> <body><! CDATA Let’s split the CouchDB indexes into two categories: - Default indexes required to support chaincode queries (known at chaincode dev time, relevant for all channels and all endorsing peers) - Additional indexes to support free form queries or to further optimize performance (potentially peer-specific).  The first priority is the default indexes, but ultimately we’ll need both.  The default index use case checks off most of the criteria that Jason mentioned for resource tree configuration - all peers in the channel should automatically attempt to deploy the default indexes upon chaincode definition/instantiation (Jason’s criteria 1-3),  and any peer without CouchDB will skip the index deployment. Peers not expected to be endorsers generally would not have the chaincode installed and would not utilize CouchDB, therefore this approach would ensure indexes are automatically deployed to all peers intended to be CouchDB endorsing peers (even if the chaincode is not yet installed).  This approach would also enable creation of new indexes for a chaincode at later points in time.  The resource tree configuration is not a perfect fit however, the total order criteria does not fit the index use case, and in fact would be awkward for peers joining the channel later, as there is no need to replay all the index create and index drop events in the ordered sequence. Additionally, there would be no ability to specify peer-specific indexes in the future.  The chaincode install approach is also not a perfect fit. Take for example a peer that did not have the chaincode installed upon chaincode definition/instantiation on the channels.  Say you want to install the chaincode at a later point in time.  The install admin action is channel-less however, and therefore upon install you’d be left in a state where the peer should now be an endorser on the channels but doesn’t have the channel_chaincode database indexes in place to support endorsements.  We could have the install step automatically iterate through all the peer’s channels and create the database indexes on any channel where the chaincode is already defined, but this would be a fundamental change to the scope/intent of chaincode install admin action.  Additionally, there would be no ability to create new channel-wide indexes at a later point in time, and no ability to specify peer-specific indexes in the future.  While I was trying to avoid injecting a new manual lifecycle step at the channel/chaincode/peer level in 1.1 timeframe, it appears that we will in fact need one.  Let me propose this approach:  *For Default indexes required to support known chaincode queries*  Define default indexes in chaincode source directory (e.g. a couchdb_<index_name>.index file per required index). These get packaged up into chaincode installation package. After chaincode is both defined on channel and installed on peer, you can deploy the indexes to the peer's channel_chaincode state database with the command: {noformat} peer statedb deploy-chaincode-indexes -C <channel> -n <chaincode> {noformat}  The same indexes may be included in subsequent chaincode version packages. If there are no new indexes, deploy-chaincode-indexes will not have to be re-run for each chaincode version (since state database spans chaincode versions), although re-execution would cause no harm, it would simply be a noop.  If indexes have been added in subsequent chaincode version packages, running deploy-chaincode-indexes for the new chaincode version will ensure new indexes are deployed. Indexes will not be automatically dropped, as peer-specific indexes may have been added and may still be required, but they may be dropped individually (see next section).  *For Additional indexes to support free form queries, or to further optimize performance after chaincode installation time (potentially peer-specific).*  Create a new index on peer’s channel_chaincode state database: {noformat} peer statedb create-index -C <channel> -n <chaincode> <index_definition> {noformat}  Drop an index from peer’s channel_chaincode state database: {noformat} peer statedb drop-index -C <channel> -n <chaincode> <index_name> {noformat}  ></body> </Action>
<Action id="35727" issue="20844" author="manish-sethi" type="comment" created="2017-12-01 16:48:14.0" updateauthor="manish-sethi" updated="2017-12-01 16:48:14.0"> <body><! CDATA I would go even a step further to say that we should think of some general approach to let the admins use the operations on couchdb directly.  Index creation is just one operation. Bulk of monitoring and performance tuning operations that couchdb offers may be needed from time to time and it could be overwhelming to think of supporting all of couch management functionality via peer commands. Equally would be confusing in the future to allow a few of the things via peer command and for others we would need them to access couchdb directly.  Also, if we start supporting another db (and versions of those..), it's hard to imagine we catching up providing all the management operations for those via peer commands.  I like the idea of bundling the default index definition within chaincode package. But based on my above views, I would limit the peer command to let the admin get the access to the idex-definition file and then let them use the couchdb management interface.  Off course, for letting the admins access the couchdb management, we will need to provide them a secure proxy or access via local machine only.  ></body> </Action>
<Action id="35745" issue="20844" author="mastersingh24" type="comment" created="2017-12-02 10:37:09.0" updateauthor="mastersingh24" updated="2017-12-02 10:47:39.0"> <body><! CDATA  ~denyeart   I don't understand what you mean by "peer specific".  If you mean allowing people who want to *directly* query CouchDB (or any other state database) without going through the peer, then I agree with  ~manish-sethi  that in those cases users should just operate directly against CouchDB.  The main issue we are trying to solve is ensuring that indexes which are required for any state data access via chaincode are "installed" across all peers without the admin for each individual peer needing to do this themselves - meaning we must have a distribution mechanism for this.    If we assume that for *production* deployment of chaincode that one knows all of the required indexes (derived via testing and knowing the queries embedded in the chaincode) and that the only reason to add/remove indexes would be when chaincode is updated, then essentially including "ddl" in the chaincode package itself seems sensible.  Further, I see no reason to do anything else at this point - at least for v1.1 (meaning we *must not* implement any of the "peer statedb ..." stuff.  P.S.   FWIW, I actually do believe that indexes are actually a good fit for the resource config because to me indexes are not another type of policy that needs to be distributed and attached to chaincode.  But if the packaging mechanism is the preferred method, then so be it.  ></body> </Action>
<Action id="35748" issue="20844" author="denyeart" type="comment" created="2017-12-02 16:04:23.0" updateauthor="denyeart" updated="2017-12-02 21:15:50.0"> <body><! CDATA  ~mastersingh24  By “peer specific” I mean indexes could be managed on individual peers.  For example if there is an auditor peer and audit queries are only ever performed on this peer, then the corresponding indexes to support audit queries (either via direct couchdb queries or via queries passed through chaincode) could be deployed on that peer only.  The “peer statedb” proposed commands create-index and drop-index are peer specific to handle these types of situations.  Similarly, the “peer statedb” deploy-chaincode-indexes command would be a peer specific command to deploy the indexes on a peer’s channel_chaincode database, for those scenarios where automatic index management is not desired.  This command would be called for each channel immediately after the “peer chaincode install” command, which has provided the peer with the chaincode installation package that includes the default index definitions for that chaincode.  The “peer statedb” proposed commands give each peer’s administrator full control of the index management.  But like  ~manish-sethi  has said, we’ll want administrators to have a way to manage indexes directly against CouchDB regardless, rather than through peer commands.  And like  ~mastersingh24  has said we’ll want an option for the default chaincode indexes to automatically be deployed.   This can be achieved through a peer (core.yaml) config setting like *peer.ledger.state.couchDBConfig.autoDeployChaincodeIndexes*.    With *peer.ledger.state.couchDBConfig.autoDeployChaincodeIndexes* set to true:  - If chaincode is already defined on peer’s channels at the time of chaincode install, the install step would iterate through the peer’s CouchDB channel_chaincode databases and automatically deploy the default chaincode indexes that are included in the chaincode installation package.  This complicates the install step (e.g. chaincode installation may succeed but create indexes may fail, which is why I was suggesting the “peer statedb” commands as a way to fix the indexes as needed). - If chaincode gets defined (or upgraded) on the resource config tree for one of the peer’s channels after the time of chaincode install, the channel_chaincode database indexes would be automatically deployed upon processing the chaincode config transaction.  Note that this would be the same trigger for creating the channel_chaincode database.  That is, the statedb database resources would be setup automatically as soon as the chaincode resources are defined on a channel, in preparation for subsequent instantiation(Init) and Invokes.  This approach preserves an option to manage indexes completely manually in CouchDB, as  ~manish-sethi  has suggested. This would likely be even more important for other types of state databases, for example if support is added for relational databases, most peer administrators would likely want table and index DDL to be executed manually by a DBA rather than automatically.  But for CouchDB indexes I think automatic deployment would be an acceptable (and preferred) default in most scenarios.  The “peer statedb” command line options can be deferred from 1.1 as  ~mastersingh24  suggests, assuming hosting services have a way to fix chaincode indexes (and create new indexes on behalf of consumers) directly against CouchDB.  I think any hosting service will need a way to service/manage CouchDB directly regardless, so this should not be a new requirement.  ~ptippett   ~varadatibm .  ></body> </Action>
<Action id="35752" issue="20844" author="mastersingh24" type="comment" created="2017-12-02 21:56:46.0" updateauthor="mastersingh24" updated="2017-12-02 21:56:46.0"> <body><! CDATA Thanks for the detailed response  ~denyeart .  WRT the  *“peer statedb” command line options*, I think this is actually two features / requirements: 1) the peer needs to expose an API for managing chaincode indexes 2) optionally add the ability to call this command from the "peer cli"  I think trying to do 1) if possible makes sense.  I don't think we should necessarily do 2) as we simply need to stop adding things to the "peer cli" and rather we need to actually create a proper "fabcli" post 1.1.    ></body> </Action>
<Action id="35768" issue="20844" author="denyeart" type="comment" body="Ok, I have written up the review comments in a cleaned up Description in FAB-3067. We&apos;ll use FAB-3067 for any remaining design comments as well as for implementation." created="2017-12-04 11:25:41.0" updateauthor="denyeart" updated="2017-12-04 11:25:41.0"/>
