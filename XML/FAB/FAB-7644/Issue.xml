<Issue id="26652" key="FAB-7644" number="7644" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10003" summary="Generalize deliver API handler" priority="3" resolution="10000" status="6" created="2018-01-08 00:04:28.0" updated="2018-07-20 14:15:23.0" resolutiondate="2018-01-10 16:53:22.0" votes="0" watches="2" workflowId="40909"> <description><! CDATA Currently the implementation of {{Deliver}} API of {{AtomicBroadcast}} service implemented by means of   {code} // Handler defines an interface which handles Deliver requests type Handler interface { 	Handle(srv ab.AtomicBroadcast_DeliverServer) error } {code}  defined in  `deliver.go`|https://github.com/hyperledger/fabric/blob/master/common/deliver/deliver.go#L48   {code} // Handler defines an interface which handles Deliver requests type Handler interface { 	Handle(srv ab.AtomicBroadcast_DeliverServer) error } {code}  which is specific to {{ab.AtomicBroadcast_DeliverServer}}, while required functionality is:  {code} 	Send(*DeliverResponse) error 	Recv() (*common.Envelope, error) {code}  where   {code} 	Send(*DeliverResponse) error {code}  specific to the definitions of `ab.proto`, e.g.:  {code} message DeliverResponse { oneof Type { common.Status status = 1; common.Block block = 2; } } {code}  The above could be abstracted such that it won't be specific to the `ab.proto` definitions and as a consequence would be abstract enough and generalized in way that will enable reuse in peer code.  It's possible to define general interface that will encapsulate required functionality  {code} type DeliverSupport interface { 	Recv() (*cb.Envelope, error) 	Context() context.Context 	CreateStatusReply(status cb.Status) proto.Message 	CreateBlockReply(block *cb.Block) proto.Message } {code}  proposed interface is general enough and would be possible to reuse for service interface defined for different package.  ></description> </Issue>
