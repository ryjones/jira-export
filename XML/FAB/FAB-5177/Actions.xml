<Action id="27859" issue="18958" author="sstone1" type="comment" created="2017-07-05 11:07:19.0" updateauthor="sstone1" updated="2017-07-05 11:07:19.0"> <body><! CDATA Couple of comments from me:  1) is there any impact to existing applications installing chaincode using the Node.js SDK? Is this auto-vendoring feature (which seems to have snuck in at some point recently) enabled for both the Node.js SDK and the peer CLI?  2) assuming the answer to 1) is no impact, then I don't object to it but it seems a big change to sneak into the 1.0 final release, so are you considering cutting an 1.0 rc2 to iron out any problems that may arise from this change?  ></body> </Action>
<Action id="27902" issue="18958" author="fbenhamo" type="comment" created="2017-07-05 21:50:25.0" updateauthor="fbenhamo" updated="2017-07-05 21:50:25.0"> <body><! CDATA Actually, including shim in fabric-ccenv also enables another optimization (in addition to space optimization): pre-compilation of the hyperledger libraries: https://jira.hyperledger.org/browse/FAB-4947  On the other side, we had issues with the fact that GRPC is vendored inside github.com/hyperledger/fabric, as it prevents a chaincode to use GRPC (it is not possible to load twice the GRPC package: once from github.com/hyperledger/fabric/vendor and once from the chaincode vendor directory:  https://github.com/grpc/grpc-go/issues/566 ). One solution might to be "unvendor" all the denpendencies of github.com/hyperledger/fabric, in fabric-ccenv. For our application, we've actually added the following line to the Dockerfile of fabric-ccenv: {code:java} RUN cp -R $GOPATH/src/github.com/hyperledger/fabric/vendor/* $GOPATH/src && rm -rf $GOPATH/src/github.com/hyperledger/fabric/vendor{code}  ></body> </Action>
<Action id="27903" issue="18958" author="greg.haskins" type="comment" created="2017-07-05 22:13:25.0" updateauthor="greg.haskins" updated="2017-07-05 22:13:25.0"> <body><! CDATA  ~sstone1  Auto-vendoring did not just sneak in.  It was introduced as CR 6991 ( https://gerrit.hyperledger.org/r/#/c/6991)  in early March and was merged in early June, making it probably one of the most long running and presumably heavily considered proposals Fabric has had to date.  Auto-vendoring feature is not yet ported to NodeSDK.  I am also of the opinion that it should not be.  Rather, we should strive for single-tool workflows (e.g. peer-package and chaintool package) that the SDKs may consume rather than having them re-invent the logic in each SDK.  As far as impact, if the SDKs are structured to consume the "peer package" output already, then really the only impact is to drive workflows away from the native SDK package flows.  Chaintool-package is already supported in node-sdk.  As far as impact, code impact is minimal.  UX impact is larger.  However that isn't the point.  The point is the current code might very well be broken/fragile.  So the question is: fix it now while we technically can, or risk having to fix it later (after v1.0 GA) when ABI breakage is much more serious/ill-advised.  So while I appreciate the notion of being conservative here, we can't evaluate the risk in a vacuum.  There is risk to _not_ doing something now too, and I would argue that my current analysis is that the risk is greater to leave it the way it is.  And to be clear, I am not the one rushing the RC/GA out the door.  I am fine with letting things bake a little longer (e.g. -rc2, etc).  I just dont want us to find that the ABI we shipped in v1.0 GA is broken, so I am raising this now (better late than never).  ></body> </Action>
<Action id="27904" issue="18958" author="greg.haskins" type="comment" body="I should also add: auto-vendoring isn&apos;t the problem.  The problem is that trying to provide some of the dependencies in ccenv is fragile, at least w.r.t. the interfaces that the shim surfaces to the chaincode app (e.g. timestamp).  You would hit this problem, for instance, even if the application manual vendors its own deps (rather than using the auto-vendoring)" created="2017-07-05 22:17:19.0" updateauthor="greg.haskins" updated="2017-07-05 22:17:19.0"/>
<Action id="27905" issue="18958" author="greg.haskins" type="comment" created="2017-07-05 22:31:44.0" updateauthor="greg.haskins" updated="2017-07-05 22:32:50.0"> <body><! CDATA  ~fbenhamo  I am not sure the compile-time optimization is worth fragility, even if it were substantial in reducing compilation time.  That said, we would also need to quantify exactly what kind of speed up it offers to even begin to evaluate whether it's worth it.  If that is what was done as part of FAB-4947, I'll take a look, but generally speaking, "fast and broken" is in no one's best interest other than benchmarkers ;)  Regarding exploding vendored deps: This was actually my first approach when I first devised CR 6991 as a solution to the previous "pack the entire GOPATH" that we used to do.  It ended poorly.  Turns out, exploding the deps causes even more conflict than retaining per-package vendoring (which is how it works today).  So, I suspect that idea is a non-starter, but someone is welcome to revisit things.  Regarding GRPC problem: I understand what you are saying here, but I would also point out that a chaincode that is trying to GRPC is probably broken to begin with (non-determinism etc).  We are currently permissive enough in the container that this could technically work, but its a bad idea IMO and should probably be locked down eventually.  In the end, I still think the most conservative thing to do is to simply stop playing games with optimizing the ccenv.  Just declare that the app must include all of its deps, and adjust the packagers (peer-package, chaintool-package) to help.  We can get fancy for v2.0 when we sort out how to manage godeps better.  ></body> </Action>
<Action id="27906" issue="18958" author="sstone1" type="comment" created="2017-07-05 23:48:57.0" updateauthor="sstone1" updated="2017-07-05 23:48:57.0"> <body><! CDATA  ~greg.haskins  I think this is what you're suggesting the install process looks like for applications using the Node.js SDK with these changes:  Option 1) the application must itself vendor both the Fabric shim and all required dependencies, before the application can use the Node.js SDK to submit an install request to the peer (by sending a directory of Go chaincode).  Option 2) the application must use the "peer package" command to vendor both the Fabric shim and all required dependencies, before it can use the Node.js SDK to submit an install request to the peer (by sending the packaged chaincode).  Am I right in my understanding?  Does the vendored Fabric shim need to match up with the exact version of the Fabric peer that it is being installed on? Would you support a v1.0 vendored shim being deployed to a v1.1 peer? If not, that is a problem being put back onto the application as per Fabric v0.6 for both option 1) and 2), where the application has to know which version of Fabric it is deploying to and vendor the right version - which was nicely solved by having the chaincode base image preinstalled with the right version.  ></body> </Action>
<Action id="27908" issue="18958" author="greg.haskins" type="comment" created="2017-07-06 01:59:00.0" updateauthor="greg.haskins" updated="2017-07-06 02:01:22.0"> <body><! CDATA  ~sstone1  Regarding option (1):  I would state it as follows:  Before this proposed change, the application today must vendor all of its dependencies _except_ the shim.  After this proposed change, the application must vendor all of its dependencies _including_ the shim.  Option 2 is the same both before and after this proposed change.  Regarding version matching question:  It's important to point out that this proposal is actually drastically _improving_ the ABI compatibility scenario you are asking about.   I say this because we would be moving from relying on a golang interface (the shim and peripheral deps like timestamp) as our ABI and moving it to a protobuf/grpc managed abstraction (the TLS+GRPC connection to the peer).  It should be noted that protobuf/grpcs are designed explicitly to support forwards/backwards ABI management.  Golang interfaces (as are most languages an API would be built with) are decidedly not structured this way and would require explicit management by us, the maintainers to monitor/control changes.  Consider, for example, a new field added to a structure exposed via the shim in a hypothetical v1.1 release.  If you code your chaincode to the v1.1 shim and then deploy it to a peer network that still contains ccenv v1.0, blamo, it wont compile.  Contrast that to a GRPC model where we add a new field to the chaincode/peer .proto in v1.1.  Applications that were compiled against v1.0 (regardless of which side we are talking about) will safely ignore the extra field in the wire protocol.  Applications that were compiled with v1.1 will see the default value for the field when communicating with a v1.0 counterparty, etc.  So to answer your question directly, not only would this proposal "support a v1.0 vendored shim being deployed to a v1.1 peer", it would be really hard/error-prone to support this _without_ this proposal.  ></body> </Action>
<Action id="27909" issue="18958" author="greg.haskins" type="comment" body=" ~mastersingh24  In addition to the conflicts you are researching with the timestamp interface, it should be noted that things like BCCSP seem to suffer from a similar fate as GRPC noted above by  ~fbenhamo .  This could have implications for chaincode applications that need to do crypto operations like signature verifications, etc.  It is these potential conflicts that concern me the most, because I think doing real crypto will be one of the first things people do once the underlying platform is stabilized and we move beyond toy applications." created="2017-07-06 02:09:45.0" updateauthor="greg.haskins" updated="2017-07-06 02:09:45.0"/>
<Action id="27927" issue="18958" author="mastersingh24" type="comment" created="2017-07-06 09:46:49.0" updateauthor="mastersingh24" updated="2017-07-06 09:46:49.0"> <body><! CDATA I think it it too late in the game to make this change.  There are so many tests across the various components (especially the SDKs) which don't vendor the shim at this point.  I'd suggest that we fix FAB-4883 (  https://gerrit.hyperledger.org/r/#/c/10967/  is a start) and either modify the current CR or create another where we modify the package / install command to actually not filter out shim and protos/peer.  We should also update the documentation to *strongly* recommend that people vendor *all* chaincode dependencies.  ></body> </Action>
<Action id="27933" issue="18958" author="greg.haskins" type="comment" created="2017-07-06 11:38:44.0" updateauthor="greg.haskins" updated="2017-07-06 11:38:44.0"> <body><! CDATA "Too late" is not relevant if the system is broken.  Broken would include the inability to use things like the timestamp or crypto features.  Here's what i suggest.  1) confirm these are indeed broken by adding a chaincode UT that uses them. 2) assuming they are broken, see if stuffing a vendored shim into the package solves the problem despite the dep being available in the ccenv. 3) if yes, we solve this issue by leaving ccenv as is, removing the "provided" filter in the packager, updating the doc as @Gari suggested, call it a day. 4) if no, regroup and discuss alternate strategies.  ></body> </Action>
<Action id="27934" issue="18958" author="weeds" type="comment" created="2017-07-06 12:27:53.0" updateauthor="weeds" updated="2017-07-06 12:27:53.0"> <body><! CDATA Gari Singh posted this in rocket chat- so I wanted to add this as comment in JIRA:  As far as I can tell, the only package we seem to have an issue with is `{{github.com/golang/protobuf/ptypes/timestamp}}` To be clear, what I am doing is actually "vendoring" all other dependencies within my chaincode package (that is - I'm not using the `{{peer chaincode package}}` to handle my dependencies for me) In order to explicitly import and use `{{github.com/golang/protobuf/ptypes/timestamp}}`, I'm force to vendor `{{github.com/hyperledger/fabric/core/chaincode/shim}}` as well as `{{github.com/golang/protobuf/ptypes/timestamp}}     {{Greg Haskins then responded with the following: As an experiment could you remove the "provided" filter from the packager and see if that vendors the shim in a similar way? }}  ></body> </Action>
<Action id="27943" issue="18958" author="greg.haskins" type="comment" created="2017-07-06 14:22:49.0" updateauthor="greg.haskins" updated="2017-07-06 14:22:49.0"> <body><! CDATA @Gari another consideration here is also the point I made above w.r.t. ABI.  I think we are in a much stronger position for managing this by requiring that the apps bundle the shim and using protobufs to manage the variance.  Thoughts?  On a slight tangent to all this, we should probably start to bundle .s files in addition to .go/.c/.h. I think there is a JIRA for this already  ></body> </Action>
<Action id="27957" issue="18958" author="mastersingh24" type="comment" body="On the ABI front, yeah  - make sense.  That&apos;s the main reason I wanted to document a recommendation to vendor the shim" created="2017-07-06 16:34:17.0" updateauthor="mastersingh24" updated="2017-07-06 16:34:17.0"/>
<Action id="28005" issue="18958" author="mastersingh24" type="comment" body="It&apos;s going to be hard to add a unit test for actually vendoring the shim, but Murali and I did a bunch of tests and were able to handle all cases with the current ccenv" created="2017-07-07 13:03:23.0" updateauthor="mastersingh24" updated="2017-07-07 13:03:23.0"/>
<Action id="28006" issue="18958" author="jonathanlevi" type="comment" created="2017-07-07 13:05:22.0" updateauthor="jonathanlevi" updated="2017-07-07 13:05:22.0"> <body><! CDATA Looked closely into these (including the exchanges with Murali on the maintainers channel, etc.) I believe we should lower the priority of this ticket, and am not sure whether we should make such a change at this point.   ~mastersingh24 ,  ~muralisr ,  ~greg.haskins : Are we OK with documenting the recommendation to vendor the shim? Do we want to put this up for a vote? Please advise.  ></body> </Action>
<Action id="28007" issue="18958" author="greg.haskins" type="comment" created="2017-07-07 13:06:34.0" updateauthor="greg.haskins" updated="2017-07-07 13:06:34.0"> <body><! CDATA  ~mastersingh24  I was just thinking that the test has to invoke the packager logic and install/instantiate the deployment payload.  Am I missing something?  I thought we do this already.  Anyway, w.r.t. to your findings, please provide details.  ></body> </Action>
<Action id="28009" issue="18958" author="greg.haskins" type="comment" created="2017-07-07 13:16:00.0" updateauthor="greg.haskins" updated="2017-07-07 13:16:00.0"> <body><! CDATA  ~JonathanLevi  I would suggest to approach this not from "should we make this change now?" to  1) Is there a problem?  E.g. can we deploy chaincode that uses things like timestamp or any of the relevant crypto features if it intersects with the stuff that was already preloaded within ccenv  2) If (1) == no, drop issue and move on.    3) If (1) == yes, can it be fixed by simply ignoring the stuff pre-loaded in the ccenv and using a vendoring technique (both doc and packager changes).  4) If (3) == yes, does promoting an ABI that both includes and discourages the use of the pre-included shim make sense?  5) If (4) or (3) == no, decide to fix before release or take chances with release as is.  IOW: I think we need to stop thinking of it as "how risky is the change" and instead think of it as "is this required or not".  Because if it's required and we cut v1.0....that's bad.  ></body> </Action>
<Action id="28010" issue="18958" author="mastersingh24" type="comment" created="2017-07-07 13:34:35.0" updateauthor="mastersingh24" updated="2017-07-07 13:34:35.0"> <body><! CDATA  ~greg.haskins   100% agree - that's why I went through all the trouble of making sure that we can meet all potential chaincode use cases with what we have today.  As far as I could could tell - which included testing any of the key functions we expose in chaincode today - there were no issues we could not solve.  Also tested that we can indeed vendor the shim with no issues.  Govendor does a very nice job of flattening vendored dependencies which is what makes most of this work.  ></body> </Action>
<Action id="28016" issue="18958" author="binhn" type="comment" created="2017-07-07 14:28:38.0" updateauthor="binhn" updated="2017-07-07 14:28:38.0"> <body><! CDATA I am summarizing the chat on #fabric-maintainers so that we can document this issue.   ~greg.haskins  It looks like the result is 1 = yes; 3 = yes; 4 = yes (IMO see below)  The result of testing so far, including many other packages in ccenv such as BCCSP, proto, msp, etc, the only time we run into problem is with Timestamp, and only in a specific usage as following:  {{   var ts *timestamp.Timestamp}} {{   ts, _ = stub.GetTxTimestamp()}}  The explicit declaration of variable of Timestamp would require vendoring the chaincode shim to avoid conflict.  But the above code can easily be replaced with implicit declaration to avoid vendoring the chaincode shim:  {{   ts, _ := stub.GetTxTimestamp()}}   This is the reason I think 4=yes, and we can document this.  ></body> </Action>
<Action id="28029" issue="18958" author="greg.haskins" type="comment" created="2017-07-07 16:20:36.0" updateauthor="greg.haskins" updated="2017-07-07 16:21:01.0"> <body><! CDATA  ~binhn  thank you to all for doing the legwork on quantifying the scope of the problem and solutions.    I get that you are voting to leave the shim in the ccenv.  It's not clear if you are advocating that we solve the problem simply by documenting how to use the timestamp interface properly, or if we advocate that we vendor the shim with chaincode (by updating the doc/packager).  Please clarify.  An additional point to consider is that we also need to make a decision regarding the question of ABI compatibility management.  I am less concerned here for chaintool-based flows, since chaintool/CAR already has the notion of a platform type/version that I can use to manage changes in the shim/ccenv going forward.  For vanilla golang chaincode, however, we still need to consider the ramifications for scenarios such as shim:v1.1 based chaincode being deployed to a peer:v1.0 fabric network.  I still think the more reasonable way to handle this may be to have the chaincode vendor the shim and use protobufs to manage the differences.    Assuming there is agreement on this, the questions then becomes "what is the value of leaving the shim in the ccenv".  Pros: # Existing tests that assume the shim is included continue to work # Existing user applications that rely on the included shim will continue to work  Cons: # If we advise against relying on the included shim but provide it anyway, it could be confusing. # Apps that work today may not work tomorrow as the fabric network (and ccenv that goes with it) change past v1.0 # We should put some ABI management processes in place (CI, etc) to ensure this remains compatible going forward (or at least alerts us when it isn't).  Thoughts?     ></body> </Action>
<Action id="28037" issue="18958" author="binhn" type="comment" created="2017-07-07 22:01:12.0" updateauthor="binhn" updated="2017-07-07 22:01:12.0"> <body><! CDATA  ~greg.haskins  {quote}I get that you are voting to leave the shim in the ccenv.  It's not clear if you are advocating that we solve the problem simply by documenting how to use the timestamp interface properly, or if we advocate that we vendor the shim with chaincode (by updating the doc/packager).  Please clarify. {quote} Yes, I am advocating to doc the issue with Timestamp and recommend the preferred method (implicit declaration) to avoid vendoring the chaincode shim.         ></body> </Action>
<Action id="28049" issue="18958" author="greg.haskins" type="comment" created="2017-07-09 12:33:11.0" updateauthor="greg.haskins" updated="2017-07-09 12:33:11.0"> <body><! CDATA  ~binhn   {quote}Yes, I am advocating to doc the issue with Timestamp and recommend the preferred method (implicit declaration) to avoid vendoring the chaincode shim. {quote}  Ok.  What are your thoughts on the ABI comments however?  I still argue that relying on the shim in the ccenv is a weaker, more fragile model.  How would we plan to manage/monitor this interface for compliance?   ></body> </Action>
<Action id="28050" issue="18958" author="muralisr" type="comment" created="2017-07-09 13:56:07.0" updateauthor="muralisr" updated="2017-07-09 14:05:16.0"> <body><! CDATA  ~greg.haskins  I think having the shim provided for in the golang package has a couple of advantages * every user does not have to include the shim (mainly, convenience and  usability) * by having the fabric would provide shim, we preventing users from mixing an incompatible shim  One thing we *could* do is make it more compatible with car and javaenv (and other future platforms) by removing the shim from ccenv and putting it into a golang image. ie, replace    {code:java} builder: $(DOCKER_NS)/fabric-ccenv:$(ARCH)-$(PROJECT_VERSION)  golang: # golang has shim in golangenv runtime: $(BASE_DOCKER_NS)/fabric-golangenv:$(ARCH)-$(BASE_VERSION)  car: # car may need more facilities (JVM, etc) in the future as the catalog # of platforms are expanded.  For now, we can just use baseos runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION)  java: # This is an image based on java:openjdk-8 with addition compiler # tools added for java shim layer packaging. # This image is packed with shim layer libraries that are necessary # for Java chaincode runtime. Dockerfile:  | from $(DOCKER_NS)/fabric-javaenv:$(ARCH)-$(PROJECT_VERSION)  {code}  Currently it looks like this  {code:java} ... golang: # golang will never need more than baseos runtime: $(BASE_DOCKER_NS)/fabric-baseos:$(ARCH)-$(BASE_VERSION) ... {code}  Given this change is not a removal of shim but more a rearrangement consistent with other platforms, I'd vote for doing it post 1.0 (if agreed to of course).  What do you think ?  ></body> </Action>
<Action id="28053" issue="18958" author="greg.haskins" type="comment" created="2017-07-09 14:54:39.0" updateauthor="greg.haskins" updated="2017-07-09 14:54:39.0"> <body><! CDATA  ~muralisr  {quote}by having the fabric would provide shim, we preventing users from mixing an incompatible shim {quote} The issue that I see is that isn't really accurate. What have three components (peer, shim, and chaincode) and two ABI contracts (the GRPC interface between the shim and peer and the GOLANG interface between the chaincode and shim. Ala.  !abi-contracts.png|thumbnail!  We can only tightly couple one of those contracts. So there's really no "prevention" of version disparity here. There is only the manner in which we manage variance when it inevitably occurs down the road. What I am arguing is that its easier to tightly couple the GOLANG contract and loosely couple the GRPC contract, rather than the other way around, since GRPCs/protobufs were designed precisely to do this. With the GOLANG option, we are on our own and there are a million subtle/non-obivous things that can creep in to an interface of this nature if we are not careful. Part of being careful here really requires an automated, CI driven process. We don't have that yet and likely won't in time for v1.0. Furthermore, the question also becomes that even if we can perfectly execute ABI compatibility monitoring on the current shim, are we ready to commit to not breaking that interface for some LTS-style window of time? The answer could be "yes", but I am skeptical.  Now to your second point: Note that the shim needs to be in the "builder" image, not the runtime. That said, another way we could handle this (and the direction I have been trying to steer us towards) is the notion of a ccenv that is coupled to a chaincode compatibility rather than the peer version. IOW, rather than implicitly having peer vX.Y.Z use ccenv vX.Y.Z, we should have the chaincode dictate what platform it needs. This is precisely what I was driving for in the notion of a "platform specifier" in chaintool ( http://fabric-chaintool.readthedocs.io/en/latest/platforms/golang/#platform-specifier ).  In this model, the chaincode deployment package may dictate what container is used to compile it (albeit indirectly) if we allow it to declare some kind of platform specifier. CAR does this today as per above. However, until CAR becomes the universal/canonical format, the others GOLANG/JAVA/etc would need a similar notion. I fully support driving towards this, but I don't think it will be ready for 1.0.  Therefore, my thought process is: # We conservatively require the bundling of the shim in chaincode for v1.0 ABI # In the future, we adopt some kind of platform-specifier specification in the deployment payloads # In the future, we adopt peer modifications to react to the platform specifiers and utilitize the appropriate container (e.g. peer v1.1 uses ccenv:platform-1 for "platform 1" chaincode and ccenv:platform-2 for "platform-2" chaincode, etc. # Payloads that lack a platform specifier are assumed to be v1.0 ABI compliant.  Thoughts?  ></body> </Action>
<Action id="35444" issue="18958" author="denyeart" type="comment" body=" ~greg.haskins   ~mastersingh24   ~muralisr  I&apos;m changing this one from Bug to Improvement.  Change back if you disagree.  And if there are updated thoughts please provide." created="2017-11-27 03:40:11.0" updateauthor="denyeart" updated="2017-11-27 03:40:27.0"/>
<Action id="50910" issue="18958" author="mastersingh24" type="comment" created="2018-09-21 10:01:45.0" updateauthor="mastersingh24" updated="2018-09-21 10:01:45.0"> <body><! CDATA Not sure if we can get this in for 1.4 but we definitely need to do this.  It is becoming a big problem.  Of course we also need to move the actual chaincode dependencies out of the fabric repo and break the link between fabric and chaincode  ></body> </Action>
<Action id="56052" issue="18958" author="denyeart" type="comment" body=" ~sykesm  I&apos;ve linked this to the Epic you created FAB-12246. Up to you whether you want to refactor/comment in this Jira or close in favor of another in FAB-12246." created="2019-01-23 01:54:43.0" updateauthor="denyeart" updated="2019-01-23 01:54:43.0"/>
<Action id="59047" issue="18958" author="michaelwang" type="comment" body="when building chaincode outside the peer, the shim can exist as an independent dependency which can be managed by dep tools. So we can separate this shim as an independent repo. Does this make any sense ?" created="2019-04-09 06:27:12.0" updateauthor="michaelwang" updated="2019-04-09 06:27:12.0"/>
