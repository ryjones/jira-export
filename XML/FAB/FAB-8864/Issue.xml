<Issue id="28525" key="FAB-8864" number="8864" project="10002" reporter="jyellick" assignee="manish-sethi" creator="jyellick" type="10001" summary="Provide a channel-scoped, peer local data store" priority="3" resolution="10001" status="6" created="2018-03-14 17:13:26.0" updated="2019-01-07 03:18:32.0" resolutiondate="2019-01-07 03:18:32.0" votes="0" watches="3" workflowId="35617"> <description><! CDATA Today, there are some local peer scoped operations, such as deploying chaincode which equate to installing files onto the filesystem.  This is an inflexible mechanism, and as more use cases arise, different peer components may need to store peer specific (non-configuration) data in a consistent way.  The most obvious way to accomplish this, is to provide per peer channel scoped, local storage within some partitioning of the state database.  This local storage must be manipulable in a safe way relative to channel ordering.  Specifically, there are two cases which must be supported:  # Reading/Writing to this storage space in a concurrency safe way during a chaincode invocation.  e.g. {{LSCC.InstallMetadata}} # Reading/Writing to this storage space in a concurrency safe way during the block commit phase e.g. during the commit of an {{LSCC.Define}} transaction  These properties are necessary to address the following case:  An Administrator attempts to install a chaincode metadata package for a chaincode.  Simultaneously, a chaincode definition is committing to the ledger.  The commit needs to check if the chaincode metadata exists in the peer local data, and if so, mark it as 'active'.  The chaincode metadata install also needs to check if the chaincode is already defined in the LSCC (non-local-data) table to see if the chaincode should be set as active.  ></description> </Issue>
