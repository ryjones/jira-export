<Issue id="15918" key="FAB-3326" number="3326" project="10002" reporter="ptippett" creator="ptippett" type="10001" summary="Update and Install operations need to clean up orphaned CC containers" priority="1" status="10000" created="2017-04-21 21:40:16.0" updated="2019-08-02 19:33:04.0" votes="3" watches="14" workflowId="43164"> <description><! CDATA When running an update or install of chaincode, the SDK needs to clean up orphaned containers. Otherwise, old version of any instantiated chaincode stay running and it's not easy for an application/user to tell when chaincode containers can be removed.  Given this environment:  I've got 3 peers, P1, P2, P3. P1 and P2 are transacting on Channel1 with CCv1 P1 and P3 are transacting on Channel2 with CCv1.  This would result in 3 instances of the CCv1 container running, 1 for each peer.  Scenario 1:  I make a call to P2 to install CCv2 and then update CCv2 on Channel1. CCv1 can be stopped and deleted on P2 since P2 is no longer using CCv1 on  any channels.  Scenario 2:  I instead make a call to install CCV2 on P1 and then update CCv1 to CCv2 on Channel1. CCv1 can't be stopped and deleted on P1 since P1 is still using CCv1 to transact with P3 on Channel2.  Once I've installed CCv2 on P1 and updated CCv2 on Channel1, performing just an install of CCv2 on P2 would mean that I could stop and remove  the CCv1 instance running on P2 since it's no longer needed.  The issue here is as currently written, the install and update operations don't ever do anything to determine if an installed or updated cc can be cleaned up and never cleans up orphaned containers. I believe this check and cleanup should be part of the update and install operations. It's difficult for a user or service owner to know when chaincode is no longer needed and clean up appropriately.  Â   ></description> </Issue>
