<Action id="23730" issue="15918" author="muralisr" type="comment" created="2017-05-11 12:23:42.0" updateauthor="muralisr" updated="2017-05-11 12:23:42.0"> <body><! CDATA  ~ptippett  let me think about this and update.  Also  ~jiangyaoguo  FYI... wondering if you'd like to help with this ?   ></body> </Action>
<Action id="23736" issue="15918" author="jiangyaoguo" type="comment" body=" ~muralisr  Sure, I&apos;d like to. I consider this as container GC problem.  It&apos;s more like a new feature of peer if we decide to handle this at peer side. In view of peer reboot, we can have a module to do periodic gc. Peer should expose interfaces that query channels peer belong to  and chaincodes instantiated on peer(lscc can supply chaincode infos). This is my original thoughts. Need more design." created="2017-05-11 13:26:34.0" updateauthor="jiangyaoguo" updated="2017-05-11 13:26:34.0"/>
<Action id="23744" issue="15918" author="muralisr" type="comment" created="2017-05-11 14:34:59.0" updateauthor="muralisr" updated="2017-05-11 14:34:59.0"> <body><! CDATA Thanks  ~jiangyaoguo  ! Agreed.. let me suggest an addition to what you have stated above.  A simpler quick approach would be just to have a time-to-live on the chaincodes so the container manager will just stop a chaincode if its not in use for a specified period. This will take care of 80% of the problem without involving Chaincode Lifecycle operations or needing serious management.  We can layer the approach to do three things # your GC module to use TTL on the container framework # layer any other clean up ("this chaincode is not referenced in any LSCC") on top # implement start/stop Life-cycle to aid with additional management  We could implement 1 immediately to provide relief.  What do you think ?  ></body> </Action>
<Action id="23763" issue="15918" author="binhn" type="comment" body="I like TTL since it also takes care of once-a-blue-moon chaincode containers. Some chaincode only runs once in a great while (eg  fiscal quarter), so TTL would shut down these chaincodes automatically." created="2017-05-11 19:46:26.0" updateauthor="binhn" updated="2017-05-11 19:46:26.0"/>
<Action id="23806" issue="15918" author="jiangyaoguo" type="comment" body="Like TTL. This method makes things simple and effective. Doing detailed gc analysis from lscc is expensive operate." created="2017-05-12 14:08:46.0" updateauthor="jiangyaoguo" updated="2017-05-12 14:08:46.0"/>
<Action id="24302" issue="15918" author="yacovm" type="comment" created="2017-05-25 08:46:10.0" updateauthor="yacovm" updated="2017-05-25 08:46:27.0"> <body><! CDATA IS this for V1.0 ? or just a WIP that is for post V1?  ~muralisr   ></body> </Action>
<Action id="24308" issue="15918" author="muralisr" type="comment" body=" ~yacovm  Its WIP. Release TBD." created="2017-05-25 11:49:42.0" updateauthor="muralisr" updated="2017-05-25 11:49:42.0"/>
<Action id="24371" issue="15918" author="christopherferris" type="comment" body="what is the impact if we postpone this to 1.1?" created="2017-05-25 22:44:48.0" updateauthor="christopherferris" updated="2017-05-25 22:44:48.0"/>
<Action id="24419" issue="15918" author="mastersingh24" type="comment" created="2017-05-26 09:36:48.0" updateauthor="mastersingh24" updated="2017-05-26 09:39:35.0"> <body><! CDATA  ~ChristopherFerris   - this problem really manifests itself when people are doing iterative development of chaincode - especially in cloud environments where they mess up their chaincode and decide to upgrade it to basically fix it.  My guess is that in true production environments we won't see this as often.  I tend to think we should defer this   I also think that there is a missing option which is that when upgrading chaincode you should be able to specify if this is a side-by-side update (meaning keep multiple versions running / enabled) or a pure replace (meaning only use the new version and make the old version unavailable)  ></body> </Action>
<Action id="24425" issue="15918" author="yacovm" type="comment" body="I think a workaround for now (if it will be decided not to go with this for V1.0)  is to document this and have the administrators manually kill the containers. " created="2017-05-26 09:56:19.0" updateauthor="yacovm" updated="2017-05-26 09:56:45.0"/>
<Action id="24429" issue="15918" author="muralisr" type="comment" created="2017-05-26 11:22:49.0" updateauthor="muralisr" updated="2017-05-26 11:22:49.0"> <body><! CDATA  ~jiangyaoguo  what do you think ? I like the document for 1.0 with suggestion that we don't get rid of unused chaincodes after upgrade and its upto admins to get rid of them.   ></body> </Action>
<Action id="24436" issue="15918" author="jiangyaoguo" type="comment" created="2017-05-26 12:04:24.0" updateauthor="jiangyaoguo" updated="2017-05-26 12:04:24.0"> <body><! CDATA For 1.0, I agree that we can ducument it and suggest to manually kill containers.  Automatic container management need more time to design and test. We can leave it for now and pick this up after 1.0.   ~mastersingh24  Now chaincode containers are shared between different channels (if instantiate/upgrade same name and version chaincode on multiple channels,there's only one container served for these channels on peer). We can only call the latest version chaincode (client can't specify version, peer will match the latest one). So every chaincode upgrade is a pure replace from client perspective. Multiple versions chaincodes will run on one peer because different channels may instantiate/upgrade different version chaincode.  ></body> </Action>
<Action id="24437" issue="15918" author="jiangyaoguo" type="comment" body=" ~ptippett  do you think if it is acceptable that we could manully kill containers for now and handle this after 1.0?  I made a WIP TTL CR in  https://gerrit.hyperledger.org/r/#/c/9711/  . you can track on this and give your advice about implement." created="2017-05-26 12:20:10.0" updateauthor="jiangyaoguo" updated="2017-05-26 12:20:10.0"/>
<Action id="24439" issue="15918" author="ptippett" type="comment" created="2017-05-26 12:57:02.0" updateauthor="ptippett" updated="2017-05-26 12:57:02.0"> <body><! CDATA I think we can leave it up to and allow customers to delete the CC containers they know they aren't using anymore.    Once point of clarification however, it's my understanding that in order to really remove chaincode, it needs to be removed from the peer image in addition to the container being stopped and removed, right?  We could stop and remove the chaincode container and that would free up CPU/Memory and reduce the container count, but without removing files from the peer, if someone tried an operation on that chaincode, it'd attempt to spin it up again and eventually, the peer could run out of disk space, although I don't think that's a big concern.  A service admin could work around this by using docker exec to delete the chaincode files from the peer if that's all that's needed to remove the peers references to it.  Not sure that's the case though.  Is that all that's needed to completely remove chaincode?     ></body> </Action>
<Action id="24809" issue="15918" author="christopherferris" type="comment" body="So, I think that where we are with this is it is post 1.0 item.  ~ptippett  I would suggest that we change this to an improvement, or maybe a story, that seeks to better address the management of chaincode (containers and the source bundle) on a peer node." created="2017-05-31 17:19:13.0" updateauthor="christopherferris" updated="2017-05-31 17:20:11.0"/>
<Action id="24815" issue="15918" author="ptippett" type="comment" created="2017-05-31 17:32:08.0" updateauthor="ptippett" updated="2017-05-31 17:32:58.0"> <body><! CDATA yeah that's cool.  I've got an idea as well how this could be managed by a service owner that I'll send around.     Changed to a Story.  ></body> </Action>
<Action id="30093" issue="15918" author="baohua" type="comment" created="2017-08-23 08:04:53.0" updateauthor="baohua" updated="2017-08-23 08:04:53.0"> <body><! CDATA I think this feature is very important for the coming 1.1 release.  So would like to +1 on this.  Currently, both channel and chaincode lacks full life-cycle management as the following.   Channel: * Leave (peer leave a channel that he joined) * Destroy (destroy an empty channel)     Chaincode: * Stop (Stop a running cc container) * Uninstantiate (Remove the cc containers from a channel) * Uninstall (Uninstall a cc from peer, and deregister)  ></body> </Action>
<Action id="30131" issue="15918" author="jiangyaoguo" type="comment" body=" ~baohua  About chaincode full life-cycle, we can discuss more at https://jira.hyperledger.org/browse/FAB-5781 " created="2017-08-24 01:54:39.0" updateauthor="jiangyaoguo" updated="2017-08-24 01:54:39.0"/>
<Action id="30397" issue="15918" author="baohua" type="comment" body="The chaincode full life-cycle management design is initiated at  https://docs.google.com/document/d/1aSWNOuvOBzi1OzZ-b8h0IP-Qs6JL8iREXM7Jtc0VkE0,  welcome for comments!" created="2017-08-31 03:16:11.0" updateauthor="baohua" updated="2017-08-31 03:16:11.0"/>
<Action id="43704" issue="15918" author="kchristidis" type="comment" body="Right URL for doc: https://docs.google.com/document/d/1aSWNOuvOBzi1OzZ-b8h0IP-Qs6JL8iREXM7Jtc0VkE0/edit (no comma)" created="2018-05-01 16:38:50.0" updateauthor="kchristidis" updated="2018-05-01 16:38:58.0"/>
