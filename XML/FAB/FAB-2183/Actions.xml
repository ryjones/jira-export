<Action id="22078" issue="14740" author="denyeart" type="comment" created="2017-04-11 12:13:04.0" updateauthor="denyeart" updated="2017-04-11 12:13:04.0"> <body><! CDATA Composite keys (ck) have an objectType prefix. Each part of composite key is delimited by null character, for example (spaces included for visual clarity only): chaincodeid 0x00 objectType 0x00 ck1 0x00 ck2 0x00	// composite key   This design ensures that various composite key types have an objectType namespace to guarantee no collisions across types.  For example range queries and partial composite key queries will never overlap.   Issue: Simple keys (sk) and composite key objectType are in the same namespace.  Range queries on simple keys will pick up composite keys in an objectType scope. They should be in different scopes to ensure no collisions.  To illustrate the issue, note that simple key and composite key objectType are in the same namespace / level:  chaincodeid 0x00 sk					                   // simple key  chaincodeid 0x00 objectType 0x00 ck1 0x00 ck2 0x00	   // composite key     *Solution * Automatically put simple keys in a reserved namespace, for example the empty “” object space. Note the simple key and composite key distinct namespaces now (spaces added for visual clarity): chaincodeid 0x00                    0x00 sk 			        // simple key chaincodeid 0x00 objectType 0x00 ck1 0x00 ck2 0x00	// composite key   A range query from a to z on a simple key would look like:  chaincodeid 0x00 0x00 a  TO   chaincodeid 0x00 0x00 z   ></body> </Action>
<Action id="22325" issue="14740" author="senthil1" type="comment" body="Adding  ~manish-sethi " created="2017-04-13 10:54:29.0" updateauthor="senthil1" updated="2017-04-13 10:54:29.0"/>
<Action id="22369" issue="14740" author="denyeart" type="comment" created="2017-04-13 16:22:55.0" updateauthor="denyeart" updated="2017-04-13 16:22:55.0"> <body><! CDATA  ~Senthil1  Approach 2,3,4 are out assuming we do not allow chaincode API changes.  Can approach 1 and approach 5 work, if we document (but don't validate in code) that simple keys, or any part of a composite key, should not contain 0x00?  ></body> </Action>
<Action id="22375" issue="14740" author="senthil1" type="comment" created="2017-04-13 16:39:57.0" updateauthor="senthil1" updated="2017-04-13 16:39:57.0"> <body><! CDATA Yes, both approach would work for that assumption. Currently, we are checking for 0x00 in attributes of composite key and return error if exist. We only need to document for simple keys.  Approach 1 requires change only in ledger side whereas Approach 5 requires change only in chaincode shim.   ></body> </Action>
<Action id="22377" issue="14740" author="denyeart" type="comment" created="2017-04-13 18:03:19.0" updateauthor="denyeart" updated="2017-04-13 18:03:19.0"> <body><! CDATA After discussion with Senthil it was decided to proceed with Approach 5.   ~Senthil1  Please add any more details to the Approach 5 Description above, for example the unbounded range query impact and anything else you find during imlementation.  Also note the typo "CreateCompositeCreate" :-)  ></body> </Action>
<Action id="22881" issue="14740" author="christopherferris" type="comment" body="https://gerrit.hyperledger.org/r/#/c/8119/" created="2017-04-23 12:55:23.0" updateauthor="christopherferris" updated="2017-04-23 12:55:23.0"/>
<Action id="27202" issue="14740" author="sanchezl" type="comment" body="Before this change, it was possible to specify composite keys as parameters to {{getStateByRange()}}, now it is not possible. Was this intended?" created="2017-06-22 15:16:32.0" updateauthor="sanchezl" updated="2017-06-22 15:16:32.0"/>
<Action id="27207" issue="14740" author="senthil1" type="comment" body="Yes, it was intended. Now, getStateByRange() returns only simple keys and getStateByPartialCompositeKey() returns only composite keys. We have different namespaces for simple keys and composite keys to avoid collisions. " created="2017-06-22 16:49:46.0" updateauthor="senthil1" updated="2017-06-22 16:49:46.0"/>
<Action id="27221" issue="14740" author="denyeart" type="comment" created="2017-06-22 19:54:15.0" updateauthor="denyeart" updated="2017-06-22 19:54:15.0"> <body><! CDATA  ~Senthil1   ~manish-sethi   ~sanchezl   Let me be devil's advocate and propose relaxing the validation constraint...  If we allowed getStateByRange() to accept composite keys, I can see there would be collisions on the open-ended range queries.  But if we allowed it when both startKey and endKey were included, I think there would be value without issues.  Using the marbles02 example, say I want to query for blue marble1 through blue marble9, where <color,id> is the composite key.  Wouldn't it be safe to query on <blue,marble1> to <blue,marble9>?  So perhaps instead of rejecting all range queries with composite keys, we could relax it and instead validate that the first parts of the composite keys are the same in startKey and endKey. I believe this would protect against the concerns, while allowing range queries within a composite key space.  What do you think?  ></body> </Action>
