<Issue id="14740" key="FAB-2183" number="2183" project="10002" reporter="nishi" assignee="senthil1" creator="nishi" type="10004" summary="GetStateByRange API: simple key and composite key collisions" priority="1" resolution="10000" status="6" created="2017-02-10 19:27:57.0" updated="2019-01-17 10:11:58.0" resolutiondate="2017-05-01 03:00:09.0" votes="0" watches="5" workflowId="37395"> <description><! CDATA When we do range query on simple keys, it does return composite key as well. For example, the following range query on marble02 chaincode example returns both simple key such as marble2, marble3, and composite key such as color~namebluemarble2, color~namebluemarble2 where it should have returned only marble2 and marble3.  $ peer chaincode query -n mycc1 -v 0 -c {"Args": "getMarblesByRange","a","z" } -o 127.0.0.1:7050 -C ch1 Query Result:    {"Key":"color~namebluemarble3", "Record":} \{"Key":"color~nameredmarble2", "Record":}  {"Key":"marble2", "Record":\{"docType":"marble","name":"marble2","color":"red","size":50,"owner":"tom"}}, {"Key":"marble3", "Record":\{"docType":"marble","name":"marble3","color":"blue","size":70,"owner":"tom"}}  How fabric can differentiate between a simple or composite so that GetStateByRange() can return only simple keys? *Approach-1* _Ledger adds a null character 0x00 as a first character in simple key._ The constructCompositeKey(namespace, key) in ledger check whether the key contains \x00. If it does not contain \x00, then the key is a simple key and add a \x00 in the front of the key. The splitCompositeKey() removes the added \x00 in the front of the key if exist. For this approach to work, we shouldn’t allow 0x00 in original simple key. Still, this approach will not work as PutState() cannot be used for both simple key and composite key when we want to allow \x00 in composite key (added by CreateCompositeKey) but not in simplekey.  *Approach-2*: _Ledger adds a null character 0x00 as a first character in simple key_ This approach is an extension to approach-1. Expose a new chaincode API named PutCompositeState(objectType, attributes, value). Internally, we can call createCompositeKey() instead of exposing an API for that followed by handlePutState(). We have done a similar thing in GetStateByPartialCompositeKey(objectType, attributes). This would simplify the chaincode as well. We can then let chaincode use PutState() API only for simple key and do not allow \x00. At ledger side, we use the approach-1 .  *Approach-3*: _Add a separate namespace for simple and composite key._ Expose two new chaincode APIs named GetCompositeState() and PutCompositeState(). In front to the composite key, chaincode APIs adds c to denote that the key is composite. Similarly, chaincode APIs such as GetState(), PutState(), GetStateByRange() adds ‘s’ in the front of simple key. At ledger side, Next() of each result iterator removes ‘c’ or ‘s’ from the front of each key.  *Approach-4* _Add separate namespace for simple and composite key._ Instead of adding ‘c’ and ‘s’ from chaincode APIs, we can add these namespace in ledger side. For this, we need to expose two new chaincode APIs and ledger APIs named GetCompositeState() and PutCompositeState(). Now, the ledger API adds ‘s’ and ‘c’ and Next() of each result iterator removes ‘c’ or ‘s’ from the front of each key.  *Approach-5* _Chaincode API CreateCompositeKey adds a null character 0x00 as a first character in composite key._ In current implementation of GetStateByRange(), we are not concatenating anything with startKey and endKey. In GetStateByPartialCompositeKey(), we concatenate U+10FFFF with the endKey. Hence, prepending 0x00 on composite key will not induce a collision. For this approach to work, we shouldn’t allow 0x00 as first character in simple key. Still, this approach will not work as PutState() cannot be used for both simple key and composite key when we want to allow \x00 as first character in composite key (added by CreateCompositeKey) but not in simplekey.  If startKey of a range query is empty (for an open ended search), current implementation treats the startKey as 0x00 (null). Hence, we replace the empty startKey with 0x01 to avoid collision. Now, there is no collision when chaincode issues open-ended search like (i) startKey="" endKey="", (ii) startKey="a" endKey="z".  TODO: we need to document somewhere that a simpleKey cannot start with a null (0x00) as we cannot introduce a new chaincode API PutCompositeState() at this time.  ></description> </Issue>
