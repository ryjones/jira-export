<Action id="31536" issue="21237" author="kchristidis" type="comment" body="As noted in the description the obvious benefit of this approach is that It follows the standard endorse/order/validate flow. An important downside of it is that instantiation requires admin signatures and having peers sign with the admin certs is bad opsec practice -- doubly so given that endorsements are an automated process. This concern could be alleviated if we were to make it easy to hook ESCC into back office logic (so that the application can decide on whether or not it wants to endorse the incoming proposal), complete with all the baggage that such a change would carry." created="2017-10-02 18:46:20.0" updateauthor="kchristidis" updated="2017-10-02 18:46:20.0"/>
<Action id="31539" issue="21237" author="binhn" type="comment" created="2017-10-02 19:39:28.0" updateauthor="binhn" updated="2017-10-02 19:39:28.0"> <body><! CDATA I think we should walk back to the original decision why we need channel admins to instantiate a chaincode  ~muralisr   ~elli-androulaki .  Bringing a chaincode into a channel would be the same as materializing any asset on the ledger (following the argument that a chaincode can be a smart contract, and a smart contract is an asset on the ledger). When a chaincode creates an asset, X, we don't require channel admin authority, so my thought would be that, when LSCC instantiates/creates a chaincode, we shouldn't require channel admin authority either, should we? Channel admins are for channel configuration related activities, and creating assets is a business activity, not admin.  So if we agree with my view, then  ~kchristidis ' description above is a good compromise to enforce chaincode instantiation process. And it is reasonable to expect that chaincodes on a channel to be governed by the same instantiation policy.  ></body> </Action>
<Action id="31564" issue="21237" author="jyellick" type="comment" created="2017-10-03 15:22:28.0" updateauthor="jyellick" updated="2017-10-03 15:22:28.0"> <body><! CDATA Regardless of whether admin or peer signatures are used, without a custom ESCC hook which calls out to some organization specific workflow, (and the as a prerequisite to that, asynchronous transactions), this proposal provides no real security for parties which wish to transact with mutual distrust.  I would further point out that this proposal maintains the conflation between chaincode owner's interests and channel interests.  Consider the relatively simple use case with a channel containing 3 members, OrgA, OrgB, and OrgC.  OrgC is hosting a proprietary chaincode which it wishes to allow OrgA and OrgB to transact with, but not to inspect/execute.  Also assume that OrgA and OrgB wish to restrict which chaincodes are instantiated on the channel.  If the instantiation policy is set to "Majority" or "OrgA and OrgB", then it is impossible to instantiate OrgC's proprietary chaincode, because only one endorsement can every be gathered.  If the instantiation policy is set to "Any" or "OrgC", then the chaincode may be instantiated, but OrgA and OrgB lose control over the channel.  If chaincode were actually a resource available to all peers on the channel, then these problems largely go away, but the decision was made to divorce the chaincode itself from the channel and instead only have chaincode metadata on the channel.  Because of this decision, proposals like the above may pass a superficial inspection, but rapidly break down in implementation.  Although we would like to treat chaincode as an asset on the chain, it is not in fact on the chain, and we cannot treat it like it is in all cases.  ></body> </Action>
<Action id="31620" issue="21237" author="binhn" type="comment" created="2017-10-04 21:01:01.0" updateauthor="binhn" updated="2017-10-06 13:06:17.0"> <body><! CDATA As I have written on FAB-6042, chaincode is not the only asset that would benefit from a more sophisticated endorsement model; however, to solve the problem as proposed there is very undesirable because we would not have the ability to extend that for other assets.  This is, as said, a compromise solution (short-term) for the use-case that we know of; that is, 1 org can control the instantiation of chaincodes. I have no doubt that other use-cases exist and valid, but they are far down the road. {quote}but the decision was made to divorce the chaincode itself from the channel and instead only have chaincode metadata on the channel {quote} That is entirely incorrect. Chaincode is always acting in the context of a channel; a chaincode is meaningless outside of the channel. What we have implemented is an optimization to remove the number of times we store the same bucket of bits (chaincode source code) on the ledgers.  We have use cases that require thousands of channels, so we decided to store the evidence (hash) of the chaincode on the ledger instead of the source; similar to many use cases requiring confidentiality to put evidence of documents on chain. This is far away from divorcing the chaincode from the channel.  The beautiful side effect of this implementation is that not all peers have to host the chaincode, but only the endorsers, and the rest of the peers are still able to validate transactions. It also allows network ownership, a critical use case in private blockchain.  ></body> </Action>
<Action id="67140" issue="21237" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:07:53.0" updateauthor="sykesm" updated="2020-01-22 22:07:53.0"/>
