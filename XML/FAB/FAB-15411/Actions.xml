<Action id="59884" issue="39749" author="sykesm" type="comment" body="-Looks like {{peer chaincode query}} doesn&apos;t exit with a non-zero return code even when the response status is &gt;= 400.-" created="2019-05-09 16:58:12.0" updateauthor="sykesm" updated="2019-05-09 17:52:48.0"/>
<Action id="59885" issue="39749" author="sudeshrshetty" type="comment" created="2019-05-09 17:00:17.0" updateauthor="sudeshrshetty" updated="2019-05-09 17:00:17.0"> <body><! CDATA  ~mastersingh24   ~sykesm  Please let me know which one is right behaviour?    As I can see addBlock creates transaction index info with empty txID  https://github.com/hyperledger/fabric/blob/eca1b14b7e3453a5d32296af79cc7bad10c7673b/common/ledger/blkstorage/fsblkstorage/block_serialization.go#L115    ></body> </Action>
<Action id="59886" issue="39749" author="sudeshrshetty" type="comment" body=" ~sykesm  Sorry, I didn&apos;t understand your comment, please elaborate. " created="2019-05-09 17:24:26.0" updateauthor="sudeshrshetty" updated="2019-05-09 17:24:26.0"/>
<Action id="59888" issue="39749" author="sykesm" type="comment" body="I expected the cli was quietly eating the issue but that is not the case. You can ignore the comment. Something is amiss." created="2019-05-09 17:52:06.0" updateauthor="sykesm" updated="2019-05-09 17:52:06.0"/>
<Action id="59889" issue="39749" author="sudeshrshetty" type="comment" created="2019-05-09 18:11:46.0" updateauthor="sudeshrshetty" updated="2019-05-09 18:11:46.0"> <body><! CDATA Thanks  ~sykesm , Do you think is it right behaviour to save txns with txID empty in block store index? And we should validate txID in qscc functions? we have a nil check there on txID bytes but there is no empty check.  ></body> </Action>
<Action id="59973" issue="39749" author="denyeart" type="comment" created="2019-05-13 20:33:14.0" updateauthor="denyeart" updated="2019-05-13 20:33:32.0"> <body><! CDATA It looks like config transaction in genesis block has a blank txid.  Therefore the config transaction gets indexed in ledger with empty txid, and you can therefore query using empty txid.  This seems problematic as every config transaction would overwrite the txid index in ledger.  Config transactions should have a txid like any other transaction.  Since orderer creates config transaction, changing component to fabric-orderer.   ~jyellick  thoughts?  ></body> </Action>
<Action id="60160" issue="39749" author="jyellick" type="comment" created="2019-05-20 17:19:29.0" updateauthor="jyellick" updated="2019-05-20 17:19:29.0"> <body><! CDATA To complicate this probably a little more than anyone actually wants, the idea that the txid field even exists is a questionable one.  It is convenient to be able to look simply at the fields of a message and determine its txid, but, txid is defined, and checked, to be the hash of the creator plus nonce.   So, the txid in a sense is encoding information into the message a second time which already exists in that message.  If the txid is not set to the hash of creator plus nonce (and not empty), then the transaction is considered to be invalid by the peer validation logic.  The orderer cares nothing about the txid, and only uses it for logging purposes.  So, yes, the orderer could be modified to set a txid equal to the hash of the creator plus nonce when generating the transaction.  This wouldn't be a huge change, and would bring these transactions inline with what most fabric clients do.  On the other hand, on the peer side, we could simply infer the txid if it is not set, as all the information is already present.  This has the benefit of working nicely for existing channels.  My gut reaction says we'd be better off deprecating the txid field, and not requiring that clients set it, but, I'm open to other thoughts.  ></body> </Action>
<Action id="60586" issue="39749" author="denyeart" type="comment" body=" ~angelo.decaro  What are your thoughts on Jason&apos;s suggestion? I believe you were involved in the v1.0 design here..." created="2019-06-03 12:02:21.0" updateauthor="denyeart" updated="2019-06-03 12:02:21.0"/>
<Action id="60589" issue="39749" author="angelo.decaro" type="comment" body="I remember that back in the days the discussion was more about where the transaction id is generated: client-side vs server-side. We wanted to have a way for the client to be able to know immediately the transaction-id to check later if the transaction got committed. As long as the rule is clear on how to compute the transaction-id from the transaction content, then, I agree with not need that redundancy.  ~ales ,  ~elli-androulaki , do you agree?" created="2019-06-03 12:41:19.0" updateauthor="angelo.decaro" updated="2019-06-03 12:41:19.0"/>
<Action id="60642" issue="39749" author="denyeart" type="comment" created="2019-06-04 10:09:51.0" updateauthor="denyeart" updated="2019-06-04 10:09:51.0"> <body><! CDATA  ~jyellick   ~angelo.decaro  For 'regular' transactions I would prefer client to provide the txid to assist with end-to-end traceability. I am agreeable to having ledger infer the txid however, when creating the internal indexes that are based on txid. This has the added benefit of resolving the issue in existing environments, as the internal indexes can always be deleted and auto-created again upon next peer restart.   ~Senthil1  Could you help with this one?  Ensure that the txid indexes get created correctly even if the transaction does not have an explicit txid set. And that for existing environments that they can be re-indexed correctly.  ></body> </Action>
<Action id="60715" issue="39749" author="senthil1" type="comment" created="2019-06-06 06:00:08.0" updateauthor="senthil1" updated="2019-06-07 19:02:43.0"> <body><! CDATA  ~denyeart  Summurizing the findings here # Endorser checks whether the txID present in the proposal is computed out of nonce and creator. # Validator does the same check for the endorsement tx and token tx but not for the config tx. Without a txID in both genesis block and config updates, these txs pass the validation. # As the genesis block and the subsequent channel config block do not have the txID, a collision would occur at the blockstore index -which means an index created for config update tx overwrites another config update tx or genesis block's index.- As we check for duplicate index before creating index for each tx, we skip it currently. We do need to rebuild the index of blockstore once to fix this. # Orderer needs to include the txID when constructing the configBlock. # Blockstore needs to compute the txID when it is empty # CSCC needs to verify whether the txID is computed correctly (if non-empty).     ></body> </Action>
<Action id="60751" issue="39749" author="denyeart" type="comment" created="2019-06-07 11:13:24.0" updateauthor="denyeart" updated="2019-06-07 18:57:42.0"> <body><! CDATA Ok, upon talking with Senthil, we agreed:  Primary fix (needed for existing blocks with config transactions) will be for peer to compute txid from creator and nonce when creating the txid indexes, if the txid is empty. Existing peer owners can manually drop indexes if they want their peer to regenerate the fixed indexes. Upon upgrade to v2.0 we expect to automatically regenerate indexes regardless.  While txid is not strictly required to get a valid config transaction, it is convenient to include in all transactions for traceability. Therefore orderer should provide txid on config transactions.  ></body> </Action>
<Action id="60839" issue="39749" author="denyeart" type="comment" created="2019-06-10 16:27:15.0" updateauthor="denyeart" updated="2019-06-10 16:27:15.0"> <body><! CDATA Several people have objected to the statement "orderer should provide txid on config transactions."  I'm fine not adding txid to orderer-created config transactions.  I wouldn't go so far as to remove txid from regular user transactions however... many people use txid for end-to-end traceability (from submission time to validation events to log/debug analysis to post-processing blocks later). While txid COULD be derived from the creator and nonce at each of these steps, in my opinion removing it would be an unnecessary hit to consumability.  ></body> </Action>
<Action id="60861" issue="39749" author="ales" type="comment" body="Just to clarify my thoughts on the txid: currently, we have a field in the proposal/transaction to store the txid as a string. However, we can&apos;t take that field at face value, because we need to recompute it by hashing two other fields (nonce and creator), and then validate that the hash matches the txid. For this reason, the txid field is redundant. I think long term, we might want to remove this field, but that&apos;s not a must. What we *must* do imho is to code the peer (especially the validator/committing peer) in a way that it ignores the txid field and always recomputes the txid on the fly. Additionally, we could verify that if the txid field is non-empty, its value must match the one we compute. Validation/committer refactoring should ensure that we compute the txid only once." created="2019-06-11 09:06:53.0" updateauthor="ales" updated="2019-06-11 09:06:53.0"/>
<Action id="60863" issue="39749" author="denyeart" type="comment" body=" ~ales  I agree, and I thought that&apos;s how it currently works.  For user transactions validation phase computes the txid from nonce and creator and ensures it matches the txid string that is passed around in the transaction.  All other code locations can therefore have trust that the txid field is correct and can be used for end-to-end traceability without recalculating the hash at each location." created="2019-06-11 10:03:06.0" updateauthor="denyeart" updated="2019-06-11 10:06:50.0"/>
<Action id="60907" issue="39749" author="baohua" type="comment" created="2019-06-12 06:00:18.0" updateauthor="baohua" updated="2019-06-12 06:00:18.0"> <body><! CDATA I agree, the user transaction works well now. The issue is the lacking of the tx_id value for the config transactions.  I guess the simplest way is to generate the tx_id too when creating the config transaction, similar as the user transactions.  Certainly there can be some enhancement like to do the re-generation on empty field when doing index.  ></body> </Action>
<Action id="60922" issue="39749" author="denyeart" type="comment" created="2019-06-12 19:02:30.0" updateauthor="denyeart" updated="2019-06-12 19:02:30.0"> <body><! CDATA  ~baohua  From the prior comments, the plan is: * Primary fix (needed for existing blocks with config transactions) will be for peer to compute txid from creator and nonce when creating the txid indexes, if the txid is empty. * No change to config transactions (they will continue to NOT have txid... not a compelling enough reason to justify a change in behavior) * No change to user transactions (they will continue to have txid... more important for end-to-end traceability)  ></body> </Action>
<Action id="60932" issue="39749" author="baohua" type="comment" created="2019-06-13 02:08:52.0" updateauthor="baohua" updated="2019-06-13 02:08:52.0"> <body><! CDATA  ~denyeart , I agree with the plan.  Besides, i think tx_id is very useful for those requirements:  1) Traceability (as mentioned)  2) Ordering (help order txs inside the same block)  3) Async requests from client (sent and query)  4) Auditing (based on traceability)  Agree with that tx_id is easy to be generated with creator/nonce, and generating once and use in other places will benefit the performance-critical scenarios.  Thanks!     ></body> </Action>
<Action id="61135" issue="39749" author="guillaumecisco" type="comment" created="2019-06-20 09:52:58.0" updateauthor="guillaumecisco" updated="2019-06-20 09:52:58.0"> <body><! CDATA TxId would be great in orderer transactions on the system channel such as application channel creation/update.  We recently tried to add the raft orderer instead of solo to our project. When using raft, we've seen we have to wait for block to be correctly commited after a channel creation/update. This was not he case with the solo orderer. For example if we write a script which create a channel and immediately after, try to make some peers join the newly created channel, it will fail. As in the process of joining, we need to get the genesis block of the channel, and we won't get it, as it is too soon. We could put a sleep of 2 or 3 seconds, but this is ugly. We should instead use a channel based event hub on the channel creation/update method, and using the orderer delivery, as we will use our channel based event hub on a system channel. I implemented with the fabric-sdk-py a way to connect channel based event hub with orderer delivery for knowing when the block of a channel creation/update is commited from the orderer delivery. I correctly get the block, but I was flabbergasted I had empty txId in these block. So I cannot register with a registerTxEvent on my systemchannel.  The channel update method give me a block with a CONFIG transaction with an empty txId in the block 'data'  'data'  'payload'  'header'  'channel_header'  'tx_id' , BUT I get a txId in the block 'data'  'data'  'payload'  'data'  'last_update'  'payload'  'header'  'channel_header'  'tx_id'  which the txId I was looking for. So I can tweak the way channel event hub works for adding this txId, but is it right? Should I really test on the last_update payload? Regarding the channel creation method which is a ORDERER_TRANSACTION, I obtain no txId. So I can absolutely never know when the block is committed.  We know that the txId is computed as hash_func(self._nonce + self._identity).hexdigest(). The identity can be computed:  serialized_identity = identities_pb2.SerializedIdentity() serialized_identity.mspid = user.msp_id serialized_identity.id_bytes = user.enrollment.cert return serialized_identity.SerializeToString()   In the block I receive I have data for computing the identity and I get the nonce. So you can tell me I could retrieve the txId in the channel event hub, even if it is empty. Unfortunately the nonce generated before sending the transaction is NOT the same as the one I receive in the block. I think this is normal, can someone confirm me that?  So I'm in a dead end here, I have empty txId for CONFIG or ORDERER_TRANSACTION and I cannot retrieve with the nonce and identity data.  What should we do? Am I missing something?  Thank you,  ></body> </Action>
<Action id="61221" issue="39749" author="denyeart" type="comment" body=" ~ales   ~jyellick  We had decided not to add the txid to orderer-created config transactions. Does the prior comment change your opinion at all?" created="2019-06-24 21:43:11.0" updateauthor="denyeart" updated="2019-06-24 21:43:11.0"/>
<Action id="61340" issue="39749" author="guillaumecisco" type="comment" created="2019-06-28 14:34:31.0" updateauthor="guillaumecisco" updated="2019-06-28 14:34:31.0"> <body><! CDATA Is there any update on this topic?  Is there another way to know when a channel has been created/updated without using channel event hub?  Does what I wrote feels right?  Thank you,  ></body> </Action>
<Action id="61437" issue="39749" author="kelvin_moutet" type="comment" body="Any update or final decision on this question ?" created="2019-07-03 07:23:20.0" updateauthor="kelvin_moutet" updated="2019-07-03 07:23:20.0"/>
<Action id="61458" issue="39749" author="jyellick" type="comment" created="2019-07-03 17:55:45.0" updateauthor="jyellick" updated="2019-07-03 17:55:45.0"> <body><! CDATA Generally speaking, we do not expect for peers to join the orderer system channel.  In fact, unless you declare a channel application section in your orderer system channel, I would expect very odd things to happen.  The behavior of Solo and Raft are actually the same, both wait to create the channel until after the block commits.  It so happens that the latency in a Solo env is necessarily much lower than in a Raft one.  You would observe the same behavior with a Kafka based orderer.  Traditionally, we've simply asked users to poll on the new channel until it becomes available, rather than to use an event driven approach.  An event driven approach would probably be superior, but, there a few problems here:  1) As mentioned above, peers are not usually joined to the orderer system channel 2) The orderer system channel should usually only be read/writable by the orderers themselves, which makes an application client listening problematic 3) Because the orderer generates the txid, there's no obvious way for the client to know which txid to listen for  Because channel creation is generally a one-off infrequent event, and not performance critical, the polling approach seemed like a 'good enough' solution.  I'll note, that we're aware of some of the shortfalls with the channel creation flow, and system channel in general, and we're working to clean this up.  Personally, I'm not vehemently opposed to having the orderer set a txid in these transactions.  But there are so many barriers to using these txids, it doesn't seem useful, so I'm not sure it's worth doing.  ></body> </Action>
<Action id="61464" issue="39749" author="baohua" type="comment" created="2019-07-04 01:19:25.0" updateauthor="baohua" updated="2019-07-04 01:19:25.0"> <body><! CDATA One interesting question might be: what's the shortfall if we let each transaction have a unique id with it?  Otherwise, this could simplify the design and implementation, as we do not need to use separate processes of enabling and disabling the tx id generation?  ></body> </Action>
<Action id="61466" issue="39749" author="kelvin_moutet" type="comment" created="2019-07-04 06:19:42.0" updateauthor="kelvin_moutet" updated="2019-07-04 06:19:42.0"> <body><! CDATA  ~jyellick  Thank you for your answer If we want to allow peers to create Application channels, we need to add them in the orderer system channel (at least in the consortium group)  ? Correct me if I'm wrong or if there is another possibility ? What are the odd things that could happen ?  If a peer is in the the application, it could listen to channel events and because it can create channel, it will have the txid so, if a event exist, it could possibility listen to it, no ?  I would be very happy if you have some ressources on security/risks of peers in the system channel. Moreover, I find it more logical that peers can create application channels and should not be limited to orderers  ></body> </Action>
<Action id="61511" issue="39749" author="kelvin_moutet" type="comment" body=" ~denyeart  I see you closed the issue, could you share what the final conclusion of it ? :)" created="2019-07-08 11:58:23.0" updateauthor="kelvin_moutet" updated="2019-07-08 11:58:23.0"/>
<Action id="61516" issue="39749" author="jyellick" type="comment" created="2019-07-08 14:21:26.0" updateauthor="jyellick" updated="2019-07-08 14:21:26.0"> <body><! CDATA  ~Kelvin_Moutet    {quote}If we want to allow peers to create Application channels, we need to add them in the orderer system channel (at least in the consortium group)  ? Correct me if I'm wrong or if there is another possibility ?{quote}  Generally speaking, we expect that channels are created by admins of the consortium members.  Deciding to create a channel, and with who, is typically thought of as a human decision, so the notion of an orderer, or peer initiating a channel creation is a bit unusual.  So, the consortium contains organization definitions, each of which defines their admins.  There is a configurable policy for channel creation, but by default, any admin of any consortium member may create a channel.  {quote}What are the odd things that could happen ?{quote}  This isn't exactly a supported path, if you are lucky, joining the channel would simply fail.  If you are unlucky, certain code paths could trigger a peer panic.  {quote}If a peer is in the the application, it could listen to channel events and because it can create channel, it will have the txid so, if a event exist, it could possibility listen to it, no ?{quote}  Peers do not create channels, consortium admins submit channel creation txes to the orderers, if the tx is valid, then the orderer generates the channel config based on the channel creation tx, and starts the channel.  {quote}I would be very happy if you have some ressources on security/risks of peers in the system channel.{quote}  The security implication is that if application members may read the orderer system channel they may see all of the channel creations occurring, what channels members are forming with whom.  {quote}Moreover, I find it more logical that peers can create application channels and should not be limited to orderers{quote}  This is simply not possible.  The orderers form consensus upon order.  And, channel creation events must have order relative to eachother.  You can imagine what if two different peers tried to create the same channel at the same time, but with different parameters.  Who's is correct? How do we inform the orderers that this is a valid channel? How do the orderers authorize that the channel was created validly?  In the future, we may allow out of band channel creation and registration with the orderers, but in this case, I see no reason that the peers would create the channel, I would simply expect the admins to use a tool like {{configtxgen}} to do so.  {quote}David Enyeart I see you closed the issue, could you share what the final conclusion of it ? ￼{quote}  I believe the conclusion was to continue to omit the txid on channel creation, as it does no one any good to generate it.  ></body> </Action>
<Action id="61517" issue="39749" author="kelvin_moutet" type="comment" created="2019-07-08 15:01:49.0" updateauthor="kelvin_moutet" updated="2019-07-08 15:03:24.0"> <body><! CDATA Thank you  ~jyellick  for your detailed answer :)  Maybe my first answer was a bit confusing. When I said `peer` is stand for organization with a peer and `orderer` it is organization with an orderer.  Sorry for this confusion that leads to this discussion ! {quote}Generally speaking, we expect that channels are created by admins of the consortium members. Deciding to create a channel, and with who, is typically thought of as a human decision, so the notion of an orderer, or peer initiating a channel creation is a bit unusual. So, the consortium contains organization definitions, each of which defines their admins. There is a configurable policy for channel creation, but by default, any admin of any consortium member may create a channel.? {quote} You're right, this confirm my idea was not well written ! When I said peers, I mean admin of organizations that have a peer node but no orderer node. If their admin are in the consortium they could create (if they are allowed) application channel. So it's not limited to orderer admin (admin of the organization with an orderer node) ? Or is it better that organizations in the consortium has an orderer node too ? And no peer node ? {quote}This is simply not possible. The orderers form consensus upon order. And, channel creation events must have order relative to eachother. You can imagine what if two different peers tried to create the same channel at the same time, but with different parameters. Who's is correct? How do we inform the orderers that this is a valid channel? How do the orderers authorize that the channel was created validly? ? {quote} It could happen with consortium admin too no ?   Thank you again for those information !        ></body> </Action>
<Action id="61518" issue="39749" author="jyellick" type="comment" created="2019-07-08 16:07:23.0" updateauthor="jyellick" updated="2019-07-08 16:07:23.0"> <body><! CDATA {quote} If their admin are in the consortium they could create (if they are allowed) application channel. So it's not limited to orderer admin (admin of the organization with an orderer node) ? Or is it better that organizations in the consortium has an orderer node too ? And no peer node ?{quote}  Actually, by default, orderer admins are not authorized to create channels (though they do control the consortium configuration, so they could modify this policy).  Instead, any consortium member's admin may create channels.  Typically, we recommend that the ordering service be run by a logically distinct entity which has no interest in the application channels (even if the same physical entity does).  {quote}It could happen with consortium admin too no ?{quote}  The orderers consent upon the order of transactions in the orderer system channel.  Whichever channel creation transaction is ordered first would be successful and create the channel, any subsequent transactions would be invalidated and discarded.  ></body> </Action>
