<Issue id="28051" key="FAB-8554" number="8554" project="10002" reporter="brucepark" creator="brucepark" type="10004" summary="validation execution timeout kill the peer" priority="3" resolution="10000" status="6" created="2018-02-27 07:28:46.0" updated="2019-07-03 15:59:12.0" resolutiondate="2018-05-21 18:46:37.0" votes="0" watches="3" workflowId="41386"> <description><! CDATA In an environment with two Orgs and four peers (each org has 2 peers), 4 kafkas, 3 zookeepers and 2 orderers (no couchdb).  During the test, four peers died at the same time.  The error messages are all the same.    {code:java} 2018-02-27 02:37:35.590 UTC  gossip/state  commitBlock -> ERRO f8a4bf Got error while committing(Invoke VSCC failed for transaction txid=72d936d31215731f58bf0b71b85cb9b7db544eceaa51246d1df1483c39833697, error error executing chaincode: failed to execute transaction: timeout expired while executing transaction  Validation failed  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).commitBlock  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:778  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:561  runtime.goexit  /opt/go/src/runtime/asm_amd64.s:2337)  2018-02-27 02:37:35.631 UTC  gossip/state  deliverPayloads -> CRIT f8a55e Cannot commit block to the ledger due to Invoke VSCC failed for transaction txid=72d936d31215731f58bf0b71b85cb9b7db544eceaa51246d1df1483c39833697, error error executing chaincode: failed to execute transaction: timeout expired while executing transaction  Validation failed  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:562  runtime.goexit  /opt/go/src/runtime/asm_amd64.s:2337  panic: Cannot commit block to the ledger due to Invoke VSCC failed for transaction txid=72d936d31215731f58bf0b71b85cb9b7db544eceaa51246d1df1483c39833697, error error executing chaincode: failed to execute transaction: timeout expired while executing transaction  Validation failed  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:562  runtime.goexit  /opt/go/src/runtime/asm_amd64.s:2337    goroutine 220  running :  github.com/hyperledger/fabric/vendor/github.com/op/go-logging.(*Logger).Panicf(0xc4201bbc50, 0xebf885, 0x2c, 0xc4228be1a0, 0x1, 0x1)  /opt/gopath/src/github.com/hyperledger/fabric/vendor/github.com/op/go-logging/logger.go:194 +0x134  github.com/hyperledger/fabric/gossip/state.(*GossipStateProviderImpl).deliverPayloads(0xc4200d1d00)  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:562 +0x4c7  created by github.com/hyperledger/fabric/gossip/state.NewGossipStateProvider  /opt/gopath/src/github.com/hyperledger/fabric/gossip/state/state.go:252 +0x6d3{code}    Not only peer but also all dev-peers were dead. All nodes seem to have died at similar times, The last log of the dev-peer is:    {code:java} ``` ======== Invoke 1 mspid: Org1MSP <nil>=========== ex02 Invoke version2 ======== Invoke 1 mspid: Org1MSP <nil>=========== ex02 Invoke version2 2018-02-27 02:37:35.863 UTC  shim  func1 -> ERRO 003 Received error from server, ending chaincode stream: rpc error: code = Unavailable desc = transport is closing Error starting Simple chaincode: rpc error: code = Unavailable desc = transport is closing{code}    chaincode:    {code:java} func (t *SimpleChaincode) get(stub shim.ChaincodeStubInterface, name string) pb.Response { valbytes, err := stub.GetState(name) if err != nil { return shim.Error("Fail to get State:" + name) }  return shim.Success(valbytes) }   func (t *SimpleChaincode) inc(stub shim.ChaincodeStubInterface, name string) pb.Response { valbytes, err := stub.GetState(name) if err != nil { return shim.Error("Fail to get State") }  val, _ := strconv.Atoi(string(valbytes)) valbytes =   byte(strconv.Itoa(val+1))  err = stub.PutState(name, valbytes)  if err != nil { return shim.Error(err.Error()) }  return shim.Success(nil) }  {code}    test client (node) {code:javascript}  //IBM-Blockchain-marbles var fcw = require('./src/fabric/fc_wrangler/index.js')({ block_delay: 60 * 1000 }, logger);  const query_chaincode_async = promisify(fcw.query_chaincode); const invoke_chaincode_async = promisify(fcw.invoke_chaincode);  async function intervalFunc() { 	let state_store = await getKeyValueStore() 	let user_context = await getUserContext(state_store)  	var idx = 0;  	var MAX = 10 	// for(var i =0; i < MAX; i++) { 	// 	let name = 'key' + i.toString(); 	// 	await incValue(name); 	// 	logger.info('done initialize', name); 	// }    	if (user_context != null) { 		while (true) { 			 			var successCount = 0; 			var errorCount = 0;  			var startedAt = Date.now(); 			logger.warn('start');  			for(var tryCount =0 ; tryCount < MAX; tryCount++) { 				let idx2 = idx; 				idx++;  				let name = uuid.v4(); 				logger.info('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>', tryCount, successCount, errorCount); 				try { 					logger.info(idx2, '###### before ######', name); 					if (isModeA()) { 						incValue(name).then(async () =>{ 							successCount++; 							logger.info(idx2, '###### Success IncA ###### ', name); 						}).catch((exception) => { 							errorCount++; 							logger.error(idx2, '###### exception ######', name); 							logger.error(exception); 						}); 						 					} else { 						incValue(name).then(async () =>{ 							successCount++; 							logger.info(idx2, '###### Success IncB ###### '); 						}).catch((exception) => { 							errorCount++; 							logger.error(idx2, '###### exception ######', name); 							logger.error(exception); 						}); 					} 					// logger.info('###### after ######', await getValue('a'), await getValue('b'), await getValue('c')); 				} catch(exception) { 					errorCount++; 					logger.error(idx2, "unexpected exception", name); 					logger.error(exception); 				} 			}   			while (tryCount > (successCount + errorCount)) { 				let info = await channel.queryInfo(); 				logger.info('==== waiting ======= ', tryCount, successCount, errorCount, info.height);  				await sleep(100); 			}  			var endAt = Date.now(); 			logger.warn('end ', MAX, Math.floor((tryCount * 1000) / (endAt - startedAt))); 			let info = await channel.queryInfo(); 			logger.warn(info.height); 			MAX += 10; 			await sleep(5000); 		} 	} else { 		console.error("user " + config.userId + " not found"); 	} }  function incValue(name) { 	let func = ""   	let args =    	if (name == "a") { 		func = "incA"; 	} else if (name == "b") { 		func = "incB"; 	} else { 		func = "inc"; 		args =  name ; 	}  	var opts = { 		chaincode_id: chaincode_id, 		cc_function: func, 		cc_args: args, 		peer_urls: config.peer_urls , 		/* target_event_url: , */ 		event_urls: config.peer_event_urls,  		peer_tls_opts: peer_tls_opts, 		endorsed_hook: function(error, res) {}, 		ordered_hook: function(error, res) {} 	};  	return invoke_chaincode_async({ client: fabric_client, channel: channel}, opts) }  function getValue(name) { 	let func = "" 	let args =    	if (name == "a") { 		func = "getA"; 	} else if (name == "b") { 		func = "getB"; 	} else if (name == "c") { 		func = "getC"; 	} else { 		func = "get"; 		args =  name ; 	}  	var opts = { 		chaincode_id: chaincode_id, 		cc_function: func, 		cc_args: args, 		peer_urls: config.peer_urls, 		peer_tls_opts: peer_tls_opts 	};  	return query_chaincode_async({ channel: channel}, opts).then((x) => { return x.parsed }) }  intervalFunc()  {code}  ></description> </Issue>
