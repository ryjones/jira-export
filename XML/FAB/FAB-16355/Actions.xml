<Action id="65848" issue="41914" author="mastersingh24" type="comment" created="2019-11-28 12:22:41.0" updateauthor="mastersingh24" updated="2019-11-28 12:22:41.0"> <body><! CDATA I'm honestly not sure why we did not have the same restrictions for keys from the beginning ... oh well. I think this makes sense ... although we should think about what we want to call the capability .... it should not be named/tied to Couch as I believe we should always be able to have a common set of key/state validation regardless of the underlying database (this of course assumes we will eventually add other state databases).  So the capability should be named something like *VXXDBValidation* as this will allow us to change this if other DBs require more restrictions.  ></body> </Action>
<Action id="66322" issue="41914" author="wenjian" type="comment" body="The capability framework requires the capabilities to be true/false. Talked to  ~denyeart  and we agreed to name the capability as *V2_0_COUCHDB_VALIDATION*. " created="2019-12-19 14:00:37.0" updateauthor="wenjian" updated="2019-12-19 14:00:37.0"/>
<Action id="66447" issue="41914" author="wenjian" type="comment" body="PR: https://github.com/hyperledger/fabric/pull/441" created="2020-01-02 13:32:40.0" updateauthor="wenjian" updated="2020-01-02 13:32:40.0"/>
<Action id="66449" issue="41914" author="jyellick" type="comment" created="2020-01-02 15:04:08.0" updateauthor="jyellick" updated="2020-01-02 15:04:08.0"> <body><! CDATA If we decide a vanilla capability is the way to go with this, then I'm fine with that, but what we had discussed at one point, was adding an explicit "database type" to the application configuration in the channel config.  Essentially require that all peers run on the same statedb for a particular channel.  If we go with capabilities alone, it's probably more flexible, but the support matrix becomes a little concerning.  If a channel has V2_0_COUCHDB_VALIDATION and V3_0_POSTGRESS_VALIDATION (the latter being hypothetical), do we really want to try to support this configuration when running level?  Note, that capabilities are dumb strings, and application capabilities are not validated in any way by ordering, so there is no obvious way to enforce in channel config that only one db-type validation capability is set.  Although it's a bit more work, if we were to go ahead and specify the required statedb type as an application channel config value, then we could go with a simple enum.  By default, if unset, we get "Unenforced" or similar (the current behavior), but, if set, we can specify which statedb type peers must be running to safely participate in this channel.  I guess the fundamental question is "Do we want to allow mixed statedb types on a single channel?".  If the answer is "yes", then the capability route probably makes the most sense (though I worry there are corner cases of couch which we will not properly emulate on level and vice-versa).  If the answer is "no", then I'd think we should explicitly set a DB type.  ></body> </Action>
<Action id="66453" issue="41914" author="denyeart" type="comment" created="2020-01-02 18:39:42.0" updateauthor="denyeart" updated="2020-01-02 18:39:42.0"> <body><! CDATA  ~jyellick  My thinking is that we'd have to allow mixed statedb types on a single channel, for at least two reasons: 1) We know that there are already users with channels of mixed peers of leveldb and couchdb (for example, when it makes sense for some orgs to have query ability while other orgs do not need it) 2) We know that occasionally a channel will want to switch their statedb, e.g. from leveldb to couchdb in order to support rich queries for new chaincodes. And potentially to support switching to new supported databases in the future. Allowing mixed state dbs on a channel would be the path to switching over peers on a rolling basis.  I do agree that channels of mixed statedbs introduces some complexity and risk (which needs to be properly documented for users), but I don't see any alternatives due to the above points. Do you see any other alternatives?  Would it be possible to use an endorsement validation application capability as described in this Jira, but have the capability value be an enum instead of a boolean? Would that be a possible compromise?  ></body> </Action>
<Action id="66456" issue="41914" author="jyellick" type="comment" created="2020-01-02 21:07:26.0" updateauthor="jyellick" updated="2020-01-02 21:07:26.0"> <body><! CDATA So I think I need to understand exactly what our goal is here?  Are we:  A) Trying to ensure that all statedbs are key/value compatible to some common denominator. And, if you were starting a network from scratch, the assumption would be that you would enable this capability in order to ensure that you may safely choose either statedb. B) Trying to specifically make it safe for leveldb peers to mix on couch networks, and, you would _only_ enable this capability if you were going to run some couchdbs on your network.  If it's (A), then I think that the capability, as  ~mastersingh24  suggests _not_ be named after couchdb, but simply implying stronger DB key/value restrictions. Any existing user can/should enable this after auditing that it will not break their application. Any new user should enable this to save themselves headaches in the future.  It it's (B), then I'm not so sure a capability is a good idea. What we're really saying is "Our application data targets Couch formatting, less restrictive DBs should pretend they enforce things like Couch". Because for the next richer database which is not Couch, you're going to need a different capability, and it's going to need to be able to mix with Couch as well. And we'll end up with a matrix of "You can mix Level and Couch, if you enabled the V2_0_COUCH capability, and you can mix Postgress and Couch if you enabled the V3_0_POSTGRESS capability, but you can't mix Postgress with Level, unless you also enable V3_1_LEVEL capability, but then you may no longer mix Level and Couch" (Obviously all made up, but the point being, it becomes difficult to understand, and error prone to implement, because there are so many different permutations). If it's (B), I would say we go back to "specify the statedb type, and require all peers use that DB".  So, if it's (A), I think it's a simple rename of this capability, and some documentation that it should be enabled for all new applications. If it's (B), let's continue on below the bar: ---- Re (1), just because users are doing it, doesn't mean it's a good idea :). For backwards compatibility reasons, I don't think we can/should take this ability away, and I wouldn't advocate it. However, I think it would have been a perfectly reasonable design decision to say "when you create a channel, you must pick your backing state database", and I'm reluctant to immediately take it off the table purely because we've always allowed mixed envs. I'd like to hear some feedback from users on why (1) is done. Is it because couch is somehow a performance bottleneck so endorsers are running level, and dedicated read-only peers are handling queries via couch? Or, (and I suspect this is the case), is it simply that non-endorsing peers don't need couch, so people don't bother to configure it (ie, there's no compelling reason to use level, it's just a default).  Re (2). switching a statedb (safely) is not in general as easy as a rolling upgrade. For instance, this JIRA demonstrates that if the statedb ever contained any non-UTF8 keys, or any JSON values with reserved fields, it would be effectively impossible to migrate from level to couch without an outage (and possibly, at all). After all, I assume the migration path would be to drop the leveldb, restart the peer with couch, and let it rebuild things. But, you can't go back in time and make all transactions couch compliant. In order to migrate safely, I expect it would minimally require some sort of pruning and snapshotting, and likely some sort of kafka->raft style migration strategy where the peers agree on a particular point in time on the ledger when everyone is going to stop processing in the old level way, populate Couch from a snapshot, and then resume processing. I guess my point being that doing a migration via a simple rolling upgrade assumes that all state data is (and always has been valid), which, if that's the case, why have this capability at all?  If doing a migration isn't simple, and requires other non-existent features like snapshotting and pruning, we can always design it properly and extend whatever we decide to use here. {quote}Do you see any other alternatives? Would it be possible to use an endorsement validation application capability as described in this Jira, but have the capability value be an enum instead of a boolean? Would that be a possible compromise? {quote} Regardless, we need a new capability – an application capability only, which changes the way the peer commits, or, a channel capability, which allows us to add a new application channel config value which is richer than a plain string. Since we have yet to release v2.0, we could piggyback on the existing V2_0 channel capability, so it would really just be adding a new application config value.  ></body> </Action>
<Action id="66460" issue="41914" author="denyeart" type="comment" created="2020-01-03 15:33:36.0" updateauthor="denyeart" updated="2020-01-03 20:37:21.0"> <body><! CDATA  ~jyellick   The goal is (B), to allow channel administrators to enable the more restrictive CouchDB validation when they expect some peers to be running CouchDB while other peers are running LevelDB, so that state forks due to database differences as mentioned in the Description can be avoided. I don't think we'd want to shift towards a least common denominator model, as that would get progressively more restrictive over time.  In terms of WHY channels want to use a mix of databases... each use case is slightly different, but the general pattern that I've seen is that people don't want to require CouchDB-based peers for endorsements/transactions on all peers (due to the performance implications or extra setup required), but want to enable individual organizations/peers to utilize CouchDB if they prefer it, for the advanced (read-only) JSON query support. It is common for consortium members to have different query requirements, e.g. a consortirum leader versus normal transactor versus regulator/auditor may agree to common transaction logic but all have very different query requirements to support their enterprises. In this way, the CouchDB usage is well aligned with the v2.0 chaincode model where each organization can customize chaincode functions based on their requirements (we've also discussed an option to support JSON queries outside of chaincode, although the ability to customize chaincode per-organization in v2.0 somewhat reduces this need).  In terms of a single application capability that could evolve to support any future JSON database in addition to CouchDB (MongoDB, PostgreSQL, etc), I personally don't think that is a good idea.  They each have slightly different data requirements/limitations, and I don't think we'd want to repeatedly add more restrictions that could break existing applications at each step. This implies the design as written up - a V2_0_COUCHDB_VALIDATION application capability for now, and potentially other database-specific application capabilities in the future.  The potential migration to other future supported dastabases does indeed get tricky. I don't think Fabric would make guarantees about cross-database support. If a channel administrator wanted to add support for a new database (e.g. PostgreSQL JSON support), to see if their channel data was compatible they would have to bring up a new peer with the database and see if they get the same state commit hash as the existing peers. If so, then they could add another application capability (like V3_0_POSTRESQL_VALIDATION), and let the members know that they could use either CouchDB or PostgreSQL going forward, potentially as part of a rolling migration from CouchDB to PostgreSQL. As you say, it may turn out that their channel data is not compatible with the new database and it would therefore not be possible for them to do such a rolling migration, but I don't think Fabric should do anything to rule out such a migration (deployments may very well have avoided the problematic edge cases that are different on each database, especially since CouchDB happens to be one of the more restrictive JSON databases).  ></body> </Action>
<Action id="66461" issue="41914" author="jyellick" type="comment" created="2020-01-03 17:22:38.0" updateauthor="jyellick" updated="2020-01-03 17:22:38.0"> <body><! CDATA  ~denyeart  You're the database expert here, so if you still think a per DB type application capability is the way to go, I'll defer to you.  But, before I go, a couple thoughts:  * It sounds to me much less like a "DB Type" and more of a set of "StateDB Restrictions". The restrictions limit both the valid keyspace and valuespace which chaincodes can access.  Level's keyvaluespace is essentially unrestricted (I believe), so it should be compatible with any subset of the keyvaluespace, while couch has restriction and therefor to safely run couchdb you must have at least the couchdb restrictions in place.  In this sense I find 'COUCHDB_VALIDATION' to be a fairly misleading name -- it's really more of 'COUCHDB_DATA_RESTRICTIONS' or something like that. * If we go this route then my take would be: move all of these checks (which currently exist in the couch path) out into the common path, and _only_ enforce them if a) the capability is enabled, b) the capability is disabled and the V2_0+ application capability is not enabled.  Then, in the couchdb path we can/should treat any errors due to illegal keys/values as fatal -- if we do not, these errors are forking (as they are today).  As a  side-effect, if you are running couch and enable the V2_0 application capability, you _must_ also enable the corresponding couchdb capability to ensure your transactions do not trigger the fatal couch errors. * I don't love the upgrade story of rebuilding a statedb and checking hashes to see that they match, if instead we treat illegal key/values as fatal in the DB commit path (always for new DBs, and if V2_0 application capability is on for couchdb), then I think the story improves.  Instead of getting a divergent statedb, you simply get a peer which declares "I can't commit valid transaction a8234bc because it contains illegal key/values for this statedb type" and gives up.  ></body> </Action>
<Action id="66462" issue="41914" author="denyeart" type="comment" created="2020-01-03 20:09:35.0" updateauthor="denyeart" updated="2020-01-03 20:09:35.0"> <body><! CDATA  ~jyellick  I agree with the suggestions.  V2_0_COUCHDB_DATA_RESTRICTIONS is a better capability name than V2_0_COUCHDB_VALIDATION, especially since it is enforced at endorsement time rather than validation time, due to the requirement to check private data which won't be available on all peers at validation time (similar to the direction we've taken with validating lifecycle rules at endorsement time, rather than a hybrid of endorsement time and validation time). I had V2_0_ in the name so that the data restrictions could be extended over time if something is discovered, but I guess we could drop the V2_0_ part and consider any new discoveries as defects to fix in the COUCHDB_DATA_RESTRICTIONS checks.  With it being a channel level config, I agree the CouchDB peer level checks get moved to common checks on all peers when the capability is enabled. And I agree that we document that channels with CouchDB peers should enable COUCHDB_DATA_RESTRICTIONS at the same time as enabling V2_0_0 app capability, with the V2_0_0 app capability being the trigger to stop the existing peer-specific CouchDB validations. And like other unexpected issues at commit time, have peer panic (or stop processing channel blocks) if an issue is hit while committing to database, rather than silently forking the state.  It's not a perfect story since there could still be database specific unknowns (unexpected data limitations in a specific database, unexpected differences in range query behavior), but I think it is an improvement over the larger existing risk of state forks. We'll need to document that the general guidance is still to use a common database type on all peers to completely eliminate risk of database specific unknowns - chaincode authors are still responsible for ensuring that their chaincodes work across databases if they'd like to support peers with different databases.  ></body> </Action>
<Action id="66464" issue="41914" author="jyellick" type="comment" body="+1 sounds good to me." created="2020-01-03 20:48:58.0" updateauthor="jyellick" updated="2020-01-03 20:48:58.0"/>
<Action id="66541" issue="41914" author="denyeart" type="comment" created="2020-01-08 18:30:19.0" updateauthor="denyeart" updated="2020-01-08 18:39:56.0"> <body><! CDATA After discussing with Manish, we have decided to put this one on hold and investigate more stringent config options that would allow for ensuring all channel members were either on leveldb or couchdb.   https://github.com/hyperledger/fabric/pull/441  has been closed for now.  ></body> </Action>
