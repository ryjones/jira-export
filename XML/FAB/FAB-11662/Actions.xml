<Action id="49188" issue="33058" author="denyeart" type="comment" body=" ~manish-sethi  What&apos;s your opinion?" created="2018-08-21 17:26:43.0" updateauthor="denyeart" updated="2018-08-21 17:26:43.0"/>
<Action id="49680" issue="33058" author="yoheiueda" type="comment" body=" ~yacovm  taught me that gossip (and org leadership) is not related to this issue, so I simplified the workaround method described in the attached PDF file." created="2018-08-31 08:34:31.0" updateauthor="yoheiueda" updated="2018-08-31 08:34:31.0"/>
<Action id="49811" issue="33058" author="sykesm" type="comment" body=" ~denyeart  I&apos;m unable to change work item types. Can you change the type of this item from Bug to a Story? As far as I can tell, what we have right now is not broken, simply sub-optimal; ie. not a bug." created="2018-09-04 13:23:08.0" updateauthor="sykesm" updated="2018-09-04 13:23:08.0"/>
<Action id="49879" issue="33058" author="denyeart" type="comment" created="2018-09-05 10:28:26.0" updateauthor="denyeart" updated="2018-09-05 10:28:26.0"> <body><! CDATA  ~yoheiueda  You mention chaincode hangs, what is the ultimate result in that scenario?  Do the chaincode executions eventually succeed?  Or do they time out and fail, requiring the client to resubmit?  In any case, clients must handle chaincode execution errors and have ability to resubmit.  ></body> </Action>
<Action id="49880" issue="33058" author="denyeart" type="comment" body=" ~sykesm  You can change type by going to More–&gt;Move.  Unfortunately the Jira wizard is required now that different issue types have different fields.  Let&apos;s see how Yohei responds first, to understand how bad the experience is." created="2018-09-05 10:29:09.0" updateauthor="denyeart" updated="2018-09-05 10:29:09.0"/>
<Action id="49887" issue="33058" author="yoheiueda" type="comment" created="2018-09-05 13:35:01.0" updateauthor="yoheiueda" updated="2018-09-05 13:35:01.0"> <body><! CDATA  ~denyeart   sendTransactionProposal returns with a timeout error. I guess it eventually returns successfully if I set a very long timeout value. Resubmitting transactions is OK. We don't mind VERSION_CONFLICT errors when chaincode upgrade is committed.  The point is that upgrading chaincode causes down time for several minutes. Resubmitting the transaction again during chaincode upgrade results in an timeout error again.  I am not sure whether this behavior is documented or not.  Even if this is not a bug, we hope this issue will be fixed in near future.  There is a workaround if we have multiple peers in an org, but the workaround complicates our management procedures.  sendUpgradeProposal can send upgrade requests to multiple peers, and building chaincode on all peers is processed in parallel. However, we can't use this feature because of the hang issue. We need to upgrade chaincode on each peer one by one, while stopping sending transactions from clients to the peer.            ></body> </Action>
<Action id="49922" issue="33058" author="manish-sethi" type="comment" created="2018-09-05 19:59:15.0" updateauthor="manish-sethi" updated="2018-09-05 20:15:12.0"> <body><! CDATA  ~yoheiueda  - you are right that the lock based model is not suitable for log running simulations. I would prefer either of the two approaches.  1) Generic lock free simulation/commit approach which will work not only for the above scenario but for any long running business transaction as well (if they happen to be there). Also, in general, this is expected to increase the overall transaction throughput. This will be implemented based on variation of timestamp-based concurrency control technique. This should not very difficult to implement because since beginning, this option was kept open and the existing txmgr implementation was managed behind a set of interfaces.  2) The solution number one that you suggested in the your list above. In which, in the endorser/peer, the TxSimulator is obtained either before or after the build process - as in the lock based implementation TxSimulator is a costly resource and should be acquired only for state related changes -  ~sykesm  - is this something easily doable?  Other approaches listed above would really create more complications of managing case specific locks (e.g., commit would anyway require lock on all the chaincodes) and has potential to create other problems in chaincode-to-chaincode invocations - and hence not worth in my opinion - Instead, I would simply prefer generic lock free approach (mentioned above) as this will give protection against long running business transactions as well and also has potential to increase throughput (especially good-throuput - since a portion of transaction conflicts would be detected at the simulation time itself).  ></body> </Action>
<Action id="49924" issue="33058" author="denyeart" type="comment" body="I&apos;ll tag as v1.4.0 to keep this on the radar." created="2018-09-05 20:10:12.0" updateauthor="denyeart" updated="2018-09-05 20:10:12.0"/>
<Action id="60943" issue="33058" author="yoheiueda" type="comment" created="2019-06-13 08:38:34.0" updateauthor="yoheiueda" updated="2019-06-13 08:38:34.0"> <body><! CDATA  ~manish-sethi   ~sykesm   ~denyeart   I prototyped the first solution in the list of Manish's comment. Please see FAB-11702  I conducted an experiment with the prototype, and I confirmed that service interruption due to chaincode upgrade is alleviated as described in the design doc.   https://docs.google.com/document/d/1GSRnlZLOqZvupUara0w2emEsVeQgO4cxUq9T0QwMEts/edit#heading=h.kf53oz92t4o0   ></body> </Action>
