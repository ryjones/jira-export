<Issue id="33598" key="FAB-11919" number="11919" project="10002" reporter="guoger" assignee="guoger" creator="guoger" type="10003" summary="Support snapshot" priority="3" resolution="10000" status="6" created="2018-09-09 09:41:03.0" updated="2018-12-01 06:22:29.0" resolutiondate="2018-11-24 12:13:31.0" votes="0" watches="2" workflowId="44892"> <description><! CDATA A summary of snapshotting in etcd/raft.  We will use *application* to denote component that interacts with etcd/raft node API, e.g. read data from {{Ready()}}, {{tick}} raft node, etc. We will be referring to etcd/raft node as *raft*. h2. workflow in swarmkit (snapshot data encapsulated in raft snapshot message) # *application* takes snapshot at its own pace (e.g. per N entries, blocks, etc) -- collect _data_ to be stored in a snapshot. Application should be able to reconstruct state from _data_ -- call {{MemoryStorage.CreateSnapshot()}} with data to create a {{snap raftpb.Snapshot}} -- persist {{snap}} to {{WAL}} with {{WAL.SaveSnapshot}} -- persist {{snap}} to _disk_ with {{Snapshotter.SaveSnap}} -- purge raft entries _in memory_ with {{MemoryStorage.Compact}} # when *raft leader* detects _local missing entries_ (purged in 1.) requested by a slow *raft follower*, it retrieves most recent snapshot and sends to that follower (via {{Ready.Messages}}, which contains _data_ that is used to reconstruct state) # *application* is responsible to send this message to follower via _transport_ -- call {{Node.ReportSnapshot}} with either {{SnapshotFinish}} or {{SnapshotFailure}} # when *application* of slow follower receives this snapshot encapsulated in {{Ready.Messages}}, it calls {{Node.Step()}} of underlying *raft* as usual # slow *raft follower* presents this snapshot in {{Ready.Snapshot}} to *application* # *application* should handle this {{snap raftpb.Snapshot}} in following ways: -- persist {{snap}} to {{WAL}} with {{WAL.SaveSnapshot}} -- persist {{snap}} to _disk_ with {{Snapshotter.SaveSnap}} -- apply {{snap}} to memory with {{MemoryStorage.ApplySnapshot}} -- apply {{data}} in {{snap}} to local state machine to reconstruct state  h2. workflow in etcd (snapshot data is pushed from leader to follower) workflow in etcd differs from that in swarmkit mainly in how {{Snapshot}} in {{Ready.Messages}} is handled. # *application* takes snapshot at its own pace (e.g. per N entries, blocks, etc) -- collect _data_ to be stored in a snapshot. Application should be able to reconstruct state from _data_ -- call {{MemoryStorage.CreateSnapshot()}} with data to create a {{snap raftpb.Snapshot}} -- persist {{snap}} to {{WAL}} with {{WAL.SaveSnapshot}} -- persist {{snap}} to _disk_ with {{Snapshotter.SaveSnap}} -- purge raft entries _in memory_ with {{MemoryStorage.Compact}} # when *raft leader* detects _local missing entries_ (purged in 1.) requested by a slow *raft follower*, it retrieves most recent snapshot and sends to that follower (via {{Ready.Messages}}, which contains _data_ that is used to reconstruct state). *Note* that this message of type {{raftpb.MsgSnap}} is *not* actually sent to follower via transport, see  this|https://github.com/etcd-io/etcd/blob/master/etcdserver/raft.go#L363  # *application* _push_ snap data to follower node by invoking an application-specific API -- call {{Node.ReportSnapshot}} with either {{SnapshotFinish}} or {{SnapshotFailure}}  h2. workflow in fabric (snapshot should be pulled from other orderers on demand) what we should do in fabric is a _pull_ based flow, as pointed in design doc (it differs from swarmkit only in very last bullet). {quote}apply {{data}} in {{snap}} to local state machine to reconstruct state {quote} use `BlockFetcher` (implemented in FAB-12398) to fetch missing blocks from other orderer  ></description> </Issue>
