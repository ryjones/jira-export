<Action id="35345" issue="24434" author="ales" type="comment" created="2017-11-22 15:36:48.0" updateauthor="ales" updated="2017-11-22 15:36:48.0"> <body><! CDATA h1. Problem  The Init function of a chaincode is supposed to be called when the chaincode is instantiated (or upgraded). With the new tree-based cc lifecycle, Init is no longer called as part of a chaincode deploy/upgrade (nor could it since deploy/upgrade no longer are endorser transactions producing a RWSet). h1. Solution approach  Remove support to invoke the Init function of a chaincode.  Pros: * the Init function encourages an anti-pattern: the cc developer may wrongly assume that the Init function is always invoked on any peer and so local Initialization may be performed inside the Init function (whereas as we know the Init function is only called on the node that receives the deploy/upgrade request) * the deploy flow would be greatly simplified * if a cc developer decided to expose a function for initial setup, they can do so * if a cc developer decided to expose a function for initial setup, it would be guaranteed that its invocation is checked against the cc's endorsement policies (as it is the case for any other cc function) as opposed to treating Init as a special function  Cons: * there is no longer any guarantee that if the chaincode is instantiated, the Init function has been invoked; if the cc developer requires that guarantee, they can achieve it by leveraging MVCC checks (e.g. by introducing a read dependency)  h1. Other approaches and why they are not desirable  A possible alternative would be one where we try to force atomicity between the config update tx that deploys/upgrades a chaincode and the endorser tx that contains the initial rwset. This atomicity could be achieved by * setting a flag when the config update tx is committed * refusing any invocation of the chaincode while that flag is set * clear that flag when the Init endorser tx is committed  The flag may be stored in a protected namespace of the ledger (e.g. LSCC's) or in the config tree itself, requiring another config udpate to clear it.  This approach is not desirable because, in order to cater for the infrequent case in which a chaincode developer requires a special initialization function, we introduce additional flags and complicate the deploy/upgrade process. h2.    ></body> </Action>
<Action id="35346" issue="24434" author="ales" type="comment" body=" ~jyellick ,  ~yacovm ,  ~denyeart ,  ~manish-sethi ,  ~aambati ,  ~elli-androulaki ,  ~angelo.decaro ,  ~muralisr  pls comment" created="2017-11-22 15:43:42.0" updateauthor="ales" updated="2017-11-22 15:43:42.0"/>
<Action id="35348" issue="24434" author="jyellick" type="comment" created="2017-11-22 16:01:04.0" updateauthor="jyellick" updated="2017-11-22 16:05:20.0"> <body><! CDATA To me, this really makes the chaincode interface cleaner.  The notion that there was a special, only chaincode-to-chaincode invokable {{Init}} function which had different rules from other chaincode invocations strikes me as inconsistent and unnecessary.  Especially as users seem to already be confused by the existing semantics, treating it as a standard chaincode invocation makes sense to me.  Although I'm obviously in favor, I'd also like to invite input from  ~jeffgarratt  who has weighed in on this issue before with some points for retaining the {{Init}} function.  I'm also adding the review-needed label.  I realize this is a sub-task, and not a feature, but as it's an architectural decision it seems appropriate.  If there's some other documented process we should be following, I'd love to hear about it.  ></body> </Action>
<Action id="35352" issue="24434" author="binhn" type="comment" created="2017-11-22 18:46:32.0" updateauthor="binhn" updated="2017-11-22 18:48:07.0"> <body><! CDATA -1  First, this change can't be a sub-task of something else. It is a change in the programming model that impacts all chaincode developers, so we should propose it as appropriate to allow people a chance to comment and contribute.   Second, the description is not complete and incorrect. We should include background why we got here and why we don't need init. Statement such as "there is no longer any guarantee that if the chaincode is instantiated, the Init function has been invoked" requires explanation for readers to understand. It's been working this way since OBC. And "the Init function encourages an anti-pattern" is incorrect as we architecturally specified that chaincode runs only on endorsers, not all peers. This is misinformed.  Last, we need to capture the purpose of Init as it was designed to do in the programming model, and specify the compatibility for the change as this is a minor release that we can't tell people that their chaincodes no longer work.  So I strongly recommend the author to create a new JIRA or google doc proposing the changes and invite the Fabric community to review and comment.      ></body> </Action>
<Action id="35353" issue="24434" author="jyellick" type="comment" created="2017-11-22 19:37:36.0" updateauthor="jyellick" updated="2017-11-22 19:37:36.0"> <body><! CDATA > First, this change can't be a sub-task of something else. It is a change in the programming model that impacts all chaincode developers, so we should propose it as appropriate to allow people a chance to comment and contribute.  I'm not sure what the process around something like this is.  I think  ~ales  opened this as a sub-task, because it is related to the lifecycle work in the current parent work item of FAB-6042, but recognizes that this is a departure from the current architectural model, and created this item explicitly so that people could comment on this separately.  If there is some official documented process for how this should have been opened, I'd love to learn about it.  > Second, the description is not complete and incorrect. We should include background why we got here and why we don't need init. Statement such as "there is no longer any guarantee that if the chaincode is instantiated, the Init function has been invoked" requires explanation for readers to understand. It's been working this way since OBC.  I'll let Ale update the description, but for those who might simply be following this thread, the basic problem is as follows.  Chaincode is not necessarily installed to all orgs, and sometimes, an org's permission must be required to deploy a chaincode in a channel, even though that org does not have the chaincode.  So, the group which approves deploying the chaincode cannot necessarily generate the RW set for that chaincode, and the group which can generate the RW set cannot necessarily authorize the deployment of that chaincode.  Because of this, the old model of bundling the approval to deploy, along with the the result of invoking {{Init}} on the target chaincode is problematic.  > And "the Init function encourages an anti-pattern" is incorrect as we architecturally specified that chaincode runs only on endorsers, not all peers. This is misinformed.  I do not believe that is what Ale was attempting to convey.  This has actually been a problem since the OBC days when chaincode was available on all peers.  The notion of {{Init}} intuitively conveys to developers that they may expect that the {{Init}} function is called in their local chaincode instance before other methods are invoked.  However, this is of course very incorrect for multiple reasons.  First, a peer which is running the chaincode may never have {{Init}} invoked (if it is not chosen to be part of the endorsement set).  Secondly, even if {{Init}} is called for the chaincode, if the chaincode container restarts, any local side effects of {{Init}} are lost.   Of course any ledger affects of {{Init}} will be reflected through the network, but this appears to be a common source of confusion for developers.  > Last, we need to capture the purpose of Init as it was designed to do in the programming model, and specify the compatibility for the change as this is a minor release that we can't tell people that their chaincodes no longer work.  Certainly, this is something we should discuss, and one of the reasons for opening this JIRA.  I would point out, that this is an opt-in change, that any change in chaincode behavior would occur only after modifying the application channels to enable the new v1.1 capabilities, so a user may safely upgrade their binaries to v1.1 without any incompatiblity.  ></body> </Action>
<Action id="35366" issue="24434" author="muralisr" type="comment" created="2017-11-23 11:09:06.0" updateauthor="muralisr" updated="2017-11-23 12:20:49.0"> <body><! CDATA  ~jyellick   ~ales  After giving it thought, to me the core problem here is one of semantics. The intent of the "Init" was "on Instantiation" and not  "on Initiailization". It gives the opportunity for the some data (or metadata) to be set at the time of the chaincode coming alive on the channel. To draw a loose parallel, a bit like the metadata we put on the genesis block when creating the chain.  Thinking of the method as "OnInstantiation" instead of "Init" will clear the air around confusion as to when that method will be used.  Viewed in that light, I believe there is some value to having this - or something like this. It provides some direction and best practices for use cases that need it instead of having to stuff it Invoke with the need to call a "init" argument before anything else.  If we grant that, we now need a RW set for the OnInitialization metadata. And if we admit _that_ , the natural way to implement that would be as a method on the chaincode.  This brings us right back to the need to call that atomically (would we split the genesis block creation into two with a "create" TX and a "SetMetadata" TX) ?   It may be expedient to just remove the "Init" method to make the config-based chaincode instantiation easier but IMO, this actually brings out the concerns with the approach.  ></body> </Action>
<Action id="35368" issue="24434" author="ales" type="comment" created="2017-11-23 12:29:22.0" updateauthor="ales" updated="2017-11-23 12:29:22.0"> <body><! CDATA Thanks  ~jyellick  for the answers above.  ~binhn : just to reiterate: * I have witnessed first-hand the fact that Init encourages cc developers to make mistakes since I've seen  developers overriding Init countless times to perform some local initialization in the hope that it would be executed on every active chaincode; * this is indeed a change in the programming model, but one that is linked to a larger change in the deployment model, which is why it's a sub-task of FAB-6042   ~muralisr ,  ~binhn : may you please weigh in on the proposed alternative approach? That is, if they so require, chaincode developers can achieve exactly what they achieve today by implementing an initialization function and - if atomicity is required - introduce a read dependency. Though there is overhead, it is minimal (one read dependency per tx that needs to check against initialization status).  ></body> </Action>
<Action id="35370" issue="24434" author="muralisr" type="comment" body=" ~ales  Sounds like you overlooked my comment above where I attempt a rationale for the &quot;init&quot; function (your comment above reads as though you hadn&apos;t seen it...)." created="2017-11-23 12:42:46.0" updateauthor="muralisr" updated="2017-11-23 12:42:46.0"/>
<Action id="35377" issue="24434" author="ales" type="comment" body="Ah sorry  ~muralisr , I have indeed missed your comment - my window hadn&apos;t refreshed after Jason&apos;s latest comment - apologies. Will read, digest and respond. Thx!" created="2017-11-23 13:54:21.0" updateauthor="ales" updated="2017-11-23 13:54:21.0"/>
<Action id="35381" issue="24434" author="ales" type="comment" created="2017-11-23 14:19:21.0" updateauthor="ales" updated="2017-11-23 15:05:27.0"> <body><! CDATA > The intent of the "Init" was "on Instantiation" and not "on Initiailization" Agreed, that's what our current Init does (and so at least we agree it's incorrectly named).  As to whether it is required to set additional metadata atomically: I can't say. FWIW I can only report from the PoCs I've seen, none of which required that feature.  Basically, given that FAB-6042 has been approved, I only see 2 options: # remove init (this fab's proposal) # add init via a separate transaction and introduce support to guarantee atomicity (-Yacov's proposal-, as described above by Yacov for the sake of completeness)  ></body> </Action>
<Action id="35382" issue="24434" author="yacovm" type="comment" created="2017-11-23 14:39:32.0" updateauthor="yacovm" updated="2017-11-23 15:27:32.0"> <body><! CDATA  I would like to hear what proposals  ~binhn  and  ~muralisr  have such that: * When we associate a chaincode to a channel, we set an endorsement policy * The policy can be signed by any number of parties in the channel * It is possible to setup the channel such that such a policy *has* to be signed by *specific* and *different* parties in the channel  ></body> </Action>
<Action id="35387" issue="24434" author="muralisr" type="comment" created="2017-11-24 01:42:17.0" updateauthor="muralisr" updated="2017-11-24 01:42:17.0"> <body><! CDATA  ~yacovm   ~ales  Actually an alternate approach has been discussed on and off in various places. Collecting them together here.  +Changes to fabric+ * add a "signatures" field to Proposal proto * add validation using signatures in the proposal agains a policy in lscc and vscc * a new "peer proposal" command with "create and sign" sub-options (equivalently in SDK)  +Workflow for instantiate and upgrade+ * peer chaincode package -s -i <*instantiation policy for cc*> -p <cc path> -n <cc name> -v <cc version> ** create a CC package using the *SignedChaincodeDeploymentSpec* (ignore the *owner_endorsements* field there for now) * peer proposal create *<proposal for instantiate/upgrade>* ** write out the proposal that is currently created under covers for instantiate/upgrade * distribute the proposal to parties needed to sign as per the instantiation policy for the CC in the package ** each member will use the *peer proposal sign* command to sign the proposal * normal workflow resumes - install package followed by instantiate/upgrade using the signed proposal ** lscc will check the sigs against the instantiation policy in the CC and so will vscc ** in addition the usual endorsement process provides another layer of protection  *Note 1* - A nice side effect of this is that it expands the protocol and opens up signed proposal workflow for normal invokes as well *Note 2* - those comfortable with the original workflow will continue to work with the raw chaincode package (predominately in test and dev but likely be useful in other flows as well where the "offline" collection is too heavy handed or there are other means to add more security.)  I believe  ~elli-androulaki  was the one who came up with the multi-sig idea for proposals (could be wrong though ... if so let me know and I'll scratch this Elli. Only reason I mention here is because I think this is a cool idea...)     ></body> </Action>
<Action id="35390" issue="24434" author="jyellick" type="comment" created="2017-11-24 06:18:38.0" updateauthor="jyellick" updated="2017-11-24 06:18:38.0"> <body><! CDATA  ~muralisr , the proposal outlined in your post is perhaps one of the most natural, and preserves many of the existing semantics, however, basing lifecycle off of the instantiation policy is in my opinion, fundamentally and fatally flawed.  A basic requirement for fabric (and the original impetus for introducing instantiation policies) is to restrict who can instantiate chaincodes on a channel.  Unfortunately, since a chaincode instantation policy is supplied by the instantiator, and the instantiation policy is what governs whether a chaincode can be instantiated, this requirement can never be satisfied.  Because of this, there is actually no way to prevent even a single rogue channel member (even without administrative rights) from instantiating a chaincode of their choosing.  To me this is the most fundamental flaw with attempting to govern instantiation via instantiation policies, and why the new lifecycle proposal does not depend on them.  It's possible to extend the non-config-based lifecycle proposal  by adding additional policies, which are defined somewhere else in lifecycle for the channel and which are evaluated in addition to the instantiation policy.  But this leads to other questions, how are these other policies mutated? What about cases when the instantiation requirements are different from the upgrade requirements? By leveraging the existing channel config framework (as FAB-6042 does), these questions come with free answers, and a fairly small amount of code required to implement them.  Per the vote in FAB-6042, my impression is that moving the lifecycle to the config model is the architectural decision which the maintainers have agreed to.  Although it's a good idea to re-examine our decisions when more information comes to light, I'd be curious to hear a proposal about how to handle {{Init}} under the assumption the lifecycle transitions to the config tree.  ></body> </Action>
<Action id="35392" issue="24434" author="yacovm" type="comment" created="2017-11-24 07:17:44.0" updateauthor="yacovm" updated="2017-11-24 07:39:40.0"> <body><! CDATA {quote}I'd be curious to hear a proposal about how to handle Init under the assumption the lifecycle transitions to the config tree.{quote}  We can always make it none-atomic, in a separate transaction that comes after the channel config, but that has 4 implications and are *quite serious*: # An Init() might not ever run, because the client might simply crash right after the resource config transaction. # This would make Init() race with Invokes and then Init() might not ever pass MVCC or pass MVCC and by doing so - override invokes of users. ## Unless of course, the users put custom code in Invoke()s that detects init: # This would require users to put custom crafted keys to detect an Init(), should they want to have atomicity # There is no real way of enforcing Init() is run before Invokes, on the chaincode.    Another approach, to make it atomic- would be simulating Init() on a set of peers that for the set, the endorsement policy holds, and do it at the time of sending the resource config to ordering, and put the RWSet in a special field, like we do in instantiate currently. My observations to this option are (and I summon / invite  ~manish-sethi  or  ~denyeart  to comment or elaborate) * If we want to enforce MVCC on Init(), it is none trivial and complex because you have 2 kinds of transactions - a resource config, and an endorser transaction, both bundled into one and: ** If the resource config transaction "passes through", the versions of the RSet of the Init() could be wrong, and this means we need to rollback the resource config transaction too! Now of course we first validate and only later commit, so there is no real rollback, but the complexity argument still holds. * If we say we don't want to enforce MVCC in Init(), this would require to enforce that it doesn't have a RSet, and this is a new requirement that doesn't exist now.  Note: To be clear, I am not advocating here against the resource config approach or pro these 2 approaches, just listing possible options and their disadvantages / challenges.   ></body> </Action>
<Action id="35407" issue="24434" author="muralisr" type="comment" created="2017-11-25 18:48:32.0" updateauthor="muralisr" updated="2017-11-26 20:54:50.0"> <body><! CDATA (I think this discussion now belongs in FAB-6042 but proceeding here for now for continuity.)   ~jyellick  {quote} A basic requirement for fabric (and the original impetus for introducing instantiation policies) is to restrict who can instantiate chaincodes on a channel. Unfortunately, since a chaincode instantation policy is supplied by the instantiator, and the instantiation policy is what governs whether a chaincode can be instantiated, this requirement can never be satisfied.  {quote} If you look at the workflow, the instantiation policy is stored with the chaincode as part of the package created for install. In other words, it is in the chaincode package and is NOT provided/computed during instantiation of the chaincode on the channel.  Let's add detailed steps to the workflow in my previous comment. Let us start at the point where the chaincode package containing the instantiation policy is installed and a user needs to instantiate the chaincode : * proposal for the instantiation/upgrade is created * above proposal is sent to users who'll sign it (i.e., those who will satisfy the instantiation policy) * the proposal with all the signatures is submitted for instantiation/upgrade * endorsing side checks the signatures against the instantiation policy in the chaincode package ** If successful, an entry is made in LSCC which also adds the instantiation policy from the chaincode package to the record (note that currently we cook up an admin policy on the fly which is at the core of the issue) * endorser signs the response. This is another signature orthogonal to the proposal signatures which is useful for multi-peer submissions and such * on the committer side VSCC does the instantiation and does the same signature checks as done on the endorser side using the instantiation policy in the lscc record  The key is that the chaincode package contains the instantiation policy and not computed at the time of instantiation.  Note that above is still a sketch even with the details ... hoping there are no major holes that cannot be fixed. For instance, to prevent rogue admin from creating a chaincode and instantiating them we could have a channel TX policy on who can instantiate CCs.  But maybe I'm missing something... the goal here is to get this right. What holes are there in the above flow that only a config TX based workflow can fix ?    ></body> </Action>
<Action id="35497" issue="24434" author="jyellick" type="comment" created="2017-11-27 14:33:31.0" updateauthor="jyellick" updated="2017-11-27 14:42:27.0"> <body><! CDATA  ~muralisr  Let's ignore the case where the chaincode even exists, because I think it is distracting.  Let's say I happen to have authority to transact (as a writer) on the channel.  I create an LSCC invocation, where the instantiation policy is set to "only my signature" and the endorsement policy is set to "only my signature", and I make up a name, hash, and version.  I submit this transaction.  During evaluation, the peer can see that: the instantiation policy is satisfied, the endorsement policy is satisfied, and there is no reason to deny this transaction.  So now, I, an unprivileged user on the channel have caused all peers to initialize a chaincode namespace for me, and I can force those peers to maintain and manipulate that state, and generally use the channel for whatever purpose I would like.  There's further no way for even the admins of the channel to delete this namespace, because they cannot satisfy the instantiation or endorsement policies.  I see no way around this without introducing some other "this is the minimum and override requirements to instantiate or modify a chaincode" policy.  At which point, the utility of an instantiation policy becomes limited at best, and can actually be enforced purely locally to a peer without exposing the policy to the rest of the network.  ></body> </Action>
<Action id="35508" issue="24434" author="binhn" type="comment" created="2017-11-27 16:10:12.0" updateauthor="binhn" updated="2017-11-27 16:11:57.0"> <body><! CDATA It looks like you guys don't heed my advice and keep on at this here.   ~jyellick  {quote}If there is some official documented process for how this should have been opened, I'd love to learn about it. {quote} I thought  ~ChristopherFerris  has provided education and numerous emails to IBM developers on this project about how to engage with community. We call ourselves "maintainers" not merely developers for a reason. We are not only responsible for producing a quality product but building an engaging and vibrant community. The most effective way to keep people engaged is to provide everyone opportunities to do so. There is no official document for this, just common sense and responsibility of a maintainer.  I am repeating: this item impacts the programming model. We should create a story JIRA and email the community. I actually didn't know about this item; someone told me. So please, all of us need to act properly for a mature project. We are post 1.0 release, so potential external changes must be communicated early.  Some of you here referred to FAB-6042 as something that has been approved, and this item is just an unfortunate by-product of that. In my mind, FAB-6042 hasn't properly vetted, and I wrote my disagreements there. This item proves my point.      ></body> </Action>
<Action id="35513" issue="24434" author="jyellick" type="comment" created="2017-11-27 16:50:19.0" updateauthor="jyellick" updated="2017-11-27 16:50:19.0"> <body><! CDATA  ~binhn   {quote} I thought Christopher Ferris has provided education and numerous emails to IBM developers on this project about how to engage with community. We call ourselves "maintainers" not merely developers for a reason. We are not only responsible for producing a quality product but building an engaging and vibrant community. The most effective way to keep people engaged is to provide everyone opportunities to do so. There is no official document for this, just common sense and responsibility of a maintainer. {quote}  There is nothing nefarious going on here.  My understanding has always been that items which require additional scrutiny, vetting, discussion, and ultimately voting, should be tagged with the 'review-needed' label.  To me, the classification of the issue, be it task, bug, feature, or epic is orthogonal to this concept, and so my attempt to raise the visibility of this question was to add this label.  If there is some other process (such as converting the issue into some other type) then certainly we should do that, but this veers away from 'common sense' and into process (hence my question).  {quote}  Some of you here referred to FAB-6042 as something that has been approved, and this item is just an unfortunate by-product of that. In my mind, FAB-6042 hasn't properly vetted, and I wrote my disagreements there. This item proves my point.  {quote}  There are certainly a lot of moving pieces to FAB-6042, but as I am discussion with  ~muralisr  above, I believe there are some fundamental problems with the original design of the lifecycle.  I've yet to see a proposal to address these problems outside of FAB-6042 which stands up to scrutiny.  ></body> </Action>
<Action id="35531" issue="24434" author="elli-androulaki" type="comment" created="2017-11-27 21:06:42.0" updateauthor="elli-androulaki" updated="2017-11-27 21:06:42.0"> <body><! CDATA Hi,  So, two comments from my side.  1) For some use-cases, knowing in advance or being able to inspect initialisation parameters is important parameter when deciding whether to trust or not an application. Take for example a (simplified) asset management use-case where initialisation sets the "admins" of the system, i.e., entities authorised to import assets. If there is no initialisation parameters commitment at instantiation phase that a user can inspect, the endorsers would quest for a match against, it is not clear to me how endorsement policy would suffice. One can of course shift the responsibility (and trust) to the init function invocation policy, but – given this would be restricted to single signature – it would be one party trusted to do the initialisation of the chaincode correctly. Simply put, where do we want to put trust on during instantiation:   a) Endorserment policy only (this may be insufficient for some cases)  b) Endorsement policy + initialisation input    c) Endorsement policy + init invocation policy (not sure this is in place)  This is assuming of course we are always trusting any channel-related chaincode deployment policy (i.e. parties that can jointly decide on adding removing a chaincode from a channel).   2) Regardless of how chaincode lifecycle operates, as  ~muralisr  mentioned, it is  worth extending proposal and transaction format to support multiple creators. For example if option (c) is used there and init invocation is possible by a threshold of parties having agreed to the input, this is not possible today, with the existing proposal and transaction format.  ></body> </Action>
<Action id="35543" issue="24434" author="jyellick" type="comment" created="2017-11-27 23:08:40.0" updateauthor="jyellick" updated="2017-11-27 23:08:40.0"> <body><! CDATA Based on the feedback here, and in the interest of minimizing changes and pain to our users, I've created proposal FAB-7114 as a sub-task of FAB-6042.  This proposal has been developed in collaboration with  ~muralisr  and preserves the {{Init}} function, in addition to generally adhering to the existing v1.0 lifecycle workflow more closely.  I've opened this as a sub-task of FAB-6042 because it is related, but have added the review-needed label to hopefully gain additional attention from the community.  As it is also preserves the existing chaincode {{Init}} mechanics, it also feels less appropriate to make it some other sort of task.  Because the proposal in this issue does not appear to have widespread support, I would propose that we close it, and move our discussion to FAB-7114.  ></body> </Action>
