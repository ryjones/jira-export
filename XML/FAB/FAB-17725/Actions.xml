<Action id="68776" issue="44757" author="sykesm" type="comment" created="2020-04-08 22:36:40.0" updateauthor="sykesm" updated="2020-04-08 22:36:40.0"> <body><! CDATA So I'm not a samples guy because the scripts hide the meaningful steps. There isn't a single package or install command listed in your steps to reproduce and the commands are spread across scripts and containers.  That said, the output from the build implies that the modules.txt is actually included in the package. The build is highlighting that something is missing from the file - not that the file is missing.  Additionally, when I locally vendor code with {{go mod vendor}} and package the chaincode with {{peer lifecycle chaincode package}}, the resulting package does include the vendor/modules.txt file.  {code} dev-box   master → origin {2} U:2 ?:3  ~/workspace/fabric/src/github.com/hyperledger/fabric/core/chaincode/platforms/golang/testdata/ccmodule  $ go version go version go1.14.1 linux/amd64 $ go mod vendor $ head -10 vendor/modules.txt  # github.com/golang/protobuf v1.3.2 github.com/golang/protobuf/proto github.com/golang/protobuf/ptypes github.com/golang/protobuf/ptypes/any github.com/golang/protobuf/ptypes/duration github.com/golang/protobuf/ptypes/timestamp # github.com/hyperledger/fabric-chaincode-go v0.0.0-20190823162523-04390e015b85 ## explicit github.com/hyperledger/fabric-chaincode-go/shim github.com/hyperledger/fabric-chaincode-go/shim/internal $ head go.mod module ccmodule  go 1.14  require ( github.com/hyperledger/fabric-chaincode-go v0.0.0-20190823162523-04390e015b85 github.com/hyperledger/fabric-protos-go v0.0.0-20190823190507-26c33c998676 ) $ cd .. $ FABRIC_CFG_PATH=~/workspace/fabric/src/github.com/hyperledger/fabric/sampleconfig ~/workspace/fabric/src/github.com/hyperledger/fabric/build/bin/peer lifecycle chaincode package -p ccmodule --label ccmodule ccmodule.tgz $ tar zxvOf ccmodule.tgz code.tar.gz | tar zxO src/vendor/modules.txt | head -10 code.tar.gz # github.com/golang/protobuf v1.3.2 github.com/golang/protobuf/proto github.com/golang/protobuf/ptypes github.com/golang/protobuf/ptypes/any github.com/golang/protobuf/ptypes/duration github.com/golang/protobuf/ptypes/timestamp # github.com/hyperledger/fabric-chaincode-go v0.0.0-20190823162523-04390e015b85 ## explicit github.com/hyperledger/fabric-chaincode-go/shim github.com/hyperledger/fabric-chaincode-go/shim/internal $ tar zxvOf ccmodule.tgz code.tar.gz | tar zxO src/go.mod | head code.tar.gz module ccmodule  go 1.14  require ( github.com/hyperledger/fabric-chaincode-go v0.0.0-20190823162523-04390e015b85 github.com/hyperledger/fabric-protos-go v0.0.0-20190823190507-26c33c998676 ) $  {code}  Perhaps you can take another look at what's going on in your environment to see what's going on? The only way I can reproduce it is to modify {{go.mod}} to go 1.14 and build **without** running {{go mod vendor}}. In that case, what go is complaining about is completely appropriate since the vendor tree does not match go.mod.  {code} dev-box   master  ~/workspace/fabric/src/github.com/hyperledger/fabric-samples/chaincode/abstore/go  $ ls abstore.go  go.mod  go.sum $ cat go.mod  module github.com/hyperledger/fabric-samples/chaincode/abstore/go  go 1.13  require github.com/hyperledger/fabric-contract-api-go v1.0.0 $ go mod vendor $ GO111MODULE=on go build -mod=vendor -o /tmp/chaincode $ rm -rf vendor $ sed -i s/1.13/1.14/ go.mod $ cat go.mod module github.com/hyperledger/fabric-samples/chaincode/abstore/go  go 1.14  require github.com/hyperledger/fabric-contract-api-go v1.0.0 $ GO111MODULE=on go build -mod=vendor -o /tmp/chaincode go: inconsistent vendoring in /home/sykesm/workspace/fabric/src/github.com/hyperledger/fabric-samples/chaincode/abstore/go: github.com/hyperledger/fabric-contract-api-go@v1.0.0: is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt  run 'go mod vendor' to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory 1 $ go mod vendor $ GO111MODULE=on go build -mod=vendor -o /tmp/chaincode $  {code}  ></body> </Action>
<Action id="68777" issue="44757" author="lehors" type="comment" created="2020-04-09 06:37:38.0" updateauthor="lehors" updated="2020-04-09 06:37:38.0"> <body><! CDATA Ok, I dug up a bit more and found the source of the problem.  It turns out that the problem is triggered by the fact that BYFN specifies the chaincode as a github go path rather than a local path.  The chaincode package is created with: {code:java} $ FABRIC_CFG_PATH=~/Projects/Go/src/github.com/hyperledger/fabric-samples/config peer lifecycle chaincode package mycc.tar.gz --path github.com/hyperledger/fabric-samples/chaincode/abstore/go/ --lang golang --label mycc_1 {code} That tar file does not contain vendor/modules.txt: {code:java} $ tar zxvOf mycc.tar.gz code.tar.gz | tar zxO src/vendor/modules.txt x code.tar.gz tar: src/vendor/modules.txt: Not found in archive tar: Error exit delayed from previous errors. {code} For what it's worth, BYFN does run go mod vendor prior to this but it's useless because it does that locally and that's not what's being used by the package command.  Changing the specification of the chaincode path to a local path works: {code:java} $ FABRIC_CFG_PATH=~/Projects/Go/src/github.com/hyperledger/fabric-samples/config ~/Projects/Go/src/github.com/hyperledger/fabric/build/bin/peer lifecycle chaincode package -p $GOPATH/src/github.com/hyperledger/fabric-samples/chaincode/abstore/go --label mycc mycc.tar.gz ~/Projects/Go/src/github.com/hyperledger/fabric-samples/first-network $ tar zxvOf mycc.tar.gz code.tar.gz | tar zxO src/vendor/modules.txt|head -10 x code.tar.gz # github.com/PuerkitoBio/purell v1.1.1 github.com/PuerkitoBio/purell # github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 github.com/PuerkitoBio/urlesc # github.com/go-openapi/jsonpointer v0.19.3 github.com/go-openapi/jsonpointer # github.com/go-openapi/jsonreference v0.19.2 github.com/go-openapi/jsonreference # github.com/go-openapi/spec v0.19.{code}  ></body> </Action>
<Action id="68778" issue="44757" author="sykesm" type="comment" created="2020-04-09 09:57:51.0" updateauthor="sykesm" updated="2020-04-09 09:57:51.0"> <body><! CDATA > package -p $GOPATH/src/github.com/hyperledger/fabric-samples/chaincode/abstore/go  Looks like you have a GOPATH set which can influence the mode of the go tooling.  > BYFN does run go mod vendor prior to this but it's useless because it does that locally and that's not what's being used by the package command.  I don't understand this. {{go mod vendor}} creates a vendor folder at the top level of the module. The package command in module mode, grabs everything under the module root (which includes the vendor tree); in legacy/GOPATH mode, it lists all dependencies of the package and captures them into the package. If the vendored packages were used by the package, they would be included from their source.  ></body> </Action>
<Action id="68779" issue="44757" author="lehors" type="comment" created="2020-04-09 11:39:27.0" updateauthor="lehors" updated="2020-04-09 11:39:27.0"> <body><! CDATA There is nothing special about my GOPATH: {code:java} $ echo $GOPATH /Users/lehors/Projects/Go {code} Where is the chaincode taken from when its path is specified as "github.com/hyperledger/fabric-samples/chaincode/abstore/go/"?  It's not a path relative to the working dir so I don't actually know where it's taken from. I thought it could be relative to the $GOPATH but it doesn't look like it either since when I expand it myself as above it works.  For that matter the following fails and I'm also not sure where the code is taken from in that case: {code:java} $ FABRIC_CFG_PATH=~/Projects/Go/src/github.com/hyperledger/fabric/sampleconfig ~/Projects/Go/src/github.com/hyperledger/fabric/build/bin/peer lifecycle chaincode package -p github.com/hyperledger/fabric/core/chaincode/platforms/golang/testdata/ccmodule --label mycc mycc.tgz Error: error getting chaincode bytes: failed to calculate dependencies: incomplete package: ccmodule/customlogger {code} Making the path relative to the current dir or absolute works.  ></body> </Action>
<Action id="68780" issue="44757" author="sykesm" type="comment" created="2020-04-09 12:23:53.0" updateauthor="sykesm" updated="2020-04-09 12:23:53.0"> <body><! CDATA > There is nothing special about my GOPATH  1. You have a GOPATH 2. You are not explicitly putting yourself into module mode (GO111MODULE=on) during packaging 3. You are using an *import path* instead of a *path* to reference the code to package 4. The *import path* is resolvable from GOPATH  So, given the current rules of modules in go, you're running in legacy GOPATH mode during packaging but the build believes it should be executing in module mode because go.mod is present. In GOPATH mode, the vendor tree is honored. In module mode, the vendor tree is honored with -mod=vendor is used (for go 1.11+) or, new with go 1.14, when present.  At the end of the day, if you're trying to package a *module*, you should be in module mode instead of legacy/GOPATH mode.  I'm going to create a PR that explicitly omits go.mod and go.sum when we're not packaging in module mode but it's hard to say if that's more or less surprising than anything else in this space. IMO, the whole magical packaging process makes things way more complicated than it needs to be.  ></body> </Action>
<Action id="68782" issue="44757" author="lehors" type="comment" created="2020-04-09 12:50:06.0" updateauthor="lehors" updated="2020-04-09 12:58:00.0"> <body><! CDATA I'm glad somebody understands what's going on here. :)  I think it's rather unnatural that it behaves differently whether it is an import path or a path when they both resolve to the exact same path.  And why is it that forcing GO111MODULE=on fails? {code:java} $ GO111MODULE=on FABRIC_CFG_PATH=~/Projects/Go/src/github.com/hyperledger/fabric-samples/config ~/Projects/Go/src/github.com/hyperledger/fabric/build/bin/peer lifecycle chaincode package -p github.com/hyperledger/fabric-samples/chaincode/abstore/go --label mycc mycc.tar.gz Error: error getting chaincode bytes: exit status 1 {code} Thanks for helping figuring this out.  ></body> </Action>
<Action id="68783" issue="44757" author="lehors" type="comment" created="2020-04-09 13:17:11.0" updateauthor="lehors" updated="2020-04-09 13:17:11.0"> <body><! CDATA Ok, I think I get it. When in module mode the path is no longer interpreted as an import path but merely a path, which fails. Pfew.  I just tried and removing go.mod and go.sum does avoid the problem in this case indeed. This should help.  Thanks.        ></body> </Action>
<Action id="68786" issue="44757" author="sykesm" type="comment" created="2020-04-09 13:43:04.0" updateauthor="sykesm" updated="2020-04-09 13:43:04.0"> <body><! CDATA > And why is it that forcing GO111MODULE=on fails?  Because {{-p}} isn't pointing to a directory, it's pointing to an import path. It case it isn't clear yet, {{path != importPath}}.  {code} $ GO111MODULE=on go list -f '{{.Dir}}' github.com/hyperledger/fabric-samples/abstore/go can't load package: cannot find module providing package github.com/hyperledger/fabric-samples/abstore/go: working directory is not part of a module {code}  The only time they're roughly equivalent is when you're in $GOPATH/src.  ></body> </Action>
<Action id="68787" issue="44757" author="sykesm" type="comment" created="2020-04-09 14:50:07.0" updateauthor="denyeart" updated="2020-04-10 17:01:25.0"> <body><! CDATA  https://github.com/hyperledger/fabric/pull/1043    https://github.com/hyperledger/fabric/pull/1045      ></body> </Action>
