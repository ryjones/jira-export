<Issue id="32437" key="FAB-11409" number="11409" project="10002" reporter="denyeart" assignee="senthil1" creator="denyeart" type="10001" summary="memberOnlyRead - config option for implicit collection ACL checks for reads based on membership" priority="3" resolution="10000" status="6" created="2018-07-31 11:28:39.0" updated="2019-09-10 08:10:19.0" resolutiondate="2018-12-08 03:13:14.0" votes="1" watches="5" workflowId="43643"> <description><! CDATA Private data collections specify which orgs peers are authorized to retrieve and persist private data.  If a client from a non-collection member does a chaincode query against an authorized peer with the private data, the client can get the private data back. Need chaincode APIs to enable access control within the chaincode such that non-member clients can be restricted from querying private data that they do not have access to. Previously the chaincode author had to manually construct such access control logic.  The access control for collection can be done in two ways: # implicit ACL – at the peer; # explicit ACL – at the chaincode;  +*Implicit ACL*+ In the implicit ACL approach, by default, the peer would ensure that only collection's members can access the private data. Though such ACL can be implemented at the chaincode (using new APIs such as IsAMemberOfCollection(Coll, MSP)), it would be better to implement at the peer so that not every applications need to rewrite the same ACL logic at chaincode. * *Pros*: Chaincode does not need to do anything special. No need to upgrade the existing chaincodes. No need to introduce new chaincode APIs. * *Cons*: Rigid. Only collection's members can access the private data (not a non-member even if such feature is required for a short time).  +*Explicit ACL*+ In the explicit ACL approach, the chaincode needs to take care of controlling the access to collection's private data. If the application has dynamic ACL requirements in which non-members may get access to particular private data for a short period of time, implicit approach may not work. In such scenarios, the chaincode should implement the ACL logic to dynamically decide the list of members who can access the collection's private data. Especially when we do asset transfer between collections, the non-member may like to read the private data before finalising the transaction.  * *Pros*: Flexible. The access list can be controlled dynamically. Even a non-member can be allowed to access the private data for a short time if required. * *Cons*: Needs to introduce new chaincode APIs. The chaincode logic would become little complex as compared to implicit ACL approach.  ></description> </Issue>
