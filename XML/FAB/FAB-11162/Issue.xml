<Issue id="31898" key="FAB-11162" number="11162" project="10002" reporter="yacovm" assignee="guoger" creator="yacovm" type="10003" summary="Implement Raft FSM " priority="3" resolution="10000" status="6" created="2018-07-15 11:30:59.0" updated="2018-09-21 19:31:17.0" resolutiondate="2018-09-06 14:31:09.0" votes="0" watches="6" workflowId="43784"> <description><! CDATA Build an object, tentatively called {{FSM}}, that wraps around etcd's {{raft.Node}} (see:  sample|https://github.com/coreos/etcd/tree/master/contrib/raftexample ) and interacts with the {{Chain}} object from FAB-11163 according to the contract shown in  Page 1|https://docs.google.com/presentation/d/1olukZUnriPS3HfWMPkQfKjypa3QV_iTacfI1lH8Mtqg/edit#slide=id.g3dec6414ec_0_0 .  At this stage, we should not worry about WALs, snapshots, or crash-fault tolerance.  Expect the {{Chain}} object from FAB-11163 to route transactions to you for appending to the channel's ledger (read: {{Chain.Order}} will eventually wire through to you).  As part of this story, you will definitely be the channel leader, so you should push the transaction back to the {{Chain}} object and have it pipe that transaction to the {{blockcutter}} (that is FAB-11163's responsibility).  Expect the {{Chain}} object to route _blocks_ to you for ordering. These should be proposed to the {{raft.Node}} via {{raft.Propose}} and eventually returned back to the {{Chain}} object via {{raft.Ready}} so that they can be appended to the local ledger. (Again this last part is FAB-11163's responsibility.)        {{Chain}} should interact with the {{FSM}} via the following APIs: * {{OnSubmit(orderer.SubmitRequest)}} submits a {{SubmitRequest}}, which contains an envelope, to the {{FSM}}. {{SubmitRequest}} originates either from other OSNs, or locally, from the {{Broadcast}} API. It: ** returns an error *if* there's no leader ** sends the {{SubmitRequest}} back to {{Chain}} *if* the current OSN is the leader (this is done via the {{RecvSubmitReq}} API) ** forwards {{SubmitRequest}} to the channel leader *if* the current OSN is a Raft follower (this will be addressed in a follow-up JIRA) * {{OnStep(orderer.StepRequest)}} relays a {{StepRequest}} received from other replicas to the {{FSM}} * {{IsLeader() bool}} indicates if this node is currently raft leader, so that {{Chain}} may make better decisions, e.g. purging blockcutter envelopes * {{RecvSubmitReq() <-chan *orderer.SubmitRequest}} returns a channel that {{Chain}} receives SubmitRequests on (these are then meant to be passed to the {{blockcutter}} * {{RecvBlock() <-chan *common.Block}} returns a channel that {{Chain}} can receive *consented* blocks on (these are meant to be passed to the local ledger for appending) * {{Propose(*common.Block) error}} proposes a block to the {{FSM}} to be ordered/consented * {{NewNode()}} constructor that assembles a Node instance with necessary dependencies    ></description> </Issue>
