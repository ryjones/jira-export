<Issue id="37404" key="FAB-14045" number="14045" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10003" summary="Ensure completely asynchronous send of consensus messages in communication layer" priority="3" resolution="10000" status="6" created="2019-02-02 22:48:47.0" updated="2019-03-03 12:58:36.0" resolutiondate="2019-02-04 23:11:41.0" votes="0" watches="2" workflowId="49035"> <description><! CDATA The goroutine that processes commands and events from the Raft FSM is the same one that invokes Send() on the communication layer.  Thus, it's crucial that this send will be as short as possible, and will never block or get delayed by any remote node that is too slow to read the messages from a gRPC stream.  Moreover, the communication layer aims to be re-usable for byzantine environments, and therefore when a consensus message is sent, it shouldn't be blocked by the gRPC buffers (in case they get full).  Â   We can add an application buffer (golang buffered channel) that the message send will put the message into the buffer, and a goroutine would asynchronously flush the buffer.  I propose, that if a message that is a consensus message is sent to a remote node, and the application (not gRPC) buffer is full - it will be dropped and the send will be canceled. For transactions - it can block.  ></description> </Issue>
