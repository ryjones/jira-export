<Action id="28197" issue="19158" author="kchristidis" type="comment" created="2017-07-12 02:02:43.0" updateauthor="kchristidis" updated="2017-07-12 02:02:43.0"> <body><! CDATA A couple questions, with perhaps overlapping answers: # All peers of org3 asked to join the channel reject the call because of background item #2. True/false? (Logic says this is true.) # At this point does each peer of org3 consider themselves a leader of that channel? Background item #3 makes it sound like they do, but how can you be the leader of a channel you haven't joined? I suspect I am misinterpreting this.  ></body> </Action>
<Action id="28214" issue="19158" author="yacovm" type="comment" created="2017-07-12 07:10:19.0" updateauthor="yacovm" updated="2017-07-12 07:10:44.0"> <body><! CDATA {quote}All peers of org3 asked to join the channel reject the call because of background item #2. True/false? (Logic says this is true.) {quote} So it's not that the peer rejects the join channel. The gossip layer of the peer does. This holds for all peers of the new org. {quote}At this point does each peer of org3 consider themselves a leader of that channel? {quote} Yeah, if leader election is used (in core.yaml)  {quote}Background item #3 makes it sound like they do, but how can you be the leader of a channel you haven't joined? I suspect I am misinterpreting this.{quote}  Great question.  So here is how it works - the gossip subcomponent of the peer can be roughly described as built in the following layers: {code:java}    L2             Leader election   module   |    state transfer module    L1                     membership and dissemination modules    L0                          communication module{code} There is also the deliver service (which pulls blocks from the ordering service) and it receives command whether to stop itself or start itself from the leader election module.  Let's take a dive and see how the flow works:  createChain|https://github.com/hyperledger/fabric/blob/master/core/peer/peer.go#L232  calls  InitializeChannel|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L174   which: *  Initializes a state transfer module|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L179  instance for that channel  *  Initializes a delivery service|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L182  instance for the channel  *  Initializes a leader election|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L206  instance for the channel, that receives its messages and sends messages via what is in L1 (in the code, L1 is aggregated under gossip/gossip).   Now, the thing that configures gossip's layers L1 with respect to the channel join is done via   createChain|https://github.com/hyperledger/fabric/blob/master/core/peer/peer.go#L181  that calls  ProcessConfigUpdate|https://github.com/hyperledger/fabric/blob/master/gossip/service/eventer.go#L69  which then does to  configUpdated|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L219  which does the following check: {code} 	myOrg := string(g.secAdv.OrgByPeerIdentity(api.PeerIdentityType(g.peerIdentity))) 	if !g.amIinChannel(myOrg, config) { 		logger.Error("Tried joining channel", config.ChainID(), "but our org(", myOrg, "), isn't "+ 			"among the orgs of the channel:", orgListFromConfig(config), ", aborting.") 		return } {code}  and if this succeeds, it calls  JoinChain|https://github.com/hyperledger/fabric/blob/master/gossip/service/gossip_service.go#L241  on the gossip module (L1)  which does the following things: * Tells the "channel" module in the gossip layer (we have a module that manages all channel related decisions and keeps all channel related information) to create a new channel instance if needed * Tells the gossip layer to try to connect to the anchor peers of the channel, if needed.  Now, the first part doesn't do the check, but the 2nd one does.  So the leader election module doesn't receive *any* messages from the layers below it, and considers itself alone in the world - hence deciding to nominate itself as a leader, and then commands the delivery service to connect to the ordering service. Eventually, the *configUpdated* method would be called again and then the configuration would contain the peer's own org and then the lower layers of gossip would join the channel.   ></body> </Action>
<Action id="28227" issue="19158" author="kchristidis" type="comment" body="I think that clears it for me, thanks." created="2017-07-12 12:40:36.0" updateauthor="kchristidis" updated="2017-07-12 12:40:36.0"/>
<Action id="35448" issue="19158" author="denyeart" type="comment" body=" ~yacovm  Do you think this should be fixed for 1.1? What do you propose as next steps?" created="2017-11-27 03:48:06.0" updateauthor="denyeart" updated="2017-11-27 03:48:06.0"/>
<Action id="35483" issue="19158" author="yacovm" type="comment" body="There is no way of fixing this in v1.1 because we can only join with the GB... " created="2017-11-27 08:01:08.0" updateauthor="yacovm" updated="2017-11-27 08:01:08.0"/>
<Action id="40368" issue="19158" author="scottz" type="comment" body="This means we cannot support gossip unless leader election is used. Is this documented anywhere???  ~denyeart  ,  ~yacovm . We could say that mode is allowed for simple experimentation, but cannot handle org additions." created="2018-02-19 02:38:53.0" updateauthor="scottz" updated="2018-02-19 02:38:53.0"/>
<Action id="40373" issue="19158" author="yacovm" type="comment" created="2018-02-19 07:31:03.0" updateauthor="yacovm" updated="2018-02-19 07:31:03.0"> <body><! CDATA {quote}This means we cannot support gossip unless leader election is used {quote} No, that is not what it means.    {quote}Is this documented anywhere??? {quote} Not to my knowledge. {quote}We could say that mode is allowed for simple experimentation, but cannot handle org additions. {quote} I wouldn't put it like that. You can always just make everyone connect to the orderer.     This issue, by the way - isn't a gossip issue at all. Gossip actually functions as it should.  We have a similar issue with the deliver service and ordering endpoints and orderer root CA certs. I suggest we document all of that in the document of the org reconfiguration or in a new one.  ></body> </Action>
<Action id="42597" issue="19158" author="christopherferris" type="comment" body="So, is this issue relevant exclusively to 1.0.x? If so, then I would advocate we close this since we aren&apos;t planning any further patches to 1.0.  ~yacovm   ~mastersingh24  do you concur?" created="2018-04-05 17:52:53.0" updateauthor="christopherferris" updated="2018-04-05 17:52:53.0"/>
<Action id="42598" issue="19158" author="yacovm" type="comment" body="not exclusive to any release. We can&apos;t solve it until we separate MSP managers between blockchain MSP managers to admission path MSP managers... " created="2018-04-05 18:11:36.0" updateauthor="yacovm" updated="2018-04-05 18:11:36.0"/>
