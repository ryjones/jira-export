<Action id="35330" issue="24416" author="jyellick" type="comment" created="2017-11-21 21:52:30.0" updateauthor="jyellick" updated="2017-11-21 21:57:25.0"> <body><! CDATA The overarching question seems to be: Should the peer be in the business of filtering blocks, period?  There is certainly some utility in it, but, in the way described in FAB-5481, the filtering is effectively being used as an access control, trying to expose a subset of transaction data for security reasons, rather than simply an optimization on the amount of data sent to the client.  When the {{Deliver}} service was originally conceived, it seemed likely that at some point in the future, it might be enhanced to only return a subset of the block structure.  In particular, the scenario of returning only block headers (and block metadata) was considered for a thin client which wished to keep a record of the hash chain for auditing purposes later, but did not need to full block contents.  This was however thought of as an optimization, rather then security enforcement.  If we conclude that we should be filtering blocks, then I think that re-using the {{Block}} proto, and stripping out the 'filtered' information is sensible (option 2 in the description).  By definition, a filtered block is always a subset of a block, so it's not obvious what we would gain with a new proto message.  On the other hand, adding a {{FilteredBlock}} type to the {{Deliver}} interface {{DeliverResponse}} seems like it's introducing a bit of an odd peer dependency into the atomic broadcast protos.  The {{Deliver}} service definition is agnostic to the block contents, so adding a different structure which exposes fabric-peer specific structures like say, chaincode events, seems very wrong to me.  ></body> </Action>
<Action id="35783" issue="24416" author="wlahti" type="comment" created="2017-12-04 15:57:30.0" updateauthor="wlahti" updated="2017-12-04 15:57:30.0"> <body><! CDATA  ~muralisr , as the originator of FAB-5481, we definitely need your input if you can spare some time in the next few days.    ~yacovm , you were fairly active in the discussion of FAB-5481; I'd appreciate your input as well when you have a moment.   ></body> </Action>
<Action id="35785" issue="24416" author="yacovm" type="comment" created="2017-12-04 16:40:14.0" updateauthor="yacovm" updated="2017-12-04 16:40:14.0"> <body><! CDATA My personal opinion is that: * If we use the Deliver API to send events, then everything is "fair game" and we can make the deliver API return more types than it currently does * Sending a custom event is more secure than nullifying fields, because the event you send in the first place doesn't contain the fields you want to nullify out, and you may take advantage of compile time type checks that enforce you to not send the data you wish to filter out.  I'm fine with  ~jyellick 's idea as well.  ></body> </Action>
<Action id="35813" issue="24416" author="muralisr" type="comment" created="2017-12-04 22:31:06.0" updateauthor="muralisr" updated="2017-12-04 22:31:06.0"> <body><! CDATA  ~jyellick   ~yacovm  I'd say filtereing is lightweight both in amount of data and ACL requirements and believe has some value from user point of view. The delivery approach to events may influence implementation details but not those basic requirements the item was written for I'd think. x  What do you think  ~denyeart   ~mastersingh24  ?  My 2c :  if we are going to have some filtered blocked, its good to have a separate type so (1) user doesn't have to test fields and (2) for future expansion of data in the event type.   ></body> </Action>
<Action id="35838" issue="24416" author="denyeart" type="comment" created="2017-12-05 11:49:26.0" updateauthor="denyeart" updated="2017-12-05 11:49:26.0"> <body><! CDATA I agree with the filtering requirement for both security and optimization reasons.  I am fine with using the filtered event structure that was already defined/debated in FAB-5481.  ></body> </Action>
<Action id="35861" issue="24416" author="denyeart" type="comment" body=" ~wlahti  I think the next design question is how do clients register for filtered events versus regular block events.  Did you and  ~jeffgarratt  have a design proposal for that part?  I think this is what  ~binhn  was alluding to when he said it makes sense to have common implementation logic across orderer and peer, but the public API name and signature may be slightly different based on different requirements that clients have for orderer vs peer." created="2017-12-05 13:01:25.0" updateauthor="denyeart" updated="2017-12-05 13:01:25.0"/>
<Action id="35877" issue="24416" author="jeffgarratt" type="comment" body="I have difficulty reasoning about this feature wrt to the actor who receiving the value.  The way the associated feature is written it seems to be in the context of a fabric client, though I do not think this is perhaps who cares in this scenario (at least not how the feature is written).  In addition, a client can still request any block it wishes through the qscc.  I am concerned that we are conflating security and optimization in the context of this feature, which I don&apos;t think we should.  In general I am against filtering in the deliver as it breaks the pipeline concept that is afforded by the deliver service, and which I think could be leveraged to provide this function independent of the peer/orderer.  This is to say I would in general approach this problem with an application layer based approach, allowing the application to make the filtering decisions independently of the peer/orderer." created="2017-12-05 18:40:33.0" updateauthor="jeffgarratt" updated="2017-12-05 18:40:33.0"/>
<Action id="35880" issue="24416" author="yacovm" type="comment" created="2017-12-05 18:59:59.0" updateauthor="yacovm" updated="2017-12-05 18:59:59.0"> <body><! CDATA {quote}In addition, a client can still request any block it wishes through the qscc. {quote} The idea is that in v1.1 you can disable this via a custom policy ( ~muralisr  's ACL work) and then you won't be able to do that anymore.  To complete the picture, I assume that there should be some matching access control in the orderer side (perhaps - ensure whoever calls deliver is not a client via  ~adc  's new role types? though, can this mess up the channel reconfiguration flows or even channel creation?  ~jyellick  wdyt? ) so the client won't be able to pull blocks from the orderer  ></body> </Action>
<Action id="35883" issue="24416" author="wlahti" type="comment" created="2017-12-05 19:34:53.0" updateauthor="wlahti" updated="2017-12-05 19:34:53.0"> <body><! CDATA This is the part of Jeff's comment I think warrants discussion before proceeding:  "This is to say I would in general approach this problem with an application layer based approach, allowing the application to make the filtering decisions independently of the peer/orderer."  ></body> </Action>
<Action id="35886" issue="24416" author="jyellick" type="comment" created="2017-12-05 21:31:37.0" updateauthor="jyellick" updated="2017-12-05 21:31:37.0"> <body><! CDATA From an orderer perspective, we have ACLs, via the {{/Channel/Readers}} and {{/Channel/Writers}} policies for {{Deliver}} and {{Broadcast}} respectively (which in turn traverse the config tree to the more familiar policies, like {{/Channel/Application/Readers}}.  For v1.0, the peer chose to use these orderer policies as a sane default in many places, but more granularity was required, so, the ACL work from  ~muralisr  was born.  I would expect that the peer would implement its own ACLs for {{Deliver}} (and not rely on {{/Channel/Readers}}), and would coordinate them with the ACLs on functions like {{QSCC.GetBlockByNumber}}.  So, I don't see securing clients from retrieving full block contents as a hopeless exercise.  In fact, I would think this is a fairly easy thing to accomplish.  Since you asked about it specifically, today, channel reconfiguration flows are typically done directly through the orderer.  However, I would suggest performing the flow against the peer is superior, as the peer has been maintaining the hash chain, validating the configuration changes, and usually has a trusted relationship with the client, so retrieving the configuration from the peer is probably best.  My concern with the proposal for filtering events is largely related to the differences which would develop between the orderer and peer implementations of {{Deliver}}.  To me, one of the biggest advantages of exposing {{Deliver}} on the peer _exactly as the orderer does_ is that clients do not have to write any special code and may re-use their existing code to connect to the {{Deliver}} service.  In fact, a client could be written such that at runtime, it could execute against the orderer directly or against some locally deployed peer, depending on the trust assumptions in the network.  it If we bifurcate {{Deliver}} into an orderer version, and a peer version, then unless we are very careful, we risk losing this primary benefit of orderer/peer agnostic clients.  For a simple transformation, like removing all transactions and returning only the block header, this seems like a fairly trivial operation that the orderer could implement as well as the peer with nearly zero overhead.  For more complex transformations, such as removing everything in the transactions but the txids, it might be something which the orderer could support, but is something we would have to consider more carefully.  If the {{Deliver}} service were to begin returning protos which discuss chaincode specific concepts like chaincode events, then I see this is a complete no-go for the ordering service, and there is definitely a bifurcation in {{Deliver}} function.  ></body> </Action>
<Action id="35895" issue="24416" author="denyeart" type="comment" created="2017-12-06 02:09:15.0" updateauthor="denyeart" updated="2017-12-06 09:41:29.0"> <body><! CDATA Adding  ~mastersingh24  and  ~binhn  to the watch list.  Let’s split the discussion into requirement and implementation.  *REQUIREMENT*  The requirement is for clients to receive block events which indicate txids and valid/invalid status of each, or to receive a transaction event for a given txid that you have submitted to understand if it was validated/invalidated.  This is one of the most fundamental requirements a client has given the asynchronous nature of transaction submission.  On top of that there is a security requirement such that certain clients should not see metadata or data for transactions they did not submit.  Additionally, there is an optimization requirement such that unnecessary data is not sent to clients that typically just need to know the valid/invalid status of submitted transactions.  In my opinion, this is not a case of conflating various requirements.  Each of the requirements independently point to the same solution - an ability to send clients filtered block events or filtered transaction events.  Why is this an important requirement for peer rather than something that can be solved by an external application layer?  I’d suggest two reasons: 1) The requirement to get transaction validation/invalidation status from peer is relevant to almost every Fabric deployment 2) Given that securing access to peer functions via ACL has generally been agreed to and implemented already, and given that the ACL mechanism is via MSP policies residing in the channel configuration, it is only logical that block event vs filtered event ACL leverage this infrastructure, rather than delegate it to an external application layer that doesn’t implicitly know about these policies and MSPs.  *IMPLEMENTATION*  I agree with the objective of a single Deliver API and implementation across orderer and peer.  I also agree with the pipeline concept where capabilities build on top of each other. This doesn’t imply that an external application layer is the solution for filtering however.  It seems we can keep block Deliver API consistent on orderer and peer, and ADDITIONALLY offer a new DeliverFilteredBlocks API on peer.  Internally the DeliverFilteredBlocks implementation would sit on top of the Deliver implementation where blocks can be filtered and sent out upon blocks becoming available in peer's ledger. This preserves the code re-use and pipelining objectives. Deliver and DeliverFilteredBlocks can each have their own ACL and response objects, meeting the security and optimization requirements.  Concerning the response object structure - while there is something to be said for leveraging the same Block structure for each response object, my opinion is that the deeply nested Block structure would only get in the way of clients that are simply looking for txid validation/invalidation status, and for this reason I’m in favor of a simplified FilteredBlock response object.  Separately, a RetrieveTransactionStatus API could provide an even more streamlined and secure solution, where a client registers for a single txid and waits for the validation/invalidation status from peer (with some timeout).  The peer would only send a client transaction status for transactions that the client had submitted. This provides implicit security and therefore the ACL could be more wide open relative to the Deliver and DeliverFilteredBlocks APIs. This being said, I’m not sure of the original design intent for SDKs registering for all block events vs registering for individual transactions.  Presumably to reduce the number of registrations that peer has to manage?  If this is the case the RetrieveTransactionStatus API idea could be deferred.  ></body> </Action>
<Action id="35902" issue="24416" author="jyellick" type="comment" created="2017-12-06 04:32:02.0" updateauthor="jyellick" updated="2017-12-06 04:32:02.0"> <body><! CDATA  ~denyeart   {quote} Concerning the response object structure - while there is something to be said for leveraging the same Block structure for each response object, my opinion is that the deeply nested Block structure would only get in the way of clients that are simply looking for txid validation/invalidation status, and for this reason I’m in favor of a simplified FilteredBlock response object. {quote}  Could you please post a proto message definition for the filtered block in your proposal? Looking back at FAB-5481, there are certainly some fields (such as the {{channel_id}} which would be unnecessary.  There is also the {{filtered_action}} field, which I can't seem to find the reasoning behind.  ></body> </Action>
<Action id="35908" issue="24416" author="mastersingh24" type="comment" created="2017-12-06 07:56:13.0" updateauthor="mastersingh24" updated="2017-12-06 10:04:31.0"> <body><! CDATA {quote}In general I am against filtering in the deliver as it breaks the pipeline concept that is afforded by the deliver service, and which I think could be leveraged to provide this function independent of the peer/orderer.  This is to say I would in general approach this problem with an application layer based approach, allowing the application to make the filtering decisions independently of the peer/orderer.{quote}  As  ~denyeart  stated, this is exactly what we are trying to avoid.  There is no reason why the peer cannot / should not provide an API / service for simply streaming transactions and their status.  The original proposal for this was to provide a new channel event service (the existing event service has numerous issues - i.e. no concept of channels, uses it's own format, etc).  Work was well underway on this when the suggestion was made to leverage the Deliver Service that is implemented by the orderer instead.   At that time, it seemed that a few of us also believed that we could leverage the common block format (as is the case in the current Deliver Service) as the mechanism for carrying what we keep referring to as "filtered" blocks.  So then we start to argue about the filtered block format and then that devolves back to arguing about the actual requirement in the first place.  Enough is enough on this.     I really cannot tell what we are actually arguing about here because there seem to be multiple discussions here.  I believe that the intent of this JIRA item was to discuss how to implement "filtered" blocks with the assumption that the service which provides these is the Delivery Service.  It seems that there are comments in here questioning doing "filtered blocks" as well.  ></body> </Action>
<Action id="35913" issue="24416" author="denyeart" type="comment" created="2017-12-06 10:32:22.0" updateauthor="denyeart" updated="2017-12-06 10:37:00.0"> <body><! CDATA  ~mastersingh24  Yes, the intent of this Jira is to determine how to implement "filtered blocks", given that we now have a Deliver service on peer for blocks.  My proposal is to have a sister API called DeliverFilteredBlocks (or potentially more simply DeliverBlockTransactionsStatus) which internally re-uses much of the same code under Deliver.   ~jyellick  Given that the primary requirement and most typical use case is to receive status of submitted transactions, I would be in favor of simplifying the response payload down to just the block number and an array of txids and tx validation codes.  Adding other information such as filtered_action with chaincode events is a slippery slope. If you need information other than tx status, it seems you should register for the actual blocks via Deliver.  ></body> </Action>
<Action id="35920" issue="24416" author="c0rwin" type="comment" created="2017-12-06 11:41:43.0" updateauthor="c0rwin" updated="2017-12-06 11:41:43.0"> <body><! CDATA I think that we can add to the `SeekInfo` message an additional field say a `IsFiltered` to indicate whenever we would like to get FilteredBlock or a regular one:  {code} message SeekInfo { enum SeekBehavior { BLOCK_UNTIL_READY = 0; FAIL_IF_NOT_READY = 1; } SeekPosition start = 1;    // The position to start the deliver from SeekPosition stop = 2;     // The position to stop the deliver SeekBehavior behavior = 3; // The behavior when a missing block is encountered bool is_filtered = 4; } {code}  And we can also add a new message type to include filtered block in response  {code} message DeliverResponse { oneof Type { common.Status status = 1; common.Block block = 2; common.FilteredBlock = 3; } } {code}  In this way IMO the adding support for "filtered blocks" will be less intrusive as we also won't have to add an additional API to `AtomicBroadcast`.  ></body> </Action>
<Action id="35926" issue="24416" author="denyeart" type="comment" created="2017-12-06 14:29:25.0" updateauthor="denyeart" updated="2017-12-06 14:29:25.0"> <body><! CDATA  ~C0rWin  That also seems feasible. In your proposal the ACL would have to be on the requested content rather than on the API itself, but I think that could be worked out. Instead of a boolean for is_filtered, there could be an enum with various degrees of "filtering" the response supported, I can think of legitimate use cases for: - FilteredBlock with txids/statuses only (necessary to fulfill current requirement) - FilteredBlock with txids/statuses and limited header info (e.g. creator would be useful) - Full Block but  RWSets nilled out (this is the 1.0 event hub behavior) - Full Block (default orderer behavior)  ></body> </Action>
<Action id="35932" issue="24416" author="c0rwin" type="comment" body=" ~denyeart  I think it make sense to introduce enum in favor of boolean as this will provide greater flexibility." created="2017-12-06 15:16:22.0" updateauthor="c0rwin" updated="2017-12-06 15:16:22.0"/>
<Action id="35934" issue="24416" author="mastersingh24" type="comment" created="2017-12-06 15:17:37.0" updateauthor="mastersingh24" updated="2017-12-06 15:18:00.0"> <body><! CDATA I don't think that we need to add an additional Type to DeliverResponse.  I think our best approach is limiting things to using the Block and then filtering out information. I will say that while the initial filter we are going to implement is a "transactionID / status only" filter, there may be additional filters in the future (for example we might want the full block minus RWSets). So I'd suggest that rather than the* bool is_filtered* suggested by Artem that we add an enum called *FilterType* (with say *TRANSACTION_STATUS* as the first / only filter type) and then add *FilterType filter_type* to the SeekInfo message   ></body> </Action>
<Action id="35935" issue="24416" author="kchristidis" type="comment" created="2017-12-06 15:18:50.0" updateauthor="kchristidis" updated="2017-12-06 15:27:21.0"> <body><! CDATA Spoke too soon above, and had a change of heart. Take two. Artem, if we do this we expose a type to the AtomicBroadcast service that the ordering service will never (at least for the foreseeable future?) use, no? David's suggestion of introducing a DeliverFilteredBlocks API on the peer strikes me as a better separation of concerns in that regard.  I will try to sketch that out a bit later today and post back here – will be a good check for me to see if I'm missing something.  ></body> </Action>
<Action id="35936" issue="24416" author="kchristidis" type="comment" body="(Off-topic: I don&apos;t care about JIRA&apos;s lack of Markdown support, I only want it to give me a popup message - like Gerrit/GitHub does - that lets me know that someone has posted a comment since I last loaded the page. Feels like I&apos;m ignoring what&apos;s being posted, when in reality I just didn&apos;t see these posts because they were posted between my loading the page and posting my comment.)" created="2017-12-06 15:24:38.0" updateauthor="kchristidis" updated="2017-12-06 15:25:00.0"/>
<Action id="35938" issue="24416" author="c0rwin" type="comment" created="2017-12-06 15:43:11.0" updateauthor="c0rwin" updated="2017-12-06 15:43:11.0"> <body><! CDATA {quote} Spoke too soon above, and had a change of heart. Take two. Artem, if we do this we expose a type to the AtomicBroadcast service that the ordering service will never (at least for the foreseeable future?) use, no? David's suggestion of introducing a DeliverFilteredBlocks API on the peer strikes me as a better separation of concerns in that regard.  I will try to sketch that out a bit later today and post back here – will be a good check for me to see if I'm missing something. {quote}   ~kchristidis  I do not think there is much difference with this regard, since adding a new API to AtomicBroadcast, which will never be used in near future within ordering service has exactly same impact. I just think that adding an enumeration to indicate the type will be be less intrusive as from ordering service perspective won't change that much, we will just need to make sure to add a check we are serving correct type.  Honestly, I'm not against adding new API to the AtomicBroadcast, just seems a bit strange to me that ordering service will have to support it.  ></body> </Action>
<Action id="35963" issue="24416" author="kchristidis" type="comment" created="2017-12-07 01:43:05.0" updateauthor="kchristidis" updated="2017-12-07 01:43:05.0"> <body><! CDATA {quote}I will try to sketch that out a bit later today and post back here – will be a good check for me to see if I'm missing something. {quote}  So just to make this a bit more concrete, imagine the following definition under {{protos/peer}}:   {code:java} syntax = "proto3";  import "common/common.proto"; import "orderer/ab.proto";  option java_package = "org.hyperledger.fabric.protos.peer"; option go_package = "github.com/hyperledger/fabric/protos/peer";  package peer;  message FilteredBlock { ... }  message SeekInfo { enum FilterType { FOO = 0; BAR = 1; BAZ = 2; } FilterType filter = 1; ab.SeekInfo seek_info = 2; }  message DeliverResponse { FilteredBlock filtered_block = 1; ab.DeliverResponse deliver_response = 2; }  service Events { rpc Deliver(stream common.Envelope) returns (stream DeliverResponse) {} }  {code}  So, the peer implements both {{peer.EventsServer}} and {{ab.AtomicBroadcastServer}} but only exposes the {{peer.Deliver}} RPC. If no filter is specified, the peer simply routes the call to the {{ab.Deliver}} RPC implementation and returns the response to the caller as is. Otherwise, it scrubs the response, places into a {{peer.DeliverResponse}} message (by setting {{peer.DeliverResponse.filtered_block}}) and returns it to the caller.  This provides a way to _extend_ the {{ab.Deliver}} RPC without messing with it directly. This is more or less Dave's idea (or at least the way I perceived it), augmented with Artem's modifications.  If you like it, cool, but I'm honestly more concerned about any flaws this proposal may have. What are we overlooking, what are breaking, what can we be doing better, etc. Ideally there is there a solution out there that allows us to keep `ab.proto` free of references to peer-specific objects, and involves less code than this one.  ></body> </Action>
<Action id="35967" issue="24416" author="jeffgarratt" type="comment" created="2017-12-07 05:39:22.0" updateauthor="jeffgarratt" updated="2017-12-07 05:39:22.0"> <body><! CDATA I would also propose for comparative purposes an application layer option that I believe would require no change to fabric.   See https://jira.hyperledger.org/browse/FAB-7367.  ></body> </Action>
<Action id="35973" issue="24416" author="mastersingh24" type="comment" body=" ~jeffgarratt  - https://jira.hyperledger.org/browse/FAB-7367?focusedCommentId=35970&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-35970" created="2017-12-07 07:12:04.0" updateauthor="mastersingh24" updated="2017-12-07 07:12:04.0"/>
<Action id="35974" issue="24416" author="mastersingh24" type="comment" created="2017-12-07 07:19:28.0" updateauthor="mastersingh24" updated="2017-12-07 07:19:28.0"> <body><! CDATA  ~kchristidis  - I'm not sure there are any major issues with your proposal, although if we are going to go down this route I'm not sure that the new "peer event service" actually needs to extend the AB protos. Seems like we basically end up sharing backend code but don't necessarily need to actually share the service definition(s).  There are a few types which could possibly be moved to the common protos (e.g. ab.SeekInfo) but other than that I'm not sure why the peer would need to implement anything other than the Events service you described above. So the net-net is that we can share some backend processing code. Some of the ACL becomes a little trickier because now we'll need to have access control for different types of filters but that's probably fairly manageable.  ></body> </Action>
<Action id="35980" issue="24416" author="denyeart" type="comment" body="I agree with the structuring that Gari proposes." created="2017-12-07 10:48:12.0" updateauthor="denyeart" updated="2017-12-07 10:48:12.0"/>
<Action id="36000" issue="24416" author="kchristidis" type="comment" created="2017-12-07 21:36:03.0" updateauthor="kchristidis" updated="2017-12-07 21:36:14.0"> <body><! CDATA {quote}There are a few types which could possibly be moved to the common protos (e.g. ab.SeekInfo) but other than that I'm not sure why the peer would need to implement anything other than the Events service you described above.{quote}  Could you clarify this?  The way I look at it, we get component reuse by having the peer implement {{ab.DeliverServer}}. But we need additional message types so as to support filtering. Thus we need the peer to also implement {{peer.EventServer}}. All {{peer.EventServer}} RPCs get routed to the {{ab.DeliverServer}} implementation. Post {{ab.DeliverServer}}, they get scrubbed/transformed according to the filter, and they are returned on the {{peer.Events}} stream.  ></body> </Action>
<Action id="36015" issue="24416" author="rickr" type="comment" created="2017-12-08 15:09:55.0" updateauthor="rickr" updated="2017-12-08 15:10:25.0"> <body><! CDATA If there is not a specific block type I don't think just not having some fields is a good design.  The application should know when it gets a block event what it is (_filtered_ vs _full_ ) and what expect rather than a field is not set.   Besides knowing that the transaction has been completed successful or not,  applications use  the chaincode events in the SDK to take actions when they are present in a block/transaction. It's  used quite al ot ( I get question on it ) A filtered implementation with out those I think would be very limiting.  ></body> </Action>
<Action id="36026" issue="24416" author="mastersingh24" type="comment" created="2017-12-08 16:57:45.0" updateauthor="mastersingh24" updated="2017-12-08 16:57:45.0"> <body><! CDATA  ~kchristidis  - I might have partially misinterpreted what you wrote. Looks like you are saying that the peer would only expose a single RPC: {code:java} service Events { rpc Deliver(stream common.Envelope) returns (stream DeliverResponse) {} } {code} And looking at the code I see how this would all work (I think).  ></body> </Action>
<Action id="36034" issue="24416" author="kchristidis" type="comment" created="2017-12-08 18:10:22.0" updateauthor="kchristidis" updated="2017-12-08 19:31:18.0"> <body><! CDATA {quote}Looks like you are saying that the peer would only expose a single RPC. {quote} Exactly. I'm suggesting that the peer implements both the {{ab.Deliver}} and this {{peer.Deliver}} RPC, but only exposes the later. I've drawn a quick sketch of the interactions here:  https://user-images.githubusercontent.com/14876848/33777738-f75a2ee2-dc13-11e7-88ba-09ed6d200be4.png   Notice the asterisk in Step 3, which brings me to my next question:  How do we handle authorization _exactly_? Is this sorted out already (perhaps via a namespace in the {{Resources}} part of the {{Config}} tree), or is this still TBD? I suspect that this is related to this quote of yours: {quote}Some of the ACL becomes a little trickier because now we'll need to have access control for different types of filters but that's probably fairly manageable. {quote}  ></body> </Action>
<Action id="36037" issue="24416" author="mastersingh24" type="comment" created="2017-12-08 19:54:31.0" updateauthor="mastersingh24" updated="2017-12-08 19:55:16.0"> <body><! CDATA  ~wlahti   - you need any help on this one?  I've got a pretty good idea how to get the basic of this done if need be and happy to help   ~kchristidis  - yeah - we'll need to figure out the ACL stuff - but I think it's feasible once we get the basic flow working end to end  ></body> </Action>
<Action id="36306" issue="24416" author="jeffgarratt" type="comment" body="After discussions between myself ( ~jeffgarratt ) and  ~wlahti ,  ~kchristidis , we aggregated the comments and suggestions into a separate design proposal which per our estimation is complete and implementable (i.e. ready for voting).  This is NOT to say there is concurrence amongst the aforementioned  that this is the right design approach.  Let us know if we missed something, and feel free to ask questions.  Please feel free to comment on the A&amp;D proposal at https://jira.hyperledger.org/browse/FAB-7419." created="2017-12-11 18:01:44.0" updateauthor="jeffgarratt" updated="2017-12-11 18:02:49.0"/>
<Action id="38918" issue="24416" author="denyeart" type="comment" body="Done in FAB-7419." created="2018-01-20 08:08:36.0" updateauthor="denyeart" updated="2018-01-20 08:08:36.0"/>
