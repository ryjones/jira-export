<Issue id="34207" key="FAB-12228" number="12228" project="10002" reporter="adarshsaraf123" assignee="adarshsaraf123" creator="adarshsaraf123" type="10003" summary="Decouple CreateNextBlock and WriteBlock" priority="3" resolution="10200" status="6" created="2018-09-28 13:46:37.0" updated="2018-10-18 05:48:59.0" resolutiondate="2018-10-18 05:48:59.0" votes="0" watches="2" workflowId="45533"> <description><! CDATA Currently, we require that {{WriteBlock}} be called post a call to {{CreateNextBlock}} before the next call to {{CreateNextBlock}}. It was okay to do so for Kafka and solo since the OSN(s) were creating and writing the blocks individually. However, for the cluster-based orderers, this is not efficient since {{WriteBlock}} can only be called once consensus on the created block is achieved. For efficiency, the leader should be able to create multiple blocks without having to wait for consensus on each such block. Of course, if can so happen, for example upon a leader change, that these created blocks will have to be discarded. However, it is intuitive that a leader would potentially create more than one block before the next round of election, and the decoupling would therefore help improve performance.  To achieve this decoupling, we maintain a queue of created blocks that are in-flight, i.e., consensus on these blocks has not yet been reached. Newer blocks are created on this queue. Every time a block is written, we verify that this block is indeed the one that was created first in the queue of in-flight blocks. If so then the queue continues to be valid and we pop the earliest block from this queue since it is no longer in-flight. Else, the written block is diverging from the chain of in-flight blocks and all these in-flight blocks will have to be discarded.  Thus, at any time, the queue is either empty and we create newer blocks on top of the last written block, or the queue is non-empty and we continue to create blocks on top of this queue. The queue is reset every time a diverging block is written. In golang, we simulate this queue using channels.  ></description> </Issue>
