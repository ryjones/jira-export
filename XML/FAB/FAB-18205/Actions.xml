<Action id="70140" issue="45975" author="jyellick" type="comment" body="Perhaps even a more general &quot;ignore TLS errors&quot; flag would be nice? Easily abused though" created="2020-09-04 13:54:01.0" updateauthor="jyellick" updated="2020-09-04 13:54:01.0"/>
<Action id="70147" issue="45975" author="yacovm" type="comment" created="2020-09-04 21:35:00.0" updateauthor="yacovm" updated="2020-09-04 21:44:47.0"> <body><! CDATA   {quote}This means that it is extremely difficult to submit a config update that updates the consenter sets with the new TLS certificates in order to resolve the problem. {quote}     We don't need to do this anymore, we can just replace the certificate.    # You are supposed to submit the config update to the *other* orderer(s) whose certificate has *not* expired. # How would it help submitting it to an orderer that can't communicate with the cluster anyway?  {quote}There is a timeshift option in the ordering service that allows the ordering service nodes to communicate with each other, but that does not resolve this problem. {quote} Why would it effect the validation on the client side? {quote}Perhaps even a more general "ignore TLS errors" flag would be nice? Easily abused though {quote} Why do we want to do such a thing? If the client can't validate the certificate, nor can the peers and the other orderers.  Besides, such things show up in  security scans|https://github.com/securego/gosec/blob/d8f249a0792bc3b1098b6958f99552e440f520c7/rules/tls.go#L67-L74 .  Lastly, with TLS validation disabled, how do we know that no one intercepted our message and is now re-transmitting it to a real orderer in order to extract information?  ></body> </Action>
<Action id="70152" issue="45975" author="sstone1" type="comment" created="2020-09-07 09:22:12.0" updateauthor="sstone1" updated="2020-09-07 09:22:12.0"> <body><! CDATA {quote}You are supposed to submit the config update to the *other* orderer(s) whose certificate has *not* expired. {quote} That would be great, if people weren't standing up ordering services where all of the nodes are issued certificates at roughly the same time, and all of those certificates have now expired.  {quote}Why would it effect the validation on the client side? {quote} Did I say it would? {quote}Why do we want to do such a thing? If the client can't validate the certificate, nor can the peers and the other orderers. Besides, such things show up in  security scans|https://github.com/securego/gosec/blob/d8f249a0792bc3b1098b6958f99552e440f520c7/rules/tls.go#L67-L74 .  Lastly, with TLS validation disabled, how do we know that no one intercepted our message and is now re-transmitting it to a real orderer in order to extract information? {quote} Pretty much every client CLI program out there has an option to disable TLS validation, don't they? At least curl and kubectl do. They're all labeled "insecure" and are opt-in. Why are we so special that we can't let the user take the risk, even if they know what they are letting themselves in for? {quote}We don't need to do this anymore, we can just replace the certificate. {quote} I'm aware of the fix you delivered, it's great, but it only recently got merged into GitHub, and I've been told that it may not be ready in the time required due to the testing required (hence the resulting discussion with  ~jyellick  and  ~robmurgai  around this patch).  ></body> </Action>
<Action id="70153" issue="45975" author="yacovm" type="comment" created="2020-09-07 10:00:26.0" updateauthor="yacovm" updated="2020-09-07 10:33:19.0"> <body><! CDATA {quote}That would be great, if people weren't standing up ordering services where all of the nodes are issued certificates at roughly the same time, and all of those certificates have now expired.  {quote}    If this is an acute problem then we should at least document it.    {quote}Pretty much every client CLI program out there has an option to disable TLS validation, don't they? At least curl and kubectl do. They're all labeled "insecure" and are opt-in. Why are we so special that we can't let the user take the risk, even if they know what they are letting themselves in for? {quote}    Well, the description of the Jira did not say anything about adding a flag, I see that Jason mentioned it, but, "ignore TLS errors" seems to me like something a user would want to opt-in if something doesn't work ;)    {quote}   I'm aware of the fix you delivered, it's great, but it only recently got merged into GitHub, and I've been told that it may not be ready in the time required due to the testing required (hence the resulting discussion with  ~jyellick  and  ~robmurgai  around this patch). {quote} I'm not sure what "it may not be ready in the time required" means (not be ready for... what?), but, *to me*, the schedule and time-frame of business related events of one organization or another, should be a function of the Fabric code base, *not the other way around*.   We need to ask ourselves: Given the fact that we no longer need to issue configuration updates upon consenter certificate expiration, would this new flag be in use? If so, then when? If not, then it makes no sense to implement it now.  ></body> </Action>
<Action id="70162" issue="45975" author="jyellick" type="comment" created="2020-09-08 20:18:55.0" updateauthor="jyellick" updated="2020-09-08 20:18:55.0"> <body><! CDATA {quote} We don't need to do this anymore, we can just replace the certificate. {quote}  This is true only if we can re-issue the certificate with the same public/private keypair.  Hopefully generally we can, but, due to infrastructure deficiencies, this might not be true.  By a similar argument, why bother allowing orderer time shift around TLS validation? It is just another tool which may be less work to utilize.  {quote} Why do we want to do such a thing? If the client can't validate the certificate, nor can the peers and the other orderers. {quote}  The assumption in this particular case is that the OSNs are timeshifted, and therefore are not rejecting eachother's connections.  {quote} Besides, such things show up in security scans.  Lastly, with TLS validation disabled, how do we know that no one intercepted our message and is now re-transmitting it to a real orderer in order to extract information? {quote}  Yes, these are good arguments for limiting the change to only allowing a TLS timeshift at the client, and not a general disabling of TLS validation.  I do think that generally disabling TLS validation could still be done in a relatively safe way -- if the user is executing the command on the same host, or other private infrastructure MiTM style attacks usually require sufficient compromise that a TLS interception is the least of your concerns.  Of course, on the other hand, allowing general disabling of TLS validation could encourage users to disable validation in scenarios which are not as safe.  It sounds to me  ~yacovm  like you would be more in favor of a plain, TLS timeshift option for the CLI, which is fine, I just thought the more general option was worth investigating.   ></body> </Action>
<Action id="70163" issue="45975" author="yacovm" type="comment" created="2020-09-08 20:42:08.0" updateauthor="yacovm" updated="2020-09-08 20:42:08.0"> <body><! CDATA {quote}By a similar argument, why bother allowing orderer time shift around TLS validation? It is just another tool which may be less work to utilize. {quote}    We don't need time shift now when we have this. But time shift was implemented long before. We can remove it if you want, I don't mind. {quote}   Yes, these are good arguments for limiting the change to only allowing a TLS timeshift at the client, and not a general disabling of TLS validation. {quote} I am in favor of a timeshift in the client side, good idea.  TLS validity is heuristic anyway, and a day or two more or less never killed anyone (famous last words?)          {quote}I do think that generally disabling TLS validation could still be done in a relatively safe way – if the user is executing the command on the same host, or other private infrastructure MiTM style attacks usually require sufficient compromise that a TLS interception is the least of your concerns. {quote}    Yes, on the same host with loopback address will work, I am unsure about the private infrastructure though, because usually you use DNS names, and plain DNS is not a very authenticated protocol.       {quote}   It sounds to me  ~yacovm  like you would be more in favor of a plain, TLS timeshift option for the CLI, which is fine, I just thought the more general option was worth investigating. {quote}    Yes, it would eliminate the security scan problem of using *InsecureSkipVerify*, and will give us good control over the possible attack vectors.  ></body> </Action>
<Action id="70166" issue="45975" author="denyeart" type="comment" body="It sounds like a client timeshift is the right compromise, I&apos;m fine going with that." created="2020-09-09 07:19:44.0" updateauthor="denyeart" updated="2020-09-09 07:19:44.0"/>
<Action id="70178" issue="45975" author="wlahti" type="comment" body="PR on master: https://github.com/hyperledger/fabric/pull/1863" created="2020-09-09 18:46:15.0" updateauthor="wlahti" updated="2020-09-09 18:46:15.0"/>
<Action id="70333" issue="45975" author="wlahti" type="comment" created="2020-09-16 15:09:15.0" updateauthor="wlahti" updated="2020-09-16 21:42:56.0"> <body><! CDATA PR on release-2.2: https://github.com/hyperledger/fabric/pull/1878  PR merged on master. Need to generate docs for master -and release-2.2-. Docs added to release-2.2 PR.  release-1.4 backport PR coming soonish.  ></body> </Action>
<Action id="70334" issue="45975" author="wlahti" type="comment" body="PR on release-1.4 with docs regenerated: https://github.com/hyperledger/fabric/pull/1887" created="2020-09-16 21:36:32.0" updateauthor="wlahti" updated="2020-09-16 21:42:19.0"/>
<Action id="71055" issue="45975" author="adarshajha" type="comment" created="2021-01-06 13:59:20.0" updateauthor="adarshajha" updated="2021-01-06 13:59:20.0"> <body><! CDATA I enabled timeshift and my orderers with expired certs went up and achieved raft consensus but when i generated new tls certs for my peers they went up but could not connect with orderers . I am getting this error :-    {code:java} 2021-01-06 13:50:02.859 UTC  deliveryClient  connect -> ERRO 0d5 Failed obtaining connection: could not connect to any of the endpoints:  {orderer1.biltilink.com:7050  OrdererMSP } {orderer3.biltilink.com:9050  OrdererMSP } {orderer6.biltilink.com:7050  OrdererMSP } {orderer5.biltilink.com:7050  OrdererMSP } {orderer2.biltilink.com:8050  OrdererMSP } {orderer4.biltilink.com:7050  OrdererMSP }  {code}    ></body> </Action>
