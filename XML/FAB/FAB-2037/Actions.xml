<Action id="20938" issue="14540" author="greg.haskins" type="comment" created="2017-02-16 17:55:59.0" updateauthor="greg.haskins" updated="2017-02-16 17:55:59.0"> <body><! CDATA Adding some additional detail.  My thoughts are as follows:  In an "installed runtime" environment, we will have generally three components  # One or more read-only configuration files (e.g. /etc/hyperledger/foo.cfg) # One or more binaries (e.g. /usr/sbin/peer) # One or more writeable data stores (e.g. /var/hyperledger).  One of the problems we have consistently struggled with is that lots of code makes certain assumptions about paths that could be classified as falling into one of two categories:  # assuming that $(GOPATH)/src/github.com/hyperledger/fabric path exists # assuming that our current working dir $CWD is something related to fabric.git structure.  It should be noted that fabric.git structure (whether it be case 1 or 2) can/should not be assumed as we will/should not have the source tree included in an installation.  Now, one could suggest that the static config path (e.g. /etc/hyperledger) could replicate the topology of fabric.git w.r.t. the relevant configuration files, and we simply set the $CWD of the process accordingly before starting it and this is technically an option.  However I would discourage it.  $CWD is typically used in R/W capacity, and therefore it would be far more natural to set it to something like /var/hyperledger than anything under /etc.  If we had no other choice, this could be used as a last resort.  However, what I am suggesting is this is $CWD=/etc/.. is suboptimal for a variety of reasons.  Here is what I consider the ideal based on other projects I have put together.  # Do not set configuration elements as environment variables that are directly* read (e.g. MSP_CFG_PATH).  Configuration elements should all be initially defined in the configuration file(s).  Overrides are ok, of course. # Do allow the path to the top-level configuration file to be specified (e.g. "-c path/to/file" or PEER_CFG_PATH are ok) # Some sensible default for the top-level configuration file location that is relative to the development tree is fine (e.g. default-path == "../peer/core.yaml") # Assume that any _external_ references in the configuration structure are either absolute FQPs, or relative to the config file itself.  E.g. if a configuration element specifies "foo/bar/baz.txt" and the config file was loaded from ./exampleconfig/config.yaml, assume this means ./exampleconfig/foo/bar/baz.txt.  If the config file was loaded from /etc/hyperledger/config.yaml, assume it means /etc/hyperledger/foo/bar/baz.txt.  This would mean we could have ./exampleconfig as the default in fabric.git but override it as necessary (e.g. from the sysvinit/systemd script or within the Dockerfile).  (*) Two exceptions: Viper overrides of configuration-file elements are fine.  And because of the way Viper works, an environment variable to specify the top-level configuration file (e.g. PEER_CFG_PATH) are ok.  ></body> </Action>
<Action id="20940" issue="14540" author="greg.haskins" type="comment" created="2017-02-16 18:06:02.0" updateauthor="greg.haskins" updated="2017-02-16 18:06:02.0"> <body><! CDATA BTW: One of the reasons I say all this is: consider the fragility we have seen with the scheme in place when someone adds MSP_CFG_PATH but only updates the ENV keys for some of the Dockerfiles/compositions.  Things break.  If the above were followed (say ./exampleconfig/ contains the entire config/files needed) then installers (e.g. .rpm/.deb/Dockerfiles) need only follow a simple rule: copy ./exampleconfig/* to /etc/hyperledger/foo and set "-c" accordingly.  No more fragility.   ></body> </Action>
<Action id="20941" issue="14540" author="kchristidis" type="comment" created="2017-02-16 18:20:20.0" updateauthor="kchristidis" updated="2017-02-16 18:20:20.0"> <body><! CDATA Thank you for expanding on the original post. Rules 2-4 are clear. Rule 1 is not.  Questions: - Is a configuration element the path to a config file? - What does reading directly mean? - What would reading indirectly mean?  ></body> </Action>
<Action id="20943" issue="14540" author="greg.haskins" type="comment" created="2017-02-16 18:46:11.0" updateauthor="greg.haskins" updated="2017-02-16 18:46:11.0"> <body><! CDATA Thanks Kostas,  The following address your questions above as items (1), (2), (3).  # By "configuration elements" I was thinking of really any type of parameterization of the program (command line args, environment variables, yaml keys) etc. # What I meant was, don't try to add ad-hoc parameters and then directly read them such as: `path := os.Getenv("MSP_CFG_PATH") + viper.GetString("peer.mspConfig")`.  I am not suggesting that everything must be yaml/viper, but what I am suggesting is that some kind app-centralized notion of "this is how I get config parameters" is important over ad-hoc solutions such as above.  If one part of the program interprets viper.GetString("peer.tls.cert") as implicitly "./"+path and  viper.GetString("peer.mspConfig") implicitly as os.GetEnv("MSP_CFG_PATH") + path, this is bad. # Reading indirectly would be to use what I alluded to above: some kind of app-centric central library.  so viper.GetBool("some.boolean") is fine for booleans, and perhaps configutil.GetPath("peer.tls.cert") for strings that should be interpreted as either FQPs or config-relative.  ></body> </Action>
<Action id="20950" issue="14540" author="kchristidis" type="comment" body="That clears it for me, thank you. (Good suggestions all.)" created="2017-02-16 20:02:18.0" updateauthor="kchristidis" updated="2017-02-16 20:02:18.0"/>
