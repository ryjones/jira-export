<Issue id="14540" key="FAB-2037" number="2037" project="10002" reporter="greg.haskins" assignee="greg.haskins" creator="greg.haskins" type="10001" summary="Provide mechanism to refer to config-relative file paths" priority="3" resolution="10000" status="6" created="2017-02-04 13:39:20.0" updated="2018-07-20 18:54:52.0" resolutiondate="2017-04-26 12:55:23.0" votes="0" watches="2" workflowId="37298"> <description><! CDATA There is a general shortcoming in the current architecture related to the configuration of external paths.  Consider a yaml key like "foo.bar.path = path/to/foobar".  This pattern is currently used for things like x509 certificates, etc.  The problem is when any code tries to utilize the key using standard techniques (e.g. os.Open(viper.GetString("foo.bar.path")) this will only succeed if the path is relative to the $CWD of the peer binary.  This has generally worked to date because we were only supporting and operating with software built from and run within the fabric.git repository, where those paths happened to exist.  Fast forward to the near future when we want to install the peer and its config using Linux Standards Base-esq techniques (e.g. config in /etc, binary in /usr/bin, etc) and this quickly becomes awkward.  We could work-around things by setting the peer $CWD to the path of the configuration, but that is hacky.  A better solution is to formally support the notion of config-relative paths with a substrate layer that can be used throughout the code base.  for example:  func GetConfigPath(key string) (string, error)  where "GetConfigPath("foo.bar.path") would return "/etc/hyperledger/fabric/peer/path/to/foobar" if the config were located in /etc/hyperledger/fabric/peer and the key equated to "path/to/foobar".  Of course, absolute paths would be passed untouched.  ></description> </Issue>
