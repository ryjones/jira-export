<Issue id="29477" key="FAB-9571" number="9571" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10003" summary="MSP cache doesn&apos;t cache indirect calls to Validate" priority="3" resolution="10000" status="6" created="2018-04-18 10:42:55.0" updated="2018-07-20 14:16:21.0" resolutiondate="2018-04-18 16:40:04.0" votes="0" watches="1" workflowId="41871"> <description><! CDATA The MSP cache, caches the invocation of *Validate*, however - many of the invocations of *Validate* are invoked indirectly via the identities that the MSP returns via DeserializeIdentity(), and these invocations are not cached, because the bccsp msp's identity simply invokes the bccsp MSP's *Validate()* which bypasses the cache.  The following code demonstrates it:  {code} func TestSatisfiesValidateIndirectCall(t *testing.T) { 	mockMSP := &mocks.MockMSP{}  	mockIdentity := &mocks.MockIdentity{ID: "Alice"} 	mockIdentity.On("Validate").Run(func(_ mock.Arguments) { 		panic("shouldn't have invoked the identity method") 	}) 	mockMSP.On("DeserializeIdentity", mock.Anything).Return(mockIdentity, nil).Once() 	mockIdentity.On("GetIdentifier").Return(&msp.IdentityIdentifier{Mspid: "MSP", Id: "Alice"})  	cache, err := New(mockMSP) 	assert.NoError(t, err)  	// First invocation of the SatisfiesPrincipal returns an error 	mockMSP.On("Validate", mockIdentity).Return(errors.New("error: foo")).Once() 	// Second invocation returns nil 	mockMSP.On("Validate", mockIdentity).Return(nil).Once()  	// Test that cache returns the correct value 	err = cache.Validate(mockIdentity) 	assert.Equal(t, "error: foo", err.Error()) 	// Get the identity we test the caching on 	identity, err := cache.DeserializeIdentity(  byte{1, 2, 3}) 	assert.NoError(t, err) 	// Ensure the identity returned answers what the cached MSP answers. 	// If the invocation doesn't hit the cache, it will return nil instead of an error. 	err = identity.Validate() 	assert.Equal(t, "error: foo", err.Error()) } {code}  ></description> </Issue>
