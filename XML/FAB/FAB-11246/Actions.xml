<Action id="46268" issue="31209" author="odowdaibm" type="comment" body="Hello  ~SjirNijssen  - this is the second JIRA that we discussed - it adds more structure to chaincode, evolving them towards a more formal smart contract.  Feel free to comment here, and participate via Google doc too.  Thanks." created="2018-06-20 08:29:36.0" updateauthor="odowdaibm" updated="2018-06-20 08:29:36.0"/>
<Action id="46270" issue="31209" author="odowdaibm" type="comment" body="Hello  ~bobbiejc  - here&apos;s the JIRA and referenced Google doc for chaincode structure - moving Fabric closer to a formal smart contract definition" created="2018-06-20 08:47:50.0" updateauthor="odowdaibm" updated="2018-06-20 08:47:50.0"/>
<Action id="46288" issue="31209" author="sjirnijssen" type="comment" created="2018-06-20 13:02:23.0" updateauthor="sjirnijssen" updated="2018-06-20 13:02:23.0"> <body><! CDATA Congratulations with this step forward.  In the associated document I read:  This also allows for future transaction level endorsement policies to be supported.  I want to repeat that not having available function based endorsement policies will be a showstopper in many business applications that have to do with government regulations. I hope the people that have the power to decide on 2.3 will remove that showstopper for Fabric.  ></body> </Action>
<Action id="46299" issue="31209" author="sjirnijssen" type="comment" body="Excuse me, 2.3 was a bad typo above; of course 1.3 is meant" created="2018-06-20 15:47:33.0" updateauthor="sjirnijssen" updated="2018-06-20 15:47:33.0"/>
<Action id="46308" issue="31209" author="yacovm" type="comment" created="2018-06-20 17:36:39.0" updateauthor="yacovm" updated="2018-06-20 17:36:39.0"> <body><! CDATA {quote} The transaction functions will be discoverable{quote}  how?  ></body> </Action>
<Action id="46592" issue="31209" author="mbwhite" type="comment" created="2018-06-27 11:19:16.0" updateauthor="mbwhite" updated="2018-06-27 12:20:38.0"> <body><! CDATA After some prototyping, I have updated the Google-doc linked above.     Also as example of what a SmartContract would look like please see  https://github.com/mbwhite/chaincode-examples/tree/europa|https://github.com/mbwhite/chaincode-examples/tree/europa   ></body> </Action>
<Action id="46991" issue="31209" author="mbwhite" type="comment" created="2018-07-06 10:10:46.0" updateauthor="mbwhite" updated="2018-07-06 10:10:46.0"> <body><! CDATA The GoogleDoc has been updated, as have the example repo mentioned above.  Would encourage you to look at this repo - as tries to show in a real example how chaincode could be written.    ~yacovm  I want to read up on the discovery features within 1.2, and see how these could be incorporated.   ></body> </Action>
<Action id="46992" issue="31209" author="yacovm" type="comment" created="2018-07-06 10:47:26.0" updateauthor="yacovm" updated="2018-07-06 10:47:26.0"> <body><! CDATA {quote}Yacov Manevich I want to read up on the discovery features within 1.2, and see how these could be incorporated. {quote} sure... you can read about it  here|https://hyperledger-fabric.readthedocs.io/en/latest/discovery-overview.html  and if we end up having state-based endorsement in v1.3 then we can add endorser queries per *namespace:key* and not only per namespace as it is now.  *However*: {quote}Having functions as a first class entity could enable possible future enhancements such as permit per-function endorsement policies - e.g. each function would have rules defining who had to endorse transactions for that function, rather than a single policy at the chaincode level governing all functions. However we are not proposing to implement these enhancements at this point. {quote} (This is from the google document)   Doing so would cripple Fabric's security:  Let's assume we have organizations *A, B, C* and a chaincode with 2 functions, *f* and *g* each with its own endorsement policy: * function *f*'s endorsement policy is *A* and *B*, * function *g*'s endorsement policy is (*A* and *C*) or (*B* and *C*). * *f* controls asset transfer, while *g* control asset creation. Since you execute transactions on only a subset of peers, if *A* and *C* collude, they can dishonestly transfer assets by crafting a transaction that claims to invoke *g*, but one that has an artificial read-write set that actually does something that *g* can't do (transfer an asset, something that only *f* can do) and signing it with a private key that corresponds to an identity from organization *A*, and a private key that corresponds to an identity from organization *C*. When the peers would validate this transaction, they'd use *g*'s endorsement policy and the business impact on the system would be that an asset was moved without consent from organization *B*, even though the endorsement policy of *f* should have prevented this from happening.  Clearly, this happens because since Fabric is an execute-order-validate blockchain - the transactions are executed on a subset of the peers, and if the endorsement policy is satisfied by the endorsements of the transaction - you have no real way of knowing whether the transaction was executed honestly or not since the peers are ignorant of how the transaction write set was created based on the read set and the chaincode proposal and thus can't distinguish between a maliciously crafted one from an honest one.  ></body> </Action>
<Action id="47029" issue="31209" author="mbwhite" type="comment" created="2018-07-06 13:33:23.0" updateauthor="mbwhite" updated="2018-07-06 13:33:23.0"> <body><! CDATA Thanks for the explanation; I'm still 'digesting' the details - together with the state-based endorsement - so I may edit this comment later..  Yes I can see how in the example you've cited how the data's integrity could be compromised. To summarise - as both functions have access to the same state namespace both create access and modify the state date (i.e. produce the same read/write sets) that would be endorsed.   By putting the endorsement policy at the namespace level forces that policy to apply to everything.   How much is this though, a consequence of poor configuration, rather than a 'design' problem?  In the per fn case it is putting more responsibility on to the admin to get the policies correct - but they have to get the policy correct for other endorsement strategies as well.   Will keep reviewing...    ></body> </Action>
<Action id="47032" issue="31209" author="yacovm" type="comment" created="2018-07-06 13:49:17.0" updateauthor="yacovm" updated="2018-07-06 13:49:17.0"> <body><! CDATA {quote}How much is this though, a consequence of poor configuration, rather than a 'design' problem? In the per fn case it is putting more responsibility on to the admin to get the policies correct - but they have to get the policy correct for other endorsement strategies as well. {quote}    But if you assume: * more than 1 function in the chaincode, * a per-function endorsement policy model and endorsement policies for functions that are not the same  Then you are automatically and immediately open for the kind of abuse I have outlined.  ></body> </Action>
<Action id="47035" issue="31209" author="sstone1" type="comment" body=" ~yacovm  putting functions to one side, I now have a bigger question based on your responses above. Is there anything in Fabric that ensures that the chaincode ever got executed as part of a valid transaction? It sounds like organisations can collude and craft their own artificial read write sets that do anything (even if the chaincode says otherwise), as long as enough organisations sign those read write sets to meet the endorsement policy. Is my understanding correct?" created="2018-07-06 14:00:40.0" updateauthor="sstone1" updated="2018-07-06 14:00:40.0"/>
<Action id="47039" issue="31209" author="yacovm" type="comment" created="2018-07-06 14:16:04.0" updateauthor="yacovm" updated="2018-07-06 14:16:04.0"> <body><! CDATA {quote}It sounds like organisations can collude and craft their own artificial read write sets that do anything (even if the chaincode says otherwise), as long as enough organizations sign those read write sets to meet the endorsement policy. Is my understanding correct? {quote}    Of course... that's exactly what the endorsement policy is for. To define the minimal set of organizations that the channel admins trust not to be hacked/collude altogether.  ></body> </Action>
<Action id="47041" issue="31209" author="sstone1" type="comment" created="2018-07-06 14:58:40.0" updateauthor="sstone1" updated="2018-07-06 14:58:40.0"> <body><! CDATA  ~yacovm  OK, so chaincode is nothing more than a simple way to generate read/write sets. If you want to have any trust that the business rules encoded in the chaincode are actually being enforced, then you must be specified as a mandatory endorser in the endorsement policy. I suspect if that was made clear to end users then I suspect all endorsement policies would read "everybody must sign" - but fine ;-)  Anyway, to combat the abuse you outline - could we not have a combination of chaincode level endorsement policies and function level endorsement policies? Why do we have to have one or the other?  The chaincode could have an endorsement policy that states that all transactions must be endorsed by a set of organisations S1. Function F could have an endorsement policy that states that a transaction for the function F must be signed by a set of organisations S2. In order for a transaction calling function F to be deemed valid, all organisations in both S1 and S2 must endorse the transaction.  This would allow the minimal set of organisations you mention above to be specified at the chaincode level - for example S1 might contain a highly trusted party such as the industry regulator - to ensure that the specified function has been executed. You could then enforce that a set of additional organisations in S2 must endorse the transaction at the function level.   ></body> </Action>
<Action id="47046" issue="31209" author="yacovm" type="comment" created="2018-07-06 15:53:23.0" updateauthor="yacovm" updated="2018-07-06 15:53:23.0"> <body><! CDATA {quote}I suspect if that was made clear to end users then I suspect all endorsement policies would read "everybody must sign" {quote} No... of course not. If both Alice and Bob sign that Bob gave Alice money then Carol shouldn't sign that because she believes that if both Alice and Bob signed the transaction then it is OK.  Anyway, to combat the abuse you outline - could we not have a combination of chaincode level endorsement policies and function level endorsement policies? Why do we have to have one or the other?     But then the function would be the only function in the chaincode namespace.  Please read  ~mbwhite  's comment - it explains the core issue pretty well:    {quote}Yes I can see how in the example you've cited how the data's integrity could be compromised. To summarise - as both functions have access to the same state namespace both create access and modify the state date (i.e. produce the same read/write sets) that would be endorsed. By putting the endorsement policy at the namespace level forces that policy to apply to everything. {quote}    ................    {quote}The chaincode could have an endorsement policy that states that all transactions must be endorsed by a set of organizations S1. Function F could have an endorsement policy that states that a transaction for the function F must be signed by a set of organizations S2. In order for a transaction calling function F to be deemed valid, all organizations in both S1 and S2 must endorse the transaction. {quote} But... how do you (a peer) *know* at commit time that the chaincode executed function F, without re-running function *F* itself at time of commit?  ></body> </Action>
<Action id="47052" issue="31209" author="jyellick" type="comment" created="2018-07-06 19:19:49.0" updateauthor="jyellick" updated="2018-07-06 19:19:49.0"> <body><! CDATA Architecturally, per-function endorsement policies don't make any sense.    As  ~yacovm  points out above, endorsement policy is what gives the system assurances that the output of a transaction corresponds to the transaction's intent.  A chaincode with per-function endorsement policies will be as insecure as the most lenient endorsement policy.  Any endorsement based validation logic which inspects the proposal's intent (function and or parameters) is something that I strongly oppose.  IMO, the only way to sanely do intent based validation is to execute the entire transaction at commit time (in which case, executing before ordering makes no sense).  This is a model Fabric needs to support, and one it is planning to, but a hybrid model of pre-order execution for endorsement and post-order intent based validation gives the worst of both worlds and invites security problems.  Most likely, the goals of per-function endorsement can actually be achieved with the more conceptually sound 'state-based-endorsement', where different parts of the chaincode namespace have different endorsement policies.  If, by convention, a chaincode function only writes into a particular subset of the chaincode namespace, and that subset has been assigned an endorsement policy, then a very similar affect is achieved, but without any of the insecurity introduced by intent based validation.  The key difference here is that the validation logic is dictated by what the chaincode invocation does, and not what it claims to do.  ></body> </Action>
<Action id="47068" issue="31209" author="sstone1" type="comment" created="2018-07-08 19:09:06.0" updateauthor="sstone1" updated="2018-07-08 19:09:06.0"> <body><! CDATA  ~jyellick   ~yacovm  okay, understood.   We need to keep the discussion on track to what we're planning on implementing under this JIRA, which is functions as a first class concept in Fabric, instead of Invoke() functions with boilerplate dispatch tables to improve the chaincode and application development experience.  I've updated the associated Google Docs to remove the reference to function level endorsement policies as something that _could_ be done as a future enhancement; as you've described above, this does not sound possible with the way Fabric works today.  ></body> </Action>
<Action id="47069" issue="31209" author="yacovm" type="comment" created="2018-07-08 20:47:04.0" updateauthor="yacovm" updated="2018-07-08 20:47:04.0"> <body><! CDATA {quote}functions as a first class concept in Fabric, instead of Invoke() functions with boilerplate dispatch tables to improve the chaincode and application development experience. {quote}    I have an additional question (if I may) but before let me make sure that I understood properly: {quote}A class *must* extend  SmartContract as follows.  *class MySmartContract extends SmartContract \{*   *constructor() \{*      *    **super(<optional namespace string>)*   *}*   *async myTransaction1(api, arg_1, arg_2, arg_3) \{*   *}*   *async myTransaction2(api, arg_1, arg_2) \{*   *}*   *async myQuery1(api, arg1) \{*      *    **return results;*   *}*  *}*     The arguments are expanded from the requested, rather than be passed as a single array {quote}    The above is from the google doc.  So, what I understood is that the chaincode shim would: # Take the Fabric *repeated bytes args* from the  chaincode input|https://github.com/hyperledger/fabric/blob/master/protos/peer/chaincode.proto#L54  protobuf message passed to the shim # Cast the first byte array of the *repeated bytes args* to a string and infer from it the function of the object to invoke # Shift the *repeated bytes args* # Treat the shifted *repeated bytes args* as parameters to the function inferred in step (2).     *1)* Is this correct?  *2)* If so - then are the remaining arguments going to be just byte arrays ?  *3)* If not - then how are they going to be represented? Surely they can't be represented by any specific type, since they can be encoded by any way the application developer wants (i.e - protobuf, XML, JSON, strings, ASN1, Thrift, etc. etc.)        ></body> </Action>
<Action id="47085" issue="31209" author="mbwhite" type="comment" created="2018-07-09 08:49:59.0" updateauthor="mbwhite" updated="2018-07-09 08:49:59.0"> <body><! CDATA 1) Almost... but following the model how the arguments are marshaled today.  i.e. following the pattern of the getFunctionaAndParameters() in the stub.   JavaScript being duck-typed gives freedom here.   So the parameters will be received by the functions as they would be today if you called getFunctionAndParameters()      ></body> </Action>
<Action id="47090" issue="31209" author="yacovm" type="comment" created="2018-07-09 10:53:12.0" updateauthor="yacovm" updated="2018-07-09 10:53:12.0"> <body><! CDATA {quote}i.e. following the pattern of the getFunctionaAndParameters() in the stub. {quote}    This just assumes these are UTF-8 encoded strings though, no? What if the client application sends a sequence of bytes in the arguments that can't be encoded as a UTF-8 string, like a single byte that is equal to 255 (all bits are set), 2 bytes that are 255,255, etc.  These (as far as I know) are not valid UTF-8 encoded strings and thus the encoding will fail, and the bytes that are going to be passed into the function implementation of the chaincode application writer would vanish.  A simple node.js example can demonstrate it:    {code} var ByteBuffer = require('bytebuffer'); var buff = ByteBuffer.allocate(2); buff.writeByte(255); buff.writeByte(255); console.log(buff.buffer.byteLength); // prints 2 var newBuff = ByteBuffer.fromUTF8(buff.toUTF8()); console.log(newBuff.buffer.byteLength); // prints 0 {code}          ></body> </Action>
<Action id="47091" issue="31209" author="mbwhite" type="comment" created="2018-07-09 11:13:25.0" updateauthor="mbwhite" updated="2018-07-09 11:13:25.0"> <body><! CDATA That is true  ~yacovm  in principle; hence the base64 encoding commonly used with strings.   The fabric-node-sdk has within 'chaincodeInvokeRequest' this property  {{args	Array.<string>	An array of string arguments specific to the chaincode's 'Invoke' method}} (ref: https://fabric-sdk-node.github.io/global.html#ChaincodeInvokeRequest)  So for bytes that couldn't be encoded, the contract between the application and sdk/chaincode interface would have been broken.  The stub would also have issues with such data.  ></body> </Action>
<Action id="48003" issue="31209" author="jmason900" type="comment" created="2018-07-27 03:07:46.0" updateauthor="jmason900" updated="2018-07-27 03:07:46.0"> <body><! CDATA The new programming model adds options easily without removing any capabilities – a clear win. Fabric will offer a new, optional, easy application abstraction model that simplifies developing business blockchain applications.  It provides an easier starting point for many companies with simpler blockchain use cases and those new to blockchain. The expected impacts include:   • shorter learning curves  • lower development  costs • shorter time to value • exponential increase in Fabric adoption  The new application layer provides introspection services as well. This metadata opens opportunities for  build tools that can generate:   • new blockchain contracts from contract models and named network configuration objects • blockchain client applications for those contracts • REST api servers for those contracts • Simple front-end applications using the REST api servers   Fabric has become the “go to” framework for robust, production-level blockchain solutions in much of the real world today. As the set of features, supported environments and performance continue to improve, Fabric expands the wide set of use cases it covers well.   The key takeaways for the new optional Fabric easy application layer value adds include:   • it dramatically lowers the time and cost to create simple blockchain applications • it does not limit in any way the Fabric full application model available for rich, scalable blockchain solutions • It provides access to the full application model as needed through network objects and other properties  • It positions Fabric as a platform that is easy to start with and scales rapidly to any level to meet business requirements • It makes Fabric the smart investment as a blockchain platform • It dramatically increases platform adoption and growth  The initial application client for the new application easy layer is the Nodejs SDK.  As a design pattern, adding layers of abstraction normally adds business value in many domains since it addresses additional use cases. In database, I have a physical data model for an order header and a related order detail table. I use a logical view as needed to access orders. I also have access to the related physical tables and their metadata in the database catalog. There is a need for access at both levels and the relations are clear between physical and logical levels. We even add more data services layers as required.  That’s my 10 cents on where this fits..  Note on documentation and training:   Our samples and documentation need to demonstrate 3 things clearly: • the easy layer application solution and life cycle  • the full layer application solution and life cycle ( our existing samples do that well )  • the integration of the application easy layer to full layer wherever needed    ></body> </Action>
<Action id="48643" issue="31209" author="sjirnijssen" type="comment" created="2018-08-09 15:18:43.0" updateauthor="sjirnijssen" updated="2018-08-09 15:18:43.0"> <body><! CDATA Hi Matthew,  I am studying the tutorial. I keep a list of the typos. But I am more interested in the contents.  You state under the heading:  "What needs to be stored in the ledger? One of the most important questions to be handled. It is not appropriate to store all the data elements in the  Fabric blockchain  system - only the parts that are essential to maintain the single source of truth."  When I see how much overhead is stored in a Fabric block, I would recommend in the name of keep it simple, not to have a parallel database with less important data. I believe it is not worth the hassle.  I look forward to your opinion on this view.   ></body> </Action>
<Action id="48649" issue="31209" author="sjirnijssen" type="comment" created="2018-08-09 16:06:42.0" updateauthor="sjirnijssen" updated="2018-08-09 16:06:42.0"> <body><! CDATA Hi Matthew,  Let me first say that I like very much the approach that is now taken to simplify the user interface. A very good step forward.  When reading further in the tutorial I come across the following:  "A data model of what needs to be stored and how it will be persisted is important; this will  be  determine d  by the requirements of the business and they also determine  (((delete: and be determined by end-of-delete))) the operations that are performed on this data."  "Remember the  state  data  part  on the ledger can be thought of as a single 'state of key value pairs'. Operations are performed using this state (and supplied parameters), from which a set of changes to the state are produced  the write-set  - that are then applied to create a new state,  provided the endorsement and validation is positive. "  I hope this format is ok with you.    ></body> </Action>
<Action id="49878" issue="31209" author="sstone1" type="comment" body=" ~denyeart  just wanted to make a clear statement on where we are with this epic; transaction methods and the smart contract APIs will be delivered for Fabric v1.3, but only for Node.js and JavaScript/TypeScript. As discussed, we will look to deliver Golang and Java support in Fabric v1.4." created="2018-09-05 08:59:49.0" updateauthor="sstone1" updated="2018-09-05 08:59:49.0"/>
<Action id="50262" issue="31209" author="denyeart" type="comment" body="Based on discussions with Anthony, moving to v1.4.0 as an early beta." created="2018-09-11 13:59:40.0" updateauthor="denyeart" updated="2018-09-11 13:59:40.0"/>
<Action id="51420" issue="31209" author="mbwhite" type="comment" created="2018-10-01 11:04:04.0" updateauthor="mbwhite" updated="2018-10-01 11:04:04.0"> <body><! CDATA Updates as a result of feedback  - https://jira.hyperledger.org/browse/FABN-940     ></body> </Action>
<Action id="56064" issue="31209" author="denyeart" type="comment" body=" ~mbwhite  Please check children stories to make sure status and FixVersion are correct. I for one don&apos;t have a good idea of what remains for v2.0 versus what is intended to be deferred to Future." created="2019-01-23 04:21:34.0" updateauthor="denyeart" updated="2019-01-23 04:21:34.0"/>
