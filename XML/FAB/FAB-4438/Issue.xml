<Issue id="17597" key="FAB-4438" number="4438" project="10002" reporter="kchristidis" assignee="kchristidis" creator="kchristidis" type="10004" summary="Potential race condition in mock ConsenterSupport WriteBlock" priority="5" resolution="10000" status="6" created="2017-06-07 00:44:29.0" updated="2018-07-20 14:13:11.0" resolutiondate="2017-06-09 15:34:37.0" votes="0" watches="1" workflowId="38873" security="10001"> <description><! CDATA Assume you want to test function Foo that invokes the blockcutter, then ranges over the resulting batches in order to create and write blocks. For example:  https://github.com/hyperledger/fabric/blob/master/orderer/kafka/chain.go#L338...L348   In the unit test TestFoo, you would pass a mock `ConsenterSupport` object to Foo, to take care of the `Ordered()`, `CreateNextBlock()`, and `WriteBlock()` calls.  Assume now that you wish to inspect the blocks written by Foo when the blockcutter returns two batches (i.e. we just got a config tx in).  I believe that the only way to achieve this is via a select statement that will pick up `WriteBlockVal` from the mock `ConsenterSupport`, when its `Batches` channel is consumed. Example:  https://github.com/hyperledger/fabric/blob/master/orderer/kafka/chain_test.go#L616...L628   However this introduces a race condition.  Before TestFoo is able to  retrieve the first `WriteBlockVal`|https://github.com/hyperledger/fabric/blob/master/orderer/kafka/chain_test.go#L618 Â that value is overwritten  by the second batch's CreateNextBlock/WriteBlock in Foo|https://github.com/hyperledger/fabric/blob/master/orderer/kafka/chain_test.go#L618 .  ></description> </Issue>
