<Issue id="40255" key="FAB-15599" number="15599" project="10002" reporter="ales" creator="ales" type="10003" summary="QueryNamespaceDefinitions should return aggregate info from old and new lifecycle" priority="3" status="10000" created="2019-05-31 17:04:42.0" updated="2020-06-11 15:31:06.0" votes="0" watches="1" workflowId="53161"> <description><! CDATA The new version of the query should return info from both the legacy and the new lifecycle. The new lifecycle returns this {code:java} type QueryNamespaceDefinitionsResult struct { 	Namespaces           map string *QueryNamespaceDefinitionsResult_Namespace `protobuf:"bytes,1,rep,name=namespaces,proto3" json:"namespaces,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"` 	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"` 	XXX_unrecognized       byte                                                `json:"-"` 	XXX_sizecache        int32                                                 `json:"-"` } type QueryNamespaceDefinitionsResult_Namespace struct { 	Type                 string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"` 	XXX_NoUnkeyedLiteral struct{} `json:"-"` 	XXX_unrecognized       byte   `json:"-"` 	XXX_sizecache        int32    `json:"-"` } {code} but the corresponding LSCC query (LSCC.GETCHAINCODES) returns {code:java} type ChaincodeQueryResponse struct { 	Chaincodes             *ChaincodeInfo `protobuf:"bytes,1,rep,name=chaincodes,proto3" json:"chaincodes,omitempty"` 	XXX_NoUnkeyedLiteral struct{}         `json:"-"` 	XXX_unrecognized       byte           `json:"-"` 	XXX_sizecache        int32            `json:"-"` }  type ChaincodeInfo struct { 	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` 	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"` 	// the path as specified by the install/instantiate transaction 	Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"` 	// the chaincode function upon instantiation and its arguments. This will be 	// blank if the query is returning information about installed chaincodes. 	Input string `protobuf:"bytes,4,opt,name=input,proto3" json:"input,omitempty"` 	// the name of the ESCC for this chaincode. This will be 	// blank if the query is returning information about installed chaincodes. 	Escc string `protobuf:"bytes,5,opt,name=escc,proto3" json:"escc,omitempty"` 	// the name of the VSCC for this chaincode. This will be 	// blank if the query is returning information about installed chaincodes. 	Vscc string `protobuf:"bytes,6,opt,name=vscc,proto3" json:"vscc,omitempty"` 	// the chaincode unique id. 	// computed as: H( 	//                H(name || version) || 	//                H(CodePackage) 	//              ) 	Id                     byte   `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"` 	XXX_NoUnkeyedLiteral struct{} `json:"-"` 	XXX_unrecognized       byte   `json:"-"` 	XXX_sizecache        int32    `json:"-"` } {code} We have 2 options: # change the query results of the new lifecycle to make them compatible (in terms of returned information) to the old ones, and then simply use the results ofÂ LSCC.GETCHAINCODES to fill info for the legacy lifecycle # keep the current semantics of the query, and return similar info for the legacy lifecycle.  We need to apply appropriate shadowing rules so that if a chaincode is present on both lifecycles, information from the new lifecycle shadows that from the legacy.  We also need a flag to tell which of the chaincodes is currently defined in the new or the legacy lifecycle.  ></description> </Issue>
