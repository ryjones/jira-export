<Action id="20189" issue="13303" author="scottz" type="comment" created="2016-12-23 21:07:02.0" updateauthor="scottz" updated="2016-12-30 03:51:33.0"> <body><! CDATA Progress so far on Murali's and Simon's submissions (listed in FAB-1434):  ============================== FAB-1192: Solo orderer not cutting blocks after first batch We must ensure that there are multiple blocks and multiple batches. 1. Create a network containing 1 endorser/committer peer and 1 orderer configured as Solo. Deploy a chaincode. 2. Propose and broadcast 1 transaction, and wait for batch timeout (the default is 10 secs) and verify that a batch/block is delivered and committed and blockheight increases. 3. Repeat previous step, and confirm blockheight increases again.  =========================== FAB-1095: atomic broadcast delivery client (committer) needs to receive delivered batches from more than one orderer. ? Is it ok to generally think as if there was communication between only 1 orderer node and a peer, since the requirement for this is really only for crash tolerance and BFT? (ie. another orderer must deliver msgs when the designated one is unavailable) ? Or, does normal behavior dictate that leader-peers receive duplicate deliveries (and therefore must ignore dups)? Can we write unit tests or feature tests to confirm that the leader-peer receives two deliveries of each block (when all orderers functioning normally) or receive at least one delivery whenever any one orderer is unavailable? Confirm by watching for those delivery msgs; or maybe use the bigger picture by using event notifications, or using queries to ensure every transaction is written exactly once.  The peers gossip and elect a leader and that one probably contacts the orderers to tell them that he wants to receive all the deliveries for the channel. But how does the peer know which orderer to talk to? And how do the orderer(s) decide which will deliver the blocks to the leader peer(s)? We can talk to Tuan about that.  # Confirm messaging between orderers and peers, regardless of which leader peer or orderer is OOS. This is more an IT test than FT, as it uses full network (unlike the next test for FAB-478 that focuses and uses only orderers). 1. Set up 4 peers on one chain. Let gossip select one or more leaders. 10. Set up 4 nodes in the orderer service using SBFT. (What is the expected behavior for others?) 20. Cycle through those 8 servers: stop one at a time, send transactions, confirm ordered and committed (either event notification or query all active committer-peers) to ledger, restart it. 40. At end, send 4 transactions, one to each orderer node, and query all peers (A & B values) to ensure all are committed and all peers are in sync.   =================================== FAB-967: Start View timer after receiving a quorum (2f+1) of view change messages instead of immediately when we send our own view change message (after recovery when we discover we are behind) (https://gerrit.hyperledger.org/r/#/c/2511/4/orderer/sbft/simplebft/simplebft_test.go) Starting it too early and timing out sooner would cause an observable incorrect behavior such as: ... ? (I need to read more about PBFT. maybe this timeout would increment our viewchange number and postpone the sync-up with rest of network?) Therefore, doing this correctly results in this: ... ? ... This is covered in UT: orderer/sbft/simplebftr/simplebft_test.go func TestViewChangeTimer(). ... Not sure we can write FT testcase. Skip it.   ======================= FAB-473: SBFT: Interaction with an atomic broadcast client and SBFT orderer Seems this was a temporary stage along the way to allow partial bootstrapping, in September. ... No FT needed.   =================================== FAB-478/FAB-472/FAB-604: SBFT: state transfers when new node joins or when detect behind; exchange Node replica state and state transfer on new connection. Objective: Node joins late, and catches up. Objective: Rotate disconnects and reconnects so that all correct nodes have gaps in their ledgers. State transfer finally manages to sync everybody to the latest batch. 1. Create an orderer service network containing 4 orderers configured as SBFT - but start only vp0 vp1 vp2. 2. Set up an authorized user (bihn) for broadcasting Tx to the orderer service, and for receiving deliveries. 3. Deploy a chaincode 4. Broadcast 10 invoke transactions. Verify all delivered/committed. # (Choose 10 to ensure a new block. #  Otherwise could send one Tx and wait 10 secs for it to be batched). ### Look at these parameters in fabric/orderer/orderer.yaml : # Batch Timeout: The amount of time to wait before creating a batch BatchTimeout: 10s # Batch Size: Controls the number of messages batched into a block BatchSize: # Max Message Count: The maximum number of messages to permit in a batch MaxMessageCount: 10 5. Start vp3. 6. Broadcast 10 Tx to any orderer vpN. 7. stop/disconnect orderer 0, broadcast 10 Tx to orderer 3, verify o1 o2 o3 all process and at least one orderer delivers 1 or 2 batch(es), restart orderer 0. 8. stop/disconnect orderer 1, broadcast 10 Tx to orderer 3, verify o0 o2 o3 all process and at least one orderer delivers 1 or 2 batch(es), restart orderer 1. 9. stop/disconnect orderer 2, broadcast 10 Tx to orderer 3, verify o0 o1 o3 all process and at least one orderer delivers 1 or 2 batch(es), restart orderer 2. 10.stop/disconnect orderer 3, broadcast 10 Tx to orderer 0, verify o0 o1 o2 all process and at least one orderer delivers 1 or 2 batch(es), restart orderer 3. 11.Broadcast 10 or 40 or 800 Tx, verify all Tx delivered, and if possible we must: verify all orderers are in sync with same view and state (by examining logs or ?), and verify matching blockchain height and chaincode attribute values on all 4 nodes   =================================== FAB-603: Limit the number of messages per replica. SBFT. Solved in https://gerrit.hyperledger.org/r/#/c/2139/ This is not configurable, although maybe should be. See consensus/simplebft/backlog.go If any one source has sent us more than (4x3) msgs into our backlog, then discard them all and reconnect. const maxBacklogSeq = 4 const msgPerSeq = 3 // (pre)prepare, commit, checkpoint: 3 msgs per viewchange There is a unit test already. I am not sure how we can do this as a feature test (black box test, without intrusions). Thoughts: - Can we keep the 4th peer alive while halting the task processing/emptying queued msgs, while other peers advance thru several viewchanges? If it is stopped, the msgs won't be queued. If it is running normally, the msgs will be processed as they arrive instead of queued. - Maybe we can docker-pause it, to disconnect it. But the msgs won't queue up and all arrive when reconnect; rather msgs sent while disconnected would be simply lost. - Maybe we could rebuild one of the other peers, to send 13 msgs (duplicates, erroneously) instead of one, to this target peer.  But then that would not be a black box feature test... 1. Create a network containing 4 orderers (configured as SBFT), COP, and 1 peer. 2. Deploy a chaincode. Cause 5 viewchanges, by stop/restarting one of the other orderers. ???  Does the target orderer discard msgs and reconnect to all the other orderers as it should? --> Decision: just leave this for unit testing, and skip trying to write a feature test.  ======================= FAB-1139: Peer exit with panic when invoking the chaincode (Network unable to find stable certificate) - we do not want to see this error in log ...This was closed; it was determined to be a chaincode problem - maybe non-determinism...     =================================== FAB-1203: Non-vpn peer name With PBFT, DEPLOY fails if we change PEER_ID from vpN to anything else This ticket was marked Done, with no submission that I can find. Write a test anyways: 1. Create a network containing 4 orderers (configured as PBFT), COP, and 1 peer, using an orderer name node1 (set PEER_ID in compose file). See peer-secure-pbft-base.yaml. 2. Deploy a chaincode on node1, a node named something other than vpN. 3. Deploy should pass; Check logs to see if the nodes synchronize. Here is example failure message in logs: node1_1 | 08:56:35.018  consensus/pbft  recvViewChange -> WARN 7eb Replica 0 found incorrect signature in view-change message: Could not verify message from vp0 (unknown peer)   ></body> </Action>
<Action id="20222" issue="13303" author="latitiah" type="comment" created="2016-12-28 21:15:20.0" updateauthor="latitiah" updated="2017-01-13 15:14:25.0"> <body><! CDATA -- FAB-1253: Send transactions to kafka server larger than 1M  - Send transactions to solo orderer larger than 1M --- What size is considered too larger? - FAB-1232: Send a "too larger" transaction to orderer: (Recv: REQUEST_ENTITY_TOO_LARGE- 413 error) 1. Create a network containing an orderer (different iterations configured as solo, kafka, sbft) (and 1 peer? Can I send transaction without the peer?) 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" a 1M jpeg to the orderer 4. The authorized user should receive a "deliver" message from the orderer 5. Within a certain amount of time (?), the "deliver" message should contain: a. 1 block b. ? c. ? 6. The authorized user should "broadcast" a 10M mpg to the orderer 7. The authorized user should receive a "deliver" message from the orderer 8. Within a certain amount of time (?), the "deliver" message should report a REQUEST_ENTITY_TOO_LARGE- 413 error    FAB-890: Kafka: produce and consume a specific topic (Be sure that different topics work using the same orderer service) - FAB-890: Kafka: multiple kafka brokers - FAB-890: Kafka: all kafka brokers go down - what happens? --- What is "replication factor 3"? - FAB-890: Kakfa: Use the partition leader when using a broker connection - FAB-1335: The Kafka orderer should be resilient to faults - FAB-1306: Adding/removing orderers from a Kafka network - FAB-1382: Windowing removed 1. Create a network containing an orderer (configured as kafka), 3 kafka brokers(, and 1 peer? Can I send transaction without the peer?) 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" 20 unique messages to the orderer 4. The authorized user should request a "deliver" message from the orderer starting with ??? and ending with ??? 5. Within a certain amount of time (?), the "deliver" message should contain: a. 2 blocks b. ? c. ? 6. Take down the kakfa network (all 3 brokers) 7. The authorized user should "broadcast" 40 unique messages to the orderer 8. The authorized user waits for a certain amount of time 9. Should a failed deliver message come from the orderer?? 10. Bring back 2 brokers of the kafka network 11. Does a "deliver" message get sent at this time?  12. The authorized user should "broadcast" 40 unique messages to the orderer 13. The authorized user should receive a "deliver" message from the orderer with a windowsize of 10 14. Within a certain amount of time (?), the "deliver" message should contain: a. 4 blocks (or will it be 8?) b. ? c. ?   - FAB-819: Multi-chain support in ordering service - FAB-839: Create per-session buffered channel for broadcast responses - FAB-892: Peer authentication when connecting to an orderer 1. Create a network containing an orderer (configured as solo), and 2 peers 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" 5 unique messages to the orderer 4. Set up an channel for user between the 2 peers 5. The authorized user should receive a "deliver" message from the orderer    - FAB-998: Config envelope for new chain creation turns into genesis block - FAB-1161: Creating genesis block when setting up broadcaster --- Be sure to verify the format of the block - FAB-1092, FAB-1013: Valid configuration envelope created by the orderer which then creates a genesis block - FAB-892: Peer authentication when connecting to an orderer 1. Create a network containing an orderer (configured as solo), cop server, and 1 peer 2. Set up an authorized user (bihn) for the orderer service 3. Obtain the genesis block 4. Verify the following items are in the genesis block: a. certs for peers b. policy information c. ??    - FAB-469: Multiple shims operating in parallel - FAB-621: Hash-chain for Kafka orderer -- 2 kafka partitions per chain??? 1. Create a network containing 3 kafka brokers and a kafka orderer 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" 5 unique messages to the orderer 4. The transactions should be batched into blocks 5. There should be a hash-chain between the blocks ?? What does this look like? -> what do the checkpoint messages look like? Is that apart of this testing or a separate test?     - FAB-467: Orderer config combinations (This test will utilize multiple docker compose combinations) 1. Create a network containing # kafka brokers and a kafka orderer - Be sure to modify BatchSize, BatchTimeout, num of brokers, queue size(?) 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" 5 unique messages to the orderer 4. The transactions should be batched into blocks according to config set     ></body> </Action>
<Action id="20227" issue="13303" author="latitiah" type="comment" created="2016-12-29 18:11:13.0" updateauthor="latitiah" updated="2016-12-29 18:11:13.0"> <body><! CDATA - FAB-526: An orderer is able to reconnect, catch up as necessary and continue as if connection was not lost - FAB-899: Orderer Block timeout 1. Create a network containing an orderer (for kafka, sbft and solo) 2. Set up an authorized user (bihn) for the orderer service 3. The authorized user should "broadcast" 5 unique messages to the orderer 4. The authorized user should receive a "deliver" message from the orderer 5. Within a certain amount of time (?), the "deliver" message should contain: a. ?? b. ?? 6. Stop the orderer 7. The authorized user should "broadcast" 5 unique messages to the orderer 8. Restart the orderer 9. Wait for a certain amount of time 10. The authorized user should receive a "deliver" message from the orderer 11. Within a certain amount of time (?), the "deliver" message should contain: a. ?? b. ?? 12. Stop the orderer 13. The authorized user should "broadcast" 5 unique messages to the orderer 14. Wait for a certain amount of time (causing a timeout - do we need a peer for this?) 15. Restart the orderer 16. What should happen here???    - FAB-817: Add ACL support on the orderer service for channels 1. Create a network containing an orderer (for kafka, sbft and solo) 2. Set up 1 authorized user for the orderer service 3. Set up 1 unauthorized user for the orderer service 4. The authorized user should "broadcast" 5 unique messages to the orderer 5. The authorized user should receive a "deliver" message from the orderer 6. The unauthorized user should "broadcast" 5 unique messages to the orderer 7. The unauthorized user should not receive a "deliver" message from the orderer 8. Should something else happen here? A message sent to someone about unauthorized user? Log about unauthorized user?    ></body> </Action>
<Action id="20230" issue="13303" author="scottz" type="comment" created="2016-12-30 03:55:35.0" updateauthor="scottz" updated="2017-01-07 22:44:10.0"> <body><! CDATA =================================== FAB-918: Orderer configs should be processed correctly  This command-line argument processing was actually fixed by Bishop Brock. Applicable to overriding any env-vars for orderers - especially the internal ones nested 2 levels deep or more inside orderer/orderer.yaml. The Retry Period is for triggering attempt by orderer to reconnect to kafka brokers, when orderer gets no response from any kafka broker for that long.  Generally, we should test the entire API. * The Orderer accepts valid broadcast Transactions of these types: 1, 3  Orderer INPUTs: only a Broadcast Transaction, Envelope.Payload.Header.type one of MESSAGE = 0;                   // Used for messages which are signed but opaque *   CONFIGURATION_TRANSACTION = 1; // Used for messages which reconfigure the chain (node set, policies, parameters...) CONFIGURATION_ITEM = 2;        // Used inside of the the reconfiguration message for signing over ConfigurationItems *   ENDORSER_TRANSACTION = 3;      // Used by the SDK to submit endorser based transactions (and after endorsements recvd, //  the sdk attaches the signed endorsements and later broadcasts Tx to ordserv) ORDERER_TRANSACTION = 4;       // Used internally by the orderer for management  Orderer OUTPUTs: only a Delivered Transaction  - confirm an error-free and good Tx is batched and delivered, or - confirm a Tx that is unsigned or illegally signed is not delivered, and the orderer instead responds immediately to sender to reject it   +++ 1. Create a bootstrapped network (docker-compose file) containing: - COP to provide ca certs for orderer and peer, and ecerts for binhn and a mysterious peer that endorses binhn's Tx - 1 orderer configured with - environment variable OrdererType set to kafka - environment variable ORDERER_KAFKA_RETRY_PERIOD set to 15s Make sure this value is more than the batch_timeout value (default=10s), but less than the stop/panic timeout value (default=60s). Set the value on command line when creating orderer(s): ORDERER_ORDERERTYPE=kafka ORDERER_KAFKA_RETRY_PERIOD=15s ./orderer The Behave/test process is the application to send/broadcast msgs to the peer, and retrieve/read the Deliver().  2. Create an authorized user (binhn) for broadcasting Tx to the orderer service  3. FUTURE when v1.0 is more fully functional, we may need to modify this test, to make this a more complete IT test, starting an entire bootstrapped network, and deploy cc and create chan, etc, instead of just creating an orderer and connecting directly to it.  A - a channel created for that user to use ? B - add a single peer to the channel C - Invoke/Deploy a chaincode to the peer  4. Broadcast 1 invoke transaction. 5. Query to verify it was successfully delivered/committed, allowing up to the batch_timeout (10 secs). 6. Disconnect the kafka broker (or simulate that condition; how do we do that? The default kafka broker is found at 127.0.0.1:9092. Can we temporarily block that port so the orderer cannot get msgs from it?) 7. Broadcast 1 invoke transaction. 8. Poll/Call Deliver(), allowing up to the batch_timeout (10 secs). Expect this to FAIL. 9. Reconnect the kafka broker. Should we wait for up to whatever timelength is needed to safely resync and resume operations??? Do we have to ping it or something to verify reconnectivity??? Should we poll/deliver(), expecting the queued Tx (prev step) to be delivered??? 10. Broadcast 1 invoke transaction. 11. Poll/Call Deliver(), allowing up to the batch_timeout (10 secs). Expect this to SUCCEED.  +++ RERUN test a 2nd time, while instead setting the env vars BEFORE composing the network (not on command line). This will simply require an Examples table, and a reference to a different docdker-compose file.  =================================== FAB-761: gRPC API for broadcast and deliver with the orderer Refer to .../protos/orderer/ab.pb.go. Test these Status response codes from fabric/protos/common/common.pb.go 0:   "UNKNOWN",			? (not used yet in code, but maybe send a HeaderType = 99 and see what happens (everything above 4 should be rejected) 200: "SUCCESS",				ok : broadcast a good Tx and get a BroadcastResponse with 200 SUCCESS 400: "BAD_REQUEST",			err during chain creation: cannot unmarshal a config item, or e.g. 1st config item must be but is not a Creation Policy; OR payload.Header == nil || payload.Header.ChainHeader == nil || payload.Header.ChainHeader.ChainID == "" 403: "FORBIDDEN",    			user recognized but unauthorized to create a chain, using an unauthorized/bad password/cert; i.e. "Failed to validate chain creation because chain creation policy is not authorized for chain creation" 404: "NOT_FOUND",			unknown chainID, both when broadcasting or delivering (peer calls deliver(0 for a chainID); OR we should see this with an unknown userid 413: "REQUEST_ENTITY_TOO_LARGE",	? (not used yet in code, but this might mean the Envelope.Payload size too big for int32) 500: "INTERNAL_SERVER_ERROR",		error marshaling a proposed new system chain Envelope or Payload, or other internal errs 503: "SERVICE_UNAVAILABLE",		no more space available when configured to use file ledger; OR orderer cannot Enqueue an incoming broadcast msg (but i don't know WHY or HOW this can happen - must ask designers)  ### BROADCAST RESPONSE CODES 1. Create a bootstrapped network (docker-compose file) containing a basic setup with: - 1 cop - 1 orderer configured with solo - 1 peer configured with no gossip - 1 deployed chaincode - 2 peers, but only on added to the channel - two authorized users (binhn, garys) for broadcasting Tx to the orderer service on same channel - one users (padawan) UNauthorized for broadcasting on that channel  2. User binhn create and broadcast a Tx (simulating a msg from SDK), to generate each of these BroadcastResponses. +++ 0    not sure what should trigger this response; let's try a transaction with an invalid headertype=99 +++ 200  ok : authorized user binhn broadcasts invoke ValidTx (with valid chainID using his own valid ecert) +++ 400  binhn broadcasts Tx except uses a chainID=nil +++ 403  binhn broadcasts Tx except uses garys ecert (User is recognized/authorized but gave the wrong password) +++ 403  binhn broadcasts Tx except uses a garbage or nil ecert (User is recognized/authorized but gave the wrong password) +++ 404  padawan broadcasts Tx (User and chainID exist but user not permitted on this chainID) +++ 404  binhn use non-null invalid chainID, one that is not created yet, when broadcast (User is not permitted) +++ 413  binhn send a Tx with Envelope.Payload size > int32 0x1 0000 0000 (can we just set a value in the header, or do we need a huge msg?) +++ 500  binhn create a chain using badly formed payload, to cause error marshaling +++ 503  ASK DESIGNERS! The only two code instances I found are: + no more space available when configured to use file ledger (difficult to reproduce in a test) + orderer cannot Enqueue an incoming broadcast msg (but i don't know WHY or HOW this can happen) 3. Confirm the indicated BroadcastResponse (200 SUCCESS) to the sender/broadcaster 4. AND confirm that the Tx is delivered within the timeout period (10 secs).  ### DELIVER RESPONSE CODES Step (1) as above. 2. Test API calls Deliver (simulating a Peer receiving a delivered msg from orderer), to generate each of these BroadcastResponses. +++ 200  ok - binhn broadcast a Tx on a channel, and binhn call deliver() on same channel to receive a block with that successfully delivered Tx +++ 400  binhn broadcast a Tx on a channel, and call deliver on a channel using chainID=nil +++ 403  binhn broadcast a Tx on a channel, and call deliver on a channel using garys cert +++ 404  binhn broadcast a Tx on a channel, and call deliver using non-null invalid chainID +++ 404  binhn broadcast a Tx on a channel, and padawan on non-member 2nd peer calls deliver +++ ???  do NOT broadcast Tx, call deliver, using a timeout (instead of wait-forever-for-a-block) to force timeout when NO delivery from orderer on the indicated channel  3. Confirm the expected BroadcastResponse 4. AND confirm NO transactions delivered (wait up to timeout period)  =================================== FAB-498: Create mechanism for orderer service to selectively process configuration transactions  MULTI-CHANNEL IT TESTING (OUT OF THIS SCOPE): add/del users and peers - and then confirm they can/cannot perform broadcast/deliver  ------------------ FAB-498 Pluggable pieces for the orderer service are set only in the initial bootstrap config file: (bootstrap simplest orderer service with each of these combinations, and do basic broadcast/deliver tests) - OrdererType = solo  default , kafka - LedgerType = ram  default , file      - check if this can be also changed on the fly like other parameters listed below? - any other pluggable pieces ??? 1. Bootstrap a network with +++    OrdererType=solo  and LedgerType=ram +++    OrdererType=solo  and LedgerType=file and FileLedger_Prefix=solo_rawledger and FileLedger_Location=/tmp/hf +++    OrdererType=kafka and LedgerType=ram +++    OrdererType=kafka and LedgerType=file (and just use defaults for FileLedger _Prefix and _Location) 2. Verify transactions can be sent/delivered. 3. If "file" case, confirm file is written/grows, in the directory specified.  ------------------ FAB-498,FAB-148: Support dynamic reconfiguration of orderers - change node set for kafka ntwk Add/delete members in node set. ASK WHAT IS ALLOWED, with each OrdererType plugin: kafka/brokers? sbft? - sbft nodes (Defer: since not yet supported) - solo - Not Applicable (this makes no sense, since we can have only one solo-orderer right?) Could we change hardware and/or IP address of an existing solo orderer to upgrade it?? +++ Kafka brokers list change: Verify can add, remove, and add+remove in same reconfig transaction. (We just want to confirm that the reconfig transaction will work when changing the orderer node set. We will not touch K0, since things are more likely to remain stable if we do not touch the first node.  It is out-of-scope to confirm Kafka robustness during all possible disruptive testing.) 1. Bootstrap a network using one kafka broker, K0, and one peer. 2. Send transactions to K0; verify blocks delivered to peer containing all successfully ordered Tx. 3. Add K1.  4. Send transactions to K0 and K1; verify blocks delivered to peer containing all successfully ordered Tx. 5. Remove K1.  6. Send transactions to K0; verify blocks delivered containing all successfully ordered Tx. 7. Send transactions to K1; verify requests are not processed (maybe err = destination not found?) nor delivered to peer 8. Add K1. 9. Send transactions to K0 and K1; verify blocks delivered to peer containing all successfully ordered Tx. 10. Add K2 and remove K1 in same transaction reconfiguration. 11  Send transactions to K0 and K2; verify blocks delivered to peer containing all successfully ordered Tx. 12. Send transactions to K1; verify requests are not processed (maybe err = destination not found?) nor delivered to peer  ------------------ FAB-498,FAB-148: Support dynamic reconfiguration of orderers - change config parameters for solo Send Transaction to reconfig by changing parameters from defaults that are defined in orderer/orderer.yaml. Here we test that each of these params can be changed in the orderer reconfiguration transaction. GENERAL: -  BatchTimeout: 10s -  BatchSize: MaxMessageCount: 10 # Queue Size: The maximum number of messages to allow pending from a gRPC client. -  QueueSize: 10 # Max Window Size: The maximum number of messages to for the orderer Deliver # to allow before acknowledgement must be received from the client. -  MaxWindowSize: 1000 # Listen address: The IP on which to bind to listen -  ListenAddress: 127.0.0.1 # Listen port: The port on which to bind to listen -  ListenPort: 7050 # Log Level: The level at which to log.  This accepts logging specifications # per fabric/docs/Setup/logging-control.md -  LogLevel: info # Genesis method: The method by which to retrieve/generate the genesis block -  GenesisMethod: provisional # Genesis file: The file containing the genesis block. Used by the orderer when GenesisMethod is set to "file" -  GenesisFile: ./genesisblock # Enable an HTTP service for Go "pprof" profiling as documented at # https://golang.org/pkg/net/http/pprof -  Profile: Enabled: false Address: 0.0.0.0:6060 RAMLedger: # History Size: The number of blocks that the RAM ledger is set to retain HistorySize: 1000 FileLedger: # Location: The directory to store the blocks in # NOTE: If this is unset, a temporary location will be chosen using # the prefix specified by Prefix Location: # The prefix to use when generating a ledger directory in temporary space # Otherwise, this value is ignored Prefix: hyperledger-fabric-rawledger Kafka: # Brokers: A list of Kafka brokers to which the orderer connects # NOTE: Use IP:port notation Brokers: - 127.0.0.1:9092 # Retry: What to do if none of the Kafka brokers are available Retry: # The producer should attempt to reconnect every <Period> Period: 3s # Panic if <Stop> has elapsed and no connection has been established Stop: 60s # Verbose: Turn on logging for sarama, the client library that we use to # interact with the Kafka cluster Verbose: false  +++ 1. GIVEN a Bootstrapped network (default 1 solo orderer, 1 peer) 2. Send transaction and verify blocks delivered to peer containing all successfully ordered Tx 3. Send transaction to reconfigure virtually all the parameters in GENERAL and RAMLEDGER section GENERAL_ -  OrdererType: solo #leave as is -  LedgerType: ram   #leave as is -  BatchTimeout=20s -  BatchSize_MaxMessageCount: 2 -  QueueSize: 20 -  MaxWindowSize: 2000 -  ListenAddress: 127.0.0.2 -  ListenPort: 7020 -  LogLevel: debug -  GenesisMethod: file -  GenesisFile: ./genesisblock_file  # does this mean file is located in .../fabric/orderer/ ??? -  Profile: Enabled: true Address: 0.0.0.0:6060 RAMLedger_HistorySize: 20 4. We should not need to bootstrap the peers and sdk/applications again after every orderer reconfiguration - but maybe we do need to do it after certain parameters are changed???  such as ports for broadcasts/delivers: - list of orderers - ListenAddress:ListenPort (used by Solo, right?) (or Kafka_Brokers node list when using kafka) where sdk needs to send/broadcast transactions 5. After reconnect peer to the new deliver ports and shared with the sdk/application the new kafka brokers addresses, look at log to confirm all these settings, and 6. send transaction and verify blocks delivered to peer containing all successfully ordered Tx  ?????????? Do we also need to verify HERE the functionality of every parameter??????????  ------------------ FAB-498,FAB-705: Updating the Policy via a policy manager. Are these simply the Signature policies, which is all that is verified here in the orderer? e.g. One default policy could be something like this: Assume user is authorized (do not authenticate identity) and always approve if the transaction formatted valid. e.g. One expected default policy could be something like this: Authenticate identity: Ensure the user submitting the Tx is an authorized user on this channel, and the signature is correct for that user. e.g. And we should also have a simple policy to verify users or peers certs (member org of indicated channel) for the Deliver API.  +++ To verify, simply rerun earlier API test for 404 broadcast (user binhn using garys cert) broadcasting to orderer a configtype transaction that changes the policies for authenticating broadcast requests from the default (dont authenticate) to one that authenticates the submitter/user.  +++ To verify, simply rerun earlier API test for 404 deliver (peer requesting delivery is in an org that is not part of the channel) broadcasting to orderer a configtype transaction that changes the policies for authenticating deliveries requests from the default (dont authenticate) to one that authenticates the submitting peer org and/or user.   ------------------ FAB-498,FAB-704: Create signature validation Domain Specific Language (DSL) for use by filtering framework and later more broad use Refer to protos/common/configuration.proto. In particular, the two primitives which comprise a policy are: NOutOf(n,   policies) SignedBy(id) To test, we need to create signature policies that use both of the following DSL concepts, while at the same time defining permissioned users that the policies will enforce: e.g. endorsed/signedby 2 out of 3 of the accompanying list of policies e.g. endorsed/signedby specific user id (This will be the certificate itself for a self-signed certificate and will be the CA for more traditional certificates) This common DSL was expected to be used by orderers as well as by peers. This was developed especially for aiding in specifying bootstrap configuration for signature policies - Covered by FAB-705 above.  ------------------ FAB-498,FAB-591: Orderer broadcast filtering framework Allows the orderer plugin (solo, kafka, sbft, etc) to specify filters, such as this one for incoming messages (which are broadcast in to orderer from outside): "accept only non-empty messages"  this is the default   +++ Try using a different "broadcast msg" filter when bootstrap/configure the orderer service. Send transactions to test and confirm it works correctly for Tx that meet (or do not meet) the criteria Should see immediate responses to sender for transactions that are rejected, or see the delivered Tx for those meeting criteria.  +++ And reconfigure the "broadcast msg" filter after ordserv is running. Send transactions to test and confirm it works correctly for Tx that meet (or do not meet) the criteria Should see immediate responses to sender for transactions that are rejected, or see the delivered Tx for those meeting criteria.   ------------------ FAB-498,FAB-593: Orderer configuration broadcast filter ### This is covered by the 2nd test written above for FAB-498/FAB-148 Send a 'configuration_transaction' transaction type to reconfigure params for solo orderer. With the completion of the broadcast filtering framework (FAB-591), the genesis block creation configurable (FAB-688), the policy manager (FAB-705), and the configuration manager (FAB-704), it is now possible for the orderer to filter and apply configuration received over the wire as a transaction. And to change config. This changeset added that functionality for the solo ordering service. This (sending transactions) will be the method used to test those configuration items.   ></body> </Action>
<Action id="20261" issue="13303" author="latitiah" type="comment" created="2017-01-04 18:30:12.0" updateauthor="latitiah" updated="2017-01-04 18:30:12.0"> <body><! CDATA - FAB-1094: Utilities to build configuration envelope for the genesis block - FAB-666: Orderer node should be able to retrieve the genesis block and join the network of nodes - FAB-666: All orderer nodes should recieve the genesis block - FAB-666: When an orderer is bootstrapped, the following should be performed: read genesis block, parse and save policies, orderer whitelist, and peer org certificates to correct locations 1. Create a network containing an orderer (configured as solo), cop server, and 1 peer 2. Set up an authorized user (bihn) for the orderer service 3. Obtain the genesis block -- What does the broadcast message look like for this? What are the different config values possibilities? 4. Verify the following items are in the genesis block: a. certs for peers b. policy information c. ??  ></body> </Action>
<Action id="23067" issue="13303" author="scottz" type="comment" body="This test design task is completed, so we can close this issue. However, we still need to review this thoroughly to ensure all these testcases are covered by existing testcases, many of which are also listed in testplan (we can use the steps included here to write the tests) https://docs.google.com/spreadsheets/d/1_IdXCuYMKkqXr3Za0pVnFP3sP1jBcNbYnTJGV-nSkxI/edit#gid=442991954 . I opened two stories to guide this effort - one for creating the Behave tests and one for the OTE tests." created="2017-04-27 15:30:04.0" updateauthor="scottz" updated="2017-04-28 22:17:22.0"/>
