<Action id="51934" issue="31353" author="sykesm" type="comment" created="2018-10-09 15:25:30.0" updateauthor="sykesm" updated="2018-10-09 15:28:54.0"> <body><! CDATA This is my independently crafted version:  As a platform operator, I want to be able to determine if a peer is healthy by hitting an http(s) endpoint on a configurable port.  *Background / Details*  As is often the case with distributed software, a running process and a healthy process aren't the same thing. To help users and operators identify the walking dead, we need to implement a simple healthcheck that can be regularly exercised by automation. In the spirit of modern, container based deployments, this healthcheck should also be usable as a liveness check in orchestration systems like Kubernetes without requiring additional infrastructure.  To prevent dragging bunch of unnecessary complexity, the healthcheck should be implemented as a basic http or https endpoint at /healthz. When the peer is healthy, it will return with a status of `HTTP 200/OK` and JSON payload of {"status": "OK"}. If the peer is responsive to the status check, but unhealthy, it will return with a staus of `HTTP 503/Service Unavailable` and a JSON message that indicates which subsystem has failed the health check.  The implementation should be structured such that checks can be wired in as implemented. Each healthcheck will implement a `HealthChecker` interface and will be added to a map of component name to check(s).  {code} type HealthChecker interface { HealthCheck() (message string, ok bool) } {code}  Note: While we can implement gRPC based healtchecks by using the gRPC Health Checking protocol, it requires us to use a separate program to drive the checks. While the grpc-ecosystem provides a go impelemntation, using it requires us to embed it in our containers and configure it with the correct TLS information. This is a higher barrier to entry than required and is specific to gRPC services.  ></body> </Action>
<Action id="52804" issue="31353" author="latitiah" type="comment" created="2018-10-31 13:19:07.0" updateauthor="latitiah" updated="2018-10-31 13:19:07.0"> <body><! CDATA This epic still needs a test plan summary associated with it. Here is a quick guide for what the summary should contain. Thanks! {code} Functional Tests: - FAB-XXX1: Make sure config is accepted and turns on feature (Integration) - PersonA - FAB-XXX2: What happens when config is set wrong (unit) - PersonA - FAB-XXX3: When FeatureX is turned on in both ComponentA and ComponentB (End-to-end) - PersonB - FAB-XXX4: When FeatureX is turned on in ComponentA and not ComponentB (End-to-end) - PersonA  System Tests: - FAB-XXX5: How is performace impacted when sending 5 packets per second for 3 hours? - PersonC * Be sure to set the following config values on ComponentA as such: - FEATUREX=true - FEATURE_PATH=/some/path/for/my/feature * Be sure to send the messages using the foo SDK - FAB-XXX6: Is the feature and component stable when executing 10 packets per second for 1 week? - PersonC * Be sure to set the following config values on ComponentA as such: - FEATUREX=true - FEATURE_PATH=/some/path/for/my/feature {code}  ></body> </Action>
