<Issue id="31353" key="FAB-10851" number="10851" project="10002" reporter="g-dazwilkin" assignee="mastersingh24" creator="g-dazwilkin" type="10000" summary="Serviceability - Monitor health for Fabric runtime components" priority="1" resolution="10000" status="6" created="2018-06-25 19:08:30.0" updated="2019-06-21 20:55:58.0" resolutiondate="2019-06-21 20:46:07.0" votes="1" watches="6" workflowId="44965"> <description><! CDATA As a platform operator, I want to be able to determine if a peer is healthy by hitting an http(s) endpoint on a configurable port.  *Background / Details*  As is often the case with distributed software, a running process and a healthy process aren't the same thing. To help users and operators identify the walking dead, we need to implement a simple healthcheck that can be regularly exercised by automation. In the spirit of modern, container based deployments, this healthcheck should also be usable as a liveness check in orchestration systems like Kubernetes without requiring additional infrastructure.  To prevent dragging bunch of unnecessary complexity, the healthcheck should be implemented as a basic http or https endpoint at /healthz. When the peer is healthy, it will return with a status of `HTTP 200/OK` and JSON payload of h3. {"status": "OK"}  . If the peer is responsive to the status check, but unhealthy, it will return with a staus of `HTTP 503/Service Unavailable` and a JSON message that indicates which subsystem has failed the health check.  The implementation should be structured such that checks can be wired in as implemented. Each healthcheck will implement a `HealthChecker` interface and will be added to a map of component name to check(s). {code:java} type HealthChecker interface { HealthCheck() (message string, ok bool) } {code} Note: While we can implement gRPC based healtchecks by using the gRPC Health Checking protocol, it requires us to use a separate program to drive the checks. While the grpc-ecosystem provides a go impelemntation, using it requires us to embed it in our containers and configure it with the correct TLS information. This is a higher barrier to entry than required and is specific to gRPC services.     *Documentation overview*  The operations REST service provides a {{/healthz}} resource that operators can use to help determine the liveness and health of peers and orderers. The resource is a conventional REST resource that supports GET requests. The implementation is intended to be compatible with the liveness probe model used by Kubernetes but can be used in other contexts.     *Original Background*  Fabric's use of gRPC is excellent. A limitation of gRPC is that we're without our customary toolkit (e.g. curl) when working with it.  As I begin to develop an understanding of Fabric, when services fail or don't work, I'm struggling to diagnose. It would be helpful to have something beyond ping and that doesn't require auth and other config to get some health signal back from each of the component services.  I'm attempting to developer a Helm Chart for Fabric and so deployment is complicated by multiple machines (DNS names) etc. It would be helpful during this deployment to be able to confirm serices are alive against DNS names and working correctly.  Lastly, during deployment (on Kubernetes), it's necessary to monitor component state before proceeding with deployments, establish peers, joining channels, deploying chaincode etc. It would be useful to be able to predicate steps. The solution that I'm building upon, uses a shared file system and checkpoint files (e.g. org1peer_created) to orchestrate its deployment, it seems preferable to be able to make a healthcheck call against the peer.  ></description> </Issue>
