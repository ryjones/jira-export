<Action id="59738" issue="39524" author="c0rwin" type="comment" body="cc  ~denyeart   ~manish-sethi " created="2019-05-06 07:03:12.0" updateauthor="c0rwin" updated="2019-05-06 07:03:12.0"/>
<Action id="59739" issue="39524" author="const" type="comment" body="https://gerrit.hyperledger.org/r/#/c/31229/" created="2019-05-06 07:25:03.0" updateauthor="const" updated="2019-05-06 07:25:03.0"/>
<Action id="59746" issue="39524" author="manish-sethi" type="comment" body="requires some investigation whether the bug fixed in this https://jira.hyperledger.org/browse/FAB-10540 has reoccurred or its a new one. " created="2019-05-06 12:55:58.0" updateauthor="manish-sethi" updated="2019-05-06 12:55:58.0"/>
<Action id="59820" issue="39524" author="wenjian" type="comment" created="2019-05-07 19:52:19.0" updateauthor="wenjian" updated="2019-05-07 19:52:19.0"> <body><! CDATA  ~ConstC    For "#2 invocation mychaincode that call _qscc.GetChainInfo",_ it is not supported to call system chaincode inside of a user chaincode. If you need to call qscc, the right way is to invoke qscc directly for the client.  ></body> </Action>
<Action id="59827" issue="39524" author="const" type="comment" created="2019-05-08 03:44:59.0" updateauthor="const" updated="2019-05-08 03:44:59.0"> <body><! CDATA  ~wenjian  I found this implementation of *InvokableCC2CC* for *qscc* system chaincode. There are no restrictions to call qscc inside of a user chaincode. {code:go} func (e *LedgerQuerier) Name() string              { return "qscc" } ... func (e *LedgerQuerier) InvokableCC2CC() bool      { return true } ... {code}  And I think this is an important feature that helps keep a ledger related domain logic in the same place (in the chaincode).  ></body> </Action>
<Action id="59836" issue="39524" author="manish-sethi" type="comment" body=" ~const  As you see, this is surely an untested path. Can you elaborate a bit on your chaincode logic, particularly, how it depends on the blockchain info? Because, a user chaincode logic should depend on state only as such." created="2019-05-08 14:07:10.0" updateauthor="manish-sethi" updated="2019-05-08 14:14:46.0"/>
<Action id="60028" issue="39524" author="denyeart" type="comment" body=" ~const  Please describe the use case of why user chaincode would need to depend on blockchain info. This was not intended and the support will likely get removed unless there is a compelling use case." created="2019-05-15 14:11:48.0" updateauthor="denyeart" updated="2019-05-15 14:11:48.0"/>
<Action id="60091" issue="39524" author="const" type="comment" created="2019-05-17 05:21:21.0" updateauthor="const" updated="2019-05-17 05:41:18.0"> <body><! CDATA I use ledger blocks as kind of event source to determine in which order entities were added.  The client side isn't an appropriate place for calling qscc in my case, because all my chaincode models are defined in a chaincode layer (I need these models to parse ledger blocks).  ></body> </Action>
<Action id="60113" issue="39524" author="denyeart" type="comment" body=" ~const  Fabric chaincode is designed to manage application state. The client SDKs are designed to handle blockchain info queries as well as block/transaction events. When deviating from the intended and tested use scenarios you are at risk of hitting limitations. Is there any reason you cannot adopt the intended usage?" created="2019-05-17 11:40:42.0" updateauthor="denyeart" updated="2019-05-17 11:40:42.0"/>
<Action id="60243" issue="39524" author="const" type="comment" created="2019-05-22 07:20:25.0" updateauthor="const" updated="2019-05-22 07:20:25.0"> <body><! CDATA  ~denyeart  You offer me a workaround which in my case will require a large code duplication from chaincode layer to the client side. It's strange to separate the use of ledger and application state, because the same models are stored here and there.  My approach worked fine on the hyperledger fabric version 1.0. Problems appeared after migration to version 1.4. I think this problem occurs after these changes https://gerrit.hyperledger.org/r/#/c/fabric/+/16563/  There is only one problem with using QSCC from user chaincode - this is the deadlock described above. QSCC is regular chaincode in other cases. It's easy to fix this deadlock by acquiring *kvLedger.blockAPIsRWLock* and *LockBasedTxMgr.commitRWLock* in the same order in "QSCC functions" and "saving a new block" processes.    ></body> </Action>
<Action id="60244" issue="39524" author="const" type="comment" body="I think that the ability to write a chaincode that can parse a ledger can be a competitive advantage of Hyperledger Fabric." created="2019-05-22 07:30:02.0" updateauthor="const" updated="2019-05-22 07:30:02.0"/>
<Action id="60878" issue="39524" author="denyeart" type="comment" created="2019-06-11 15:39:38.0" updateauthor="denyeart" updated="2019-06-11 15:39:38.0"> <body><! CDATA Discussed with a few other maintainers.  Intent is to document the limitation in v1.4.x and deprecate, then remove the ability to call qscc from user chaincodes in v2.0.  ></body> </Action>
<Action id="60902" issue="39524" author="baohua" type="comment" created="2019-06-12 01:11:52.0" updateauthor="baohua" updated="2019-06-12 01:12:07.0"> <body><! CDATA  ~denyeart , curious to know how we can disable the qscc call from user chaincode, i.e., to distinguish the callers from clients or from chaincode.  Thanks!  ></body> </Action>
<Action id="64032" issue="39524" author="jyellick" type="comment" body="To summarize the above discussion – it&apos;s never safe to call qscc cc2cc, and we should enforce this in v2.0.  Setting fix version to 2.0 and adding to the ipm backlog." created="2019-09-24 14:16:37.0" updateauthor="jyellick" updated="2019-09-24 14:16:37.0"/>
<Action id="64107" issue="39524" author="lmars" type="comment" created="2019-09-25 02:45:23.0" updateauthor="lmars" updated="2019-09-25 14:35:44.0"> <body><! CDATA  ~denyeart   ~jyellick  why do you want to remove this feature?  Using the client SDK isn't always the answer. Only the chaincode logic can be endorsed (by several endorsers). Any client logic can be ignored by the application and domain logic can be hacked :(  There are at least several scenarios when the logic of the user chaincode may depend on the system chaincode(s):  1) some voting system which is limited by the time range. This is only one real safe way to extract the time of transaction (which has added the voting object to the blockchain) by parsing the block! 2) the same applies to the order of some "orders" in the ordering system. When we implement such system we must know the real order of orders (for example, to select top ten). It's difficult (impossible) to implement without analyzing the ledger. 3) analysis of the configuration block to select MspIds of connected organizations (this is already disabled in Fabric :() 4) analysis of the configuration block to check rights of the creator of the transaction (we have some functions that only administrators of specific organizations can access) (this is already impossible in Fabric :() 5) etc...  ></body> </Action>
<Action id="64128" issue="39524" author="jyellick" type="comment" created="2019-09-25 15:52:10.0" updateauthor="jyellick" updated="2019-09-25 15:52:10.0"> <body><! CDATA So I would start with – today, we have a situation where chaincodes are able to call QSCC, but every time they do, they risk deadlocking the peer.  No matter how useful, this needs to be addressed.  The proposed solution to prevent the deadlock has too high of a performance impact, so, we are left with the only other practical option, of disabling the feature.  Now, nothing prevents us from adding back the ability to perform these operations from user chaincode in the future, but, this is addressing a real problem that exists now, and v2.0 is a natural boundary to make such a breaking change.  On to your more specific points: 1) You may retrieve the timestamp of your current transaction via the {{GetTxTimestamp}} chaincode API.  You may store this value into the statedb if you wish to easily reference it later.  You may trust this value, because it has undergone the multi-party endorsement process.  I would note, that in general, the timestamp in txes should not be relied upon, as clients may shift this timestamp forward or back within allowable clock drift, so if you reference this value, use it with care. 2) I don't quite follow this one, but I think you are wanting to know the actual order that multiple txes committed in.  In this case, you could employ a strategy of 'blind writes' to a key.  Select a key, and have all of the transactions perform a `PutState` to this key, but importantly not a `GetState`, this will allow them to commit concurrently without conflict, but, you will be able to use {{GetHistoryForKey}} to see the order that these txes committed in. 3) I do think we need a better story around providing identity services to the chaincode.  However, reading and parsing the config block is not a very nice model for accomplishing this.  And, as you say it's already not possible. 4) The same goes as for 3.  So, I think for (1) and (2) there are already better options than QSCC available.  For (3)/(4), this was already cludgy, and broken, and we should look for a better way to provide these services.  ></body> </Action>
<Action id="65048" issue="39524" author="sykesm" type="comment" created="2019-10-28 20:17:59.0" updateauthor="sykesm" updated="2019-10-28 20:17:59.0"> <body><! CDATA https://gerrit.hyperledger.org/r/c/fabric/+/34123 https://gerrit.hyperledger.org/r/c/fabric/+/34124  ></body> </Action>
<Action id="65073" issue="39524" author="lmars" type="comment" created="2019-10-29 12:27:14.0" updateauthor="lmars" updated="2019-10-29 12:27:14.0"> <body><! CDATA  ~jyellick  Thanks for the detailed clarification. {quote}The proposed solution to prevent the deadlock has too high of a performance impact {quote} I think I understand why. Is it because *kvLedger.CommitWithPvtData* holds *txmgr.commitRWLock* for too long?  Can I propose an alternative solution? If we couldn't change the order of acquiring locks in *kvLedger.CommitWithPvtData* can we change the order of acquiring locks in the user chaincode? I think of some special (advanced) mode in the user chaincode to call some system chaincode before calling *LockBasedTxMgr.NewTxSimulator*.  In this case, the user chaincode can call any system chaincodes like the client SDK does.  What do you think? {quote}On to your more specific points {quote} Thank you for proposed solution for my specific points.  I like some, but the problem what we already have our project released, it is hard to change the ledger scheme now :(  ></body> </Action>
<Action id="65092" issue="39524" author="jyellick" type="comment" created="2019-10-29 15:01:59.0" updateauthor="jyellick" updated="2019-10-29 15:01:59.0"> <body><! CDATA {quote} Can I propose an alternative solution? If we couldn't change the order of acquiring locks in kvLedger.CommitWithPvtData can we change the order of acquiring locks in the user chaincode? I think of some special (advanced) mode in the user chaincode to call some system chaincode before calling LockBasedTxMgr.NewTxSimulator. {quote}  The problem here is two-fold.  First, I'm a little skeptical of delegating ledger locking to application code.  Getting locking right is hard, and a mistake in the application code will deadlock the entire channel.  Secondly, it would expand the chaincode API surface considerably, something which has been problematic in the past, and would require implementations in every chaincode platform.  {quote} I like some, but the problem what we already have our project released, it is hard to change the ledger scheme now ￼ {quote}  The good news is that thanks to the chaincode model you can migrate your db schema on chaincode upgrade.  If the size of your DB is relatively small (tens of MBs), then you can do this in the 'Init' step of your chaincode.  If the DB is larger, you may need to paginate/batch your updates across multiple transactions and hold internal state as to whether the schema upgrade is complete.  I realize it's no fun to update application logic in response to a platform update, but v2.0 gives us the opportunity to make some breaking changes, and you can always run on v1.4.x until you're ready to migrate.  ></body> </Action>
<Action id="65183" issue="39524" author="lmars" type="comment" created="2019-10-30 11:36:44.0" updateauthor="lmars" updated="2019-10-30 11:36:44.0"> <body><! CDATA {quote}The problem here is two-fold. First, I'm a little skeptical of delegating ledger locking to application code. {quote} I will try to explain my proposal in more detail. * *ChaincodeEx* interface would be introduced {code:java} type ChaincodeEx interface { Chaincode  // DecorateInvoke is called before Invoke out of transaction context // It isn't possible to query ledger in DecorateInvoke // Returned value will be merged and will be available by using ChaincodeStubInterface.GetDecorations inside Invoke DecorateInvoke(stub ChaincodeStubInterface) map string   byte } {code}  * *Shim* would call *DecorateInvoke* only if user chaincode implements *ChaincodeEx* interface * An user chaincode would be able to use any system chaincodes in *DecorateInvoke* method (since this method is called before calling *LockBasedTxMgr.NewTxSimulator*) * The result of *DecorateInvoke* will be available inside Invoke by using *ChaincodeStubInterface.GetDecorations*  So: {quote}Getting locking right is hard, and a mistake in the application code will deadlock the entire channel. {quote} In the proposed solution, it is impossible to obtain a lock manually. So there is no place for mistake. {quote}Secondly, it would expand the chaincode API surface considerably, something which has been problematic in the past, and would require implementations in every chaincode platform. {quote} We can introduce *ChaincodeEx* on one platform and implement this feature on other platfroms at any time. {quote}The good news is that thanks to the chaincode model you can migrate your db schema on chaincode upgrade {quote} The bad news is that in some scenarios (see, for example, my points 3) and 4)) we still need to call arbitrary system chaincodes.  ></body> </Action>
<Action id="65187" issue="39524" author="jyellick" type="comment" created="2019-10-30 15:04:23.0" updateauthor="jyellick" updated="2019-10-30 15:04:23.0"> <body><! CDATA Perhaps I misunderstand your proposed solution, but I don't see how it can work.  When the initial proposal from the client is received, we first explicitly check if the request is for CSCC/QSCC  here|https://github.com/hyperledger/fabric/blob/5ed287c5f15c01b2acc54435515d8872d2ba31ac/core/endorser/endorser.go#L446-L462  and if not, we acquire the initial TxSimulator  here|https://github.com/hyperledger/fabric/blob/5ed287c5f15c01b2acc54435515d8872d2ba31ac/core/endorser/endorser.go#L350 .  At this point, long before any call is made into the chaincode, it's unsafe to invoke QSCC.  So, by the time the invoke is actually dispatched to the chaincode the simulator lock is already acquired.  The only way I see this working is if the endorser code were to dispatch to the DecorateInvoke prior to acquiring the TxSim, but this creates a new problem.  If the chaincode makes a cc2cc call (which the peer necessarily cannot know of until after the invocation has occurred), then the new chaincode cannot call DecorateInvoke  without the lock acquired, because the lock already acquired for the first Invoke.  So now the chaincode calling semantics differ, whether your chaincode is being invoked directly, or cc2cc.  Note, even if we accepted this differing behavior, we'd still have a significant performance impact of requiring a round-trip message to the chaincode prior to every invocation.  Perhaps we could negotiate with the chaincode ahead of time whether the additional round-trip is necessary, but you can see that 'correctly' implementing this approach rapidly balloons in complexity. {quote}In the proposed solution, it is impossible to obtain a lock manually. So there is no place for mistake. {quote} What happens if a user chaincode invokes QSCC from the normal Invoke path? We're back to preventing a deadlock, or inventing yet another mechanism to pass info that the Invoke is coming from a different pre-lock context.  In the former, we have not addressed the bug, in the latter, we've introduced significantly more code and complexity. {quote}We can introduce ChaincodeEx on one platform and implement this feature on other platfroms at any time. {quote} We try to keep the chaincode platforms in sync, it's a documentation nightmare and general user experience problem when one platform has access to APIs that the others do not.  This would also be relatively obscure and I expect not often used API that we would need to maintain indefinitely. {quote}The bad news is that in some scenarios (see, for example, my points 3) and 4)) we still need to call arbitrary system chaincodes. {quote} Per your own admission: {quote}3) analysis of the configuration block to select MspIds of connected organizations (this is already disabled in Fabric ￼) 4) analysis of the configuration block to check rights of the creator of the transaction (we have some functions that only administrators of specific organizations can access) (this is already impossible in Fabric ￼) {quote} The use cases of 3 and 4 are already broken.  As I've voiced before, I do think there's value in exposing more of the channel state to chaincodes to allow them to perform ACL and other checks.  However, there's no requirement that this be done through a cc2cc call, and in fact, I think there's some strong arguments to be made that it shouldn't be.  ></body> </Action>
<Action id="65291" issue="39524" author="lmars" type="comment" created="2019-11-05 12:26:20.0" updateauthor="lmars" updated="2019-11-05 12:26:20.0"> <body><! CDATA  ~jyellick   {quote} When the initial proposal from the client is received, we first explicitly check if the request is for CSCC/QSCC here and if not, we acquire the initial TxSimulator here.  At this point, long before any call is made into the chaincode, it's unsafe to invoke QSCC. {quote}  Oh no! You're right. My solution will not work :(  {quote}I do think there's value in exposing more of the channel state to chaincodes to allow them to perform ACL and other checks.{quote}  I vote for it! It's strange for me that I can do something by using Client SDK (is not a suitable place for these checks), but can not do the same on chaincode side.  ></body> </Action>
<Action id="71004" issue="39524" author="JIRAUSER21227" type="comment" created="2020-12-23 20:23:13.0" updateauthor="JIRAUSER21227" updated="2020-12-23 20:23:13.0"> <body><! CDATA Sorry for digging this up, but I would like to add some comments about accessing channel state/blocks from user chaincodes.  As mentioned by  ~lmars  , some use cases require checking the ordering of Txs by the endorsers. One example I can think of is building an (append-only) merkle tree for some types of transaction on the ledger.  ~jyellick 's solution of putting all those Txs in the same key then use GetHistoryForKey to get the actual ordering might work, but 1) it is unnatural and 2) it would have bad performance for some use cases since HistoryQueryIteratorInterface is very restricted. For example, reading some latest Txs history requires reading from the oldest.  Is there a possibility of extending ChaincodeStubInterface's functionality to access channel state in the future?  ></body> </Action>
