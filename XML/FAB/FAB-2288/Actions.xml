<Action id="20983" issue="14850" author="markparz" type="comment" created="2017-02-17 18:35:57.0" updateauthor="markparz" updated="2017-02-17 18:36:15.0"> <body><! CDATA  ~muralisr  for the peer section, how about these additions? I wanted to add the committer role as well. •	Peers - There are two 2 separate runtimes on a single peer – endorser and committer. Both require access to the ledger. In the role of an endorser, a peer executes the request (transaction proposal)through a chaincode installed on a peer (life cycle chaincode). The role of the committer is to write the verified transactions to the ledger. The architecture has been designed such that a peer is always a committer, but not necessarily always an endorser. {color:red}–Define further via use case in the use case section and point to it?{color}  ></body> </Action>
<Action id="20993" issue="14850" author="joshhus" type="comment" created="2017-02-17 22:23:42.0" updateauthor="joshhus" updated="2017-02-17 22:23:42.0"> <body><! CDATA For the Transaction comment, okay but those additional types are not all performed "against the ledger" either, per first sentence. Will figure something out.   (Note there also isn't one/the ledger anymore. Because we document from the network perspective, there is one ledger per channel.)  ></body> </Action>
<Action id="20994" issue="14850" author="joshhus" type="comment" body="For peer, it&apos;s simply a node right, first of all, that subscribes to/belongs to one or more channels. And it gossips with its fellow peers on a channel; it&apos;s not only endorsing and committing. Will address. Perhaps that&apos;s why  ~muralisr  changed &quot;role&quot; to &quot;runtime&quot; ... " created="2017-02-17 22:40:37.0" updateauthor="joshhus" updated="2017-02-17 22:41:38.0"/>
<Action id="20995" issue="14850" author="joshhus" type="comment" body="When we get the cross-linking of terms and topics complete, the glossary will improve in usability. For this item, just getting the defs. updated." created="2017-02-17 22:47:01.0" updateauthor="joshhus" updated="2017-02-17 22:47:01.0"/>
<Action id="20996" issue="14850" author="joshhus" type="comment" created="2017-02-17 23:07:18.0" updateauthor="joshhus" updated="2017-02-17 23:07:18.0"> <body><! CDATA (For all of these definitions, goal is to keep them simple; we don't need to write the whole doc for the term/concept in the glossary. Will eventually add the links to more / related info.  Proposed Peer definition:  ## Peer A peer is a node that belongs to (subscribes to) one or more network channels. The main roles performed by peers are endorsing and committing transactions. A peer always commits valid transactions to its ledger, but does not necessarily endorse every transaction. To endorse a transaction, the peer executes the referenced chaincode application, which is installed on the peer. To commit a transaction, the peer writes the validated transaction   to its copy of the channel ledger. To remain in sync, peers also broadcast information across the channel, using the gossip protocol. (See also: Lifecycle Chaincode, endorsement policy, validation policy, gossip protocol.)  ></body> </Action>
<Action id="20997" issue="14850" author="joshhus" type="comment" created="2017-02-17 23:11:22.0" updateauthor="joshhus" updated="2017-02-17 23:11:22.0"> <body><! CDATA Hello,   Moving this discussion to a JIRA issue and linked Gerrit Patch set, FYI.  How do we want to organize the glossary. It's currently partially logical, not entirely, and non-alphabetical. (Potential for retrieval / usability complaints.)  An alphabetical children, by alphabetical parent, method could be done using indentation: e.g.:   Chaincode - definition  indented >     Configuration chaincode: definition 		      Lifecycle chaincode - definition 		      etc.   Peer - definition 		     Anchor peer: definition 		     Leading peer: definition 		      etc.   (Glossaries are almost never read sequentially in any kind of logical order; they are instead find it, jump to it, repeat.)  Will add this to the JIRA Glossary issue.   ></body> </Action>
<Action id="20998" issue="14850" author="joshhus" type="comment" created="2017-02-17 23:22:30.0" updateauthor="joshhus" updated="2017-02-17 23:22:30.0"> <body><! CDATA Proposed: these would be sub-entries (indented) under the previous general "Peer" definition:  Proposed definitions:  ### Anchor Peer (escapes me at the moment, I will come back to it.)  ### Leading Peer Each network member can own multiple peers on a channel. One of these member peers is designated as the leading peer, which communicates with the ordering service on behalf of the member peers. The leading peer distributes ordered transactions to the member peers, for commitment to their replicas of the ledger. When necessary, an algorithm can be invoked to select the leading peer.   ></body> </Action>
<Action id="20999" issue="14850" author="joshhus" type="comment" created="2017-02-17 23:24:31.0" updateauthor="joshhus" updated="2017-02-17 23:37:32.0"> <body><! CDATA Like the "Why blockchain" topic, the "Blockchain network" entry is (arguably) too broad/high level to be included in a "Hyperledger Fabric" glossary. To be determined ...   The def. also describes a fabric network more than a "blockchain" network - e.g. not all bc networks have endorsers. ... I would delete the term, but not deciding for the community.  (The intro Glossary "Note" is arguably contradicted by the subsequent term:  *Note: This glossary is structured to prioritize new terms and features specific to architecture.  It makes the assumption that one already possesses a working familiarity with the basic tenets of blockchain.*)  I deleted the note/added new text, and did the network term edit:  # Hyperledger Fabric Glossary  The glossary includes definitions of terms used in the Hyperledger Fabric  library, and links to related terms and topics.  ## Blockchain Network A blockchain network consists of, at minimum, one peer (responsible for endorsing and committing transactions) leveraging an ordering service, and a membership services component (certificate authority).  ></body> </Action>
<Action id="21000" issue="14850" author="joshhus" type="comment" created="2017-02-17 23:51:40.0" updateauthor="joshhus" updated="2017-02-17 23:54:18.0"> <body><! CDATA ## Permissioned Hyperledger Fabric networks are permissioned; all nodes and peers are required  to maintain a membership identity. End users must also be authorized and authenticated  through the fabric-CA or an alternative certificate authority plug-in.  (CA applies to only the auth/auth part right - not the membership identity part.)  ></body> </Action>
<Action id="21003" issue="14850" author="joshhus" type="comment" created="2017-02-18 13:42:24.0" updateauthor="joshhus" updated="2017-02-18 13:42:24.0"> <body><! CDATA For Member discussion - we need to be able to discuss a "Member" since we have the concept of Membership. So I think an updated def. of Member is called for here. Participant is more vague, potentially over-inclusive -- risks excluding folks who will participate in the network, but not as a "Participant" by our term   (So let's rephrase this definition, but keep the Member term - my recommendation.) Please weigh in ...   I will figure out an updated def. of Member. Current def.:  Member- Keith needs to update this definition- does not seem quite right <ks>I agree that this is confusing. I think we should just use the word "Participant" or "Organization" and not use "Member" for this</ks> A Member is a participant (such as a company or organization) that operates components - Peers, Orderers, and applications - in the blockchain network. A member is identified by its CA certificate (i.e. a unique enrollment). A Member’s peer will be leveraged by end users in order to perform transaction operations on specific channels  ></body> </Action>
<Action id="21005" issue="14850" author="bmos299" type="comment" body="What is confusing is what is actually in the community and what is not.  We need to specify if this is new document being written from scratch or an existing document being edited.  For a brand new document, sure, maybe we get it somewhat presentable by work through a Jira item.  Once it is submitted as a patch set, I think from that point forward all edits are done via the patch sets.  I think we (doc team) need to really establish the ground rules to avoid confusion and doc&apos;s being updated all over the place.  What do you think?" created="2017-02-18 14:13:29.0" updateauthor="bmos299" updated="2017-02-18 14:13:29.0"/>
<Action id="21006" issue="14850" author="joshhus" type="comment" body="e.g. seems a &quot;participant&quot; would have a &quot;membership identity&quot; but not be a &quot;member&quot; by our defs." created="2017-02-18 14:34:25.0" updateauthor="joshhus" updated="2017-02-18 14:34:25.0"/>
<Action id="21007" issue="14850" author="joshhus" type="comment" body=" ~bmos299  Mark has set this up well in JIRA so that when a writer takes an issue to work, writer changes the Issue to In Progress. Then worked until Done. ... So then anything marked ToDo is open to the community to take. Right any Issue that is edits to an existing doc page include the filename/link to the existing doc in the Issue." created="2017-02-18 14:38:22.0" updateauthor="joshhus" updated="2017-02-18 14:39:07.0"/>
<Action id="21008" issue="14850" author="markparz" type="comment" body=" ~bmos299  it should all be community, maybe I misunderstood your comment... Is there some specific that doesn&apos;t look right?" created="2017-02-18 14:53:34.0" updateauthor="markparz" updated="2017-02-18 14:53:34.0"/>
<Action id="21009" issue="14850" author="joshhus" type="comment" created="2017-02-18 15:02:59.0" updateauthor="joshhus" updated="2017-02-18 15:08:54.0"> <body><! CDATA End user   Current and Proposed below:  Current:  End User An end user is someone who would interact with the blockchain through a set of published APIs (i.e. the hfc SDK). You can have an admin user who will typically grant permissions to the Member’s components, and a client user, who, upon proper authentication through the admin user, will drive chaincode applications (deploy, invoke, query) on various channels. In the case of self-executing transactions, the application itself can also be thought of as the end user. Remove what is in red  Proposed:  End User An end user (person or self-executing application) interacts with the fabric network through an SDK API. For example, an admin end user would manage permissions (using ACL lists) for the specific member-owned components, including the member organization's ordering nodes, peers and chaincode applications. A client end user, with authentication and authorization from an administrator, would deploy chaincode applications to various channel peers. (See also: member.)  ></body> </Action>
<Action id="21010" issue="14850" author="joshhus" type="comment" created="2017-02-18 15:33:27.0" updateauthor="joshhus" updated="2017-02-18 15:33:27.0"> <body><! CDATA Ordering Service term: current and proposed:  Current:  Ordering Service A centralized or decentralized (replace this with"Ordering"-- we don't want to go into centralized/decentalized specifically) service that orders transactions in a block. You can select different implementations of the “ordering” function - e.g “solo” for simplicity and testing, Kafka for crash fault tolerance, or sBFT/PBFT for byzantine fault tolerance. You can also develop your own protocol to plug into the service.  Proposed:  (Reviewers note: the ordering service also does some other stuff, this proposed definition is currently limited to the ordering task only - feel free to weigh in on the priority of adding that other stuff here, or perhaps instead for another glossary term.)  Ordering Service A defined collective of nodes that orders transactions, using a pluggable ordering protocol, and writes them to a discrete block. The specific ordering protocol could be the basic SOLO orderer, the Kafka Crash Fault-Tolerant (CFT) protocol, or a Byzantine Fault-Tolerant (BFT) implementation. (Note that a **consensus** protocol is properly limited to an algorithm, such as PFBT, that manages the consensus messaging problem.) To optimize fabric network performance, security and scalability, no ordering nodes are peers, and no peers are ordering nodes. (See also: block, consensus, leading peer, ordering protocol.)    ></body> </Action>
<Action id="21011" issue="14850" author="bmos299" type="comment" body="I am seeing the doc changes go from email to jira to gerrit...isn&apos;t this too much cut and paste of the same changes?  It just seems we make a jira item line to a patch set, have the patch set link to the jira item and make comments in gerrit.  Wouldn&apos;t this save a lot of work?  Just my opinion." created="2017-02-18 15:43:55.0" updateauthor="bmos299" updated="2017-02-18 15:43:55.0"/>
<Action id="21013" issue="14850" author="joshhus" type="comment" created="2017-02-18 16:36:45.0" updateauthor="joshhus" updated="2017-02-18 16:36:45.0"> <body><! CDATA I suggest that we already have the orderer concept covered, by the ordering service definition / leave it out for now. Feel free to weigh in.  (I don't think the service "delivers" the transactions to the member's leading peer (on a channel); technically, the leading peer pulls the ordered transactions. (If that's a valuable distinction to some.)  Current:  Orderer One of the network entities that form the ordering service. A collection of ordering service nodes (OSNs) will order transactions into blocks according to the network’s chosen ordering implementation. In the case of “solo”, only one OSN is required. Transactions are “broadcast” to orderers, and then “delivered” as blocks to the appropriate channel. (if you mention solo- then you should mention CFTimplementation. I would just remove solo part)  Proposed:  Remove "Orderer", as a distinct term/entry, from glossary - ordering nodes are described by the Ordering Service definition, and other term definitions, such as Peer.   ></body> </Action>
<Action id="21016" issue="14850" author="joshhus" type="comment" created="2017-02-18 17:19:42.0" updateauthor="joshhus" updated="2017-02-18 17:19:42.0"> <body><! CDATA Endorser term/def. current and proposed.  (Reviewers: Note this will be located as one of the subentry terms/defs., under the main "Peer" term and definition, in Glossary.)  (Question: What determines whether or not an unsigned / not endorsed / i.e. failed endorsement transaction is forwarded to the ordering service? - Is that Lifecycle Chaincode - the current proposed definition below assumes so.)   Current:  Endorser A specific peer role, where the Endorser peer is responsible for simulating transactions , and in turn preventing unstable or non-deterministic transactions from passing through the network. (remove what is in red- replace with) and signing the transaction based on the policy set. A transaction is sent to an endorser in the form of a transaction proposal and send the information back to the application layer, which will in turn will send to the orderer All endorsing peers are currently also committing peers (i.e. they write to the ledger).  This actually isn't quite true- you can actually send transactions that don't have a consistent result onto consensus- it will be validated at the comitting peer with VSCC Validated system chain code. We do recommend the application checks this, but I suspect some will go ahead and send to the orderer.  Proposed:   (a sub-entry under the "Peer" term/def. umbrella):  ### Endorsing Peer An endorsing peer receives a transaction proposal (request) from the **SDK** and executes the transaction. The endorsing peer then applies the channel **endorsement policy** to the transaction results, to either endorse (sign) the transaction, or not. The endorsing peer then returns the transaction results, signed or unsigned, to the SDK. The SDK then forwards signed (endorsed) transactions to the **ordering service**; **Lifecycle Chaincode** for the channel dictates whether or not the SDK also forwards unsigned transactions for ordering. Depending on the endorsement policy, all peers on a channel may or may not be  endorsing peers for any specific transaction proposal. (See also: deterministic chaincode, endorsement policy, Lifecycle Chaincode, SDK.)  ></body> </Action>
<Action id="21017" issue="14850" author="joshhus" type="comment" created="2017-02-18 17:31:39.0" updateauthor="joshhus" updated="2017-02-18 17:41:33.0"> <body><! CDATA  ~bmos299  That wouldn't save work for this long/debated item - the current method saves work, my opinion, by facilitating ongoing review / debate in JIRA, in a single place/version, while I continue work the remaining terms. Avoids me pushing, and reviewers managing, many multiple patch sets. ... For this doc item anyway - lots of items (glossary), lots of comments and input and Q&As, this method is working. https://jira.hyperledger.org/browse/FAB-2288?focusedCommentId=21011&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-21011  If you guys disagree I can push a patch set to Gerrit, though do all reviewers use it? I'm still using email also, because of the color-coding of the comments. - color not preserved in JIRA.  ></body> </Action>
<Action id="21019" issue="14850" author="joshhus" type="comment" created="2017-02-18 19:16:18.0" updateauthor="joshhus" updated="2017-02-18 19:16:18.0"> <body><! CDATA "Committer" term/def. current and proposed:  Current:  Committer A specific peer role, where the Committing peer appends the validated transactions to the channel-specific ledger. If the read/write set is not the same across peers, the transaction will be rejected. A peer can act as both an endorser and committer, but in more regulated circumstances might only serve as a committer.   Proposed:  Committing Peer A committing peer validates ordered blocks of transactions and commits (appends) the blocks to its replica of the channel ledger. All peers, including endorsing peers, are committing peers, because all peers maintain one or more ledgers (one ledger per channel). Committing peers also mark each transaction in the ordered block as valid or invalid, by applying the **validation policy** for the channel. (See also: ledger, Lifecycle Chaincode, validation policy.)  ></body> </Action>
<Action id="21022" issue="14850" author="joshhus" type="comment" created="2017-02-18 20:25:28.0" updateauthor="joshhus" updated="2017-02-18 21:17:55.0"> <body><! CDATA "Bootstrap" current and proposed:  For this one I'll do Proposed first:  Proposed:    (Review comment: this def. needs to be refined/limited to an HL fabric bootstrap. Fabric network "setup" and "installation" are separate topics. "bootstrap" has specific   implications in IT generally; bringing networked nodes online without fully re-booting all OS-es in a network, I believe is the general idea.) (Gerrit patch coming soon). )   Current:   Bootstrap The initial setup of a network. There is the bootstrap of a peer network, during which policies, system chaincodes, and cryptographic materials (certs) are disseminated amongst participants, and the bootstrap of an ordering network. The bootstrap of the ordering network must precede the bootstrap of the peer network, as a peer network is contingent upon the presence of an ordering service. A network need only be “bootstrapped” once.  Side notes:  Bootstrapping the network requires creating the network, creating/viewing multiple channels, setting up policies of network, setting up policies for channels, inviting participants to the network and setting up access control on the participants. You do have to have a CA and in that case you need to enroll id, passwords and certificates for applications and peers.  May want to rephrase your bootstrap section as a result of this information--   ></body> </Action>
<Action id="21023" issue="14850" author="joshhus" type="comment" created="2017-02-18 21:00:18.0" updateauthor="joshhus" updated="2017-02-18 21:03:53.0"> <body><! CDATA Block: current and proposed.  (Reviewer note: to answer the comment below, there are valid and invalid transactions, and they are marked as such in the ledger, in non-hashed, queryable data. ... If the objection is that this invalid designation is not part of the hashed "block", proper, that's true I believe; but an invalid transaction is still written to the ledger, as hashed Tx. ... Seems we should add an term. and definition for an "invalid transaction" - one that fails the validation policy for the channel. What else - one that could get sent for ordering / inclusion even though no peers "endorsed" it? Would all of these not-endorsed transactions subsequently also fail the validation policy, always? I guess so. Will attempt an invalid transaction entry and definition, Please weigh in.) ... (And I'll add my questions/comments as such to the Gerrit patch set.)  p.s. I was instructed to dump "batch" as a term for v1.0.  p.p.s. Need confirmation that it is the "Lifecycle Chaincode" that determines when a block is "done" / no new TX - e.g. This could be after x number of Tx in block, and/or after x amount of time without a new Tx added to block, etc.   Current:  Block A batch of ordered transactions, potentially containing ones of an invalid nature, that is delivered to the peers for validation and committal.  I do not know why you think there are transactions that are invalid- I would remove this.  Proposed:  Block:  A block is a self-contained unit of a number of ordered transactions, which is eventually written to the channel ledger. Like each transaction within a block, each block is also cryptographically-linked by a series of unique hashtags. Lifecycle Chaincode determines when a block gets ordered and signed, by the ordering service, and broadcast to the channel leading peer. Committing peers then run the validation policy against the ordered block, mark transactions as valid or invalid (in non-hashed data for query), and commit (append) the block to the ledger.   ></body> </Action>
<Action id="21024" issue="14850" author="joshhus" type="comment" created="2017-02-18 21:18:37.0" updateauthor="joshhus" updated="2017-02-18 21:18:37.0"> <body><! CDATA System Chain and System Chaincode. Current only:  System chain (have Murali verify this definition and the one immediate below) Contains a configuration block defining the network at a system level. The system chain lives within the ordering service, and similar to a channel, has an initial configuration containing information such as: root certificates for participating organizations and ordering service nodes, policies, listening address for OSN, and configuration details. Any change to the overall network (e.g. a new org joining or a new OSN being added) will result in a new configuration block being added to the system chain.  The system chain can be thought of as the common binding for a channel or group of channels. For instance, a collection of financial institutions may form a consortium (represented through the system chain), and then proceed to create channels relative to their aligned and varying business agendas.  System Chaincode System Chaincode (SCC) is a chaincode built with the peer and run in the same process as the peer. SCC is responsible for broader configurations of fabric behavior, such as timing and naming services.  ></body> </Action>
<Action id="21025" issue="14850" author="joshhus" type="comment" created="2017-02-18 21:25:45.0" updateauthor="joshhus" updated="2017-02-18 21:26:10.0"> <body><! CDATA Channel: Current and Proposed:  Current:  Channel A Channel is formed as an offshoot of the system chain; and best thought of as a “topic” for peers to subscribe to, or rather, a subset of a broader blockchain network. A peer may subscribe on various channels and can only access the transactions on the subscribed channels. Each channel will have a unique ledger, thus accommodating confidentiality and execution of multilateral contracts.  I like this better:  With a network created by peers, there are some use cases where some of the transactions may only go to specific peers. Channels allows you to create a topic for a subset of peers. As an example, Network has a, b,c, d participants. A channel can be created that the transactions can only be seen by a,b,and c, whereby participant d does not see the transaction or the ledger.    Proposed: (don't know yet if anchor is correct here)  A channel is a private line of communication between two or more specific network members, for the purpose of conducting private and confidential transactions. A channel is defined by an anchor peer for each member, the shared ledger, chaincode applications and the ordering service nodes. Each transaction on the network is executed on a channel, where each party must be authenticated and authorized to transact on that channel. Although any one anchor peer can belong to multiple channels, and therefore maintain multiple ledgers, no ledger data can pass from one channel to another.  ></body> </Action>
<Action id="21027" issue="14850" author="joshhus" type="comment" created="2017-02-18 22:58:23.0" updateauthor="joshhus" updated="2017-02-18 22:58:23.0"> <body><! CDATA Dynamic Membership: Current and Proposed:  Current:  Dynamic membership he fabric will allow for endorsers and committers to come and go based on membership, and the blockchain network will continue to operate. Dynamic membership is critical when businesses grow and members need to be added or removed for various reasons.  You are missing a T in The up in the beginning  Proposed:  I would delete from glossary, or fix the term and definition - membership at the org. level exists. and then for peers we have members of members? we can't really say we have members of members with a straight face. so this could be dynamic something, but not dynamic "membership".   ></body> </Action>
<Action id="21029" issue="14850" author="joshhus" type="comment" created="2017-02-18 23:36:27.0" updateauthor="joshhus" updated="2017-02-18 23:36:27.0"> <body><! CDATA Query Current and Proposed:  (Note Proposed now sounds like we recommend Couch over Level, if that's what we want to do.)  Current:  Query/Non-Key Value Query using couchDB 2.0 you now have the capability to leverage an API to perform more complex queries against combinations of variables, including time ranges, transaction types, users, etc.  This feature allows for auditors and regulators to aggregate and mine large chunks of data.  Capitlize "u" in Using. Remove "2.0" we can get into that later into the documentation.  Start with "There are two ledgers that are currently implemented in fabric by default- level DB and CouchDB.  Users can also plug in their own ledger as a pluggable component. Using,...""  Proposed:   ## Query The fabric provides two ledger database programs to choose from: LevelDB and CouchDB. Alternative pluggable database programs are also supported. CouchDB leverages an API for performing queries against multiple variables, including time ranges, transaction types and user names. This complex query feature allows authorized users, including auditors and regulators, to aggregate and mine large chunks of data from the ledger.   ></body> </Action>
<Action id="21030" issue="14850" author="joshhus" type="comment" created="2017-02-18 23:46:28.0" updateauthor="joshhus" updated="2017-02-18 23:46:28.0"> <body><! CDATA New addition: Gossip Protocol:   Proposed:  ## Gossip Protocol The gossip data dissemination protocol performs three functions on a fabric network: 1) manages peer discovery and channel membership; 2) disseminates ledger data across all peers on the channel; and 3) syncs ledger state across all peers on the channel. Gossip broadcasting operates by peers receiving messages from other peers on the channel, and then forwarding these messages to randomly-selected peers. This cycle continually repeats, with the result of channel membership, ledger and state information being kept current and in sync.  ></body> </Action>
<Action id="21031" issue="14850" author="joshhus" type="comment" created="2017-02-19 00:18:47.0" updateauthor="joshhus" updated="2017-02-19 00:18:47.0"> <body><! CDATA Endorsement System Chaincode: Current and Proposed:  (Review Question here: does ESCC manage both whether or not a peer signs the transaction, and also whether or not an unsigned transaction is forwarded by the SDK to the orderer? -- Or is the latter lifecycle chaincode. I think some of the percentage/numbers stuff in the "current" text is instead lifecycle chaincode,  that controls forwarding (or not) to the ordering service.)   Current:  Endorsement System Chaincode Endorsement System Chaincode (ESCC) is a system chaincode that andles the endorsement policy for specific pieces of chaincode deployed on a network, and defines the necessary parameters (percentage or combination of signatures from endorsing peers) for a transaction proposal to receive a successful proposal response (i.e. endorsement). Deployments and invocations of user chaincodes both require a corresponding ESCC, which is defined at the time of the deployment transaction proposal for the user chaincode.  andles- needs to change to handles  Proposed:   ## Endorsement System Chaincode Endorsement System Chaincode (ESCC) defines the transaction **endorsement policy**  for each specific chaincode application. Following transaction execution, each endorsing peer applies the endorsement policy for the invoked chaincode application. Each endorsing peer then either signs (endorses) its transaction results, or does not sign, based on the endorsement policy, and returns its results to the SDK. (See also: Lifecycle Chaincode.)   ></body> </Action>
<Action id="21032" issue="14850" author="joshhus" type="comment" created="2017-02-19 00:25:36.0" updateauthor="joshhus" updated="2017-02-19 00:25:36.0"> <body><! CDATA Endorsement Policy. Current and Proposed.  Keeping this Proposed text short b/c we have it pretty much covered already by the previous ESCC definition.  Current:  Endorsement policy A blockchain network must establish rules that govern the endorsement (or not) of proposed, simulated transactions. This endorsement policy could require that a transaction be endorsed by a minimum number of endorsing peers, a minimum percentage of endorsing peers, or by all endorsing peers that are assigned to a specific chaincode application. Policies can be curated based on the application and the desired level of resilience against misbehavior (deliberate or not) by the endorsing peers. A distinct endorsement policy for deploy transactions, which install new chaincode, is also required.  Endorsements that are required to run a transaction for a chaincode will be validated by the orderer. (ie it will make sure all signatures were obtained before sending to committer)  Proposed:  ## Endorsement Policy The endorsement policy for a chaincode application determines whether or not an endorsing peer signs (endorses) a specific transaction proposal, or not. (See also: Endorsement System Chaincode.)  ></body> </Action>
<Action id="21033" issue="14850" author="joshhus" type="comment" created="2017-02-19 01:02:23.0" updateauthor="joshhus" updated="2017-02-19 01:02:23.0"> <body><! CDATA Proposal and Deploy: Current and Proposed.  (Are we saying "deploy" is to be replaced now, everywhere, with install or instantiate? That's a big hit to the library.)  (A "configuration request" is just an invoke of system chaincode, right. It's an invoke.)  Current:   Proposal A transaction request sent from a client or admin user to one or more peers in a network; examples include deploy, invoke, query, or configuration request. (you should take out deploy- we have install/instantiate chaincode now)  Proposed:  Proposal: A proposal is a transaction request sent from the SDK to a channel for endorsement. Each proposal is either a deploy/install/instantiate, invoke or query request. The term *proposal* is used to indicate that execution of a transaction does not guarantee that the transaction will be appended to the ledger. (See also: endorsing peer.)   (Deploy is marked for deletion it seems. Or change to install/instantiate.)   Deploy (this should be removed) Refers to the function through which chaincode applications are deployed on chain. A deploy is first sent from the client SDK or CLI to a Lifecycle System Chaincode in the form of a proposal.  ></body> </Action>
<Action id="21038" issue="14850" author="joshhus" type="comment" created="2017-02-19 14:30:16.0" updateauthor="joshhus" updated="2017-02-19 14:30:16.0"> <body><! CDATA Membership Services and MSP:  Current:  Membership Services (keith to validate the following two definitions) Membership Services manages user identities on a permissioned blockchain network; this function is implemented through the fabric-ca component.  fabric-ca is comprised of a client and server, and handles the distribution and revocation of enrollment materials (certificates), which serve to identify and authenticate users on a network  The in-line MembershipSrvc code (MSP) runs on the peers themselves, and is used by the peer when authenticating transaction processing results, and by the client to verify/authenticate transactions. Membership Services provides a distinction of roles by combining elements of Public Key Infrastructure (PKI) and decentralization (consensus). By contrast, non-permissioned networks do not provide member-specific authority or a distinction of roles.  A permissioned blockchain requires entities to register for long-term identity credentials (Enrollment Certificates), which can be distinguished according to entity type. For users, an Enrollment Certificate authorizes the Transaction Certificate Authority (TCA) to issue pseudonymous credentials; these certificates authorize transactions submitted by the user. Transaction certificates persist on the blockchain, and enable authorized auditors to associate, and identify the transacting parties for otherwise un-linkable transactions.  <ks> I would write this section as follows ... Membership Services authenticates, authorizes, and manages identities on a permissioned blockchain network.  The membership services code that runs in peers and orderers both authenticates and authorizes blockchain operations.  It is a PKI-based implementation of the Membership Services Provider (MSP) abstraction. The fabric-ca component is an implementation of membership services to manage identities.  In particular, it handles the issuance and revocation of enrollment certificates and transaction certificates.  An enrollment certificate is a long-term identity credential; a transaction certificate is a short-term identity credential which is both anonymous and un-linkable.  </ks>  Membership Service Provider The Membership Service Provider (MSP) refers to an abstract component of the system that provides (anonymous) <ks> Remove "(anonymous)" as MSP says nothing about anonymity.  This is implemented by fabric-ca.</ks> credentials to clients, and peers for them to participate in a Hyperledger/fabric network. Clients use these credentials to authenticate their transactions, and peers use these credentials to authenticate transaction processing results (endorsements). While strongly connected to the transaction processing components of the systems, this interface aims to have membership services components defined, in such a way that alternate implementations of this can be smoothly plugged in without modifying the core of transaction processing components of the system.  Proposed:  ## Membership Services Membership services authenticates, authorizes, and manages identities on a permissioned blockchain network. (All Hyperledger Fabric networks are  permissioned.) The membership services code that runs in peers and ordering nodes both authenticates and authorizes blockchain operations. It is a PKI-based implementation of the Membership Services Provider (MSP) abstraction. The `fabric-ca` component is an implementation of membership services for managing identities. In particular, `fabric-ca` issues and revokes enrollment certificates (eCerts) and transaction certificates (tCerts). eCerts are long-term identity credentials; tCerts are short-term identity credentials, which are both anonymous and unlinkable.  ## Membership Service Provider The Membership Service Provider (MSP) is an abstract system component that provides credentials to clients and peers. Credentials are used by clients to authenticate transactions, and by peers to authenticate (endorse) transaction results. The MSP supports pluggable implementations of the Membership Services component, without requiring any modification of core transaction processing components.  (EOF)    ></body> </Action>
