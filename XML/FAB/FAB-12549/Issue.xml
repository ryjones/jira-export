<Issue id="34806" key="FAB-12549" number="12549" project="10002" reporter="yacovm" creator="yacovm" type="10004" summary="Adapt to orderer node revocation and organization reconfiguration" priority="3" status="10300" created="2018-10-21 08:05:59.0" updated="2019-02-18 12:39:08.0" votes="0" watches="5" workflowId="46221" security="10000"> <description><! CDATA Blocks can enter the peer via several pathways: * Pulling the blocks sequentially from the orderer * Pulling blocks sequantially from a node via p2p block transfer - this is done when the peer detects it is lagging behind, and is more effective for late peers that join the network than for synchronizing peers that only lack 1 or 2 blocks to have a consecutive set to be committed. * Pulling blocks via the pull mechanism - pulls blocks out of band and verifies (signature verification + validation of the CA cert chain) each block separately and not in any particular order. * Receiving blocks from other peers via push - here, blocks are also verified out of band, as a peer might receive them out of band.  In case the e-cert root CAs of the orderer(s) changed, a peer might drop legit blocks because it considers them as invalid. Since the peer will eventually get the sequence of the blocks up to that block, and will be able to verify them all - it will eventually re-acquire these blocks via one of the mechanisms above, and will commit the block it considered before as invalid.     However - it may be that an orderer has been revoked (or a root CA of an orderer org has been revoked) and then a peer might not detect that revocation and commit a block that is signed by an orderer that it otherwise wouldn't have committed had he received the block after it committed all prior blocks.     It might appear at first glance that this is not an issue, because since out of band block dissemination only happens within the same organization, an attack requires a collusion of a peer, because any leader peer - pulls blocks in order and verifies them before committing and gossiping, but - it is not the case.  I think that a leader peer might be fooled into disseminating an invalid block despite verifying it, because there is a block reordering buffer between the mechanism that pulls block from the orderer and the block commit goroutine. That reorder buffer has "room" for up to 200 blocks, and if the block commit is slower than the block pulling, then this buffer would accumulate, and an orderer that has been revoked - can still send blocks to peers that are unaware of the revocation of that orderer, and these blocks would be verified with an old configuration sequence and then forwarded to other peers.     We can't use the last config block field, because it may contain an invalid entry: A peer might be at height 100, with a last config block of 80, get a block numbered 120 out of band with a last config block field of 80, though the last config block for that block might be 110.  Since configuration blocks are rare in comparison to data blocks, I think an easy but effective solution for this, would be to simply do the following: # For each block verified and put into any in-memory buffer in gossip, add a "validated sequence" field (the configuration block sequence). # At commit, look at the validated sequence field of the block, and the validated sequence field of the last config block (we need to track it). If they differ, then re-validate the block being committed. # At commit, see if the block that was committed is a configuration block, and increment the validated sequence field.   Another nice thing to have is to ensure that if an invalid block was received from the orderer, we need to disconnect from that orderer.  This is important since a block might be verified and be added to the reorder buffer and in hind-sight it should not have been verified.  In such a case we need to disconnect from the orderer node.  (*)  I think that it's not an issue for Kafka based orderers, since I find it hard to believe that Kafka clusters are actually shared among organizations - thus the orderer nodes also probably belong to the same organization, and also - since we have the  peer boostrapping problem|https://jira.hyperledger.org/browse/FAB-5288  - it's unlikely that users would actually change the ordering nodes. However I think this needs to be addressed...   (*) A similar problem exists for p2p state transfer of blocks since it also  adds messages to the reorder buffer|https://github.com/hyperledger/fabric/blob/release-1.3/gossip/state/state.go#L483 .   (*) This is important for BFT orderer types, since even if we have a multi-signature - nodes might be revoked and replaced by other nodes, and then these nodes might fork the network because the blocks that revoke these nodes are committed too late, and blocks that were produced after these blocks - will be verified incorrectly and be put into the reorder buffer.  ></description> </Issue>
