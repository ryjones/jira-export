<Action id="49913" issue="32081" author="manish-sethi" type="comment" created="2018-09-05 18:07:03.0" updateauthor="denyeart" updated="2018-09-05 18:35:43.0"> <body><! CDATA I checked locally at the ledger side and GetHistoryForKey works fine even with a key as an empty string. Further, what puzzles me is this statement in bug description - "using levelDB (seems to be fine with CouchDB)". The history db is largely unaffected by the choice of statedb.  Though, chaincode handler should simply be a pass through but in case there is some internal details that  ~sykesm  wants to have a look.  ></body> </Action>
<Action id="49937" issue="32081" author="sykesm" type="comment" created="2018-09-05 22:07:49.0" updateauthor="sykesm" updated="2018-09-05 22:07:49.0"> <body><! CDATA The chaincode message is simply unmarshaled  1  and passed along unmolested to the query executor  2 .  As an aside, did you look at the log record that was created?  {code} 2018-07-19 18:01:05.366 UTC  leveldbhelper  GetIterator -> DEBU 20a1 Getting iterator for range    byte\{0x77, 0x65, 0x6c, 0x6c, 0x6c, 0x69, 0x6e, 0x63, 0x2d, 0x31, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x0, 0x77, 0x6c, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x0, 0x0}  -    byte\{0x77, 0x65, 0x6c, 0x6c, 0x6c, 0x69, 0x6e, 0x63, 0x2d, 0x31, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x0, 0x77, 0x6c, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x0, 0x0, 0xff}  {code}  If I'm reading that correctly (may not be), there's a byte(0) embedded in the middle of the namespace.  {code}   byte{ 0x77, 0x65, 0x6c, 0x6c, 0x6c, 0x69, 0x6e, 0x63, 0x2d, 0x31, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x0,  0x77, 0x6c, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x63, 0x6f, 0x64, 0x65, // namespace: welllinc-1singldhost\000wlchaincode 0x0,  // post-ns separator // empty-key 0x0,  // post-key separator }   byte{ 0x77, 0x65, 0x6c, 0x6c, 0x6c, 0x69, 0x6e, 0x63, 0x2d, 0x31, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x68, 0x6f, 0x73, 0x74, 0x0,  0x77, 0x6c, 0x63, 0x68, 0x61, 0x69, 0x6e, 0x63, 0x6f, 0x64, 0x65, // namespace: welllinc-1singldhost\000wlchaincode 0x0,  // post-ns separator // empty-key 0x0,  // post-key separator 0xff, // end-key indiecator } {code}  If there's a 0 byte, I'm pretty sure that will completely hose the ledger code.   1 : https://github.com/hyperledger/fabric/blob/9db3fbcf97df1655de828ec8be6e33db215ae795/core/chaincode/handler.go#L1119-L1124  2 : https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/handler.go#L1134  ></body> </Action>
<Action id="50006" issue="32081" author="sykesm" type="comment" created="2018-09-06 13:57:03.0" updateauthor="sykesm" updated="2018-09-06 13:58:20.0"> <body><! CDATA The chaincode name gets extracted in an obtuse way in the chaincode handler from the registration message. (I continue to be amazed at how complicated we make things.)   While there may be a bug there, it looks like we just decode what we receive from the chaincode register message. If the if the ChaincodeID.Name send by in the REGISTER message contained a nil byte, we would just carry it along. While this shouldn't happen, the protobuf encoding for a string is length delimited so decoding is unlikely to care.  So, at this point, I think {{historydb.ConstructPartialCompositeHistoryKey}} and/or {{LevelHistoryDBQueryExecutor.GetHistoryForKey}} need to validate that the namespace and key do not contain the delimiters used by the iterator.  The chaincode registration logs and code would be interesting to review relative to 0 bytes in the name; without that, it's hard to see if the handler received garbage or not.  ></body> </Action>
<Action id="50047" issue="32081" author="manish-sethi" type="comment" body="As per the log record, the key that gets stored contains a nil byte and I looked at the historydb code and found that it assumes somehow that the key does not contain a nil byte. There is no such assumption anywhere else as such - not sure why historydb code assumes this." created="2018-09-06 18:55:40.0" updateauthor="manish-sethi" updated="2018-09-06 18:55:40.0"/>
<Action id="50052" issue="32081" author="manish-sethi" type="comment" created="2018-09-06 22:57:12.0" updateauthor="manish-sethi" updated="2018-09-06 22:57:12.0"> <body><! CDATA Submitted a CR -  https://gerrit.hyperledger.org/r/#/c/26155/  with the fix however, I have -1ed for now or preventing an accidental merge. We need to decide on how should this be released as this requires rebuilding of historydb.   ~denyeart  - what is best way to release this in your opinion? Add the requirement of rebuilding historydb in the release notes or having this as a patch here for some time (till we go for 2.0)?  ></body> </Action>
<Action id="50118" issue="32081" author="manish-sethi" type="comment" body="Discussed with  ~denyeart  and decided that it may not be better to force a rebuild of history db in an intermediate release. Perhaps release 2.0 may be right candidate for that. For now, submitted another fix (https://gerrit.hyperledger.org/r/#/c/26174/) which is a sub-optimal  solution but provides correctness of results and would work with existing historydb. Abandoned the earlier CR and will revive later for version 2.0" created="2018-09-07 22:07:06.0" updateauthor="manish-sethi" updated="2018-09-07 22:07:06.0"/>
<Action id="50484" issue="32081" author="denyeart" type="comment" created="2018-09-15 05:10:07.0" updateauthor="denyeart" updated="2018-09-15 05:10:07.0"> <body><! CDATA Testing with the pre-fixed code, I see another manifestation of the problem when other keys with nil bytes are picked up within the history range query for a key: {code:java} 2018-09-15 01:03:06.269 EDT  chaincode  HandleTransaction -> DEBU 342  fd113ca5  handling GET_HISTORY_FOR_KEY from chaincode 2018-09-15 01:03:06.269 EDT  leveldbhelper  GetIterator -> DEBU 343 Getting iterator for range    byte{0x6d, 0x79, 0x63, 0x0, 0x6d, 0x61, 0x72, 0x62, 0x6c, 0x65, 0x73, 0x0, 0x6d, 0x61, 0x72, 0x62, 0x6c, 0x65, 0x36, 0x0}  -    byte{0x6d, 0x79, 0x63, 0x0, 0x6d, 0x61, 0x72, 0x62, 0x6c, 0x65, 0x73, 0x0, 0x6d, 0x61, 0x72, 0x62, 0x6c, 0x65, 0x36, 0x0, 0xff}  2018-09-15 01:03:06.270 EDT  historyleveldb  Next -> DEBU 344 Found history record for namespace:marbles key:marble6 at blockNumTranNum 0:0 2018-09-15 01:03:06.270 EDT  fsblkstorage  retrieveTransactionByBlockNumTranNum -> DEBU 345 retrieveTransactionByBlockNumTranNum() - blockNum =  0 , tranNum =  0  2018-09-15 01:03:06.270 EDT  fsblkstorage  fetchTransactionEnvelope -> DEBU 346 Entering fetchTransactionEnvelope() fileSuffixNum=0, offset=38, bytesLength=14655 2018-09-15 01:03:06.270 EDT  historyleveldb  getKeyModificationFromTran -> DEBU 347 Entering getKeyModificationFromTran() %!(EXTRA string=marbles, string=marble6) 2018-09-15 01:03:06.270 EDT  chaincode  BuildQueryResponse -> ERRO 348 Failed to get query result from iterator 2018-09-15 01:03:06.270 EDT  chaincode  HandleTransaction -> ERRO 349  fd113ca5  Failed to handle GET_HISTORY_FOR_KEY. error: proto: can't skip unknown wire type 7 error unmarshaling ProposalResponsePayload github.com/hyperledger/fabric/protos/utils.GetProposalResponsePayload /Users/denyeart/work/src/github.com/hyperledger/fabric/protos/utils/proputils.go:190 github.com/hyperledger/fabric/protos/utils.GetPayloads /Users/denyeart/work/src/github.com/hyperledger/fabric/protos/utils/txutils.go:36 github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb.getKeyModificationFromTran /Users/denyeart/work/src/github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb/historyleveldb_query_executer.go:108 github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb.(*historyScanner).Next /Users/denyeart/work/src/github.com/hyperledger/fabric/core/ledger/kvledger/history/historydb/historyleveldb/historyleveldb_query_executer.go:80 github.com/hyperledger/fabric/core/chaincode.(*QueryResponseGenerator).BuildQueryResponse /Users/denyeart/work/src/github.com/hyperledger/fabric/core/chaincode/query_response_generator.go:32 github.com/hyperledger/fabric/core/chaincode.(*Handler).HandleGetHistoryForKey /Users/denyeart/work/src/github.com/hyperledger/fabric/core/chaincode/handler.go:824 github.com/hyperledger/fabric/core/chaincode.(*Handler).HandleGetHistoryForKey-fm /Users/denyeart/work/src/github.com/hyperledger/fabric/core/chaincode/handler.go:214 github.com/hyperledger/fabric/core/chaincode.(*Handler).HandleTransaction /Users/denyeart/work/src/github.com/hyperledger/fabric/core/chaincode/handler.go:257 runtime.goexit{code} I've confirmed the fix fixes this problem as well.  ></body> </Action>
<Action id="50486" issue="32081" author="denyeart" type="comment" created="2018-09-15 05:18:59.0" updateauthor="denyeart" updated="2018-09-15 05:18:59.0"> <body><! CDATA Also note the problem does NOT occur with normal composite keys.  These were a concern due to the nil byte separator in composite keys, but it turns out that these are not a problem, since composite keys end in a nil byte and the history keys also have nil byte separators.  This results in two nil bytes at the end of the history range query startkey and endkey, which ensures (as designed) that other composite keys in the same namespace with similar prefixes will NOT be picked up.  The problem will therefore only occur if applications create their own namespaces or keys with nil bytes.  ></body> </Action>
<Action id="50487" issue="32081" author="denyeart" type="comment" created="2018-09-15 05:23:48.0" updateauthor="denyeart" updated="2018-09-19 20:35:43.0"> <body><! CDATA  https://gerrit.hyperledger.org/r/#/c/26174/  merged in master for v1.3.0.  I'm thinking this should be backported to release-1.2 and release-1.1 as well.  It will require manual, but simple, cherry pick.  ></body> </Action>
