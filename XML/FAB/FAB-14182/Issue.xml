<Issue id="37677" key="FAB-14182" number="14182" project="10002" reporter="tecnalia" creator="tecnalia" type="10002" summary="Golang chaincode production runtime container optimization" priority="3" resolution="10001" status="6" created="2019-02-14 09:05:12.0" updated="2020-01-22 22:32:48.0" resolutiondate="2020-01-22 22:32:48.0" votes="0" watches="1" workflowId="49291"> <description><! CDATA After compiling the chaincode using runtime CCENV container for golang based smart contracts, the compiled code is executed inside a docker container for isolation purposes.  This approach is fine. however there is so much unnecessary software and tools inside running container image that should be removed on 'real production' environment.  A golang based chaincode contract should contain only: * a minimum container image based on alpine (which minimizes also the vulnerabilities on container software, and possible attacks on them) * a compiled executable chaincode  Currently a runtime container image has the following structure:  h2. Filesize internals  {{root@0a13214caf13:/# du -sh *}} {{7.2M bin}} {{4.0K boot}} {{0 dev}} {{1.8M etc}} {{4.0K home}} {{24M lib}} {{4.0K lib64}} {{4.0K media}} {{4.0K mnt}} {{4.0K opt}} {{du: cannot access 'proc/51/task/51/fd/4': No such file or directory}} {{du: cannot access 'proc/51/task/51/fdinfo/4': No such file or directory}} {{du: cannot access 'proc/51/fd/3': No such file or directory}} {{du: cannot access 'proc/51/fdinfo/3': No such file or directory}} {{0 proc}} {{12K root}} {{24K run}} {{3.5M sbin}} {{4.0K srv}} {{0 sys}} {{4.0K tmp}} {{91M usr}} {{6.0M var}}  h2. Docker runtime container image layers history  IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT d6cad6d2231a        About an hour ago   /bin/sh -c #(nop)  ENV CORE_CHAINCODE_BUILDL…   0B                   61db5fa4f596        About an hour ago   /bin/sh -c #(nop)  LABEL org.hyperledger.fab…   0B                   1c60132085be        About an hour ago   /bin/sh -c #(nop) ADD file:a110a7c6e08d29a84…   27.4MB               75f5fb1a0e0c        4 months ago        /bin/sh -c cd /tmp/scripts &&     common/ini…   8.67MB               <missing>           4 months ago        /bin/sh -c #(nop) COPY dir:7a02c249ea4b9fc7d…   10.7kB               <missing>           5 months ago        /bin/sh -c #(nop)  CMD  "/bin/bash"             0B                   <missing>           5 months ago        /bin/sh -c mkdir -p /run/systemd && echo 'do…   7B                   <missing>           5 months ago        /bin/sh -c sed -i 's/^#\s*\(deb.*universe\)$…   2.76kB               <missing>           5 months ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0B                   <missing>           5 months ago        /bin/sh -c set -xe   && echo '#!/bin/sh' > /…   745B                 <missing>           5 months ago        /bin/sh -c #(nop) ADD file:a83ab1826f43e88bc…   115MB    h2. Docker runtime container chaincode file size  {{root@0a13214caf13:/# ls -alh ./usr/local/bin/chaincode}}  {{-rwxr-xr-x 1 root root 27M Feb 14 08:18 ./usr/local/bin/chaincode}} h2. *{{proposed optimizations}}*  *{{As can be seen, for a 27mb golang chaincode, a container of 151Mb is created adding an extra size of 124Mb. This represents more than x4 size increment over optimal size. This process clearly needs to be optimized for production taking into account that most cloud providers pay per byte transfer and storage used, so that the less used the better.}}*  *{{We propose to create this final runtime container using just an alpine docker image and copying inside compiled golang executable to achieve these goals.}}*  ></description> </Issue>
