<Action id="39711" issue="27436" author="c0rwin" type="comment" body="Can you please attach peer logs file?" created="2018-02-06 13:19:00.0" updateauthor="c0rwin" updated="2018-02-06 13:19:00.0"/>
<Action id="39716" issue="27436" author="yacovm" type="comment" created="2018-02-06 14:17:57.0" updateauthor="yacovm" updated="2018-02-06 14:26:12.0"> <body><! CDATA FWIW - this scenario doesn't fail in our unit tests, I just wrote an integration test in the release branch (we're at v1.0.5 but nothing has changed since v1.0.4 in the area) that works. {code} func TestDeliverServiceShutdownAndRespawn(t *testing.T) { 	defer ensureNoGoroutineLeak(t)() 	// Scenario: Launch an ordering service node and let the client pull some blocks. 	// Then, start a new instance and shut down the old instance 	osn1 := mocks.NewOrderer(5614, t)  	time.Sleep(time.Second) 	gossipServiceAdapter := &mocks.MockGossipServiceAdapter{GossipBlockDisseminations: make(chan uint64)}  	service, err := NewDeliverService(&Config{ 		Endpoints:     string{"localhost:5614", "localhost:5615"}, 		Gossip:      gossipServiceAdapter, 		CryptoSvc:   &mockMCS{}, 		ABCFactory:  DefaultABCFactory, 		ConnFactory: DefaultConnectionFactory, 	}) 	assert.NoError(t, err)  	li := &mocks.MockLedgerInfo{Height: uint64(100)} 	osn1.SetNextExpectedSeek(uint64(100)) 	err = service.StartDeliverForChannel("TEST_CHAINID", li, func() {}) 	assert.NoError(t, err, "can't start delivery")  	// Check that delivery service requests blocks in order 	go osn1.SendBlock(uint64(100)) 	assertBlockDissemination(100, gossipServiceAdapter.GossipBlockDisseminations, t) 	go osn1.SendBlock(uint64(101)) 	assertBlockDissemination(101, gossipServiceAdapter.GossipBlockDisseminations, t) 	atomic.StoreUint64(&li.Height, uint64(102))  	// Now start the new instance 	osn2 := mocks.NewOrderer(5615, t) 	// Now stop the old instance 	osn1.Shutdown() 	// Send some a block from osn2 	osn2.SetNextExpectedSeek(uint64(102)) 	go osn2.SendBlock(uint64(102)) 	assertBlockDissemination(102, gossipServiceAdapter.GossipBlockDisseminations, t) 	service.Stop() 	osn2.Shutdown() } {code}  Could it be a docker related issue that stems from the fact that the second instance was started after the peer and docker's name resolution at the peer wasn't "refreshed"?  As Artem said - logs would be good, but also can you perhaps get into the peer and try to ping the host of the second orderer (the one that started late)?   ></body> </Action>
<Action id="39734" issue="27436" author="yacovm" type="comment" body="actually it seems we have a bug. Actually the UT above fails if I put a sleep just as  ~rhegde  implied (to mimic the &quot;no blocks being sent&quot;) . I&apos;ll post here a fix shortly. " created="2018-02-06 17:55:54.0" updateauthor="yacovm" updated="2018-02-06 19:19:51.0"/>
<Action id="39738" issue="27436" author="yacovm" type="comment" body="https://gerrit.hyperledger.org/r/#/c/17599/" created="2018-02-06 19:03:16.0" updateauthor="yacovm" updated="2018-02-06 19:03:16.0"/>
<Action id="39739" issue="27436" author="clayton sims" type="comment" created="2018-02-06 19:11:59.0" updateauthor="clayton sims" updated="2018-02-06 19:11:59.0"> <body><! CDATA  ~bmos299   ~scottz  we should investigate and ensure we cover these in system test     ></body> </Action>
<Action id="39994" issue="27436" author="scottz" type="comment" body=" ~yacovm  I took a quick look at see that you added a test. But I am not an expert and it is not clear if you have indeed written a test for the identified scenario: let the network lay idle for 5 or more minutes without sending any transactions, then restart the orderer to which a peer is connected, then send another transaction and confirm that peer connects to another orderer automatically and receives the block. If you have done this exactly, then I do not feel we need to write a system test (as Clayton suggested). What do you think?" created="2018-02-11 19:16:14.0" updateauthor="scottz" updated="2018-02-11 19:16:14.0"/>
<Action id="39996" issue="27436" author="yacovm" type="comment" created="2018-02-11 20:35:18.0" updateauthor="yacovm" updated="2018-02-11 20:36:10.0"> <body><! CDATA The  test I added|https://gerrit.hyperledger.org/r/#/c/17599/3/core/deliverservice/deliveryclient_test.go  checks the following scenario (as written in the comments): {quote}	// Scenario: Launch an ordering service node and let the client pull some blocks. 	// Then, wait a few seconds, and don't send any blocks. 	// Afterwards - start a new instance and shut down the old instance.{quote}  The "wait a few seconds" part is equivalent to the 5 minutes because I manually and artificially reduced the wait time from 5 minutes to a second. From the code: {code} 	SetReconnectTotalTimeThreshold(time.Second) 	defer func() { 		SetReconnectTotalTimeThreshold(time.Second * 60 * 5) 	}() {code}  The exact scenario is the following: {quote}	// Check that delivery service requests blocks in order from osn1 	// Now wait for a few seconds 	// Now start the new instance (osn2) 	// Now stop the old instance (osn1) 	// Send a block from osn2 	// Ensure it is received{quote} To your question: {quote}then restart the orderer to which a peer is connected, then send another transaction and confirm that peer connects to another orderer automatically {quote} We can't ensure the peer connects to a different node in case the orderer is restarted, because it may select that same one with probability of 50%. That's why I shut down the active and bring up the inactive.  {quote} If you have done this exactly, then I do not feel we need to write a system test (as Clayton suggested). What do you think?{quote}  I guess that depends on your team's priorities. I would prioritize tests for code paths that are not tested in the unit tests over code paths that are.  My suggestion is to first and foremost focus on security related scenarios that deal with channel reconfiguration and client (none)eligibility of data, since these are the code paths that are not tested in the code from an end-to-end perspective.  However, the ideal is to be able to test from an end-to-end perspective the scenario outlined in this item, as it is not a rare scenario (and I can't but think that we must have seen users complaining about this issue before this, but were too inattentive to their plights).   An even more comprehensive testing type that is nice to have, is to have some sort of long-term running system (not a PTE test) that does thinks randomly (sends transactions randomly, crashes nodes randomly, etc.) and see how the system behaves, and does it recover.   ></body> </Action>
