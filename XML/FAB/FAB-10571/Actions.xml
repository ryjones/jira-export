<Action id="45639" issue="30931" author="kchristidis" type="comment" body="/cc  ~manish-sethi ,  ~denyeart " created="2018-06-07 12:36:07.0" updateauthor="kchristidis" updated="2018-06-07 12:36:07.0"/>
<Action id="45650" issue="30931" author="denyeart" type="comment" body="CouchDB was not a production supported database in v1.0 (for example indexes were not supported).  Starting in v1.1 CouchDB is a supported database.  Top level field restrictions are documented at  https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_as_state_database.html  .  Let&apos;s use this defect to clarify that field restrictions include any field starting with underscore." created="2018-06-07 14:17:28.0" updateauthor="denyeart" updated="2018-06-07 14:17:28.0"/>
<Action id="45763" issue="30931" author="chris.elder" type="comment" body="https://gerrit.hyperledger.org/r/#/c/22919/" created="2018-06-10 16:29:12.0" updateauthor="chris.elder" updated="2018-06-10 16:29:12.0"/>
<Action id="45765" issue="30931" author="hamptonsmith" type="comment" created="2018-06-10 20:41:43.0" updateauthor="hamptonsmith" updated="2018-06-10 20:44:02.0"> <body><! CDATA Certainly if one of the production-supported state databases doesn't support top-level underscores, then Fabric itself does not support top-level underscores?  If Org A advertises its fancy Fabric ledger, not using CouchDB, and Org B elects to join, and all their nodes crash because they are using CouchDB (causing a denial-of-service on other, unrelated chains!), that seems like a serious defect.  I shouldn't have to take a closure of all the footnotes in all the individual documentation for datastores to know what sort of data is valid, particularly given that data is strongly immutable.  Put another way, what guarantee do I have that some future new kind of production database won't be introduced that crashes under other, impossible-to-foresee circumstances?  ></body> </Action>
<Action id="45812" issue="30931" author="manish-sethi" type="comment" created="2018-06-11 21:32:26.0" updateauthor="manish-sethi" updated="2018-06-11 21:41:03.0"> <body><! CDATA {quote} Certainly if one of the production-supported state databases doesn't support top-level underscores, then Fabric itself does not support top-level underscores? {quote} No, there is no intentions for fabric to act as a common minimum layer of supported databases. e.g., the top-level underscores can well be used if the underlying db is the leveldb. Similarly, couchdb only supports a valid utf-8 string as a key while it can be any random bytes in the case of leveldb.  {quote} If Org A advertises its fancy Fabric ledger, not using CouchDB, and Org B elects to join, and all their nodes crash because they are using CouchDB (causing a denial-of-service on other, unrelated chains!), that seems like a serious defect.{quote} A corollary of the above statement is that theoretically, a mixed databases are not going to be supported in a single channel. However, in practice, in the current Fabric version, this limitation is even wider and is imposed at the level of a network (Based on demand/need, this restriction can certainly be made less restricted in the future versions at the channel level)  {quote} I shouldn't have to take a closure of all the footnotes in all the individual documentation for datastores to know what sort of data is valid, particularly given that data is strongly immutable.  Put another way, what guarantee do I have that some future new kind of production database won't be introduced that crashes under other, impossible-to-foresee circumstances?{quote} This should be clear from the above that you do not need to look at the footnotes of all the datastores.  Finally, if we extend the choice of datastore at the channel level in the future versions, it would be easy to guess that we would need to specify this at part of the channel configuration. However, I agree that to be able to specify at the channel config level makes sense even with current implementation which could make a peer result into an error much early on - at the time of channel join if the peer tries to join a channel that uses a different datastore from the datastore that the peer's exiting channels use - though not sure whether it is worth the effort when every participant in the network agrees to use a single type (somewhat open discussion...)  ></body> </Action>
<Action id="45844" issue="30931" author="hamptonsmith" type="comment" created="2018-06-12 17:46:23.0" updateauthor="hamptonsmith" updated="2018-06-12 17:48:41.0"> <body><! CDATA You said: {quote}couchdb only supports a valid utf-8 string as a key while it can be any random bytes in the case of leveldb {quote} From the  CouchDB state database docs|https://hyperledger-fabric.readthedocs.io/en/release-1.1/couchdb_as_state_database.html : {quote}Like the LevelDB key-value store, CouchDB can store any binary data that is modeled in chaincode {quote} So the flow-chart seems to be "If the data happens to look like a JSON document..." (no documentation on what that means!) "...we add it to the store as a JSON document, and maybe that causes a crash.  Otherwise, we add it as a binary attachment."  You said: {quote}mixed databases are not going to be supported in a single channel {quote} From the  CouchDB state database docs|https://hyperledger-fabric.readthedocs.io/en/release-1.1/couchdb_as_state_database.html : {quote}You may consider starting with the default embedded LevelDB, and move to CouchDB if you require the additional complex rich queries. It is a good practice to model chaincode asset data as JSON, so that you have the option to perform complex rich queries if needed in the future. {quote} So the strong suggestion is that I might want to change the database that backs a channel some day, which I can only do peer-at-a-time.  Both of which you're telling me are not the intended architecture.  That said, the architecture you describe is sensible.  But I definitely think it is worth the effort to improve the robustness here so that the actual architecture matches the intended architecture (particularly given that the documentation is not reliable).  Here is an incomplete list of things I would expect my production-ready enterprise-grade software to do in this situation from most-proximal to the failure to least.  If you'll help me suss out which of these is reasonable, I can open separate feature requests for them.  Obviously, some of these are large efforts, but it costs little to just make a note of them in the milestones.  1) documentation for  state databases generally|http://hyperledger-fabric.readthedocs.io/en/release-1.1/ledger.html  needs to say, unambiguously, "The chosen state database is an immutable property of the channel and if multiple peers participating on a channel have different state databases, undefined behavior may occur."  This would preferably be reiterated in the  CouchDB state database docs|https://hyperledger-fabric.readthedocs.io/en/release-1.1/couchdb_as_state_database.html .  2) when the state database crashes, the peer notes the error in its logs but does not crash.  It continues to service the channel in some kind of degraded mode, possibly rejecting queries.  (If this peer is going to crash, it stands to reason all peers are about to, which is bad!)  3) when bad data is thrown at the state database, a validator detects the issue and returns a friendly error rather than crash.  This error is returned to the client submitting the transaction and the transaction is not added to the ledger (if all peers behave this way, then the network avoids getting into a bad state at the last possible moment and productive work can continue!)  4) the required data schema (preferably separate from the specific backing database so that different orgs can use different databases/versions of databases that support the schema) is bound to the channel and peers will refuse to join channels that require schemas they do not support  5) simulating peers test their proposed change sets against the channel's data validator and reject simulations if they result in invalid data (this accurately refuses to endorse transactions that cannot possibly be valid, and if "most" (by the channel's endorsement policy) peers behave this way, we prevent the breaking change-sets from being endorsed at the first possible moment.)  6) peers can have multiple state databases so they can support multiple channels with different requirements  7) when it is trivially easy to do so (by, say, wrapping data in an object), state databases do not restrict otherwise-valid Fabric data  Of these, (1), (2), (3), (4) seem critical for the following reasons:  (1) because docs should match reality  (2) seems like a security issue.  Currently if I'm a misbehaving actor at an otherwise-valid participating org, I can exploit bugs in Fabric, CouchDB, or the underlying platform to DOS an entire network–with data that is irrevocable by design!  (3) prevents a bug in chaincode from irrevocably corrupting the ledger in an otherwise-detectable way.  (4) makes the actual architecture match the intended architecture, particularly important since A) there is the possibility that by "messing this up" (i.e., doing what the docs told you to do!) you end up with irrevocable bad data, and B) this is happening against a backdrop of a heterogeneous, federated network  ></body> </Action>
