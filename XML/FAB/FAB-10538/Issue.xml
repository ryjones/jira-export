<Issue id="30877" key="FAB-10538" number="10538" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10003" summary="Fix scatter requestion of private data" priority="3" resolution="10000" status="6" created="2018-06-04 22:22:01.0" updated="2018-07-20 14:16:54.0" resolutiondate="2018-06-05 14:33:28.0" votes="0" watches="1" workflowId="42406"> <description><! CDATA While scattering digest to pull missing private data, we using following code:  {code} func (p *puller) scatterRequests(members   discovery.NetworkMember, peersDigestMapping peer2Digests)   util.Subscription { 	var subscriptions   util.Subscription 	for peer, digests := range peersDigestMapping { 		msg := &proto.GossipMessage{ 			Tag:     proto.GossipMessage_CHAN_ONLY, 			Channel:   byte(p.channel), 			Nonce:   util.RandomUInt64(), 			Content: &proto.GossipMessage_PrivateReq{ 				PrivateReq: &proto.RemotePvtDataRequest{ 					Digests: digestsAsPointerSlice(digests), 				}, 			}, 		}  		// Subscribe to all digests prior to sending them 		for _, dig := range msg.GetPrivateReq().Digests { 			hash, err := dig.Hash() 			if err != nil { 				// Shouldn't happen as we just built this message ourselves 				logger.Warning("Failed creating digest", err) 				continue 			} 			sub := p.pubSub.Subscribe(hash, responseWaitTime) 			subscriptions = append(subscriptions, sub) 		} 		logger.Debug("Sending", peer.endpoint, "request", msg.GetPrivateReq().Digests) 		p.Send(msg, peer.AsRemotePeer()) 	} 	return subscriptions } {code}  where  {code} Digests: digestsAsPointerSlice(digests) {code}  used to flatten {{digest}} into  slice of {{  *proto.PvtDataDigest}} in the following way:  {code} func digestsAsPointerSlice(digests   proto.PvtDataDigest)   *proto.PvtDataDigest { 	res := make(  *proto.PvtDataDigest, len(digests)) 	for i, dig := range digests { 		res i  = &dig 	} 	return res } {code}  where since we storing an address of {{dig}} in resulted slice, i.e. {{res i  = &dig}} in case lenght of digests would be more than one, for instance block has more than one transaction with same collection, the resulted slice eventually will include repetitions of the last digest within {{for-range}} iteration.  As a consequence this would lead to the peer asking same digest multiple times as well, will omit other digest, thus leading to inefficient retrieval.   ></description> </Issue>
