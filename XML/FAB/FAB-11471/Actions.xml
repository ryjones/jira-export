<Action id="49039" issue="32548" author="mastersingh24" type="comment" created="2018-08-17 18:41:45.0" updateauthor="mastersingh24" updated="2018-08-17 18:41:45.0"> <body><! CDATA I'm not sure that there's a great solution to this.  We can limit the total number of streams, but there's no built-in functionality in grpc-go to actually have a per client limit (which I think is what we are after).   ~jyellick  - thoughts?  ></body> </Action>
<Action id="49062" issue="32548" author="yacovm" type="comment" created="2018-08-18 16:58:29.0" updateauthor="yacovm" updated="2018-08-18 16:59:20.0"> <body><! CDATA shouldn't we just prevent clients from opening 2 or more deliver streams at the same time?  Meaning - detect the identity of the client, and record it and delete it upon stream disconnect.     IMO interceptors might be a double-edges sword because if we set the number of concurrent streams too low, a single client can open that many streams and prevent all other clients to pull events, and also - if you suddenly have more clients but you set the config value to be too low - you need to restart the node...  ></body> </Action>
<Action id="49065" issue="32548" author="mastersingh24" type="comment" created="2018-08-19 12:09:09.0" updateauthor="mastersingh24" updated="2018-08-19 12:57:17.0"> <body><! CDATA  ~yacovm  We can use interceptors to track per client limits.  Of course we need to define the properties which make a client unique.  We can also look at other ways and remove the dependency on interceptors in we desire.  ></body> </Action>
<Action id="49069" issue="32548" author="yacovm" type="comment" created="2018-08-19 13:11:53.0" updateauthor="yacovm" updated="2018-08-19 13:12:29.0"> <body><! CDATA How do you associate a stream to a client? * You can't use the source IP because it would mean people can't connect behind NAT * You can't use source IP || port, because some clients might open more than 1 connection and then you don't block them.  Perhaps we can just do it in the application layer via keeping track of the certificates of the clients that are connected? This is not as simple as it looks though, because the client might be disconnected while the gRPC dispatching goroutine is stuck on waiting for the block iterator, and then it might prevent the client from re-connecting, but I'm sure we can work something out  ></body> </Action>
<Action id="49095" issue="32548" author="jyellick" type="comment" created="2018-08-20 13:33:19.0" updateauthor="jyellick" updated="2018-08-20 13:33:19.0"> <body><! CDATA > because the client might be disconnected while the gRPC dispatching goroutine is stuck on waiting for the block iterator  Hopefully this is largely fixed.  We now check for client cancellation while waiting for new blocks.  > I'm not sure that there's a great solution to this.  We can limit the total number of streams, but there's no built-in functionality in grpc-go to actually have a per client limit (which I think is what we are after).  Really, I suspect we want both.  Per client, and total.  Per client so that a single client cannot eat up the total DoS others, but also total to avoid a DDoS style attack which crashes the peer.  The 'per client' though is the most important to prevent poorly written applications from causing problems for the peer.   ~sykesm  I believe you said that CF had implemented a suite of connection limiting stuff, do you have any thoughts?  ></body> </Action>
<Action id="49097" issue="32548" author="yacovm" type="comment" created="2018-08-20 13:54:35.0" updateauthor="yacovm" updated="2018-08-20 13:55:22.0"> <body><! CDATA {quote}Hopefully this is largely fixed. We now check for client cancellation while waiting for new blocks. {quote} What I meant to say is - it may be that the client cancellation never comes. I might be wrong, but consider the following scenario:  The client is connected to the peer and between them there is a router that is shut down.  The select in the deliver waits on the gRPC context.Done() or on the erroredChan of the chain, or on the block iterator.  Will the gRPC context fire the Done() because of the router shut down? I tend to think not, even in spite of keepalives (I might be wrong though... )    {quote}Really, I suspect we want both. Per client, and total. Per client so that a single client cannot eat up the total DoS others {quote} At least to my knowledge - usually you use kind of firewall module or some proxy to do that,  though I guess if we really want to limit TCP connections we can just implement our own *net.Listener* to do the work, but - then we don't know if the connection comes from NAT or not.     ></body> </Action>
<Action id="67397" issue="32548" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:32:25.0" updateauthor="sykesm" updated="2020-01-22 22:32:25.0"/>
