<Action id="43191" issue="28951" author="manish-sethi" type="comment" created="2018-04-20 02:45:19.0" updateauthor="manish-sethi" updated="2018-04-20 02:45:19.0"> <body><! CDATA Based on our last discussion, we need to allow rolling upgrade from 1.1 experimental feature to 1.2. This means that we cannot simply introduce a new type of proto for storing this additional information. This means that we have following choicde... * Either, introduce a capability tag * Or simply extend the existing proto message `{color:#000000}TxPvtReadWriteSet{color}` for encapsulating the additional details.  The first option has complications. For instance, even after turning the capability 'ON', there may be left over data in the transient store pertaining to the in-flight transactions. This demands that either we always support both types of protos even after turning the capability 'ON'  (which is ugly) or include the capability information in the transaction simulation results and invalidate the transaction during commit if the capability is found to be enabled during commit.  Keeping above in mind, the second option seems more appealing. Thoughts?  ></body> </Action>
<Action id="43208" issue="28951" author="yacovm" type="comment" created="2018-04-20 13:16:38.0" updateauthor="yacovm" updated="2018-04-20 13:16:38.0"> <body><! CDATA {quote} This means that we cannot simply introduce a new type of proto for storing this additional information {quote} why? can't we store it separately? We can have gossip send both these TxPvtReadWriteSets and also that metadata alongside it but not inside it.  {quote} Either, introduce a capability tag {quote} Aren't capabilities for validation ? We're not doing here any validation... only data dissemination.   I think we first need to answer a more basic question - how do we treat the data in the transient store, that doesn't have this corresponding mapping? I don't think we *have* to have this data as part of the endorsement. Why can't the peer simply compute it on his own, and attach it to the gossip messages which it already anyway sends point to point? Then we can say that if the peer is missing the corresponding metadata in the transient store - just grab the last configuration and act upon it. This would force customers that have v1.1 and want to upgrade to v1.2 - just not make any config changes until all their peers purge the transient store via replicating the data and committing it.   ></body> </Action>
<Action id="43216" issue="28951" author="manish-sethi" type="comment" created="2018-04-20 14:47:02.0" updateauthor="manish-sethi" updated="2018-04-20 14:47:02.0"> <body><! CDATA "why? can't we store it separately? We can have gossip send both these TxPvtReadWriteSets and also that metadata alongside it but not inside it."  Store separately would means altogether different entries for the metadata which is not good when you always need them together. Why you say that gossip cannot send it inside it?     "Aren't capabilities for validation ? We're not doing here any validation... only data dissemination"  This statement was in the context if we were to chose a new proto message. In that case, the message from a 1.2 peer will not be interpreted by a receiving peer running 1.1. And hence capability could have been a choice for 1.2 peer to decide whether to send the old message or new message. But anyways, as I said this looks 'ugly' to me.  On the more basic question - The data which won't have corresponding height will have to continue to depict 1.1 behavior (which you also mentioned when you say - just grab the latest config)...  "I don't think we *have* to have this data as part of the endorsement. Why can't the peer simply compute it on his own, and attach it to the gossip messages which it already anyway sends point to point?"  I did not mention that this data is to 'part of the endorsement'. This JIRA is about scoping out the changes to the transient store for accommodating this additional metedata. The suggestion for using existing proto `TxPvtReadWriteSets` was from the prospective of persisting in the transient store (as gives us backward compatibility). How gossip obtains this metadata and sends across is entirely orthogonal. In fact - the first set of APIs we briefly discussed on Monday are intended for helping gossip to retrieve this metadata     ></body> </Action>
<Action id="43225" issue="28951" author="yacovm" type="comment" created="2018-04-20 15:32:03.0" updateauthor="yacovm" updated="2018-04-20 15:32:03.0"> <body><! CDATA {quote}Store separately would means altogether different entries for the metadata which is not good when you always need them together. Why you say that gossip cannot send it inside it?{quote} I just think it's odd to mix access control metadata and the data itself in the same message. Of course, we can put it together if you think it's important.  {quote}This statement was in the context if we were to chose a new proto message. In that case, *the message from a 1.2 peer will not be interpreted by a receiving peer running 1.1*. And hence capability could have been a choice for 1.2 peer to decide *whether to send the old message or new message.* But anyways, as I said this looks 'ugly' to me.{quote} I'm not following. Gossip doesn't need new messages... we can even use the pull messages for state reconciliation (I think).  A v1.2 peer would use access control that befits v1.2 regardless of the other peer.     ></body> </Action>
<Action id="43228" issue="28951" author="manish-sethi" type="comment" created="2018-04-20 16:01:29.0" updateauthor="manish-sethi" updated="2018-04-20 16:01:29.0"> <body><! CDATA On the latter part of you comment where you say - "I am not following...."  The transient store API  `{color:#000000}Persist(txid {color}{color:#0000ff}string{color}{color:#000000}, blockHeight {color}{color:#0000ff}uint64{color}{color:#000000}, privateSimulationResults {color}{color:#000000}*{color}{color:#000000}rwset.TxPvtReadWriteSet) {color}{color:#0000ff}error{color}` in 1.1 peer will always always expect a message type `{color:#000000}*{color}{color:#000000}rwset.TxPvtReadWriteSet{color}`. If we were to change this API in 1.2 to ``{color:#000000}Persist(txid {color}{color:#0000ff}string{color}{color:#000000}, blockHeight {color}{color:#0000ff}uint64{color}{color:#000000}, privateSimulationResults {color}{color:#000000}*{color}{color:#000000}NewProtoType){color}` - will gossip be able to work with two different APIs exposed by the transient store in different versions?  ></body> </Action>
<Action id="43230" issue="28951" author="yacovm" type="comment" body="oh, now i see.... well we&apos;ll have to be able to convert from one format to the other. " created="2018-04-20 16:11:43.0" updateauthor="yacovm" updated="2018-04-20 16:11:43.0"/>
<Action id="43234" issue="28951" author="manish-sethi" type="comment" created="2018-04-20 16:34:25.0" updateauthor="manish-sethi" updated="2018-04-20 16:34:56.0"> <body><! CDATA Yes, and further in 1.2 peer, this would also require you to check whether you can start using new message type. Otherwise, 1.1 peer would crash because the 1.1 will not have the conversion code (which indirectly demands using the V1.2 capability check).  To avoid all these, I thought of simply introducing additional fields in the existing proto `{color:#000000}*{color}{color:#000000}rwset.TxPvtReadWriteSet` for the `H` height and keep the API same. Does this work for you?{color}  ></body> </Action>
<Action id="43235" issue="28951" author="yacovm" type="comment" created="2018-04-20 16:49:27.0" updateauthor="yacovm" updated="2018-04-20 16:54:45.0"> <body><! CDATA I'm not sure.  What I'd like is that gossip would be ignorant of whether a peer is allowed some private data or not based on the metadata of that data, and that code would reside in a different module, so that the existing gossip code won't have to change.  By the way - doesn't that mean you'd also have to change *rwsetutil.TxRwSet* ?  If we couple the TxPvtReadWriteSet it means we'll need to change *all our code* to adjust, and it'll also mean the access control will no longer be relevant because the access control source would move to another place.     So, at least I - need to think about it some more.   ~C0rWin  wdyt?  ></body> </Action>
<Action id="43236" issue="28951" author="manish-sethi" type="comment" created="2018-04-20 17:05:23.0" updateauthor="manish-sethi" updated="2018-04-20 17:11:15.0"> <body><! CDATA I am not sure I understand your last comment. I am not saying that we would change *rwsetutil.TxRwSet* or you would have to change your access control code.  What I am suggesting is that, *rwsetutil.TxRwSet will still produce the `{color:#000000}wset.TxPvtReadWriteSet{color}` as it does today (i.e., the newly added field say `H` will be empty). Gossip uses this field as a placeholder to fill the `H`. And similarly, to your access control code, you can always pass just `H` after pulling it from {color:#000000}wset.TxPvtReadWriteSet{color} (ultimately, you need to pull this `H` from transient store... even if we have a new proto message).  Finally, as this API `{color:#000000}Persist(txid {color}{color:#0000ff}string{color}{color:#000000}, blockHeight {color}{color:#0000ff}uint64{color}{color:#000000}, privateSimulationResults {color}{color:#000000}*{color}{color:#000000}rwset.TxPvtReadWriteSet){color}` and corresponding retrieval API affects gossip code more so, I'll leave the final choice to you and  ~C0rWin . Whether you prefer * A new proto message and hence manage two versions of the APIs across 1.1 and 1.2 * Or extend {color:#000000}rwset.TxPvtReadWriteSet{color} with an additional field that gossip can use for carying additional data meant only for 1.2 and automatically gets ignored by 1.1  ></body> </Action>
