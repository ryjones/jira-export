<Issue id="30763" key="FAB-10479" number="10479" project="10002" reporter="mgk" assignee="xxs" creator="mgk" type="10004" summary="&quot;Blind Writes&quot; not mentioned in the docs / faqs" priority="3" resolution="10001" status="6" created="2018-05-31 10:04:08.0" updated="2020-01-22 22:34:12.0" resolutiondate="2020-01-22 22:34:12.0" votes="0" watches="2" workflowId="35832"> <description><! CDATA When writing chaincode if I call PutState() to create a new key without having first called GetState() for that same key I'm open to the possibility of a race condition going undetected between two different clients, each issuing a different transaction but both thinking the key does not exist and so both calling a create() chaincode function with different values.   As an example, a common pattern seems to have chaincode that looks like this: {{queryThing("x") \{}} {{  //return thing "x" if it exists}} {{}}}  {{createThing("x") \{}} {{  //call PutState("x") to create thing "x" but do not not call GetState("x") first}} {{}}}  {{updateThing("x") \{}} {{  //call GetState("x") followed by PutState("x") - all good here}} {{}}}    This seems like a common enough pattern and it's open to the problem above especially if the client has a UI that calls queryThing() first, then based on existence call createThing() or updateThing(). Ideally they could have a single "createOrUpdateThing()" method but people seem to like the above so are open to the race condition...   Really this potential problem should be documented so people can avoid this problem which would be hard to debug. Best practice should be to suggest people always have a matching "GetState("x")" for each "PutState("x")" which will prevent the problem from occurring.  ></description> </Issue>
