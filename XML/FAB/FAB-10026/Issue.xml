<Issue id="30154" key="FAB-10026" number="10026" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10003" summary="While TransientStore need to filter out collections config based on filter provided" priority="3" resolution="10000" status="6" created="2018-05-13 11:21:03.0" updated="2018-07-20 14:16:37.0" resolutiondate="2018-05-16 02:07:26.0" votes="0" watches="2" workflowId="42148"> <description><! CDATA There is a new API was added to TransientStore to support retrieval of private collection endorsement along with the collections config available during endorsement.   {code} // PersistWithConfig stores the private write set of a transaction along with the collection config / in the transient store based on txid and the block height the private data was received at PersistWithConfig(txid string, blockHeight uint64, privateSimulationResultsWithConfig *transientstore.TxPvtReadWriteSetWithConfigInfo) error {code}  where {{RWSetScanner}} API was extended with   {code} NextWithConfig() (*EndorserPvtSimulationResultsWithConfig, error) {code}  function, that takes care to filter our irrelevant collections based on filter provided to  {{Store#GetTxPvtRWSetByTxid}} function, i.e.:  {code} GetTxPvtRWSetByTxid(txid string, filter ledger.PvtNsCollFilter) (RWSetScanner, error) {code}  the implementation works as following:  {code} func (scanner *RwsetScanner) NextWithConfig() (*EndorserPvtSimulationResultsWithConfig, error) { 	if !scanner.dbItr.Next() { 		return nil, nil 	} 	dbKey := scanner.dbItr.Key() 	dbVal := scanner.dbItr.Value() 	_, blockHeight := splitCompositeKeyOfPvtRWSet(dbKey)  	txPvtRWSet := &rwset.TxPvtReadWriteSet{} 	filteredTxPvtRWSet := &rwset.TxPvtReadWriteSet{} 	txPvtRWSetWithConfig := &transientstore.TxPvtReadWriteSetWithConfigInfo{}  	if dbVal 0  == nilByte { 		// new proto, i.e., TxPvtReadWriteSetWithConfigInfo 		if err := proto.Unmarshal(dbVal 1: , txPvtRWSetWithConfig); err != nil { 			return nil, err 		} 		filteredTxPvtRWSet = trimPvtWSet(txPvtRWSetWithConfig.GetPvtRwset(), scanner.filter) 	} else { 		// old proto, i.e., TxPvtReadWriteSet 		if err := proto.Unmarshal(dbVal, txPvtRWSet); err != nil { 			return nil, err 		} 		filteredTxPvtRWSet = trimPvtWSet(txPvtRWSet, scanner.filter) 	}  	txPvtRWSetWithConfig.PvtRwset = filteredTxPvtRWSet  	return &EndorserPvtSimulationResultsWithConfig{ 		ReceivedAtBlockHeight:          blockHeight, 		PvtSimulationResultsWithConfig: txPvtRWSetWithConfig, 	}, nil } {code}  taking care to trim not related collections  {code} filteredTxPvtRWSet = trimPvtWSet(txPvtRWSet, scanner.filter) {code}  However since collection config is now also propagated and returned we need to take care and filter out collection config based on filter provided to {{GetTxPvtRWSetByTxid}} API  ></description> </Issue>
