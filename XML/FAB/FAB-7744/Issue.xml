<Issue id="26821" key="FAB-7744" number="7744" project="10002" reporter="yoheiueda" creator="yoheiueda" type="10001" summary="Alleviating the lock contention for chaincode GRPC stream" priority="3" resolution="10001" status="6" created="2018-01-16 05:29:17.0" updated="2020-01-22 22:23:06.0" resolutiondate="2020-01-22 22:23:06.0" votes="0" watches="8" workflowId="35489"> <description><! CDATA I analyzed goroutine proifles of Fabric peer, and found that the lock that guards the GRPC stream for the communication between peer and chaincode causes heavy lock contention.   https://github.com/hyperledger/fabric/blob/v1.1.0-preview/core/chaincode/handler.go#L139   I think removing this lock contention is important to improve the overall performance. I implemented a proof-of-concept code, and obtained 10% throughput improvement in my workload, and I think performance gain will become larger when the other bottlenecks in Fabric are fixed.  I come up with three ideas to alleviate this lock contention.    ---- *Solution 1: Lock Sharding*  One straightforward solution is to use lock sharding.  Lock sharding is a technique that split a single lock into multiple locks.  A similar technique is used in Java’s ConcurrentHashMap.  To use multiple locks, we need to establish a fixed number of multiple GRPC streams between peer and chaincode in advance, and manage relationship between each transaction and a used GRPC stream.  *Solution 2: Opposite TLS connection*  Currently, the TLS connection for GRPC is established from chaincode to peer.  In this case, chaincode is GRPC server and chaincode is GRPC client.  If this connection direction can be reversed, we can initiate a new GRPC stream per transaction.  With this change, we don’t need to guard each GRPC stream by a giant lock.    Initiating a GRPC connection from peer will need a lot of code changes in Fabric, but will simply the code of managing transactions. For example, currently we need to manage mapping of transaction contexts in order to correctly handle responses from chaincode, but if we use this solution, each transaction uses a dedicated stream for chaincode communication, so we don’t need to manage such relationship.  *Solution 3:  Reversal GRPC connection*  We can create a new GRPC connection using an existing TLS connection. This means that we can establish a TLS connection from chaincode to peer, and then create a new GRPC connection from peer to chaincode using the established TLS connection.  Using this technique, we can obtain all benefit of Solution 2 without changing the direction of TLS connection. ---- I implemented a toy benchmark program that compares these 3 solutions as well as original approach.   https://github.com/yoheiueda/grpc-test   The result shows these three techniques show about 30% better performance than the original one.  I think Solution 3 (reversal GRPC connection) is best one among three, so I am currently working of a proof-of-concept implementation of solution 3, and obtained 10% TPS improvement. I will post the PoC code later as a comment when I finish cleaning my code.     ></description> </Issue>
