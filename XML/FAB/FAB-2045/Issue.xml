<Issue id="14548" key="FAB-2045" number="2045" project="10002" reporter="sstone1" assignee="binhn" creator="sstone1" type="10004" summary="Document that Chaincode cannot read back written values in same transaction" priority="2" resolution="10000" status="6" created="2017-02-04 20:58:02.0" updated="2018-07-20 14:11:29.0" resolutiondate="2017-06-05 17:52:55.0" votes="0" watches="6" workflowId="37299"> <description><! CDATA I am trying to port some chaincode from v0.6 to v1.0. I am running my v1.0 tests against the recent Docker images from the Hyperledger Hackfest. This chaincode makes calls to read data that it has written in the same transaction, but the data always seems to be read as nil: {code:java} err = stub.PutState("test", "hello world") ... value, err = stub.GetState("test") // value == nil, should be "hello world" {code} This does not match up with the design here, nor the previous behaviour in v0.6:  https://github.com/hyperledger/fabric/blob/master/core/ledger/ReadWriteSet.md   In particular: _Also, if a transaction reads a value for a key that the transaction itself has written before, the last written value is returned instead of the value present in the committed snapshot; one implication of this is that if a transaction writes a value for a key before reading it from the committed snapshot, the key does not appear in the read set of the transaction._  Looking at the code it seems that lockBasedTxSimulator.GetState() does not look at the RWSet to see if a new value has been written in the current transaction.  I had a stab at an initial fix which seemed to fix the problem: {code:java} // GetState implements method in interface `ledger.TxSimulator` func (s *lockBasedTxSimulator) GetState(ns string, key string) (  byte, error) { // uncomment following lines for fix 	// value, ok := s.rwset.GetFromWriteSet(ns, key) 	// if ok { //      // use latest value from rwset rather than committed value from db 	// 	return value, nil 	// } 	return s.helper.getState(ns, key) } {code} However it looks like a more complicated fix will be needed for lockBasedQueryExecutor for handling range queries?  In ReviewÂ https://gerrit.hyperledger.org/r/#/c/10023/  ></description> </Issue>
