<Issue id="33344" key="FAB-11798" number="11798" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10003" summary="Wire consenter into multichannel registrar" priority="3" resolution="10000" status="6" created="2018-08-30 07:52:28.0" updated="2018-10-15 22:54:55.0" resolutiondate="2018-10-15 22:52:56.0" votes="0" watches="2" workflowId="46098"> <description><! CDATA Once the etcd/raft consenter is finished (FAB-11163), we'll need to add it into the registrar  consenters mapping|https://github.com/hyperledger/fabric/blob/release-1.2/orderer/common/server/main.go#L256-L260  that maps the type of consensus to the instance of the consenter.  A challenge in doing this, is that the communication layer of the etcdraft that handles intra-cluster messaging needs to route messages to instances of chains, which are only reachable from within the registrar. In order to do this, we'd need the consenter to have a reference of the registrar, while the registrar itself is created with being given the reference to the map of consenter types mapping.  If we create the registrar with an empty map, it won't work because the registrar's initialization logic scans the map at creation time.  A way around this, is to extract the registrar's initialization logic into an exported method, and then to: # Create the consenter type mapping without populating it # Create the registrar with the empty mapping # Create the etcdraft consenter with the reference to the registrar # Initialize the registrar with the newly exported method which extracts the initialization logic.  How do we wire the etcraft consenter into the registrar? * The registrar, or a wrapper around it, is going to need to implement  ReceiverGetter|https://github.com/hyperledger/fabric/blob/master/orderer/consensus/etcdraft/dispatcher.go#L32-L35  in order for the Dispatcher to route messages from the  communication layer|https://github.com/hyperledger/fabric/blob/master/orderer/common/cluster/comm.go#L39-L40  to the chain instances inside the registrar.  This is problematic in a way, because the Chain objects in the registrar shouldn't be aware of being of being of any specific consensus type. A way around it, I think - is to have the Dispatcher to be initialized with an instance of an interface that is a subset of the Registrar: {code:java} type ChainGetter interface { GetChain(chainID string) (*ChainSupport, bool) } {code} instead of with ReceiverGetter, and simply work with ChainGetter and do an explicit cast to the instance of the etcdraft.Chain from the consensus.Chain instance, knowing that the chains returned by the etcdraft consenter would be of the etcdraft.Chain instance.   ~kchristidis   ~sykesm   ~jyellick  wdyt?  ></description> </Issue>
