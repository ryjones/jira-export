<Action id="38360" issue="18804" author="troyronda" type="comment" created="2018-01-10 01:41:55.0" updateauthor="troyronda" updated="2018-01-10 02:06:18.0"> <body><! CDATA  ~denyeart  The ability to update collection configuration is very important, since organizations can come and go and purge policies need updates over time.  I'd label the priority of this item very high in the context of the SideDB feature.  ></body> </Action>
<Action id="39314" issue="18804" author="troyronda" type="comment" created="2018-01-29 17:56:50.0" updateauthor="troyronda" updated="2018-01-30 13:12:30.0"> <body><! CDATA Capabilities for organizations to join and leave are needed along with considerations for existing data access. * Support for implementing _new policies on an existing collection_. Over time, organizations can join and leave. In particular: ** New organizations will need to transact against existing collections. ** In some private data collections, new organizations will need to transact/access against data covered by one or more previous policies. In some other private data collections, new organizations do not access existing data and wouldn’t be granted access to data covered under previous policies. ** Removed organizations should not receive new data. ** Need the ability to implement new collection policy for other parameters – particularly evolving purge policies (FAB-5092). * Ability for _a joining organization to retrieve a copy of existing collection data_. In cases where an organization is granted access to data covered by one or more policies, they should have the ability to replicate the existing data to their peers from other (willing) organization(s)’ peers, as a capability of Fabric. Related: FAB-5093  ></body> </Action>
<Action id="41700" issue="18804" author="manish-sethi" type="comment" body="Initial design doc - https://docs.google.com/document/d/1ORt3HFE13gnq204lXNp6i1BpMLMm-RAKVts8cH50kK4/edit?usp=sharing" created="2018-03-15 20:30:27.0" updateauthor="manish-sethi" updated="2018-03-15 20:30:27.0"/>
<Action id="45214" issue="18804" author="jufeng.yao" type="comment" created="2018-05-29 05:41:23.0" updateauthor="jufeng.yao" updated="2018-05-30 00:46:16.0"> <body><! CDATA one question for peer's knowledge of private data (or collection) : from design doc, there are 2 assumptions  1, Private data is accessible to {color:red}all peers on the channel{color} (assumption for core solution in Section 2, assumption is revised in Section 3 to allow partitioning of private data). 2, When storage partitions are defined, private data is not persistently known to all peers on the channel, but rather a subset of peers. The private data is, {color:red}however, temporarily known across the channel (revised from Section 1, assumption 2){color}.  what I'm not sure is that : does these mean that {color:red}Unauthorized peers{color} can also persistently (from #1) or temporarily (from #2) access the private data?   for example, 3 orgs : org0 (org0-peer0 & org0-peer1), org1 (org1-peer0 & org1-peer1), org2 (org2-peer0 & org2-peer1), while peers from org2 aren't allowed to access private data.   for #1, peers from org2 can still get private data for txes by gossip in endorsement? (since design doc says : ESCC will make sure at least K other peers for redundancy, The K other peers will also store the private read write set in their temp DB and continue gossipping to {color:red}make the data available across the peers in the network. {color}) for #2, peers from org2 can temporarily get keys & values for range query validation? (since range query must apply against to private data)  if I'm correct, seems private data can't completely keep secret from unauthorized peers, right?  thanks    ></body> </Action>
<Action id="45287" issue="18804" author="manish-sethi" type="comment" created="2018-05-30 14:01:46.0" updateauthor="manish-sethi" updated="2018-05-30 14:01:46.0"> <body><! CDATA  ~jufeng.yao  - No, only authorized Orgs get the private data. In your example above org2 won;t get the private data.  In your scenario #1, K other peers are subset of the authorized members and  hence the K should be less than the size of the member-set for a collection. Similarly, in your scenario #2, a range query on the private data on org2 is meaningless and client should not send the query to org2 in this example.  ></body> </Action>
<Action id="45318" issue="18804" author="jufeng.yao" type="comment" created="2018-05-31 01:31:01.0" updateauthor="jufeng.yao" updated="2018-05-31 01:31:01.0"> <body><! CDATA  ~manish-sethi , thanks very much for explains.   {color:red}client should not send the query to org2 in this example{color} do you mean hashed RW set returned doesn't contain range query read set at all ?  since it is meaningless for unauthorized org2, and range query read set already saved in temp db, right?  thanks very much  ></body> </Action>
<Action id="45321" issue="18804" author="manish-sethi" type="comment" created="2018-05-31 02:39:39.0" updateauthor="manish-sethi" updated="2018-05-31 02:44:31.0"> <body><! CDATA  ~jufeng.yao  yes.  In addition, before returning any query results on a private data for a single key, the peer performs a check whether it has the pvt data corresponding to the hashes present in the public space. In your example, the org2 does not have any pvt data, hence any point query on org2 will result in an error.  ></body> </Action>
<Action id="45325" issue="18804" author="jufeng.yao" type="comment" created="2018-05-31 06:52:49.0" updateauthor="jufeng.yao" updated="2018-05-31 06:58:01.0"> <body><! CDATA  ~manish-sethi , thanks very much.  after I checked your answers several times, seems we are talking about different things of range query ^^. what I asked is this: client send proposal to endorsers (org1.peer1, org2.peer0) which will access private data, we pick response from org1.peer1 as an example, suppose it will include hashed RW set, focus on hashed read set, it will include hashed keys & values, but {color:red}do not include range query result{color} (right?), then client will commit tx which include hashed RW set, first to orderer, and finally to peers, include {color:red}unauthorized peers{color} (org2.peer0, org2.peer1), we pick org2.peer1 as our target, when block validation, single hashed key & value in hashed read set can be checked against to normal db, since they should already exist, while range query of private data is not included in hashed RW set, so unauthorized peers needn't verify them.   Please check and point out any mistakes if I'm not correct, thanks very much.  ></body> </Action>
<Action id="45327" issue="18804" author="manish-sethi" type="comment" created="2018-05-31 07:04:35.0" updateauthor="manish-sethi" updated="2018-05-31 07:04:35.0"> <body><! CDATA  ~jufeng.yao  I see your doubt now. Range queries are in fact, not supported in the update transactions on pvt data for this specific reason. Because, all the peers need to decide whether the transaction is valid or not just based on the hashed read-write set.  Range queries can be used only in a read-only transactions. If you mix writes and a range query on pvt data in a transaction, you will receive an error during simulation.  ></body> </Action>
<Action id="45333" issue="18804" author="jufeng.yao" type="comment" body=" ~manish-sethi  thanks very much ! that is what exactly I want !" created="2018-05-31 09:11:56.0" updateauthor="jufeng.yao" updated="2018-05-31 09:11:56.0"/>
<Action id="48661" issue="18804" author="troyronda" type="comment" created="2018-08-09 18:41:31.0" updateauthor="troyronda" updated="2018-08-09 18:41:31.0"> <body><! CDATA There are some remaining TODO comments related to FAB-5096 in https://github.com/hyperledger/fabric/blob/master/core/transientstore/store.go e.g., https://github.com/hyperledger/fabric/blob/release-1.2/core/transientstore/store.go#L49  ></body> </Action>
<Action id="48663" issue="18804" author="senthil1" type="comment" body="Thanks  ~troyronda  for pointing this out. Will push a CR." created="2018-08-09 19:05:37.0" updateauthor="senthil1" updated="2018-08-09 19:05:37.0"/>
<Action id="54473" issue="18804" author="scottallan" type="comment" created="2018-12-07 02:50:45.0" updateauthor="scottallan" updated="2018-12-07 02:50:45.0"> <body><! CDATA When is the plan to deal with the second aspect:     *2) Collection BTL (Block-to-live) change*  ></body> </Action>
