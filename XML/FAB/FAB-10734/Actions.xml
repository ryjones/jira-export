<Action id="47622" issue="31201" author="yacovm" type="comment" created="2018-07-22 19:45:28.0" updateauthor="yacovm" updated="2018-07-22 19:45:28.0"> <body><! CDATA {quote}The error should be logged to standard out {quote}    Any reason not to stderr? Ideally I'd say both the verbose and the errors would be logged to stderr, and output to stdout, so one could easily distinguish and also at the same time we should really get rid of all that logging we have in the peer CLI that makes output redirection to pipes not usable ;)     ></body> </Action>
<Action id="47660" issue="31201" author="christopherferris" type="comment" created="2018-07-23 15:46:05.0" updateauthor="christopherferris" updated="2018-07-23 15:46:05.0"> <body><! CDATA Agree with  ~yacovm  - why would you log errors to stdout?  As for the proposal, I am not sure that I am on board. If we are going to refactor and rethink the CLI, then I think we should follow well worn path of CI design of the likes of kubectl, cf and others that establish an extensible framework that not only enables plugins, but where the commands are themselves plugins. It should also enable the user to establish context for a session/series of interactions so that the user is not required to script all interaction because so much information is required. e.g. I do NOT think we should preserve the same CLI, but give it some UX design.  export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp export CORE_PEER_ADDRESS=peer0.org1.example.com:7051 export CORE_PEER_LOCALMSPID="Org1MSP" export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt  peer channel create -o orderer.example.com:7050 -c $CHANNEL_NAME -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  ^^^ this is insane  ></body> </Action>
<Action id="47663" issue="31201" author="bpbuch" type="comment" created="2018-07-23 16:45:36.0" updateauthor="bpbuch" updated="2018-07-23 16:45:36.0"> <body><! CDATA  ~yacovm  I fully agree that it should be stderr, not stdout. This was a mistake on my part.    ~ChristopherFerris  I think we are on the same page.  The design should follow the well worn path that you have mentioned, and "connection profiles" should alleviate a lot of the pain with regards to session and UX issues.  The mention of plugins was more of a stretch goal for a sprint.  ></body> </Action>
<Action id="47664" issue="31201" author="sykesm" type="comment" created="2018-07-23 16:48:34.0" updateauthor="sykesm" updated="2018-07-23 16:48:34.0"> <body><! CDATA Can we please adopt the more modern and more flexible GNU command argument conventions?  1  Long option names are a very helpful way of self-documenting a command.   1  https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html  ></body> </Action>
<Action id="47665" issue="31201" author="sykesm" type="comment" created="2018-07-23 16:59:02.0" updateauthor="sykesm" updated="2018-07-23 16:59:02.0"> <body><! CDATA {quote} Rather than driving the CLI by yaml files, a profile configuration workflow should be implemented to drive the same details as core.yaml.  The profiles can be easily toggled for an improved user experience and removes the dependency on environment variables. {quote} I'm assuming this is in the spirit of {{cf config}} and {{kubectl config}} with corresponding support for commands like {{cf api}}, {{cf target}}, and {{kubectl config set-context}}?  If so, will the configuration state be stored in the users's home directory by default? Will there be an easy way to point to an alternate location in the spirit of {{CF_HOME}} and {{KUBECONFIG}}?  ></body> </Action>
<Action id="48195" issue="31201" author="latitiah" type="comment" created="2018-07-31 15:29:51.0" updateauthor="latitiah" updated="2018-07-31 15:29:51.0"> <body><! CDATA  {quote}The existing CLI will become deprecated one release after the redesigned CLI becomes production ready.  This will provide current users with a grace period to migrate to the new tool. {quote} Can we allow for a combination of using this CLI as well as the old CLI? This will allow for an easier migration over to the proposed CLI. This means *not* deprecating the existing CLI after 1 release, but more. The existing CLI is used extensively in testing.  ></body> </Action>
<Action id="48209" issue="31201" author="lehors" type="comment" created="2018-07-31 17:56:49.0" updateauthor="lehors" updated="2018-07-31 17:56:49.0"> <body><! CDATA There is no need to commit to any specific timeframe for deprecating the old CLI. This can happen at any time. Hopefully, the new CLI will become the norm and eventually the old CLI will become unused and can be deprecated.  We probably should separate the peer function from the old CLI into a separate executable but that can be done independently of this project. For what it's worth I have actually performed that surgery and it's pretty straightforward.     ></body> </Action>
<Action id="51746" issue="31201" author="mastersingh24" type="comment" body="Moving to 2.0.0 for now ... if we get something sooner, great." created="2018-10-04 11:33:48.0" updateauthor="mastersingh24" updated="2018-10-04 11:33:48.0"/>
<Action id="55427" issue="31201" author="denyeart" type="comment" body="Have not seen a recent update, therefore moving to v2.1.0 for now." created="2019-01-09 06:00:47.0" updateauthor="denyeart" updated="2019-01-09 06:00:47.0"/>
<Action id="64687" issue="31201" author="topjohn" type="comment" body="when can we move this project from gerrit to github? I saw some projects have finished migration." created="2019-10-14 07:30:14.0" updateauthor="topjohn" updated="2019-10-14 07:30:14.0"/>
