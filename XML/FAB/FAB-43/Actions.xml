<Action id="18550" issue="12342" author="kchristidis" type="comment" created="2016-08-16 18:40:19.0" updateauthor="kchristidis" updated="2016-08-16 18:47:37.0"> <body><! CDATA Should it be our goal to make the messages and interfaces defined here restrictive enough so that they don't give room for multiple interpretations?  If it is, there may be some room for refinement here. For example:  1. Can a client send an update message containing both acknowledgement and properties? We discussed privately yesterday and we both agreed that we generally expect a properties message to show up only when establishing the connection, or when something's up mid-connection and the client wishes to reset the connection. Then an update message cannot contain both an acknowledgement and a window. If we want to impose this flow on whomever implements the service, we should look into using the oneof operator (https://developers.google.com/protocol-buffers/docs/proto3#oneof) for the update message (same as we've done in our PBFT work), or a similar construct.  2. What happens if a client sends an acknowledgement for a block that is *inside* the window? The client sets the specified_number to 50 and the window_size to 100, and a bit later it sends an acknowledgement for block 76. I claim that the only reasonable thing for the server is to stop the current transmission (assume it was in the midst of sending block 140) and restart the 50-149 sequence.  Generally, I understand that the fact that gRPC methods can accept only a single protocol buffer message type as their request and return only a single protocol buffer type as their response makes our lives a bit difficult. Also: dealing with such level of detail may well be outside the proto's scope - it may not even be our job to define how the server should behave in case #2 for example.  If it is though, adding comments to the proto (see point #2) or changing the message types and RPC definitions so as to be more restrictive (see point #1) could help.  Let me know what you think.  ></body> </Action>
<Action id="18551" issue="12342" author="jyellick" type="comment" created="2016-08-16 18:58:54.0" updateauthor="jyellick" updated="2016-08-16 18:58:54.0"> <body><! CDATA 1. We did discuss this offline.  I think we could either have an implicit contract that, when `new_properties` is set, then `acknowledgement` is ignored.  This is trivial to implement, as even an implementation of apply acknowledgement, then apply properties would give you the correct behavior.  Still, I agree, explicit is better than implicit.  I would support using the oneof definition you linked to.  2. I actually completely disagree here.  This is actually entirely the point of the window, in that it can slide, and my sample client implementation relies on this fact.  In the model you propose, with a window size of 4 the flow to send 6 blocks looks like this:  Receive: Block 1 (5 ms) Receive: Block 2 (5 ms) Receive: Block 3 (5 ms) Receive: Block 4 (5 ms) (Sender stops and waits) Reply:  Ack 4 (5 ms) Receive Block 5 (5 ms) (Sender resumes) Receive Block 6 (5 ms) Total: 35ms  But instead, imagine if you allow intermediate acks  Receive: Block 1 (5 ms) Receive: Block 2 (5 ms) Reply: Ack Block 2 (5 ms) Receive: Block 3 (5 ms) Receive: Block 4 (5 ms) Reply: Ack Block 4 (5 ms) Receive Block 5 (5 ms) Receive Block 6 (5 ms) Reply: Ack Block 6 (5 ms) Total: 30ms  The big difference here to me, is that by allowing intermediate acks, you don't have to completely fill and then drain buffers on each side.  The receiver is essentially free to ack whenever there is buffer available, but only required to ack once the window size has been exhausted.  I agree that in a perfect world, the gRPC connection would accept parameters to configure the stream once, and then to seek would be a new connection, but I see no way around this.  I am certainly in favor of adding comments and more specificity via protobuf defs if possible.  ></body> </Action>
<Action id="18553" issue="12342" author="kchristidis" type="comment" body="Great, case #2 then serves as a nice example of how the proto can be misinterpreted. Seems like we agree on everything else." created="2016-08-16 19:24:32.0" updateauthor="kchristidis" updated="2016-08-16 19:24:32.0"/>
<Action id="18555" issue="12342" author="jyellick" type="comment" created="2016-08-16 20:18:30.0" updateauthor="jyellick" updated="2016-08-16 20:18:30.0"> <body><! CDATA I've revised the proto per your comments, feedback is welcome:  https://github.com/jyellick/fabric/blob/4d7fce08bda9d6aa159483139631899b62084f1e/orderer/atomicbroadcast/ab.proto  ></body> </Action>
<Action id="18556" issue="12342" author="kchristidis" type="comment" body="Looks great. If I think of any new interpretations, I&apos;ll post here." created="2016-08-16 20:29:05.0" updateauthor="kchristidis" updated="2016-08-16 20:29:05.0"/>
<Action id="18560" issue="12342" author="jyellick" type="comment" created="2016-08-17 13:51:25.0" updateauthor="jyellick" updated="2016-08-17 13:51:25.0"> <body><! CDATA I've been thinking more on this and decided I absolutely hated some of the proto names, as they seem unexpressive.  See below for an updated version which makes the following changes:  update becomes deliver_update  new_properties becomes seek  properties becomes seek_info  message becomes broadcast_message  This obviously breaks compatibility with any existing code out there, but if we want to change these names, now seems like the time to me  https://github.com/jyellick/fabric/blob/aefd4b6c6dcef19d38101a4ff88fe9115317bb8c/orderer/atomicbroadcast/ab.proto  ></body> </Action>
<Action id="18561" issue="12342" author="jyellick" type="comment" created="2016-08-17 13:57:40.0" updateauthor="jyellick" updated="2016-08-17 13:57:40.0"> <body><! CDATA One change I did not make above, which I was torn on, and would especially like feedback on.  I'd consider changing 'block_reply' to be 'deliver_reply' which would no longer contain both 'status' and 'block', instead, it would contain 'oneof' 'error' still of type status and block.  Thoughts?  ></body> </Action>
<Action id="18564" issue="12342" author="kchristidis" type="comment" body="Strong yes on the extensive use of the oneof keyword, as it makes the path restrictive and the implementation clearer. And yes on block_reply -&gt; deliver_reply as it makes it consistent with the broadcast function signature." created="2016-08-17 15:32:41.0" updateauthor="kchristidis" updated="2016-08-17 15:32:41.0"/>
<Action id="18565" issue="12342" author="jyellick" type="comment" created="2016-08-17 18:17:41.0" updateauthor="jyellick" updated="2016-08-17 18:17:41.0"> <body><! CDATA Please see an updated proto here:  https://github.com/jyellick/fabric/blob/97f37efe4f47d8e5aee14a4d9441273c36c112b2/orderer/atomicbroadcast/ab.proto  This changes the block_reply to deliver_reply, and adds the oneof semantics.  The corresponding branch also has updated solo and sample client code.   ></body> </Action>
<Action id="18621" issue="12342" author="binhn" type="comment" body="The Peer assumes that there will be 1 endpoint to Orderer service, and the same root CA for TLS connection. " created="2016-08-22 15:03:45.0" updateauthor="binhn" updated="2016-08-22 15:03:45.0"/>
<Action id="18625" issue="12342" author="jyellick" type="comment" body=" ~binhn , how should the orderer service authenticate clients?" created="2016-08-22 18:46:32.0" updateauthor="jyellick" updated="2016-08-22 18:46:32.0"/>
<Action id="18700" issue="12342" author="jeffgarratt" type="comment" body="I left a step in the current behave test that states the user &quot;binhn&quot; is authorized to use the orderer service.  This is a placeholder for the authentication mechanism, but highlights that it must be defined at some point." created="2016-08-26 17:22:46.0" updateauthor="jeffgarratt" updated="2016-08-26 17:23:22.0"/>
