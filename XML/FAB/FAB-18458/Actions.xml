<Action id="71725" issue="46823" author="manish-sethi" type="comment" body=" exit condition|https://github.com/hyperledger/fabric/blob/2d504026e664c689d65ef7b479a040bb94892ebd/orderer/common/follower/follower_chain.go#L415  for join-by-block to transition from follower to member is verified after fetching n blocks. If there were more than one config blocks in this range, it will verify only the last one." created="2021-04-28 05:10:38.0" updateauthor="manish-sethi" updated="2021-04-28 05:10:38.0"/>
<Action id="71726" issue="46823" author="tock" type="comment" created="2021-04-28 06:46:49.0" updateauthor="tock" updated="2021-04-29 05:41:41.0"> <body><! CDATA This is not a bug.   ~manish-sethi   The follower is normally started when an orderer is first joined to a channel with the channel-participation API. The way it works is that the orderer is given the last config block (say #N) from one of the other orderers in the channel (usually the last config, but maybe a "recent enough" config as well, more on that later). That block #N is called the join block. The orderer will start a follower to fetch all the blocks up to and including #N (pull before join). There may be multiple config blocks up to #N, but it this point we don't care, we fetch up to it.  Now, the follower goes to fetch the blocks after #N, if necessary (pull after join). The follower stop condition is that the orderer is a part of the consenters set, which means the follower must stop and transfer control to a normal consenter chain that runs Raft and participates in consensus. So the first thing it does in that loop is to check whether the last config block (#N) indicates membership. If yes, done; it exits and transfers control to a consensus chain. If not, it will fetch all blocks up to the head of the ledger and check again.  This is the main difference between "pull-before" and "pull-after", pull-before does not check intermediate config blocks before the join block (#N), whereas pull-after checks config blocks that shows up from the join block onwards. However, the pull-after code will not check every config block; it will pull every block until the tip of the ledger (at a given point in time) - and only then check the last config - because blocks that are committed in a remote orderer do not need to be consented upon again, and the decision whether to start a consenter chain can be based on the last config only.    There are two "join" scenarios: 1. the join block does not indicate the new orderer membership, 2. the new join block does indicate the new orderer membership. Case 1. is the recommended  course of action for joining a new orderer: it is given the last join-block, it catches up up to that and goes on to catch up until the admin thinks it is close enough to the tip of the ledger, and then the channel admin will issue a config tx that adds the new orderer to the consenters set. When that tx is pulled by the follower, it will stop, cause a consensus chain to start, and the new orderer will start taking part in consensus. Case 2. is when the admin adds the new orderer to the consnters set, and after that gets that last config block and uses it as a join block. This will work, but leaves the channel in a state of reduces fault tolerance until the orderer catches up to the join block and starts a consenter. In long ledgers that may take a significant amount of time, hence (1) is the recommended procedure.  ></body> </Action>
