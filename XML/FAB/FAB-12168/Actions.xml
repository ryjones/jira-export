<Action id="51180" issue="34090" author="sykesm" type="comment" created="2018-09-25 21:13:37.0" updateauthor="sykesm" updated="2018-09-25 21:13:37.0"> <body><! CDATA There's a hard coded timeout of one minute in {{core/chaincode/platforms/golang/list.go}} that kills {{go list}}. The error processing does not seem to report the more meaningful timeout error up the stack.  {code} //runProgram non-nil Env, timeout (typically secs or millisecs), program name and args func runProgram(env Env, timeout time.Duration, pgm string, args ...string) (  byte, error) { 	if env == nil { 		return nil, fmt.Errorf("<%s, %v>: nil env provided", pgm, args) 	} 	var stdOut bytes.Buffer 	var stdErr bytes.Buffer  	cmd := exec.Command(pgm, args...) 	cmd.Env = flattenEnv(env) 	cmd.Stdout = &stdOut 	cmd.Stderr = &stdErr 	err := cmd.Start()  	// Create a go routine that will wait for the command to finish 	done := make(chan error, 1) 	go func() { 		done <- cmd.Wait() 	}()  	select { 	case <-time.After(timeout): 		if err = cmd.Process.Kill(); err != nil { 			return nil, fmt.Errorf("<%s, %v>: failed to kill: %s", pgm, args, err) 		} else { 			return nil, errors.New(fmt.Sprintf("<%s, %v>: timeout(%d msecs)", pgm, args, timeout/time.Millisecond)) 		} 	case err = <-done: 		if err != nil { 			return nil, fmt.Errorf("<%s, %v>: failed with error: \"%s\"\n%s", pgm, args, err, string(stdErr.Bytes())) 		}  		return stdOut.Bytes(), nil 	} }  // Logic inspired by: https://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife func list(env Env, template, pkg string) (  string, error) { 	if env == nil { 		env = getEnv() 	}  	lst, err := runProgram(env, 60*time.Second, "go", "list", "-f", template, pkg) 	if err != nil { 		return nil, err 	}  	return strings.Split(strings.Trim(string(lst), "\n"), "\n"), nil } {code}  ></body> </Action>
<Action id="54156" issue="34090" author="mastersingh24" type="comment" body="https://gerrit.hyperledger.org/r/27865" created="2018-12-02 12:54:28.0" updateauthor="mastersingh24" updated="2018-12-02 12:54:28.0"/>
