<Issue id="18417" key="FAB-4883" number="4883" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Chaincode vendor dependencies placed into the wrong folder while packing chaincode" priority="3" resolution="10000" status="6" created="2017-06-20 11:31:55.0" updated="2018-07-20 14:13:31.0" resolutiondate="2017-07-07 12:11:39.0" votes="0" watches="4" workflowId="39198" security="10001"> <description><! CDATA If chaincode has external dependency on the vendored library this dependency will be misplaced while preparing a packaging. For example, having following CC:  {code} package main  import ( 	"fmt"  	"github.com/golang/protobuf/proto" 	"github.com/hyperledger/fabric/core/chaincode/shim" 	"github.com/hyperledger/fabric/protos/msp" 	"github.com/hyperledger/fabric/protos/peer" )  type MyChaincode struct { }  func (MyChaincode) Init(stub shim.ChaincodeStubInterface) peer.Response { 	fmt.Println("Init") 	return shim.Success(nil) }  func (MyChaincode) Invoke(stub shim.ChaincodeStubInterface) peer.Response { 	bytes, err := stub.GetCreator() 	fmt.Println(bytes) 	if err != nil { 		fmt.Println("Error", err) 	}  	sId := &msp.SerializedIdentity{} 	proto.Unmarshal(bytes, sId) 	fmt.Println(sId)  	return shim.Success(nil) }  func main() { 	err := shim.Start(new(MyChaincode)) 	if err != nil { 		fmt.Printf("Error starting Simple chaincode: %s", err) 	} } {code}  the output of the {{go list -f '{{join .Deps "\"}} '}} command related to `protobuf` dependency will be following:  {code} github.com/hyperledger/fabric/vendor/github.com/golang/protobuf/proto github.com/hyperledger/fabric/vendor/github.com/golang/protobuf/ptypes/any github.com/hyperledger/fabric/vendor/github.com/golang/protobuf/ptypes/empty github.com/hyperledger/fabric/vendor/github.com/golang/protobuf/ptypes/timestamp github.com/hyperledger/fabric/vendor/google.golang.org/genproto/googleapis/rpc/status {code}  Therefore while packing based on the code:  {code} 	// -------------------------------------------------------------------------------------- 	// Reclassify and sort the files: 	// 	// Two goals: 	//   * Remap non-package dependencies to package/vendor 	//   * Sort the final filename so the tarball at least looks sane in terms of package grouping 	// -------------------------------------------------------------------------------------- 	files := make(Sources, 0) 	pkgPath := filepath.Join("src", code.Pkg) 	vendorPath := filepath.Join(pkgPath, "vendor") 	for _, file := range fileMap { 		// Vendor any packages that are not already within our chaincode's primary package.  We 		// detect this by checking the path-prefix.  Anything that is prefixed by "src/$pkg" 		// (which includes the package itself and anything explicitly vendored in "src/$pkg/vendor") 		// are left unperturbed.  Everything else is implicitly vendored under src/$pkg/vendor by 		// simply remapping "src" -> "src/$pkg/vendor" in the tarball index. 		if strings.HasPrefix(file.Name, pkgPath) == false { 			origName := file.Name 			file.Name = strings.Replace(origName, "src", vendorPath, 1) 			logger.Debugf("vendoring %s -> %s", origName, file.Name) 		}  		files = append(files, file) 	}  	sort.Sort(files) {code}  it will be placed into {{go/mychaincode/vendor/github.com/hyperledger/fabric/vendor/github.com/golang/protobuf/proto}} folder instead of {{go/mychaincode/vendor/github.com/golang/protobuf}}  ></description> </Issue>
