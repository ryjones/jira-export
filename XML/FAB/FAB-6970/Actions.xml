<Action id="35659" issue="23922" author="blw" type="comment" created="2017-11-30 01:41:29.0" updateauthor="blw" updated="2017-11-30 01:41:29.0"> <body><! CDATA Another approach I have been testing out would be to set a minimum TTL before deleting an expired identity; through experiment, I've found that a 1 second minimum would be sufficient. This approach has the added benefit of letting the CertStore initialization complete without a calling the callback prematurely (causing the null pointer panic). When the callback is called, the cleanup will complete as designed.  This would require the additional step of blocking gossip until the minimum TTL has passed. This is because if an expired cert is provided, functionality should not be allowed to continue for any length of time.  Does this seem like a good approach  ~yacovm ?  ></body> </Action>
<Action id="35663" issue="23922" author="yacovm" type="comment" created="2017-11-30 07:20:08.0" updateauthor="yacovm" updated="2017-11-30 07:20:08.0"> <body><! CDATA No, I don't think we need to over-engineer things :)  We should just check if the certificate has expired upon startup. Certificates are issued for months or years so the probability you start with a non expired certificate and then it expires before gossip is initialized is negligible.   ></body> </Action>
<Action id="35760" issue="23922" author="blw" type="comment" body="https://gerrit.hyperledger.org/r/#/c/15887/" created="2017-12-03 18:14:46.0" updateauthor="blw" updated="2017-12-03 18:14:46.0"/>
<Action id="37607" issue="23922" author="yacovm" type="comment" created="2017-12-18 21:47:34.0" updateauthor="yacovm" updated="2017-12-18 21:47:34.0"> <body><! CDATA  ~adc   ~angelo.decaro    Ben here uploaded a change set above and I asked him for a unit test.  However, it seems it's not a trivial thing to do - The bccsp factory is initialized in the TestMain of deserializer_test, and as a result - the sync.Once in the factory.go of bccsp/factory sets the key store path to sampleconfig/msp/keystore and now we can't use another keystore.  Now, if Ben changes the production code of his change set to change the code in the msp package instead of the mgmt package, all the OU and revocations unit tests fail, because their certificates are all expired....   Can you help us out?   ></body> </Action>
<Action id="37766" issue="23922" author="blw" type="comment" created="2017-12-22 19:40:40.0" updateauthor="blw" updated="2017-12-22 19:40:40.0"> <body><! CDATA  ~adc   ~yacovm   I was able to regenerate all the unit test certs, so no action needed from your end.  ></body> </Action>
<Action id="38215" issue="23922" author="angelo.decaro" type="comment" body=" ~blw ,  ~yacovm , What happens if the default signing identity expires when the peer is already running? Would it cause an issue?" created="2018-01-05 08:26:29.0" updateauthor="angelo.decaro" updated="2018-01-05 08:26:29.0"/>
<Action id="38216" issue="23922" author="yacovm" type="comment" body="yes." created="2018-01-05 08:30:44.0" updateauthor="yacovm" updated="2018-01-05 08:30:44.0"/>
<Action id="38218" issue="23922" author="angelo.decaro" type="comment" body="Do we need another patch then?" created="2018-01-05 09:21:31.0" updateauthor="angelo.decaro" updated="2018-01-05 09:21:31.0"/>
<Action id="38220" issue="23922" author="yacovm" type="comment" created="2018-01-05 10:02:10.0" updateauthor="yacovm" updated="2018-01-05 10:02:10.0"> <body><! CDATA We could make a patch that makes the peer commit suicide if its signing identity is expired.    ~mastersingh24  what do you think?  ></body> </Action>
<Action id="38229" issue="23922" author="blw" type="comment" created="2018-01-05 15:32:13.0" updateauthor="blw" updated="2018-01-05 15:32:13.0"> <body><! CDATA  ~yacovm   ~adc   I think if the identity expires after the peer has started, it will cause the expired identity to be deleted. According to lines 129-136 of gossip/identity/identity.go, a callback is defined to wipe out the identity 1 millisecond after it expires: {code:java} var expirationTimer *time.Timer if !expirationDate.IsZero() { 	// Identity would be wiped out a millisecond after its expiration date 	timeToLive := expirationDate.Add(time.Millisecond).Sub(time.Now()) 	expirationTimer = time.AfterFunc(timeToLive, func() { 		is.delete(pkiID, identity) 	}) } {code} Â   ></body> </Action>
<Action id="38279" issue="23922" author="angelo.decaro" type="comment" created="2018-01-08 08:13:57.0" updateauthor="angelo.decaro" updated="2018-01-08 08:14:43.0"> <body><! CDATA  ~yacovm ,  ~blw ,  ~elli-androulaki ,  ~ales   At the current stage, identities never expire, they can be revoked though. I guess then, the peer should shut down only if the identity is revoked. We should not check expiration.  ></body> </Action>
<Action id="38280" issue="23922" author="yacovm" type="comment" created="2018-01-08 08:19:59.0" updateauthor="yacovm" updated="2018-01-08 08:22:40.0"> <body><! CDATA Well I think a peer needs to shut down if its identity has expired, so its administrator would be alerted to replace its identity.   The fact that the MSP has no sense of time doesn't mean time doesn't flow  ></body> </Action>
<Action id="38281" issue="23922" author="angelo.decaro" type="comment" body="If the identity is just expired, it should not be an issue in the current setting. Only revocation should trigger a failure." created="2018-01-08 08:43:18.0" updateauthor="angelo.decaro" updated="2018-01-08 08:43:18.0"/>
