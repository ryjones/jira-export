<Action id="50407" issue="33717" author="ales" type="comment" created="2018-09-13 11:47:42.0" updateauthor="ales" updated="2018-09-13 11:47:42.0"> <body><! CDATA +1 Interesting work that will certainly open up many possibilities. It's also worth mentioning that - while we would be enabling the chaincode to perform external calls that may lead to non-deterministic behaviour (e.g. peer 1 successfully communicates while peer 2 has a temporary network failure) there's no risk of any forks because fabric's programming model doesn't guarantee liveness to non-deterministic chaincodes by design.  One consideration that comes to mind: the semantics of this communication layer must be clear - do we inherit transport-level security guarantees at the chaincode level if TLS is used by gossip? If so, how will this be achieved?  ></body> </Action>
<Action id="50408" issue="33717" author="yacovm" type="comment" created="2018-09-13 12:26:23.0" updateauthor="yacovm" updated="2018-09-13 12:26:23.0"> <body><! CDATA {quote}do we inherit transport-level security guarantees at the chaincode level if TLS is used by gossip? If so, how will this be achieved? {quote} Since the messages are carried by the gossip communication layer in a point-to-point manner you get authentication and encryption "for free".  ></body> </Action>
<Action id="50409" issue="33717" author="ales" type="comment" created="2018-09-13 12:31:27.0" updateauthor="ales" updated="2018-09-13 12:31:27.0"> <body><! CDATA {quote} Since the messages are carried by the gossip communication layer in a point-to-point manner you get authentication and encryption "for free". {quote} Right, the important point will be to ensure that the chaincode interface doesn't lead to information loss, so that the intent of the chaincode developer to - say "send this message to a peer of org foo with attribute bar" - leads to the exchange of information to the intended recipient, or an error. Just to avoid confused deputy attacks.   ></body> </Action>
<Action id="54596" issue="33717" author="binhn" type="comment" created="2018-12-10 15:42:49.0" updateauthor="binhn" updated="2018-12-10 15:42:49.0"> <body><! CDATA +1 I am particularly interested in this capability to implement cc to cc calls to a remote external channel. That is, a cc1 from org1 on channel1 may call cc2 from org2 on channel2, which org1 is not a member of. A general use case is reference data channel, which provides common data for other channels but members of other channels don't want to be a member of the reference data channel due to reasons like privacy.  ></body> </Action>
<Action id="54598" issue="33717" author="yacovm" type="comment" created="2018-12-10 15:54:02.0" updateauthor="yacovm" updated="2018-12-10 15:54:02.0"> <body><! CDATA Yep, this is one of the use cases in the google doc :)   ></body> </Action>
<Action id="55113" issue="33717" author="senthil1" type="comment" body="If a chaincode calls a chaincode hosted on a different channel, with the current implementation, we don&apos;t ensure serialisability isolation level. Even repeatable read isolation level is not possible. If we are planning for a transaction to span multiple channels (that is to say that the read set consist of &lt;k, version&gt; where each belong to a different channel), we need changes at the ledger component too. It would become more like an implementation of a distributed transaction.Â " created="2018-12-24 03:39:30.0" updateauthor="senthil1" updated="2018-12-24 04:44:30.0"/>
<Action id="55116" issue="33717" author="yacovm" type="comment" created="2018-12-24 07:21:10.0" updateauthor="yacovm" updated="2018-12-24 07:21:10.0"> <body><! CDATA  ~Senthil1 , this will be treated in the same manner as accessing an external data source via chaincode, only that the external data source is a chaincode that resides on a different peer.    ></body> </Action>
