<Action id="20857" issue="14739" author="angelo.decaro" type="comment" body=" ~ash1kumar  ~vpaprots  So it looks to me this would be difficult to achieve with HSM because the output of the HMAC might be sensitive and not exportable. " created="2017-02-13 14:59:51.0" updateauthor="angelo.decaro" updated="2017-02-13 14:59:51.0"/>
<Action id="20863" issue="14739" author="ashutosh_kumar" type="comment" created="2017-02-13 15:27:28.0" updateauthor="ashutosh_kumar" updated="2017-02-13 15:30:32.0"> <body><! CDATA Can you have 2 functions :  # Generating Key Object and  # Generating Byte array ?   Just an advice.  ></body> </Action>
<Action id="20874" issue="14739" author="ashutosh_kumar" type="comment" created="2017-02-13 16:12:17.0" updateauthor="ashutosh_kumar" updated="2017-02-13 16:12:17.0"> <body><! CDATA I tried this piece of code :  buff := new(bytes.Buffer) 		buffError := binary.Write(buff, binary.LittleEndian, tidxKey) 		*if buffError != nil { 			return nil, fmt.Errorf("tidx byte conversion faield with error : %s ", buffError) 		}*  where tidxKey is  tidxKey, tidxKeyError := tm.BCCSP.KeyDeriv(expansionValue, &bccsp.HMACTruncated256AESDeriveKeyOpts{Temporary: true, Arg: tidx})  While executing the code , got this error :  *tidx byte conversion failed with error : binary.Write: invalid type *sw.aesPrivateKey*     ></body> </Action>
<Action id="20877" issue="14739" author="ashutosh_kumar" type="comment" body="Based on my Rocket Chat conversation with  ~vpaprots@ca.ibm.com  : We need to support tm.BCCSP.KeyDeriv(pk2, &amp;bccsp.ECDSAReRandKeyOpts{Temporary: true, *Expansion: /*tidxKeyByte*/ buff.Bytes()*}) for Expnsion argument to be of type bccsp.Key as for TCert work , I want the HMACked Key to be passed as Expansion Argument." created="2017-02-13 17:59:22.0" updateauthor="ashutosh_kumar" updated="2017-02-13 17:59:22.0"/>
<Action id="20880" issue="14739" author="vpaprots" type="comment" created="2017-02-13 18:43:30.0" updateauthor="vpaprots" updated="2017-02-13 18:43:30.0"> <body><! CDATA Something like this in bccsp/opts.go  // ECDSAReRandKeyOpts contains options for ECDSA key re-randomization. type ECDSAReRandKeyOptsFromKey struct { 	Temporary bool 	Expansion Key }  // Algorithm returns the key derivation algorithm identifier (to be used). func (opts *ECDSAReRandKeyOptsFromKey) Algorithm() string { 	return ECDSAReRand }  // Ephemeral returns true if the key to generate has to be ephemeral, // false otherwise. func (opts *ECDSAReRandKeyOptsFromKey) Ephemeral() bool { 	return opts.Temporary }  ></body> </Action>
<Action id="20917" issue="14739" author="ashutosh_kumar" type="comment" body="Based on discussion with  ~ellaki  and  ~adc  , I have to use the function HMACDeriveKeyOpts to get expansion value. Will give it a try." created="2017-02-15 16:12:58.0" updateauthor="ashutosh_kumar" updated="2017-02-15 16:12:58.0"/>
<Action id="21214" issue="14739" author="ashutosh_kumar" type="comment" body="The approach worked.  ~vpaprots  is working on alternative approach. Closing it now." created="2017-02-28 16:35:08.0" updateauthor="ashutosh_kumar" updated="2017-02-28 16:35:08.0"/>
