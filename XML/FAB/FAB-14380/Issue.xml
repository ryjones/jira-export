<Issue id="38022" key="FAB-14380" number="14380" project="10002" reporter="guoger" assignee="guoger" creator="guoger" type="10004" summary="It is racy to send two etcdraft Type B config back-to-back" priority="3" resolution="10000" status="6" created="2019-02-27 06:30:48.0" updated="2019-03-10 14:49:57.0" resolutiondate="2019-03-10 14:49:46.0" votes="0" watches="3" workflowId="49640"> <description><! CDATA h3. Problem Suppose we have a cluster that contains 3 nodes: A, B, C. And we send two config transactions, {{Tx_add}} and {{Tx_rm}}, that have consenter set {{<A, B, C, D>}} and {{<A, B>}} respectively, result is erroneous. To reproduce, put this to {{chain_test.go}} and observe logs: {code} 				It("foo", func() { 					configEnvAdd := newConfigEnv(channelID, 						common.HeaderType_CONFIG, 						newConfigUpdateEnv(channelID, addConsenterConfigValue()))  					configEnvRm := newConfigEnv(channelID, 						common.HeaderType_CONFIG, 						newConfigUpdateEnv(channelID, removeConsenterConfigValue(2)))  					c1.cutter.CutNext = true  					Expect(c1.Configure(configEnvAdd, 0)).To(Succeed()) 					Expect(c1.Configure(configEnvRm, 0)).To(Succeed()) 				}) {code}  h3. Reason We have a rule in etcdraft: bq. _*only 1 node* can be added/removed at a time_ and this is checked against *current* consenter set  here|https://github.com/hyperledger/fabric/blob/83f7fa7555263b67a1b4a8796668f0b62d7cc49f/orderer/consensus/etcdraft/chain.go#L1089-L1095 . However, *current consenter set* is accessed by multiple readers (whoever calls {{Chain.Configure}}) and updated by one writer (when config block is being written  here|https://github.com/hyperledger/fabric/blob/83f7fa7555263b67a1b4a8796668f0b62d7cc49f/orderer/consensus/etcdraft/chain.go#L1146-L1148 ). Lock here only makes it thread-safe, but does not guarantee correct behavior.  While {{Tx_add}} is in-flight, {{Tx_rm}} is checked against {{<A, B, C>}}, *deemed valid*, and enqueued to {{submitC}}, even though it's blocked because {{Tx_add}} is in-flight.  h3. Solution We need to perform the check in the same go routine as the one commits config block, because only that go routine holds up-to-date truth. And if we still want to return error to client if check is failed, {{Configure}} should wait on an error channel, similar to  this trick|https://github.com/hyperledger/fabric/blob/83f7fa7555263b67a1b4a8796668f0b62d7cc49f/orderer/consensus/etcdraft/chain.go#L505   ></description> </Issue>
