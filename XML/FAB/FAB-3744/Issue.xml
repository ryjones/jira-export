<Issue id="16495" key="FAB-3744" number="3744" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10004" summary="Pull mechanism should only pull from peers in the same org" priority="3" resolution="10000" status="6" created="2017-05-09 13:03:26.0" updated="2018-07-20 14:12:38.0" resolutiondate="2017-05-10 09:45:31.0" votes="0" watches="1" workflowId="38400"> <description><! CDATA Currently, the pull mechanism works with peers from any orgs that are eligible of being in the channel.  This has the following problem:  If in a certain channel there are 2 orgs: \{A, B} and a peer from orgB initiates a pull with a peer from orgA and as a result, the peer from orgA sends the peer from orgB blocks with sequences  n... n+k  it has received from either the ordering service or from peers in its own org, it is not safe because a block i in  n.. n+k  can be a configuration block that evicts orgB from the channel, and as a result - orgB would receive blocks it isn't eligible of receiving.     This problem doesn't exist in the state transfer because we only send blocks that were committed into the ledger before and therefore processed and updated the MSP and then if the peer that requests the block is not eligible to the channel, the MSP of the peer as been updated before the state transfer request is serviced.     The fix of this issue is very simple:  1)  The channel pull adapter uses the following struct to select the peers to pull blocks from: {code:java} type membershipFilter struct {     adapter Adapter     *gossipChannel }  // GetMembership returns the known alive peers and their information func (mf *membershipFilter) GetMembership()   discovery.NetworkMember {     var members   discovery.NetworkMember     for _, mem := range mf.adapter.GetMembership() { // here we need to add a check of the peer's org         if mf.EligibleForChannel(mem) {             members = append(members, mem)         }     }     return members }{code} We just need to add a filtering that also ensures the selected remote peer is from the peer's org.     2) When the channel code receives a pull message we would also need to filter out if the remote peer is from a different org. {code:java}     if m.IsPullMsg() && m.GetPullMsgType() == proto.PullMsgType_BLOCK_MSG {         if !gc.EligibleForChannel(discovery.NetworkMember{PKIid: msg.GetConnectionInfo().ID}) { // here we need to add a check of the peer's org             gc.logger.Warning(msg.GetConnectionInfo().ID, "isn't eligible for channel", string(gc.chainID))             return         }{code}  ></description> </Issue>
