<Action id="44107" issue="30059" author="yacovm" type="comment" created="2018-05-09 11:28:06.0" updateauthor="yacovm" updated="2018-05-09 11:28:47.0"> <body><! CDATA  ~muralisr  .  ~manish-sethi   ~denyeart   IMO it's trivially fixable if the chaincode shim doesn't wait for a response when it sends the putstate message, and the peer doesn't return a put state status back to the shim.   So, instead of  {code}handlePutState-->callPeerWithChaincodeMsg-->sendReceive {code} we'll just do a send in the end.   ></body> </Action>
<Action id="44109" issue="30059" author="muralisr" type="comment" created="2018-05-09 11:47:46.0" updateauthor="muralisr" updated="2018-05-09 11:47:46.0"> <body><! CDATA  ~yacovm  Chaincode dev typically do want to know if PutState failed for some reason. I don't think we want to change that default behavior. Perhaps you are suggesting "just do a send" as an option ?   I feel adding a bulk put API (option 2 in description) has merits.  ></body> </Action>
<Action id="44110" issue="30059" author="yacovm" type="comment" created="2018-05-09 11:58:38.0" updateauthor="yacovm" updated="2018-05-09 11:58:38.0"> <body><! CDATA The put state can't really fail... you're just adding a key->value mapping to a map in the peer's memory. I guess it can fail if the key name isn't supported by the DB implementation, but for that i think we can just batch all errors and let the peer code handle them and fail the simulation instead the chaincode shim would.     ></body> </Action>
<Action id="44111" issue="30059" author="pd93" type="comment" created="2018-05-09 12:13:49.0" updateauthor="pd93" updated="2018-05-09 12:13:49.0"> <body><! CDATA I would +1 a `BulkPutState()` method (or similar) that would defer running ledger operations until the end of the invocation. * It makes it clear to a chaincode developer exactly what is happening with regards to information being put on the ledger. ** `PutState()` - Pushes to ledger immediately and returns errors if found. ** `BulkPutState()` - Pushes to a queue first and then pushes to ledger when the invocation is complete. * It doesn't break the existing API, so developers need not change anything if they don't want to. * It can be made clear to the user that errors will not be handled until the very end of the invocation.  ></body> </Action>
<Action id="44114" issue="30059" author="yacovm" type="comment" body="I think instead of a bulk putstate, we can just keep the putStates in the shim at runtime, and at the end of the transaction it can send it to the peer before the operation finishes....  ~muralisr  wdyt?" created="2018-05-09 12:30:49.0" updateauthor="yacovm" updated="2018-05-09 12:30:49.0"/>
<Action id="44123" issue="30059" author="pd93" type="comment" created="2018-05-09 12:47:29.0" updateauthor="pd93" updated="2018-05-09 12:47:29.0"> <body><! CDATA Took a look at the HandlePutState() code out of curiousity and noticed there is a comment and JIRA link about setting/getting multiple keys already (see  https://github.com/hyperledger/fabric/blob/master/core/chaincode/shim/handler.go#L332 ). It may be worth associating this with https://jira.hyperledger.org/browse/FAB-1244 ?  I'm also totally happy with  ~yacovm 's approach as long as there are no side effects to the existing behavior of PutState() for non-bulk operations.  ></body> </Action>
<Action id="44138" issue="30059" author="manish-sethi" type="comment" created="2018-05-09 17:43:01.0" updateauthor="manish-sethi" updated="2018-05-09 17:43:01.0"> <body><! CDATA Just to add to the context - In the ledger, a function already exists for allowing bulk read and write... https://github.com/hyperledger/fabric/blob/release-1.1/core/ledger/ledger_interface.go#L150  In my opinion, chaincode shim should be a simple pass through and should not be adding any buffer. Because, architecturally, this is not the right place for interpreting the meaning of the sequence of read and write operations. This become important if we want to start supporting advance operations say - read-your-write semantics or update queries. We have already began moving to allow delta-updates in the terms of introducing metadata...  ></body> </Action>
<Action id="45234" issue="30059" author="pd93" type="comment" created="2018-05-29 12:42:17.0" updateauthor="pd93" updated="2018-05-29 12:42:17.0"> <body><! CDATA As per  ~manish-sethi  's last comment, I'm linking the issue for adding support for multiple get/set calls. aka. SetStateMultipleKeys().   https://jira.hyperledger.org/browse/FAB-1244  ></body> </Action>
<Action id="49153" issue="30059" author="denyeart" type="comment" body=" ~manish-sethi  Are you saying that we should not implicitly buffer the PutStates, and rather expose new chaincode shim API to allow the chaincode author to set multiple keys at once?" created="2018-08-21 12:30:35.0" updateauthor="denyeart" updated="2018-08-21 12:30:35.0"/>
<Action id="49356" issue="30059" author="manish-sethi" type="comment" body=" ~denyeart  - yes, that&apos;s what I meant. Ledger already has functions for allowing this -  https://github.com/hyperledger/fabric/blob/release-1.2/core/ledger/ledger_interface.go#L146 " created="2018-08-24 18:10:32.0" updateauthor="manish-sethi" updated="2018-08-24 18:10:32.0"/>
<Action id="49524" issue="30059" author="yoheiueda" type="comment" created="2018-08-29 07:24:03.0" updateauthor="yoheiueda" updated="2018-08-29 07:24:03.0"> <body><! CDATA {quote}Calls to `stub.PutState()` should be queued up and called together when the invocation is complete. {quote} I implemented PoC code for this approach in FAB-11322.  If I remember correctly, PutState returns errors if specified  collection is not found when private ledger is used, or if values are not formed in JSON format when CouchDB is used.     In the other cases, PutState never fails, and we can transparently queue PutState calls, and piggyback them with a completed meessage back to peer.  We can reduce one more round-trip communication between shim and peer with piggybacking than with BultPutState. We can utilize the ledger's SetStateMultipleKeys when processing the piggybacked PutState calls.     We may also introduce a Capability in configtx.yaml or a parameter in core.yaml to specify whether to enable piggybacking to accommodate incompatibility of behavior when PutState fails.     ></body> </Action>
<Action id="49563" issue="30059" author="denyeart" type="comment" body=" ~yoheiueda  The current recommendation is to expose the bulk API to allow chaincode to set multiple keys at once. This way there is no change in behavior and the chaincode author has full control.  Does that sound reasonable?" created="2018-08-29 16:02:06.0" updateauthor="denyeart" updated="2018-08-29 16:02:06.0"/>
<Action id="49591" issue="30059" author="yoheiueda" type="comment" created="2018-08-30 07:49:32.0" updateauthor="yoheiueda" updated="2018-08-30 07:49:32.0"> <body><! CDATA  ~denyeart  I see. It is reasonable for me.     I think it is more reasonable if we have GetStateMultipleKeys as well.     After Get/SetStateMultipleKeys are implemented., we will rethink the piggybacking approach when it becomes really necessary to reduce one more round-trip communication between peer and shim.     ></body> </Action>
<Action id="67506" issue="30059" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:32:43.0" updateauthor="sykesm" updated="2020-01-22 22:32:43.0"/>
<Action id="72110" issue="30059" author="JIRAUSER22568" type="comment" created="2021-10-24 05:24:38.0" updateauthor="JIRAUSER22568" updated="2021-10-24 05:24:38.0"> <body><! CDATA Hi, i'm very new to Hyperledger ecosystem, but quite early in my journey i realized lack of bulk putState API for the chaincode. I found this (and related) issues, but they are all stale. I understand this was discussed by v1.2 and we are now at v2.3, but I believe this issue has not been resolved yet.  Are there any recommended workarounds for this?  ~pd93   ~sykesm   ~yoheiueda   ~denyeart   ></body> </Action>
<Action id="72112" issue="30059" author="denyeart" type="comment" body=" ~jrojek  I&apos;ve removed the stale tag. Yes it makes sense to add the bulk Get/Set chaincode APIs.   ~mbwhite  looks over chaincode API these days, what do you think?" created="2021-10-24 14:37:12.0" updateauthor="denyeart" updated="2021-10-24 14:37:12.0"/>
<Action id="72114" issue="30059" author="c0rwin" type="comment" created="2021-10-24 19:18:57.0" updateauthor="c0rwin" updated="2021-10-24 19:18:57.0"> <body><! CDATA > Yes it makes sense to add the bulk Get/Set chaincode APIs   I guess it also counts the delete operation as well, correct?  ></body> </Action>
<Action id="72115" issue="30059" author="JIRAUSER20406" type="comment" body="Yes, there would be a lot of sense in being able to do these operations in bulk. it would save quite a bit of network round trip time. " created="2021-10-25 15:30:59.0" updateauthor="JIRAUSER20406" updated="2021-10-25 15:30:59.0"/>
<Action id="72116" issue="30059" author="JIRAUSER20406" type="comment" body="It&apos;s been a while since I looked at the original discussion, but don&apos;t believe that anything will have occured that would mean it&apos;s outdated.    If anybody in the community would like to take a run at this, I&apos;m happy to mentor..." created="2021-10-25 15:33:13.0" updateauthor="JIRAUSER20406" updated="2021-10-25 15:33:13.0"/>
