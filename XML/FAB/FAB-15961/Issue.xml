<Issue id="41216" key="FAB-15961" number="15961" project="10002" reporter="ryjones" assignee="denyeart" creator="dhuseby" type="10004" summary="BCCSP Issues from Audit" priority="3" status="10300" created="2019-07-15 18:26:26.0" updated="2021-10-04 07:47:06.0" votes="0" watches="2" workflowId="54218" security="10000"> <description><! CDATA Some notes of discrepancies that Graham Shaw from Nettitude noticed while conducting the 1.4.x and 2.0 audits. Here are his notes:  I’ve been looking through the bccsp component. Not found anything exploitable, and most of the following are not really security issues, but in the absence of anything more juicy I’ve recorded everything that looks to be not as it should be:     bccsp/utils/io.go (DirExists): Contrary to what the comment (and function name) would lead you to expect, this only checks that there is an object at the specified pathname, not that it is a directory.     bccsp/sw/aes.go (GetRandomBytes): The error message states that the length must be larger than zero, but the code allows it to be equal to zero.     bccsp/sw/aes.go (GetRandomBytes): The test for n != len is unreachable unless the implementation of rand.Read is non-conformant with the published API, in which case a different (and much more alarming) error message would be called for. If you wish to report failure to fill the buffer using this message then the test must precede the one for err != nil. (Not discouraging you from performing both tests – no harm in belt and braces – it is just the message at issue here.)     bccsp/sw/aes.go (pkcs7UnPadding): Does not check for the case of len(src) == 0, and would panic (as opposed to returning an error) if this was the case. Cannot occur in normal use, since padding would always result in there being at least one block. I don’t know whether this could be exploited using crafted input, but it would be easier to fix than to spend time finding out (since we are deep in the crypto library here).     bccsp/sw/aeskey.go (SKI): Using the SHA256 of the secret key as the SKI ought to be safe given that you are already relying on it for preimage resistance in other parts of the codebase. However, this does make me feel slightly uneasy, in part due to the input being half the length of the output. It may be too late to make changes to this without causing backward compatibility problems, however given a free choice, my recommendation would be to take a fixed block of plaintext, encrypt that using the secret key, then hash the ciphertext to produce the SKI.     bccsp/sw/conf.go (config): This has members named aesBitLength and rsaBitLength, however whereas the latter is measured in bits (as the name suggests), the former is measured in bytes. I can’t find anything wrong with the usage given these meanings, however there is some risk of confusion.     bccsp/sw/fileks (StoreKey): The in-memory keystore checks whether a key exists before storing it, whereas the file-based keystore simply overwrites it. Since they are implementations of the same API, it would be reasonable to expect the same semantics.     (I’d also note that the file-based keystore is capable of some very non-intuitive behaviour if there were two different key types with the same SKI, or if an attacker were to gain access to the directory where the key files are stored, due mainly to the way in which it handles extensions. However it appears to behave correctly in all states which should be reachable in normal use.)     bccsp/sw/keyimport.go (KeyImport): The KeyImport function for aes256ImportKeyOptsKeyImporter checks that the raw data is exactly 32 bytes long, whereas the one for hmacImportKeyOptsKeyImporter only checks that it is non-empty. Even if the latter permits more than one possible key length (not checked this), it could be better validated for consistency.     Most of these apply to both 1.4 and 2.0. Not sure whether you want low-level observations like these put in Jira.  ></description> </Issue>
