<Issue id="36051" key="FAB-13224" number="13224" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Blocks provider intermitent failure" priority="3" resolution="10000" status="6" created="2018-12-10 22:41:10.0" updated="2019-03-19 10:57:32.0" resolutiondate="2018-12-14 04:59:15.0" votes="0" watches="1" workflowId="47566"> <description><! CDATA There is {{TestBlocksProviderImpl_GetBlockFromSpecified}} intermittent failure in CI:  {quote} 21:25:32 --- FAIL: TestBlocksProviderImpl_GetBlockFromSpecified (1.00s) 21:25:32     <autogenerated>:1:  21:25:32         	Error Trace:	blocksprovider_test.go:97 21:25:32         	            				blocksprovider_test.go:85 21:25:32         	            				blocksprovider_test.go:135 21:25:32         	Error:      	Should be true 21:25:32         	Test:       	TestBlocksProviderImpl_GetBlockFromSpecified {quote}  https://jenkins.hyperledger.org/job/fabric-verify-unit-tests-x86_64/6963/console  there is code which generates test case:  {code} func makeTestCase(ledgerHeight uint64, mcs api.MessageCryptoService, shouldSucceed bool, rcv rcvFunc) func(*testing.T) { 	return func(t *testing.T) { 		gossipServiceAdapter := &mocks.MockGossipServiceAdapter{GossipBlockDisseminations: make(chan uint64)} 		deliverer := &mocks.MockBlocksDeliverer{Pos: ledgerHeight} 		deliverer.MockRecv = rcv 		provider := NewBlocksProvider("***TEST_CHAINID***", deliverer, gossipServiceAdapter, mcs) 		defer provider.Stop() 		ready := make(chan struct{}) 		go func() { 			go provider.DeliverBlocks() 			// Send notification 			ready <- struct{}{} 		}()  		time.Sleep(time.Second)  		assertDelivery(t, gossipServiceAdapter, deliverer, shouldSucceed) 	} } {code}  where assertion is done before provider has been stopped, hence there is probability that during assertion one more block will be delivered:  {code} func assertDelivery(t *testing.T, ga *mocks.MockGossipServiceAdapter, deliverer *mocks.MockBlocksDeliverer, shouldSucceed bool) { 	// Check that all blocks received eventually get gossiped and locally committed  	select { 	case <-ga.GossipBlockDisseminations: 		if !shouldSucceed { 			assert.Fail(t, "Should not have succeede") 		} 		assert.True(t, deliverer.RecvCount() == ga.AddPayloadCount()) 	case <-time.After(time.Second): 		if shouldSucceed { 			assert.Fail(t, "Didn't gossip a block within a timely manner") 		} 	} } {code}  The fix should be to stop provider prior to checking assertion.   ></description> </Issue>
