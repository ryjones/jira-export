<Action id="27863" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" created="2017-07-05 11:48:03.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-05 11:48:03.0"> <body><! CDATA I'm interested in this idea since the scenarios you describe also work when the idea is to interact with an existing System of Record as part of the endorsement logic.  Have you seen the Composer feature (currently experimental) to allow  calls to external REST services|https://hyperledger.github.io/composer/integrating/call-out.html ?  That is leaning on the fact that unless you try to store data from an external call in the transaction (which will then fall foul of non-determinism), getting an opinion from an external service about whether to endorse or not should be OK (their section on "Idempotency and Consenus" covers some of this).  I don't think Composer has solved the problem of different endorsers all making the same service request and having some local variation in the service provider (ie is it intended that they all ask the same common service instance the same question, or should the service call resolve to a locally-specified service instance not shared with other endorsers?).  So you're idea for local configuration is interesting - it would allow different peers to rely on local config to make such requests with more explicit config.  I think the idea of local peer variation for endorsement logic execution is actually separable from the notion that there is some local data stored uniquely in the DB of the peer.  ></body> </Action>
<Action id="27864" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" body="(I also suggested an update to your google doc - the link to this item wasn&apos;t complete.)" created="2017-07-05 11:57:15.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-05 11:57:15.0"/>
<Action id="27867" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" created="2017-07-05 13:01:00.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-05 13:01:00.0"> <body><! CDATA OK... I'm missing something fundamental here (perhaps it's hidden in the description of the demo which I've not fully digested yet). You want to hide some information from some of the endorsers (all except one in the extreme case) by relying on encryption to keep it from the excluded peers. So this has to arrive in a transaction from the client... it can't be injected during the execution of the endorsement logic - so there's a coupling of the encryption between the client and the included peer(s), and the chain code needs to tolerate that data that it's local config does not provide the keys to decrypt should be just passed through (ignored).  Is that correct?  As you say, local config could provide more than just keys to this data - you mention the possibility I'm interested in ('tokens for access to an external resource or API').   ></body> </Action>
<Action id="27923" issue="18863" author="baohua" type="comment" created="2017-07-06 06:19:42.0" updateauthor="baohua" updated="2017-07-06 06:19:42.0"> <body><! CDATA One interesting question is how to share the keys between those should access the data? e.g., client gives keys to the chaincode and peer beforehand?  Thanks!  ></body> </Action>
<Action id="27925" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" created="2017-07-06 09:11:37.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-06 09:38:48.0"> <body><! CDATA  ~baohua  - yes, that's what I meant when I said about the coupling of the encryption between the client and the included peers.  If I'm getting the hang of this, then also won't the data be read-only to the endorsing code in the permitted peers (since the excluded peers can do nothing with it), so the permitted peers just need a public key in order to look at the data? Oh... or am I getting the public/private keys the wrong way round?  ></body> </Action>
<Action id="27926" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" body="Have you considered whether the privacy scope is better associated with an organisation than the infrastructure elements such as peers? (I&apos;ve not got the relationship between orgs and channels straight enough in my head to answer that with confidence myself.)" created="2017-07-06 09:46:07.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-06 09:46:24.0"/>
<Action id="27954" issue="18863" author="ianj_mitchell@uk.ibm.com" type="comment" body="I&apos;ve realised I&apos;ve not fully absorbed the peer communication piece of this properly - have to read more fully." created="2017-07-06 15:56:46.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-06 15:56:46.0"/>
<Action id="28246" issue="18863" author="tzipih0" type="comment" created="2017-07-12 15:09:28.0" updateauthor="tzipih0" updated="2017-07-12 15:09:28.0"> <body><! CDATA  ~ianj_mitchell@uk.ibm.com  - concerning the privacy scope, we agree that it might better be associated with an organisation rather than peers. Maybe the two options should be given.   ~ianj_mitchell@uk.ibm.com  and  ~baohua  - concerning keys: there should indeed be a way to populate the local configuration and write into it the keys. The chaincode cannot write directly to the local configuration with our current proposal.   ~ianj_mitchell@uk.ibm.com  - the private key is used to decrypt data, while the public key is used to encrypt data. So the client might only have the public key, but the peer really needs to have the private key, as it needs to decrypt data from the ledger.  ></body> </Action>
<Action id="33156" issue="18863" author="fredbi" type="comment" created="2017-10-25 11:46:51.0" updateauthor="fredbi" updated="2017-10-25 11:46:51.0"> <body><! CDATA Hello.  I've read the document (but not the code) and you get many strong points.  There are however some assumptions that require an advanced knowledge of the current status of hyperledger.  It might be worth clarifying some of these points.  Overall, a highly required feature in my opinion: nice work, thumbs up. h2. Assumptions/Assertions where clarification might be needed  _- P.2 "The current Hyperledger Fabric architecture has some limited support for private data, but it is not nearly enough for applications such as above. For example, private channels can only be used for a complete partition of the data, where access to the data on a given channel is all-or-nothing. Moreover, hiding data in a private channel means that it cannot be a part of any transaction on any other channel."_  I understand the idea about private channels. For permissioned channels, mixing peers vs channel is, in my understanding, misleading. In the current (v1.0.3) setup, I assume it is possible for a chaincode to exist on a channel where only some peers have acces to it, while other participants to the channel (which are not peers for this chaincode) cannot have access to its state and tx.  Example: let us-channel be a channel for all US corporations. Let ibm-sales a CC with peers peer 0  org: IBM Corp  and 3 others from 3 distinct organizations (org1, org2, org3). My assumption is that peers from another organization on the same channel (say Microsoft) may be barred from deploying this chaincode and cannot query/invoke ibm-sales CC.  P.2 "_To support private data, some of the information on the ledger is kept in an encrypted form, under keys that are only available to those peers that are allowed to see it._"  The setup is not clear from what follows. I understand that "decryption keys" (shared secret key?) are stored there, but nothing is told about how "state variable keys" are referred to.  An additional note: when using couchdb as a JSON store, state variable keys are mapped to documents. There is however a difference when data type is not JSON (which I suppose, is the natural outcome of the data encryption process): values are stored in couchdb as attachment to a (stub) document. This means that the document db has not the same structure for all peers. peers with crypted documents should restrain to attempt rich-queries which would fail.  Conducting experiments with JSON data should help clarifying this behavior.  P.4 "_To be able to handle data that is only visible to some peers but not others, the endorsement process must allow communication between peers_"  Current transaction workflow isolates peers from each other: endorsing peers take their decisions independently, other peers just apply endorsed decisions after ordering by an independant ordering service.  It doesn't appear clearly in the doc why endorsing peers must communicate directly (maybe it is in the code): after all, the outcome of endorsement is just a signature. I understand that the outcome of one's peer simulation on encrypted bits must be broadcast to other endorsing peers then merged so all of them may converge to the same state before ordering.  Could this be clarified?     § Appendix: "uses homomorphic encryption"  Question: I understand the need for ZK proof in the protocol established between endorsing peers. However, no precision is given regarding the encryption of data themselves. Could this encryption be designed as pluggable? An interesting use-case could be to use attribute based encryption so that no secret needs to be shared between peers. h2. Strong points - but separate concern (=> could be split in shorter stories and prioritized differently)  *local conf for CC*:  as well state, it is a highly desirable feature, not necessarily related to privacy.  *GetPeerId():* in other words, "who am I". This extension proposal is indeed much needed, and is not specific to private date.  My understanding: this function would prove very useful to implement "oracles": an oracle is a peer with access to an external interface. Among endorsement peers, not all of them may implement this interface: it is therefore important that the endorsement logics may differ according to peers.  Other example: distinct legal/business check duties. If several endorsement peers have distinct validation requirements, it is important that the chaincode is able to reproduce this split of responsibilities. Hence, GetPeerId().        ></body> </Action>
<Action id="33194" issue="18863" author="shaih" type="comment" created="2017-10-25 20:16:53.0" updateauthor="shaih" updated="2017-10-25 20:16:53.0"> <body><! CDATA Hi Frédéric, thanks for the detailed comment. Here is my take on things: h3. *Are channels really all-or-nothing*  My understanding of channels is that they are all-or-nothing, i.e. if a peer belongs to some channel then that peer can see every variable on that channel. If this is incorrect (i.e., you can restrict some variables on a channel to only a subset of the peers) then we may be able to use that facility also for the type of transactions that we want to support in this proposal. (Of course, we would still need to implement the protocols themselves, which would still require the two changes in the current proposal.) h4. *Decryption keys*  Keys are *not* stored on the ledger, and are *not* shared between the peers. These are cryptographic encryption/decryption keys, where each peer has access only to its own keys. (The mechanisms for key management are out of scope for this proposal, but likely we will use the same mechanisms that are now used for signature keys and other credentials.) When a peer is running, these keys are loaded into some local store. A chain-code running on this peer then uses the GetLocalConf(...) interface that we propose here to access these keys. h4. *Inter-peer communication during endorsement*  This is a crucial point, so let me try to clarify with a simple example. Imagine a transaction that depends on variable X that only peer1 is allowed to see and variable Y that only peer2 is allowed to sees, where the transaction should only take place if X>Y. No peer separately has enough information to make the determination if the transaction should be endorsed or not, so communication between these peers is required.  There is an extra complication that comes from the fact that none of them can communicate its value to the other in cleartext form, this is where we use the crypto-magic that lets you compute on values without revealing them in the clear. But this aspect is orthogonal to the current proposal (and does not require any changes to the fabric), the only changes we need it the ability to communicate and to access the encryption keys. h4. *Homomorphic encryption*  I didn't understand this comment     ></body> </Action>
<Action id="63029" issue="18863" author="mastersingh24" type="comment" body="This was implemented via the private data feature starting in v1.2.x" created="2019-08-18 11:47:09.0" updateauthor="mastersingh24" updated="2019-08-18 11:47:09.0"/>
