<Issue id="15360" key="FAB-2788" number="2788" project="10002" reporter="ryokawajp" creator="ryokawajp" type="10004" summary="Peer response becomes slow and finally crashed after writing many entries to World State" priority="3" resolution="10000" status="6" created="2017-03-15 07:42:28.0" updated="2018-07-20 14:12:00.0" resolutiondate="2017-04-12 15:58:05.0" votes="0" watches="4" workflowId="37792"> <environment><! CDATA - Fabric v0.6.0-preview docker image,  - HFC for Node.js 0.6.5,  - consensus=noop,  - batch size=1 - one peer  ></environment> <description><! CDATA I understand that Table API and Rocks DB are no longer supported in Fabric v1.0, but just want to share this information with v0.6.  - During a long run (about one or two days), Client 1 sends many transactions using HFC for Node.js. The chaincode recorded the contents of the transactions to World State, creating one key for one transaction with Table API. - Approximately 0.1-0.5 transactions per second. - I guess there were approximately 10K records. - Another client (Client 2) queries a small amount of records (about 10 records), or invokes a transaction with very low frequency (less than 0.01 TPS). - During the long run, the response time of the query / invoke by Client 2 becomes gradually slower by approx. 2x - 5x. One query requires 20 seconds. - Sometimes the peer crashes. - The error messages are not always the same. Typical two errors are attached. - The crash may be accompanied by chaincode crash or may not.  I got a kind comment from Manish that when there are a large number of entries in World State and one queries a small number of entries, ledger.state.dataStructure.name='trie' instead of 'bucketree' in core.yaml gives a better performance. https://github.com/hyperledger/fabric/blob/v0.6/peer/core.yaml#L360  So as a workaround, -I tried 'trie' configuration with a few thousand records and up to now, I observe no response time increase nor crash. Looks working fine to me.- - Sorry. I found a mistake in a test case. Let me confirm it later.  I believe that Problem 1 of this JIRA item does not apply to our case because we only query small number of items up to 10. While Problem 2 could apply because we are using v0.6.0. https://jira.hyperledger.org/browse/FAB-860  The error message and its situation are similar to this JIRA item, but we did not see "Timeout expired while executing transaction". Instead we see "Context canceled". https://jira.hyperledger.org/browse/FAB-1163  A sample chaincode program to be attached later. Error 1. (I remember that this crash happened when I send an Invoke TX) {noformat}  31m15:04:23.654  chaincode  processStream -> ERRO 01d 0m Error handling chaincode support stream: stream error: code = 1 desc = "context canceled" pure virtual method called terminate called without an active exception SIGABRT: abort PC=0x7f07cf69ec37 m=8 signal arrived during cgo execution  goroutine 1134  syscall, locked to thread : runtime.cgocall(0xbb7a90, 0xc8249636c0, 0x0) 	/opt/go/src/runtime/cgocall.go:123 +0x11b fp=0xc824963670 sp=0xc824963640 github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb._Cfunc_rocksdb_iter_seek(0x7f07bc000930, 0xc820a18690, 0xe1) 	github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb/_obj/_cgo_gotypes.go:1090 +0x3a fp=0xc8249636c0 sp=0xc824963670 github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb.(*Iterator).Seek(0xc8200205e8, 0xc820a18690, 0xe1, 0xf0) 	/opt/gopath/src/github.com/hyperledger/fabric/vendor/github.com/tecbot/gorocksdb/iterator.go:93 +0xd1 fp=0xc824963730 sp=0xc8249636c0 github.com/hyperledger/fabric/core/ledger/statemgmt/buckettree.(*RangeScanIterator).seekForStartKeyWithinBucket(0xc8249ae930, 0xb22c3) 	/opt/gopath/src/github.com/hyperledger/fabric/core/ledger/statemgmt/buckettree/range_scan_iterator.go:92 +0x9a fp=0xc824963790 sp=0xc824963730 github.com/hyperledger/fabric/core/ledger/statemgmt/buckettree.(*RangeScanIterator).Next(0xc8249ae930, 0xf9e620) 	/opt/gopath/src/github.com/hyperledger/fabric/core/ledger/statemgmt/buckettree/range_scan_iterator.go:70 +0x634 fp=0xc8249639f8 sp=0xc824963790 github.com/hyperledger/fabric/core/ledger/statemgmt/state.(*CompositeRangeScanIterator).Next(0xc8249b3860, 0xc8214c2bb0) 	/opt/gopath/src/github.com/hyperledger/fabric/core/ledger/statemgmt/state/composite_range_scan_iterator.go:51 +0x183 fp=0xc824963af8 sp=0xc8249639f8 github.com/hyperledger/fabric/core/ledger/statemgmt/state.(*CompositeRangeScanIterator).Next(0xc8249b3860, 0xc8214c2ab0) 	/opt/gopath/src/github.com/hyperledger/fabric/core/ledger/statemgmt/state/composite_range_scan_iterator.go:79 +0x7e2 fp=0xc824963bf8 sp=0xc824963af8 github.com/hyperledger/fabric/core/ledger/statemgmt/state.(*CompositeRangeScanIterator).Next(0xc8249b3860, 0xc824929000) 	/opt/gopath/src/github.com/hyperledger/fabric/core/ledger/statemgmt/state/composite_range_scan_iterator.go:79 +0x7e2 fp=0xc824963cf8 sp=0xc824963bf8 github.com/hyperledger/fabric/core/chaincode.(*Handler).handleRangeQueryState.func1(0xc822b3c180, 0xc823783a90) 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:729 +0xb85 fp=0xc824963f90 sp=0xc824963cf8 runtime.goexit() 	/opt/go/src/runtime/asm_amd64.s:1998 +0x1 fp=0xc824963f98 sp=0xc824963f90 created by github.com/hyperledger/fabric/core/chaincode.(*Handler).handleRangeQueryState 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:774 +0x3f  (stack trace continues ...) {noformat}  Error 2 {noformat} panic: runtime error: invalid memory address or nil pointer dereference 	panic: runtime error: invalid memory address or nil pointer dereference  signal 0xb code=0x1 addr=0x0 pc=0x7789b1   goroutine 436555  running : panic(0xd96880, 0xc8200120b0) 	/opt/go/src/runtime/panic.go:464 +0x3e6 github.com/hyperledger/fabric/core/chaincode.(*Handler).handleRangeQueryStateClose.func1.1(0xc820470180, 0xc8228d83c0, 0xc820927ea0) 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:911 +0x261 panic(0xd96880, 0xc8200120b0) 	/opt/go/src/runtime/panic.go:426 +0x4e9 github.com/hyperledger/fabric/core/chaincode.(*Handler).getRangeQueryIterator(0xc820470180, 0x0, 0xc8234c8b70, 0x24, 0x0, 0x0) 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:155 +0x89 github.com/hyperledger/fabric/core/chaincode.(*Handler).handleRangeQueryStateClose.func1(0xc820470180, 0xc8228d83c0) 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:925 +0x52f created by github.com/hyperledger/fabric/core/chaincode.(*Handler).handleRangeQueryStateClose 	/opt/gopath/src/github.com/hyperledger/fabric/core/chaincode/handler.go:945 +0x3f {noformat}  A sample program added. This program queries 10 records which have a common prefix using RangeQueryState(), from World State which also has 20000 entries of a different prefix.  As in memo2.txt, the result shows that the query time increased by 6 times in the case of "buckettree" and no increase observed in the case of "trie". In either cases, I did not observe crashes (it took only 3.5s in the worst case.).  After you deployed the chaincode to a blockchain network of a clean database, you can run {noformat} time ./query.sh ./create_keys_l.sh time ./query.sh {noformat} (it takes 20 minuites to run the second step.)   ></description> </Issue>
