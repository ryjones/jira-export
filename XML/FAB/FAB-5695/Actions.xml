<Action id="29722" issue="20082" author="yacovm" type="comment" created="2017-08-11 14:03:32.0" updateauthor="yacovm" updated="2017-08-11 14:03:32.0"> <body><! CDATA {quote}This means that a client receives all events from the peer (that they are interested in).{quote} I don't understand - this is in contrast to receiving events from all peers in the channel? Is the goal here to have a distributed event service that would propagate events from peers to other peers and then to clients?  {quote} Adding ACL checks to this framework in addition to being unwieldy would also create a processing overhead{quote} Why? You check if the client is eligible for receiving events for the type that it requests at subscription time, and then upon config update - you revalidate this subscription. The orderer does just that (  ~jyellick  correct me please if I'm wrong) for *Deliver*.  {quote} as we'd have to cycle through every client for every event whether they are interested in the channel or not.{quote} This is an implementation detail, no? If we pass the event in the subscription message the client sends, we won't have to - unless I'm missing something  {quote}While this could be done by extending the event framework, adding a channel level context  with ACL support on the peer wide framework is clugy.{quote} Why?  {quote}A new channel service could be implemented on the peer endpoint to prepare for future ACL on events{quote} I don't understand why we need a new gRPC service for this.  Why can't we just expand the  event proto|https://github.com/hyperledger/fabric/blob/release/protos/peer/events.proto  with a channel?       ></body> </Action>
<Action id="29732" issue="20082" author="jyellick" type="comment" created="2017-08-11 15:35:03.0" updateauthor="jyellick" updated="2017-08-11 15:35:03.0"> <body><! CDATA > Why? You check if the client is eligible for receiving events for the type that it requests at subscription time, and then upon config update - you revalidate this subscription. > The orderer does just that ( Jason Yellick correct me please if I'm wrong) for Deliver.  Absolutely correct.  The APIs are already built to invoke callbacks on changes, so this is very easy to implement within the configuration/policy framework.  Simply re-validate any existing subscriptions on change, and the overhead should be minimal.  ></body> </Action>
<Action id="29737" issue="20082" author="mastersingh24" type="comment" created="2017-08-11 16:36:32.0" updateauthor="mastersingh24" updated="2017-08-11 16:36:32.0"> <body><! CDATA This really comes down to the fact that the existing eventHub was actually designed as an integration endpoint and not as an endpoint for notifying clients if transactions were successful.  But back in v0.6 days we started down this path and it has continued to date.  There are 2 common event cases:  1) (MOST COMMON) Clients simply want to be notified that their transactions have been committed and/or if there were any failures  2) Integration with legacy / enterprise applications (less common but the original intent of the eventHub)  So when the requirement came up to start to limit access to events (specifically for clients and transactions by channel), it made sense to me that we should start with a fresh service and build up from there rather than try to keep misusing the original service.  And while we can technically bind the same service to multiple endpoints, it also does not make sense that clients should have to connect to a different endpoint to get response for transactions nor does it make sense that the endpoint for enteprise integration be exposed publicly  ></body> </Action>
<Action id="29741" issue="20082" author="muralisr" type="comment" body="+1 to  ~mastersingh24  ...would be gilding the lily to add more." created="2017-08-11 17:56:48.0" updateauthor="muralisr" updated="2017-08-11 17:56:48.0"/>
<Action id="29743" issue="20082" author="yacovm" type="comment" created="2017-08-11 18:02:56.0" updateauthor="yacovm" updated="2017-08-11 18:02:56.0"> <body><! CDATA {quote}1) (MOST COMMON) Clients simply want to be notified that their transactions have been committed and/or if there were any failures{quote} If that's any use - we have a  pub sub|https://github.com/hyperledger/fabric/blob/release/gossip/util/pubsub.go  implementation in gossip  ></body> </Action>
<Action id="31555" issue="20082" author="yacovm" type="comment" created="2017-10-03 11:37:37.0" updateauthor="yacovm" updated="2017-10-03 11:37:37.0"> <body><! CDATA Another important thing - we need a way to make the channel service to re-evaluate all connected clients in terms of access control- when a config update (or, when RSCC is merged - also an RSCC update) happens - the service needs to re-compute policies regarding to all registrations of connected clients.  I currently don't see such support in the ACL related change set.  * We need to save the signed events in some data structure in the server.go and whenever there is a config update, we need to re-evaluate all subscriptions.  * We need to provide a method of providing the channel service with a callback that would notify a config update has happened.  ~jyellick 's config framework  provides such a thing|https://github.com/hyperledger/fabric/blob/master/core/peer/peer.go#L293-L298 . * I also think that since we're building this now, we might as well address the server-side support for the  transferable events|https://jira.hyperledger.org/browse/FAB-4824  which isn't included in the change set series.    ~wlahti    ></body> </Action>
<Action id="31557" issue="20082" author="wlahti" type="comment" created="2017-10-03 12:08:14.0" updateauthor="wlahti" updated="2017-10-03 12:08:14.0"> <body><! CDATA Agreed on all points.  In regards to reevaluating after an update, that's why I created subtask FAB-6160. The last I was aware, the ability to update RSCC policies hadn't yet been implemented.   For the event relay security hole, yes, I think I can reincorporate that CR (updating it according to the latest JIRA discussion) into this series of CRs now that the concerns expressed by Murali have been responded to by Elli.     ></body> </Action>
<Action id="31558" issue="20082" author="yacovm" type="comment" created="2017-10-03 12:11:46.0" updateauthor="yacovm" updated="2017-10-03 12:42:14.0"> <body><! CDATA We need to re-evaluate also upon config update, not just RSCC update.  Can you perhaps change FAB-6160 to include that?   Edit: I see you have. thanks.  So, I think we need JIRA sub-task(s) to handle the bullets I outlined.  I'd like to help at least with the design, would you like to sync with me on this?  ></body> </Action>
<Action id="35566" issue="20082" author="denyeart" type="comment" body="This is now being implemented using Deliver API (FAB-6911)." created="2017-11-28 11:31:36.0" updateauthor="denyeart" updated="2017-11-28 11:34:19.0"/>
<Action id="35991" issue="20082" author="wlahti" type="comment" body="Marking this item as done now that the Deliver service is available on the peer via FAB-6911. " created="2017-12-07 15:54:31.0" updateauthor="wlahti" updated="2017-12-07 15:54:31.0"/>
<Action id="38310" issue="20082" author="yacovm" type="comment" created="2018-01-08 19:41:59.0" updateauthor="yacovm" updated="2018-01-08 19:47:52.0"> <body><! CDATA Sorry for the thread necromancy, but this comment by me which  ~wlahti  said that he added to this JIRA, should have migrated to the peer deliver service ( good thing  ~C0rWin  mentioned it in gerrit because I think everyone (including me) forgot about it ).     We currently have no way of detecting an RSCC policy ACL update, which means that if a client is connected to the peer's deliver service (or to the legacy event service ? Do we use that there too?) and the policy changes such that it it should have not been able to connect if he had re-connected - then we need: * A way to detect this reconfiguration * To connect this to the peer and act accordingly.        Or - I could be wrong and the ability to update the ACL isn't implemented / supported from some reason (I don't know)     !Capture.PNG|thumbnail!  ></body> </Action>
<Action id="38311" issue="20082" author="yacovm" type="comment" created="2018-01-08 20:14:43.0" updateauthor="yacovm" updated="2018-01-08 20:14:43.0"> <body><! CDATA Actually I might be wrong and we have  this thing|https://github.com/hyperledger/fabric/blob/master/core/peer/peer.go#L328-L334  here that can be used for this.      ~jyellick  can you confirm ?  ></body> </Action>
<Action id="38312" issue="20082" author="denyeart" type="comment" body="Thanks for the reminder  ~yacovm .  Accordingly I have moved FAB-6160 for the event re-evaluation over to the Deliver Service JIRA item - FAB-6911.  It sounds like there is infrastructure in place to register to resource bundle changes, which can then be used for the event re-evaluation." created="2018-01-08 20:15:41.0" updateauthor="denyeart" updated="2018-01-08 20:15:41.0"/>
<Action id="38322" issue="20082" author="yacovm" type="comment" created="2018-01-08 21:42:36.0" updateauthor="yacovm" updated="2018-01-08 21:42:36.0"> <body><! CDATA So,   ~jyellick  came up with a really neat idea how to make this change easily using his resource config bundle code.  I implemented it in  https://gerrit.hyperledger.org/r/#/c/16677/   ></body> </Action>
