<Issue id="39538" key="FAB-15294" number="15294" project="10002" reporter="ales" creator="ales" type="10004" summary="The validator accepts transactions for _lifecycle on channels &lt;2.0" priority="2" resolution="10203" status="6" created="2019-04-27 09:09:38.0" updated="2019-07-31 17:39:53.0" resolutiondate="2019-07-31 17:39:53.0" votes="0" watches="10" workflowId="52418" security="10000"> <description><! CDATA h1. Problem  The validator for versions <2.0 determines the validation information for a transaction in a different way depending on whether the chaincode is an application chaincode or a system chaincode: {code:java} if !v.sccprovider.IsSysCC(ccID) { // when we are validating a chaincode that is not a // system CC, we need to ask LSCC to give us the name // of VSCC and of the policy that should be used  ...  } else { // when we are validating a system CC, we use the default // VSCC and a default policy that requires one signature // from any of the members of the channel p := cauthdsl.SignedByAnyMember(v.cr.GetMSPIDs(chdr.ChannelId)) policy, err = protoutil.Marshal(p) if err != nil { return nil, nil, nil, err } } {code} The snippet above shows that system chaincodes receive by default an endorsement policy allowing ledger writes to any member of any org currently defined in the channel.  Unfortunately, the {{_lifecycle}} system chaincode is a registered system chaincode since release 1.3, and so peer binaries at versions 1.3, 1.4 and 2.0 operating with <2.0 capability will consider any transaction writing to {{_lifecycle}} as valid if it is signed by any member (even a client SDK certificate will qualify). h1. Fixes  Unfortunately the fix is not obvious. The addition of {{_lifecycle}} as a registered system chaincode may already have caused forks because it was not gated via a capability: on a channel with a 1.2 capability, a transaction writing to {{_lifecycle}} would be considered as valid by a 1.3 peer binary and invalid by a 1.2 peer binary.  Clearly, its removal (without a capability gate) may equally become the cause of forks.   Note that this flaw makes the attack in FAB-15290 even simpler.  ></description> </Issue>
