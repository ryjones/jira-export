<Issue id="16966" key="FAB-4078" number="4078" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10004" summary="StateInfo expiration should only expire dead peers and not the self peer" priority="1" resolution="10000" status="6" created="2017-05-21 13:55:22.0" updated="2018-07-20 14:12:53.0" resolutiondate="2017-05-29 23:21:26.0" votes="6" watches="5" workflowId="38617" security="10001"> <description><! CDATA * The stateInfo message store is used in gossip to know the membership of the peers of the channel. * Each entry in the message store is the latest StateInfo message a peer has sent either directly or indirectly. * Peers send StateInfo messages in the following manner: ** Upon reception of a block, a new StateInfo message is created and is propagated to adjacent peers. ** Once in a while, a peer send StateInfo pull requests to adjacent peers and they send back the entire StateInfo message set stored in their memory that they have received from other peers (reconciliation).  However - the StateInfo message store is an expirable message store - its messages are expired after a limited time.  This causes the following problem: If no new blocks are generated in the channel, no new StateInfo messages are generated as a result, and eventually - the StateInfo messages of peers are cleaned up from memory.   This causes many problems, namely that when a new peers joins a channel after no new blocks were created in that channel for a while - it will not get StateInfo messages from other peers and thus won't be able to pull blocks from them, unless it is configured to use leader election, and then it will elect itself as a leader and connect directly to the ordering service.  The following test shows this problem: {code} func TestMsgStoreNotExpire(t *testing.T) { 	t.Parallel()  	cs := &cryptoService{} 	adapter := new(gossipAdapterMock) 	cs.Mock = mock.Mock{} 	cs.On("VerifyBlock", mock.Anything).Return(nil)  	org := api.OrgIdentityType("ORG1")  	pkiID1 := common.PKIidType("1") 	pkiID2 := common.PKIidType("2") 	pkiID3 := common.PKIidType("3")  	peer1 := discovery.NetworkMember{PKIid: pkiID1, InternalEndpoint: "1", Endpoint: "1"} 	peer2 := discovery.NetworkMember{PKIid: pkiID2, InternalEndpoint: "2", Endpoint: "2"} 	peer3 := discovery.NetworkMember{PKIid: pkiID3, InternalEndpoint: "3", Endpoint: "3"}  	adapter.On("GetOrgOfPeer", pkiID1).Return(org) 	adapter.On("GetOrgOfPeer", pkiID2).Return(org) 	adapter.On("GetOrgOfPeer", pkiID3).Return(org) 	adapter.On("ValidateStateInfoMessage", mock.Anything).Return(nil) 	adapter.On("GetMembership").Return(  discovery.NetworkMember{peer1, peer2, peer3}) 	adapter.On("DeMultiplex", mock.Anything) 	adapter.On("Gossip", mock.Anything) 	adapter.On("GetConf").Return(conf)  	gc := NewGossipChannel(pkiID1, org, cs, channelA, adapter, &joinChanMsg{}) 	gc.UpdateStateInfo(createStateInfoMsg(1, pkiID1, channelA)) 	// Receive StateInfo messages from other peers 	gc.HandleMessage(&receivedMsg{PKIID: pkiID2, msg: createStateInfoMsg(1, pkiID2, channelA)}) 	gc.HandleMessage(&receivedMsg{PKIID: pkiID3, msg: createStateInfoMsg(1, pkiID3, channelA)})  	simulateStateInfoRequest := func(pkiID   byte, outChan chan *proto.SignedGossipMessage) { 		sentMessages := make(chan *proto.GossipMessage, 1) 		// Ensure we respond to stateInfoSnapshot requests with valid MAC 		snapshotReq := &receivedMsg{ 			PKIID: pkiID, 			msg: (&proto.GossipMessage{ 				Tag: proto.GossipMessage_CHAN_OR_ORG, 				Content: &proto.GossipMessage_StateInfoPullReq{ 					StateInfoPullReq: &proto.StateInfoPullRequest{ 						Channel_MAC: GenerateMAC(pkiID, channelA), 					}, 				}, 			}).NoopSign(), 		} 		snapshotReq.On("Respond", mock.Anything).Run(func(args mock.Arguments) { 			sentMessages <- args.Get(0).(*proto.GossipMessage) 		})  		go gc.HandleMessage(snapshotReq) 		select { 		case <-time.After(time.Second): 			t.Fatal("Haven't received a state info snapshot on time") 		case msg := <-sentMessages: 			for _, el := range msg.GetStateSnapshot().Elements { 				sMsg, err := el.ToGossipMessage() 				assert.NoError(t, err) 				outChan <- sMsg 			} 		} 	}  	c := make(chan *proto.SignedGossipMessage, 3) 	simulateStateInfoRequest(pkiID2, c) 	assert.Len(t, c, 3)  	c = make(chan *proto.SignedGossipMessage, 3) 	simulateStateInfoRequest(pkiID3, c) 	assert.Len(t, c, 3)  	time.Sleep(conf.StateInfoExpirationInterval + time.Second)  	c = make(chan *proto.SignedGossipMessage, 3) 	simulateStateInfoRequest(pkiID2, c) 	assert.Len(t, c, 3)  	c = make(chan *proto.SignedGossipMessage, 3) 	simulateStateInfoRequest(pkiID3, c) 	assert.Len(t, c, 3)  } {code}  The 2 assertions below fail after the expiration interval has passed.   ></description> </Issue>
