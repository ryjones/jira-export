<Action id="24173" issue="16966" author="yacovm" type="comment" body="https://gerrit.hyperledger.org/r/#/c/9637/" created="2017-05-23 12:57:11.0" updateauthor="yacovm" updated="2017-05-23 12:57:11.0"/>
<Action id="24422" issue="16966" author="mastersingh24" type="comment" body="I&apos;m good with this. Â We have good test coverage here anyway" created="2017-05-26 09:41:59.0" updateauthor="mastersingh24" updated="2017-05-26 09:41:59.0"/>
<Action id="24423" issue="16966" author="yacovm" type="comment" body="The great test coverage tested that the bug exists... " created="2017-05-26 09:53:21.0" updateauthor="yacovm" updated="2017-05-26 09:53:21.0"/>
<Action id="24475" issue="16966" author="muralisr" type="comment" created="2017-05-26 16:20:55.0" updateauthor="muralisr" updated="2017-05-26 16:20:55.0"> <body><! CDATA  ~yacovm  can you expand upon this for my clueless self  ? :-)  {code:java} ....when a new peers joins a channel after no new blocks were created in that channel for a while - it will not get StateInfo messages from other peers and thus won't be able to pull blocks from them,.... {code}  When a new peer joins its cache is clean and I assume its not in other peers cache anyway. I'm not able to see how doing  `StateInfo expiration should only expire dead peers and not the self peer` help this problem.  ></body> </Action>
<Action id="24509" issue="16966" author="yacovm" type="comment" created="2017-05-26 19:47:04.0" updateauthor="yacovm" updated="2017-05-26 20:38:51.0"> <body><! CDATA So the problem here is: Peers need to hear StateInfo messages from other peers in order to know they are in the channel (note that they know which peers *could* be in the channel but they need to know whether they actually have joined the channel).  For scalability and efficiency reasons - we gossip StateInfo messages via 2 mechanisms: 1) Push to peers new state info messages - this happens when a block is committed and the ledger height is increased, and as a result new state info messages are sent to peers. 2) once in a while, ask from peers StateInfo messages of other peers.   We added Expiration support to the data structure that we use to hold our messages (all types of messages), and as a result- if the channel has no "activity", the stateInfo messages of the peers would evaporate.  The reason it happens only in stateInfo and not in alive messages is that in alive messages, every few seconds a new message is generated, and they replace the old ones so the expiration there is useful and OK, but in StateInfo it's a big problem. {quote} I'm not able to see how doing `StateInfo expiration should only expire dead peers and not the self peer` help this problem.{quote} Now, we still need to expire stateInfo messages of peers that have been long dead. We achieve this by once in a while iterating over the stateinfo message cache and then *asking the membership module* - "do you know who that peer is?" If it doesn't, it means that peer has been long gone, and we can safely delete its state info  message.  ></body> </Action>
<Action id="24564" issue="16966" author="jimthematrix" type="comment" created="2017-05-29 03:47:06.0" updateauthor="jimthematrix" updated="2017-05-29 03:48:27.0"> <body><! CDATA  ~yacovm  thanks for the detailed explanation. so this happens when the interval b/w transactions for that channel exceeds the "stateInfoRetentionInterval". wouldn't this problem be circumvented by setting the stateInfoRetentionInterval value to large enough for the expected largest transaction interval? I think a business app should have a rough idea of what that is, right? Would that be considered a bad practice, or have undesired consequences?  Trying to see if this can be documented for v1.0 and fixed in the next iteration.  ></body> </Action>
<Action id="24570" issue="16966" author="yacovm" type="comment" created="2017-05-29 05:31:38.0" updateauthor="yacovm" updated="2017-05-29 05:31:38.0"> <body><! CDATA {quote}so this happens when the interval b/w transactions for that channel exceeds the "stateInfoRetentionInterval". {quote} Yeah. {quote} wouldn't this problem be circumvented by setting the stateInfoRetentionInterval value to large enough for the expected largest transaction interval? I think a business app should have a rough idea of what that is, right?{quote} Well, you can't set this value per channel. This value is set per peer, and at the same time must be identical across peers in all channels otherwise the messages might never expire because of a distributed feedback cycle (peer p expires a message, peer q doesn't, peer q sends peer p the message and peer p considers it a new one. peer q expires the message, now peer p sends peer q the message, etc. etc. Our message Store has a mechanism that makes sure this distributed cycle doesn't happen but it only works if the retention interval is configured the same)  {quote}Trying to see if this can be documented for v1.0 and fixed in the next iteration.{quote} There is no way of fixing this without coding intervention. This bug already exists in alpha2, so and I think also in alpha, so fixing this would also make it that a client could run peers with alpha2 version alongside v1.0 and the peers with alpha2 version would be saved with this help.    ></body> </Action>
<Action id="24584" issue="16966" author="denyeart" type="comment" body="The problem appears to be legitimate, and the fix is well thought out, therefore I vote +1." created="2017-05-29 14:53:54.0" updateauthor="denyeart" updated="2017-05-29 14:53:54.0"/>
<Action id="24595" issue="16966" author="christopherferris" type="comment" body="This has also met the criteria and can be merged." created="2017-05-29 17:57:59.0" updateauthor="christopherferris" updated="2017-05-29 17:57:59.0"/>
