<Action id="60012" issue="39817" author="manish-sethi" type="comment" created="2019-05-15 03:11:31.0" updateauthor="manish-sethi" updated="2019-05-15 03:11:31.0"> <body><! CDATA Ah, don't know how this fact slipped through my mind that the encoding scheme for block numbers is not varint and it could contain nil bytes :-(  However, considering this, we have even bigger problem i.e., clashes are possible in the keys if they keys were to contain empty bytes. I could construct one such example - the historydb key for both <ns, key, 16777473, 1> and <ns, key\x00\x04\x01, 1, 1> would be same (the tuple is in the format <namespace, key, blockNum, tranNum>).  Perhaps, we will have to go with the alternate approach that we did not go earlier since that required rebuilding historydb  - https://gerrit.hyperledger.org/r/#/c/26155/  ></body> </Action>
<Action id="60021" issue="39817" author="denyeart" type="comment" created="2019-05-15 11:01:18.0" updateauthor="denyeart" updated="2019-05-15 11:05:32.0"> <body><! CDATA In v1.x we can further extend the https://gerrit.hyperledger.org/r/#/c/26174/ fix.  If blockNumTranNumBytes contains nil character AND blockNumTranNumBytes decodes to a valid block and tran number (like 256), then it may be a valid entry and we should check the block/tran number in block storage (see next step). If blockNumTranNumBytes contains nil character AND blockNumTranNumBytes does not decode to a valid block and tran number, then we know it was a false entry (user key with nils) and we can immediately remove it from the result set.  For the entries that passed the first check above, we already pull the associated block/tran from block storage to get the write set for the key.  If we don't find the block/tran or don't find the expected key in the block/tran write set, then we know it was a false entry in the result set and we can then exclude it from the ultimate result set that gets returned to the client.  This additional check will resolve the problem that https://gerrit.hyperledger.org/r/#/c/26174/ introduced.  In v2.0, we can rebuild history db to a new format that protects against these edge cases.  ></body> </Action>
<Action id="60030" issue="39817" author="manish-sethi" type="comment" body="We can certainly go for next level of hack to solve this problem partially. However, lets be clear that the final result set could still be missing of entries that may have possibly be overwritten because of key clashes - because the underlying key encoding scheme is not lossless." created="2019-05-15 14:26:15.0" updateauthor="manish-sethi" updated="2019-05-15 14:26:15.0"/>
<Action id="60225" issue="39817" author="baohua" type="comment" created="2019-05-21 23:32:43.0" updateauthor="baohua" updated="2019-05-21 23:32:43.0"> <body><! CDATA Seems no perfect solution now. I feel we can improve as david suggested, and mark this as known issue in 1.x. The current situation is too easy to cause issues.  ></body> </Action>
<Action id="60353" issue="39817" author="wenjian" type="comment" created="2019-05-24 13:04:12.0" updateauthor="wenjian" updated="2019-05-24 13:04:12.0"> <body><! CDATA CR:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31519/   Fixed the problem that blocks with blockNum in multiple of 256 are skipped in history search - see Dave's comment above. * decode, pull transaction, and look for key for all blockNumTranNumBytes no matter if it contains a nil byte * skip an entry if its blockNumTranNumBytes contains nil byte and an error occurs in above process     ></body> </Action>
<Action id="60877" issue="39817" author="wenjian" type="comment" created="2019-06-11 15:13:31.0" updateauthor="wenjian" updated="2019-06-11 15:13:31.0"> <body><! CDATA CRs:  2.0:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31519/   1.4:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31807/   1.3:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31808/   1.2:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31814/   1.1:  https://gerrit.hyperledger.org/r/#/c/fabric/+/31835/   ></body> </Action>
<Action id="60901" issue="39817" author="baohua" type="comment" created="2019-06-12 01:07:30.0" updateauthor="baohua" updated="2019-06-12 01:07:30.0"> <body><! CDATA Thanks for the fixing,  ~wenjian .  Besides, wanna indicate that with the "decode, pull transaction, and look for key for all blockNumTranNumBytes no matter if it contains a nil byte", the performance penalty is not be negligible.  Let's consider this in next-gen ledger design.     ></body> </Action>
<Action id="60906" issue="39817" author="wenjian" type="comment" created="2019-06-12 03:18:19.0" updateauthor="wenjian" updated="2019-06-12 11:37:30.0"> <body><! CDATA  ~baohua  Thank you for your comments. Agree that we should revisit key schema in a future release so that we can avoid key clashes and false keys returned in range query.  The performance penalty due to extra validation for false keys really depends on how many false keys fall in the range. For most false keys, we should be able to skip before loading the block from block storage. * Not every key with a nil byte is a false key. Only "key\x00..." are false keys when querying for "key" * Most false keys will be skipped due to decoding error or not being able to consume all the (false) blockNumTranNumBytes in decoding.  * If a false key can be decoded to blockNum/tranNum, either the blockNum or tranNum will be a big number (because a false key has extra bytes in blockNumTranNumBytes), the chance that blockNum/tranNum maps to an existing block/tran is low. Therefore, no need to pull the block/transaction and look for the key in most cases.     ></body> </Action>
<Action id="60921" issue="39817" author="denyeart" type="comment" body="The improved format for history database is planned for v2.0 and tracked by FAB-15490." created="2019-06-12 18:53:12.0" updateauthor="denyeart" updated="2019-06-12 18:53:12.0"/>
