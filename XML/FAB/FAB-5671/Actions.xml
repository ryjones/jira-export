<Action id="29564" issue="20045" author="muralisr" type="comment" created="2017-08-08 19:14:23.0" updateauthor="muralisr" updated="2017-08-08 19:14:23.0"> <body><! CDATA As described in the description we currently do not "instantiate" System CCs on the LSCC's table like we do with user chaincodes (scc's are not instantiated via a proposal). This means that we don't have endorsement policies for the SCCs in the LSCC table and so will fail at commit validation time.  The approach suggested here is a peer wide policy baked into the SCC to be retrieved and used at commit validation time. The problem is that if two peers have different policies for whatever reason (say different versions of peer) then we introduce non-determinism.   We should consider other approaches first (1) try find other means to solve the requirement that gave rise to SCC transactions or (2) use a baked-in policy check as is done for "lscc" validation - signed by channel members - which will be the same on the channel for all peers.              ></body> </Action>
<Action id="29567" issue="20045" author="aleksandar.likic" type="comment" created="2017-08-08 19:55:56.0" updateauthor="aleksandar.likic" updated="2017-08-08 19:55:56.0"> <body><! CDATA  ~muralisr   (1) try find other means to solve the requirement that gave rise to SCC transactions * We have framework components (implemented as SCCs) that need to persist their own data (not application data). Calls could come from a client, or from another CC. I see two ways of implementing this: ** SCC calling a companion user CC to persist data; in this case there should be a way to restrict access to the companion user CC, and currently there isn't. ** SCC persisting data itself  (2) use a baked-in policy check as is done for "lscc" validation - signed by channel members - which will be the same on the channel for all peers. * "sign by any member" should work for these use cases, so +1 for this option     ></body> </Action>
<Action id="29620" issue="20045" author="aleksandar.likic" type="comment" body=" ~muralisr  How do you think we should test SCC persistence? Normally we would add a new SCC that has some persistence, but that would mean adding it to the Fabric core source code, as it&apos;s the only way to do it now." created="2017-08-09 16:35:04.0" updateauthor="aleksandar.likic" updated="2017-08-09 16:35:04.0"/>
<Action id="29625" issue="20045" author="aleksandar.likic" type="comment" created="2017-08-09 18:04:32.0" updateauthor="aleksandar.likic" updated="2017-08-09 18:04:32.0"> <body><! CDATA We could test it using an external SCC, see https://jira.hyperledger.org/browse/FAB-5688     ></body> </Action>
<Action id="29746" issue="20045" author="binhn" type="comment" created="2017-08-11 18:12:11.0" updateauthor="binhn" updated="2017-08-11 18:12:11.0"> <body><! CDATA I would classify this one as bug.  I would proposal that the default behavior is what you mentioned in option 2, but we should look into the possibility of allowing user to instantiate an scc on a channel to bind it to a different endorsement policy and/or with different e/vscc.  ></body> </Action>
<Action id="29752" issue="20045" author="aleksandar.likic" type="comment" body="OK, just changed it to a bug." created="2017-08-11 18:24:41.0" updateauthor="aleksandar.likic" updated="2017-08-11 18:24:41.0"/>
<Action id="29794" issue="20045" author="aleksandar.likic" type="comment" body="The change has been submitted for review, see  https://gerrit.hyperledger.org/r/#/c/12385/.  The existing test cases involving lscc&apos;s persistence should be sufficient for all SCCs, as &apos;lscc&apos; is not hard-coded any more and the code now handles all SCCs the same." created="2017-08-14 10:43:02.0" updateauthor="aleksandar.likic" updated="2017-08-14 10:43:02.0"/>
