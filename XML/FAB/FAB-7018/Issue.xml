<Issue id="23993" key="FAB-7018" number="7018" project="10002" reporter="yacovm" creator="yacovm" type="10001" summary="Error sending in the endorser makes error handling tricky" priority="3" resolution="10001" status="6" created="2017-11-16 23:08:24.0" updated="2020-01-22 22:15:26.0" resolutiondate="2020-01-22 22:15:26.0" votes="0" watches="2" workflowId="35405"> <description><! CDATA In the endorser, whenever an error is returned from the simulation, the peer returns: {code:java}         if res.Status >= shim.ERROR {             endorserLogger.Errorf("simulateProposal() resulted in chaincode response status %d for txid: %s", res.Status, txid)             var cceventBytes   byte             if ccevent != nil {                 cceventBytes, err = putils.GetBytesChaincodeEvent(ccevent)                 if err != nil {                     return nil, errors.Wrap(err, "failed to marshal event bytes")                 }             }             pResp, err := putils.CreateProposalResponseFailure(prop.Header, prop.Payload, res, simulationResult, cceventBytes, hdrExt.ChaincodeId, hdrExt.PayloadVisibility)             if err != nil {                 return &pb.ProposalResponse{Response: &pb.Response{Status: 500, Message: err.Error()}}, err             }              return pResp, &chaincodeError{res.Status, res.Message}         }{code}    However, in the client side in go, nil is always returned in the response: {code:java} func (c *endorserClient) ProcessProposal(ctx context.Context, in *SignedProposal, opts ...grpc.CallOption) (*ProposalResponse, error) {     out := new(ProposalResponse)     err := grpc.Invoke(ctx, "/protos.Endorser/ProcessProposal", in, out, c.cc, opts...)     if err != nil {         return nil, err     }     return out, nil }{code}    I assume that in  java SDK|https://github.com/hyperledger/fabric-sdk-java/blob/13337b64716141995e49f3f0b81e6356fc05a06a/src/main/java/org/hyperledger/fabric/sdk/EndorserClient.java#L89-L102  it's similar and an  exception|https://grpc.io/grpc-java/javadoc/io/grpc/StatusRuntimeException.html  is simply thrown, and although exceptions are serializable, it can't be that you can send an exception down the wire because gRPC is platform independent in java it's impossible to classify the exception according to its cause (chaincode or gRPC failure)  *My first question is - how does a client SDK handle the reasons of the proposal failure?* * The way to recover from a communication error is inherently different than other failures such as access control error, or invalid parameter failures. * Unless I'm wrong - there is no good way for the SDK to distinguish between communication errors to other erros, due to the fact that the cause of the errror / exception is returned as a string and cannot be classified using type inference or some switch on a number, etc.     *My second question is - given the above fact is true - should we fix this? and if so, how?* I guess we can always return the response with nil as the error but that might (?) break compatibility with existing client code (is this true?)         ~muralisr    ~wlahti    ~mastersingh24    ~jimthematrix    ~rickr    ~harrisob@us.ibm.com      ></description> </Issue>
