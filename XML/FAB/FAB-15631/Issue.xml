<Issue id="40419" key="FAB-15631" number="15631" project="10002" reporter="ales" creator="ales" type="10004" summary="LSCC: Malicious LSCC transaction results into LSCC still being writeable after the 2.0 upgrade" priority="2" resolution="10002" status="6" created="2019-06-05 08:05:02.0" updated="2019-08-07 19:46:07.0" resolutiondate="2019-08-07 19:44:26.0" votes="0" watches="12" workflowId="53336" security="10000"> <description><! CDATA h1. Background  The new lifecycle no longer relies on the system chaincode provider to determine which chaincodes are user chaincodes and which are system chaincodes. At validation time, the determination of validation artefacts for any given chaincode is performed in the same way, by querying the lifecycle support interface. This interface currently behaves as follows: * if the chaincode is defined in the new lifecycle, return that definition; * else, if it is defined in the legacy lifecycle, return that definition, * else return an error (and mark the tx as invalid).  This way, legacy system chaincodes which used to be writeable because of the definition returned by the system chaincode provider are in theory no longer writeable, since the new lifecycle will have no definition for them (names of reserved system chaincodes cannot be deployed through the new lifecycle), nor will (in theory) the legacy lifecycle. h1. Issue  It is possible to circumvent this restriction by using the legacy lifecycle (when the channel is still at <2.0 capability) to create a definition for the {{lscc}} namespace. This definition will have no meaning when theÂ channel is still at <2.0 capability because the system chaincode provider will override it. However, as soon as the channel is upgraded to 2.0, LSCC will still be writeable, because the namespace will have a definition in the legacy lifecycle and it will be used. Since the namespace of the legacy lifecycle system chaincode is still writeable, the legacy lifecycle is still "active", despite the fact that by design it shouldn't. h1. PoC  The attached proof of concept shows the following: # While the channel is operating with the 1.4 capability, a malicious org member creates an LSCC transaction that deploys a chaincode called "lscc" # later the channel is upgraded to 2.0 # at this point, the malicious org member is still able to deploy chaincodes using LSCC  h1. Fixes  We need to ensure that the lscc custom validation forbids the deployment of a chaincode with the name "lscc".  ></description> </Issue>
