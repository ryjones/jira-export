<Issue id="15786" key="FAB-3199" number="3199" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10004" summary="Committer should call CSCC upong config block arrival" priority="3" resolution="10000" status="6" created="2017-04-17 09:50:16.0" updated="2018-07-20 14:12:15.0" resolutiondate="2017-06-02 14:35:42.0" votes="6" watches="6" workflowId="38019"> <description><! CDATA Currently while new configuration block arrives from the ordering service no call for CSCC *UpdateConfig* is made, this need to be fixed and once configuration block reaches the committer it has to call the appropriate CSCC.  Right now code which is responsible of any updates regarding new configuration arrival is:  {code}  // createChain creates a new chain object and insert it into the chains func createChain(cid string, ledger ledger.PeerLedger, cb *common.Block) error {  	envelopeConfig, err := utils.ExtractEnvelope(cb, 0) 	if err != nil { 		return err 	}  	configtxInitializer := configtx.NewInitializer()  	gossipEventer := service.GetGossipService().NewConfigEventer()  	gossipCallbackWrapper := func(cm configtxapi.Manager) { 		gossipEventer.ProcessConfigUpdate(&chainSupport{ 			Manager:     cm, 			Application: configtxInitializer.ApplicationConfig(), 		}) 	}  	trustedRootsCallbackWrapper := func(cm configtxapi.Manager) { 		updateTrustedRoots(cm) 	}  	configtxManager, err := configtx.NewManagerImpl( 		envelopeConfig, 		configtxInitializer, 		  func(cm configtxapi.Manager){gossipCallbackWrapper, trustedRootsCallbackWrapper}, 	) 	if err != nil { 		return err 	}  	// TODO remove once all references to mspmgmt are gone from peer code 	mspmgmt.XXXSetMSPManager(cid, configtxManager.MSPManager())  	cs := &chainSupport{ 		Manager:     configtxManager, 		Application: configtxManager.ApplicationConfig(), // TODO, refactor as this is accessible through Manager 		ledger:      ledger, 	}  	c := committer.NewLedgerCommitter(ledger, txvalidator.NewTxValidator(cs)) 	ordererAddresses := configtxManager.ChannelConfig().OrdererAddresses() 	if len(ordererAddresses) == 0 { 		return errors.New("No orderering service endpoint provided in configuration block") 	} 	service.GetGossipService().InitializeChannel(cs.ChainID(), c, ordererAddresses)  	chains.Lock() 	defer chains.Unlock() 	chains.list cid  = &chain{ 		cs:        cs, 		cb:        cb, 		committer: c, 	} 	return nil } {code}  Where relevant part of callback registration for config block arrival is:  {code} 	configtxManager, err := configtx.NewManagerImpl( 		envelopeConfig, 		configtxInitializer, 		  func(cm configtxapi.Manager){gossipCallbackWrapper, trustedRootsCallbackWrapper}, 	) {code}  This should be refactored and replaced with call for *CofigUpdate* from CSCC:  {code} // These are function names from Invoke first parameter const ( 	JoinChain         string = "JoinChain" 	UpdateConfigBlock string = "UpdateConfigBlock" 	GetConfigBlock    string = "GetConfigBlock" 	GetChannels       string = "GetChannels" ) {code}  And   {code} func updateConfigBlock(blockBytes   byte) pb.Response { 	if blockBytes == nil { 		return shim.Error("Configuration block must not be nil.") 	} 	block, err := utils.GetBlockFromBlockBytes(blockBytes) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to reconstruct the configuration block, %s", err)) 	} 	chainID, err := utils.GetChainIDFromBlock(block) 	if err != nil { 		return shim.Error(fmt.Sprintf("Failed to get the chain ID from the configuration block, %s", err)) 	}  	if err := peer.SetCurrConfigBlock(block, chainID); err != nil { 		return shim.Error(err.Error()) 	}  	return shim.Success(nil) } {code}  ></description> </Issue>
