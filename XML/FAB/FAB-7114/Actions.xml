<Action id="35545" issue="24486" author="yacovm" type="comment" created="2017-11-27 23:30:55.0" updateauthor="yacovm" updated="2017-11-27 23:50:53.0"> <body><! CDATA {quote}The client sends the LSCC transaction to peers, collecting enough endorsements to satisfy the endorsement policy as specified in the chaincode metadata in the resources tree. {quote} How exactly do we do that in the peer CLI? It doesn't support multiple endorsements. We use the CORE_PEER_ADDRESS to specify the peer to connect to. Does the instantiator need to know: * The channel "version" (if it's in v1.1 or in v1.0) * What peers to query to satisfy the endorsement policy  ? {quote}  * The client sends the LSCC transaction to peers, collecting enough endorsements to satisfy the endorsement policy as specified in the chaincode metadata in the resources tree.    {quote} So there is no channel instantiation policy now, only endorsement policy, and the instantiation policy is now only local. Correct?     1 more question - how does the client know that phase (4) has successfully completed?  Because, for example - the config fetched from the peer might not be up to date, resulting in a config mismatch at validation, which is silent. And then the next stages will fail. So I guess, we would need a check at LSCC that fails if the config wasn't validated, so that we can fail LSCC to indicate to the user?  ></body> </Action>
<Action id="35553" issue="24486" author="jyellick" type="comment" created="2017-11-28 02:48:11.0" updateauthor="jyellick" updated="2017-11-28 02:48:11.0"> <body><! CDATA {quote} How exactly do we do that in the peer CLI? It doesn't support multiple endorsements. We use the CORE_PEER_ADDRESS to specify the peer to connect to. {quote}  Assuming there is not some other pattern which we use for specifying multiple endpoints in the peer CLI, then we would need to invent something.  Perhaps a new flag to pass 'additional endorsers' or similar?  The particulars of the implementation do not matter too much to me, but this seems to be reasonably easy to achieve technically?  {quote} Does the instantiator need to know: The channel "version" (if it's in v1.1 or in v1.0) What peers to query to satisfy the endorsement policy {quote}  Assuming that the parameters to the LSCC instantiate remain the same, I don't see any reason the client would need to differentiate between v1.0 and v1.1, unless you can think of some reason. I would suggest that yes, the client must know which peers to invoke against to satisfy the endorsement policy, but this is no more onerous than any other chaincode invocation.  {quote} So there is no channel instantiation policy now, only endorsement policy, and the instantiation policy is now only local. Correct? {quote}  Correct.  There is a policy, which governs who can define chaincode configurations in the resource tree, but this is not really an 'instantiation policy', as it defines metadata about a chaincode, it does not instantiate.  The instantiation policy would continue to live inside the chaincode package but would _not_ be part of the RW set.  Instead, the instantiation policy would control whether a peer 1) endorsers an {{Init}} proposal, 2) makes its local copy of the chaincode available for invoke endorsements after the {{Init}} commits.  {quote} 1 more question - how does the client know that phase (4) has successfully completed?  Because, for example - the config fetched from the peer might not be up to date, resulting in a config mismatch at validation, which is silent. And then the next stages will fail. So I guess, we would need a check at LSCC that fails if the config wasn't validated, so that we can fail LSCC to indicate to the user? {quote}  I don't believe this is actually a new problem.  Today, if an instantiate request is sent, and something about it goes wrong (say an MVCC failure) I do not believe that there is any feedback to the user.  Ultimately, if we wish for the CLI to give reliable feedback about success or failure, we would need to implement something via events.  But, just like if the user tries to send an 'invoke' after a failed instantiate, I would expect an error to be returned indicating the cause of the failure (in this case, it would be that the target chaincode is not defined for the channel).  ></body> </Action>
<Action id="35563" issue="24486" author="mastersingh24" type="comment" created="2017-11-28 08:55:36.0" updateauthor="mastersingh24" updated="2017-11-28 08:55:36.0"> <body><! CDATA {quote}*How exactly do we do that in the peer CLI? It doesn't support multiple endorsements. We use the CORE_PEER_ADDRESS to specify the peer to connect to.*  _Assuming there is not some other pattern which we use for specifying multiple endpoints in the peer CLI, then we would need to invent something. Perhaps a new flag to pass 'additional endorsers' or similar? The particulars of the implementation do not matter too much to me, but this seems to be reasonably easy to achieve technically?_ {quote}  In the short term, I think you are stuck with the fact that the CLI can only send to a single peer - which have this some issue when trying to invoke chaincode from the CLI as well.  This is of course the problem with not having a real dedicated CLI package.  ></body> </Action>
<Action id="35564" issue="24486" author="mastersingh24" type="comment" created="2017-11-28 09:37:20.0" updateauthor="mastersingh24" updated="2017-11-28 09:37:20.0"> <body><! CDATA I think this is a decent compromise to alleviate various concerns.  I will state that if one started from scratch, I don't think this is the best solution, but best to move forward.  I also think it might be important for those who have not read all of the related JIRAs why things end up like this.  1) Installation of the chaincode bytes is an administrative action performed on individual peers. 2) While chaincode must be installed on a peer in order for it to endorse transactions, peers do not need to have chaincode installed in order to validate and commit transactions for a given chaincode.  This is due to the fact that what gets sent through the orderer is actually the read-write set and not that actual chaincode invocation.  Because of this, you cannot "include" configuration about a chaincode (i.e. endorsement policy) as part of installation.  You also cannot use the chaincode endorsement model alone to bootstrap the initial endorsement policy for a chaincode (the chicken and egg problem which  ~jyellick  refers to in the description).  Endorsement is also not an approval workflow model - it is an agreement protocol on output given a set of inputs.  This is why the "resource configuration" is required (note that this will go to all peers in a channel not just the ones with chaincode installed).   ></body> </Action>
<Action id="35567" issue="24486" author="denyeart" type="comment" created="2017-11-28 14:44:27.0" updateauthor="denyeart" updated="2017-11-28 14:44:27.0"> <body><! CDATA If I understand this correctly, there would now be three steps to deploy a chaincode to a network: 1) Install chaincode on each peer 2) Define chaincode on channel via config 3) Instantiate/Init chaincode on channel via normal endorser transaction  Question - With the addition of the 'Define' step, would it now be possible to actually distribute the chaincode as part of the Define step, and thereby provide an option of skipping the Install step on each peer?  For networks where all peers should have the chaincode, and where all channel orgs must agree and sign off on step #2 regardless (this may be a very common deployment model), it seems like there is an opportunity to streamline the process so that manual installation on every peer would not be required.  Thoughts?  ></body> </Action>
<Action id="35569" issue="24486" author="yacovm" type="comment" created="2017-11-28 15:00:00.0" updateauthor="yacovm" updated="2017-11-28 15:00:31.0"> <body><! CDATA {quote}If I understand this correctly, there would now be three steps to deploy a chaincode to a network: {quote}    They are 3 invocations to peers/orderers, but they will be still 2 steps from the user perspective.  I'm tackling the peer CLI side for this item and steps 2 and 3 happen continuously and the user still invokes the old "instantiate" without knowing what is happening behind. {quote}Question - With the addition of the 'Define' step, would it now be possible to actually distribute the chaincode as part of the Define step, and thereby provide an option of skipping the Install step on each peer? For networks where all peers should have the chaincode, and where all channel orgs must agree and sign off on step #2 regardless (this may be a very common deployment model), it seems like there is an opportunity to streamline the process so that manual installation on every peer would not be required. Thoughts? {quote} * The person that instantiates should have channel-scoped permissions, but not local admin permissions.    * The person that instantiates doesn't necessarily even have the chaincode code itself... it doesn't actually have anything more than he had before.  Apart from that I think it's orthogonal to the problem we're solving here, and this should not be leveraged in the same mechanism.    {quote}it seems like there is an opportunity to streamline the process so that manual installation on every peer would not be required. {quote} Not sure why this is better than having a script that iterates over the peers and invokes a chaincode install     ></body> </Action>
<Action id="35581" issue="24486" author="muralisr" type="comment" created="2017-11-28 17:01:02.0" updateauthor="muralisr" updated="2017-11-28 17:01:02.0"> <body><! CDATA Not to disturb the comments flow but may I suggest this section from  ~mastersingh24  be brought into Description in some form  ~jyellick  ? You do mention "chicken and egg problem" but this would help explain what that is for those not following discussion. {quote}1) Installation of the chaincode bytes is an administrative action performed on individual peers. 2) While chaincode must be installed on a peer in order for it to endorse transactions, peers do not need to have chaincode installed in order to validate and commit transactions for a given chaincode. This is due to the fact that what gets sent through the orderer is actually the read-write set and not that actual chaincode invocation. Because of this, you cannot "include" configuration about a chaincode (i.e. endorsement policy) as part of installation. You also cannot use the chaincode endorsement model alone to bootstrap the initial endorsement policy for a chaincode (the chicken and egg problem which  ~jyellick  refers to in the description). Endorsement is also not an approval workflow model - it is an agreement protocol on output given a set of inputs. This is why the "resource configuration" is required (note that this will go to all peers in a channel not just the ones with chaincode installed). {quote}  ></body> </Action>
<Action id="35591" issue="24486" author="jyellick" type="comment" created="2017-11-28 19:37:28.0" updateauthor="jyellick" updated="2017-11-28 19:37:28.0"> <body><! CDATA  ~muralisr  I've updated the description per your suggestion.  {quote} Question - With the addition of the 'Define' step, would it now be possible to actually distribute the chaincode as part of the Define step, and thereby provide an option of skipping the Install step on each peer? For networks where all peers should have the chaincode, and where all channel orgs must agree and sign off on step #2 regardless (this may be a very common deployment model), it seems like there is an opportunity to streamline the process so that manual installation on every peer would not be required. Thoughts? {quote}  I would second the statement of  ~yacovm  that even if we wished to do this, it would be outside the scope of this item and should be written up separately.  However, because it was asked here, in the v0.5/v0.6 times when chaincode was distributed through transactions, this caused many problems for the orderer, because of the unusually large transaction size.  If we wanted a chaincode distribution mechanism, I would think it would make more sense to use the peer to peer gossip dissemination, with validation based on the hash presented through the definition.  ></body> </Action>
<Action id="35634" issue="24486" author="jeffgarratt" type="comment" body=" ~denyeart  your thinking is they way the 0.X release works.  The 1.X design made the decision to move to the bifurcated model for install and instantiation to allow for finer control of chaincode distribution (and perhaps other reasons as well).  " created="2017-11-29 15:32:09.0" updateauthor="jeffgarratt" updated="2017-11-29 15:32:09.0"/>
<Action id="35665" issue="24486" author="mastersingh24" type="comment" body="Bumping the priority and setting the version to 1.1 (even though this is a subtask)" created="2017-11-30 09:14:40.0" updateauthor="mastersingh24" updated="2017-11-30 09:14:58.0"/>
<Action id="35667" issue="24486" author="denyeart" type="comment" body="It is difficult to like an approach that splits chaincode deployment into three steps (install/define/instantiate), each having a unique method of distribution and storage.  That is one reason I was asking about whether the install/define steps could be combined in a config transaction, at least for the most typical deployment scenario where chaincode gets distributed to all peers. That being said, the solution here does seem to meet all the functional and security objectives, and does not change anything in the actual chaincode programming model.  Given that we have not been able to meet all these objectives using a simpler approach, and given the extent that other alternatives have already been explored, I am ready to vote in favor of this approach." created="2017-11-30 11:21:03.0" updateauthor="denyeart" updated="2017-11-30 11:21:03.0"/>
<Action id="35668" issue="24486" author="mastersingh24" type="comment" body=" ~denyeart  The original design was to basically combine steps 2/3 (well really we were eliminating step 3).  Keeping step 3 basically keeps the current flow but of course adds an extra step to handle the &quot;chicken and egg&quot; policy issue" created="2017-11-30 11:48:25.0" updateauthor="mastersingh24" updated="2017-11-30 11:48:25.0"/>
<Action id="35695" issue="24486" author="muralisr" type="comment" created="2017-12-01 00:14:29.0" updateauthor="muralisr" updated="2017-12-01 00:14:29.0"> <body><! CDATA Thought it would be illustrative to go through an example using the main steps outlined in description.   ~jyellick  can you vet this  please?     4 Peers P1,P2,P3,P4 5 admins Alice, Bob, Charlie, Dan and Ella.  +Channel setup+  1. The channel is initialized, and in the genesis block, a resources config tree contains a Chaincodes group with a mod_policy, defaulted to /Channel/Application/Admins - This results in a Chaincode Group mod_policy ({color:#ff0000}*MP*{color}) for all chaincodes in the channel - Alice or Bob or Charlie  +Chaincode installed on P1,P2+  2. A chaincode is installed via LSCC, or an installed chaincode is queried using the LSCC to retrieve the metadata for the chaincode. - This results in mycc.package \{ name : mycc, version:0 , instantiationpolicy({color:#ff0000}*IP*{color}): Dan and Ella }  +Chaincode is defined on the config tree for the channel+  3. The client retrieves the current resources tree, and adds a new chaincode group to the resources tree, as described in FAB-6042, this modification must satisfy the mod_policy of the chaincodes group, and the chaincode is defined with the metadata from (2) and the desired endorsement policy. - This results in an endorsement policy ({color:#ff0000}*EP*{color}) for instantiation of chaincode "mycc"  - P1 and P2  4. The client submits the resource update to the orderer, it is propagated through the blockchain, and committed at the peer. When it commits successfully, the chaincode is now defined. - The request passes as modification signed by Alice according to {color:#ff0000}*MP*{color} 1  +Chaincode instantiation is sent to P1, P2+  5. The client crafts a traditional LSCC transaction containing the name, version, and arguments for instantiation. The LSCC checks that the chaincode is defined for the channel in the resources tree, checks the locally defined instantiation policy in the chaincode package, and does a chaincode-to-chaincode invocation of Init (as it does today). The resulting read/write set includes an 'instantiated' bit in the LSCC table, as well as some representation of the chaincode metadata it was instantiated with. - The request passes as the Proposal is signed by Dan and Ella according to {color:#ff0000}*IP*{color} 2  6. The client sends the LSCC transaction to peers, collecting enough endorsements to satisfy the endorsement policy as specified in the chaincode metadata in the resources tree. - The instantiation sent to P1 and P2 and signatures collected  +Instantiation committed on P1,P2,P3,P4+  7. The client sends the LSCC transaction to ordering, which propagates to the peers through the blockchain. This LSCC transaction is validated that the metadata in the resource tree is at the same level, and the usual MVCC checks prevent double Init invocations. - Commit time validation passes as signatures P1 and P2  according to {color:#ff0000}*EP*{color} in 3  ></body> </Action>
<Action id="35696" issue="24486" author="jyellick" type="comment" created="2017-12-01 02:47:02.0" updateauthor="jyellick" updated="2017-12-01 02:47:02.0"> <body><! CDATA  ~muralisr  by and large looks correct.  I've done an inline style comment below with some minor corrections.  {quote} 4 Peers P1,P2,P3,P4 5 admins Alice, Bob, Charlie, Dan and Ella. Channel setup 1. The channel is initialized, and in the genesis block, a resources config tree contains a Chaincodes group with a mod_policy, defaulted to /Channel/Application/Admins This results in a Chaincode Group mod_policy (MP) for all chaincodes in the channel - Alice or Bob or Charlie Chaincode installed on P1,P2 {quote}  The /Channel/Application/Admins policy actually requires a majority of admin signatures, rather than any one of the admin signatures.  However, if the 'single admin' policy were desirable, this could be configured. We could include profiles for each in {{configtx.yaml}}.  {quote} 2. A chaincode is installed via LSCC, or an installed chaincode is queried using the LSCC to retrieve the metadata for the chaincode. This results in mycc.package \{ name : mycc, version:0 , instantiationpolicy(IP): Dan and Ella } {quote} Correct, however, I would note that the query also returns the ID/hash of the chaincode, which is required to be defined as part of the metadata.  Also note, that as of v1.1, there is still no mechanism to satisfy an instantiation policy which requires Dan and Ella, though nothing precludes this in a future update.  {quote} Chaincode is defined on the config tree for the channel 3. The client retrieves the current resources tree, and adds a new chaincode group to the resources tree, as described in FAB-6042, this modification must satisfy the mod_policy of the chaincodes group, and the chaincode is defined with the metadata from (2) and the desired endorsement policy. This results in an endorsement policy (EP) for instantiation of chaincode "mycc"  - P1 and P2 {quote} This would be one possible and sensible endorsement policy, though like today, it could be whatever the user chose to pass in.  {quote} 4. The client submits the resource update to the orderer, it is propagated through the blockchain, and committed at the peer. When it commits successfully, the chaincode is now defined. The request passes as modification signed by Alice according to MP 1 {quote} Correct, if the 'any admin' policy were selected, then the definition would commit successfully.  {quote} Chaincode instantiation is sent to P1, P2 5. The client crafts a traditional LSCC transaction containing the name, version, and arguments for instantiation. The LSCC checks that the chaincode is defined for the channel in the resources tree, checks the locally defined instantiation policy in the chaincode package, and does a chaincode-to-chaincode invocation of Init (as it does today). The resulting read/write set includes an 'instantiated' bit in the LSCC table, as well as some representation of the chaincode metadata it was instantiated with. The request passes as the Proposal is signed by Dan and Ella according to IP 2 {quote} As mentioned previously, the proposal data structure only supports a single signature, so this IP could not pass as of v1.1.  Instead an IP of "Dan or Ella" would be required.  {quote} 6. The client sends the LSCC transaction to peers, collecting enough endorsements to satisfy the endorsement policy as specified in the chaincode metadata in the resources tree. The instantiation sent to P1 and P2 and signatures collected  Instantiation committed on P1,P2,P3,P4 7. The client sends the LSCC transaction to ordering, which propagates to the peers through the blockchain. This LSCC transaction is validated that the metadata in the resource tree is at the same level, and the usual MVCC checks prevent double Init invocations. Commit time validation passes as signatures P1 and P2  according to EP in 3 {quote} Correct.  ></body> </Action>
<Action id="35703" issue="24486" author="yacovm" type="comment" created="2017-12-01 10:43:29.0" updateauthor="yacovm" updated="2017-12-01 10:43:29.0"> <body><! CDATA {quote}Chaincode instantiation is sent to P1, P2 5. The client crafts a traditional LSCC transaction containing the name, version, and arguments for instantiation. The LSCC checks that the chaincode is defined for the channel in the resources tree, checks the locally defined instantiation policy in the chaincode package, and does a chaincode-to-chaincode invocation of Init (as it does today). The resulting read/write set includes an 'instantiated' bit in the LSCC table, as well as some representation of the chaincode metadata it was instantiated with.{quote}  This part does not make sense to me.  * We can have an endorsement policy that is arbitrary, and this gives us an ability to ensure that several organizations agreed to a certain read and write * Yet when we initialize the chaincode data structures, only 1 user gets to pick the input (instantiate). Even though the simulation is simulated on several peers of different organizations, no one other than the instantiator has "a say" in the input to the chaincode.   This is a problem as far as I can see, and can be easily solved via binding the LSCC Init() to the previous chaincode configuration. * What if we include the arguments to Init() in the chaincode resource config update * Upon validation of the instantiate, we also check that the peers attested that they were given the matching input as was declared in the config update?  ></body> </Action>
<Action id="35705" issue="24486" author="muralisr" type="comment" body=" ~yacovm  I think its better to do it properly with multi-sig ( ~ellaki  ) support to Proposal *which has benefit beyond just Instantiation (ie, potentially for invokes too).* I suppose the argument is that we don&apos;t have time for 1.1 ? Actually all this means is extending Proposal.proto and doing the check in LSCC / VSCC ? Isn&apos;t that better to do it now ?" created="2017-12-01 12:52:42.0" updateauthor="muralisr" updated="2017-12-01 12:52:42.0"/>
<Action id="35709" issue="24486" author="yacovm" type="comment" body="So the participants would need to first pass around the proposal, and everyone would add their signature header to it, and afterwards - pass it around again, to sign it? because currently the signature is stored outside of the proposal and the signed payload is the proposal bytes... " created="2017-12-01 13:38:32.0" updateauthor="yacovm" updated="2017-12-01 13:38:32.0"/>
<Action id="35710" issue="24486" author="muralisr" type="comment" created="2017-12-01 14:05:25.0" updateauthor="muralisr" updated="2017-12-01 14:53:09.0"> <body><! CDATA  ~yacovm  basically yes.... Just like confg updates we'd get signatures on the proposal before submitting it... Id phrase like this : participants (real users) sign the proposal and _peers_ would endorse it.  Note that the default packaging can still be used - say for dev test etc- where only sig need is the senders  ></body> </Action>
<Action id="35714" issue="24486" author="jyellick" type="comment" created="2017-12-01 14:54:13.0" updateauthor="jyellick" updated="2017-12-01 14:54:13.0"> <body><! CDATA  ~yacovm   {quote} This part does not make sense to me. We can have an endorsement policy that is arbitrary, and this gives us an ability to ensure that several organizations agreed to a certain read and write Yet when we initialize the chaincode data structures, only 1 user gets to pick the input (instantiate). Even though the simulation is simulated on several peers of different organizations, no one other than the instantiator has "a say" in the input to the chaincode. This is a problem as far as I can see, and can be easily solved via binding the LSCC Init() to the previous chaincode configuration. What if we include the arguments to Init() in the chaincode resource config update Upon validation of the instantiate, we also check that the peers attested that they were given the matching input as was declared in the config update? {quote}  This has been discussed, and if we decide that it is a problem, then we can do something to address it, but I am not convinced it is a problem.  First, since the {{Init}} is subject to the same endorsement policy as the rest of the transactions now, there's nothing which prevents the chaincode from doing its own ACL on {{Init}}.  Secondly, {{Init}} must still satisfy the instantiation policy, which, for the time being is limited to one signature, but it does at least restrict who may supply the {{Init}} parameters.  Finally, there is no requirement that {{Init}} do anything sensitive, in fact, most chaincodes can be written quite happily with {{Init}} as a simple no-op.  So, although there are plenty of schemes which could be used to control the parameters which are passed to {{Init}}, I think for this pass, let's keep it simple, and not build in even more complexity until there's really a need for it.  ></body> </Action>
<Action id="35715" issue="24486" author="muralisr" type="comment" created="2017-12-01 15:00:42.0" updateauthor="muralisr" updated="2017-12-01 15:24:11.0"> <body><! CDATA     ~yacovm  agreed. The multi-sig could be a future item....should have mentioned that. It was put there for completeness and to point out the distinction between peers endorsing vs users signing off on a proposal and the resulting expansion of proposal workflows.  One thing... I would disagree on this {quote}Finally, there is no requirement that Init do anything sensitive, in fact, most chaincodes can be written quite happily with Init as a simple no-op. {quote} Features give raise to uses. I'm sure there would be use cases where you want to construct a chaincode with some initialized state. IMO just renaming "Init" to something like "OnInstantiation" would be clarifying and would invite usage.  ></body> </Action>
<Action id="35722" issue="24486" author="yacovm" type="comment" created="2017-12-01 15:47:55.0" updateauthor="yacovm" updated="2017-12-01 15:49:59.0"> <body><! CDATA {quote} there's nothing which prevents the chaincode from doing its own ACL on Init.{quote}  Of course there is. The init transaction is special as it bootstraps the chaincode's data on the ledger. Consider for example a chaincode that tracks people's accounts and has an init function that initializes the accounts to a starting value. You can't have any ACL that does correct enforcement, unless you manually hard-code the data into the chaincode, which means it will be the same for all channels and you can't reuse the chaincode ever unless with the same accounts and numbers.  {quote}which, for the time being is limited to one signature, but it does at least restrict who may supply the Init parameters.{quote} Well I thought the idea here is that we move away from the model where there is a single entity which all the channel members trust to initialize the chaincode properly. To me, we're almost there, and this part is nice to have and completes the solution. {quote} So, although there are plenty of schemes which could be used to control the parameters which are passed to Init, I think for this pass, let's keep it simple, and not build in even more complexity until there's really a need for it.{quote} I don't think there is any complexity. There is zero complexity addition from the user's perspective and a minimal complexity in the development perspective.  But, if you think it's not important then I won't push back.   ></body> </Action>
<Action id="35728" issue="24486" author="muralisr" type="comment" created="2017-12-01 17:03:41.0" updateauthor="muralisr" updated="2017-12-01 17:03:41.0"> <body><! CDATA  ~yacovm  those were my thoughts as well FWIW... but again, if this is too much to do for 1.1, we can slate it for later.   {quote} I don't think there is any complexity.  {quote} That;s what I thought too... but I understand every little thing adds up (in this case I'm thinking doc, testing etc).  ></body> </Action>
<Action id="35739" issue="24486" author="binhn" type="comment" created="2017-12-01 21:27:58.0" updateauthor="binhn" updated="2017-12-01 22:29:28.0"> <body><! CDATA I appreciate everyone here, especially  ~jyellick  and  ~muralisr  for coming up with a design, documenting and explaining the steps to deploy a chaincode on a channel. The example Murali illustrated helps stitching things together. However, after reading through all this, 1 word comes to mind is complexity, and I ponder on how to possibly simplify it but satisfy our objective.  My grasp of the proposal is as follow: # a channel has a chaincode group mod policy indicating who can define a chaincode on this channel # to define a chaincode on a channel, the tx must be signed by majority of those in group mod policy; this tx also defines the chaincode Init endorsement policy used during the chaincode instantiation # to instantiate the chaincode on the channel, the tx must be signed (out of band) by 1 of those on the instantiate policy (specified in the chaincode install package) and endorsed by peers on Init endorsement policy; this tx also specifies the chaincode Invoke endorsement policy  If I got that right, in summary then, each chaincode would be associated with 4 policies # chaincode group mod policy # chaincode instantiate policy # chaincode Init   function  endorsement policy # chaincode Invoke  function  endorsement policy  This all seems to be necessary, but 1 thought to offer some simplification would be to make an assumption that for a given channel, we would have the same set of orgs responsible for defining any chaincode on the channel, effectively this would eliminate step 3 and 4 (from the description above) due to invariants. It would simplify SDK and CLI not having to process 3 and 4 and subsequently handle 5 and 6.  Of course this simplification would restrict the flexibility of having different sets of endorsers per chaincode on a channel, but it seems worthy of the first pass as I can't come up (at this point) with a real-life use-case where we would need to support multiple completely independent chaincodes, each with a different set of endorsers on a channel.  Thoughts?        ></body> </Action>
<Action id="35740" issue="24486" author="muralisr" type="comment" created="2017-12-01 21:44:58.0" updateauthor="muralisr" updated="2017-12-01 21:45:54.0"> <body><! CDATA  ~binhn  {quote}This all seems to be necessary, but 1 thought to offer some simplification would be to make an assumption that for a given channel, we would have the same set of orgs responsible for defining any chaincode on the channel, effectively this would eliminate step 3 and 4 due to invariants. It would simplify SDK and CLI not having to process 3 and 4 and subsequently handle 5 and 6. {quote} In other words, if we can make it so that ALL chaincodes in the channel have the same set of endorsering signatures, then the per chaincode Endorsement Policy in Step 3 can be moved to channel-wide Endorsement Policy for ALL chaincodes in that channel. Since the key reason for Step 3 is the Endorsement Policy, we can eliminate Step 3 altogether.  In addition, there's another benefit to this... from  ~denyeart  comment {quote}It is difficult to like an approach that splits chaincode deployment into three steps (install/define/instantiate), each having a unique method of distribution and storage. {quote} With this, we are back to using the state as the main data model as before.  Sounds like this simplification is not without its merits... in reality how many usecases would need CC1 to be on P1 and P2 while CC2 to be on P2 and P3 - *on the same channel* ? If the answer is rarely then we are paying a lot in terms of complexity (and usability) for something that will rarely be needed.  ></body> </Action>
<Action id="35742" issue="24486" author="jyellick" type="comment" created="2017-12-01 21:57:29.0" updateauthor="jyellick" updated="2017-12-01 22:08:41.0"> <body><! CDATA  ~binhn  {quote}If I got that right, in summary then, each chaincode would be associated with 4 policies 1. chaincode group mod policy 2. chaincode instantiate policy 3. chaincode Init  function  endorsement policy 4. chaincode Invoke  function  endorsement policy {quote}  ~muralisr  and I discussed (3)/(4) and whether we should allow a differentiation between the two. There are some good arguments for doing so, but as you point out, things already feel pretty complex. Instead, for v1.1, we will enforce that (3) and (4) are in fact the same policy. Of course if we can come up with good concrete use cases for allowing them to differ in the future, we can do so – but for now it seems like a welcomed simplification.  Edit:  I posted before the page refreshed to show  ~muralisr 's comment. -I think I'm getting a little confused with the numbering, in particular, (5)/(6) don't seem to appear in your post, did JIRA try to be too smart and end up changing the numbering?- It has been a long week, I believe that 5/6 are referring to the original description. Since my brain has apparently stopped functioning correctly, I'll return to this later.  ></body> </Action>
<Action id="35743" issue="24486" author="muralisr" type="comment" created="2017-12-01 23:45:20.0" updateauthor="muralisr" updated="2017-12-03 17:31:38.0"> <body><! CDATA No worries  ~jyellick . So assuming  ~binhn  agrees with the clarification above what we have then is basically these policies {quote} # chaincode{color:#ff0000}S{color} Init  function  endorsement policy {color:#d04437}(*EP*){color} (channel wide and specified at channel creation time *assuming one endorser set for all chaincodes. E.g endorsement policy will cover P1 and P2 for all the CCs from the set \{P1, P2, P3, P4}. P3 and P4 may have CCs or not have them. This is a statement about what the endorsement policy +for Instantiation+ will be...in  ~binhn  scheme this is fixed for all chaincodes in the channel* 2. chaincode instantiate policy (*{color:#d04437}IP{color}*) specified in the chaincode package (if we go along with multi-sig Proposal) 3. chaincode Invoke  function  endorsement policy (as currently implemented, no change here){quote} and this workflow for instantiation # The channel is initialized, and in the genesis block, a resources config tree contains a Chaincodes group with *{color:#ff0000}EP{color}* defaulted to /Channel/Application/Admins # A chaincode is installed via LSCC, or an installed chaincode is queried using the LSCC to retrieve the metadata for the chaincode. # The client crafts a traditional LSCC transaction containing the name, version, and arguments for instantiation and sends to peers. LSCC in each peer checks the locally defined *{color:#d04437}IP****{color}* in the chaincode package, and does a chaincode-to-chaincode invocation of Init. The resulting read/write set is identical to 1.0 RW set. # The client collects endorsements to satisfy {color:#d04437}*EP*{color} as specified in the channel configuration # The client sends the LSCC transaction to ordering, which propagates to the peers through the blockchain. This LSCC transaction is validated that the metadata in the resource tree is at the same level, and the usual MVCC checks prevent double Init invocations.  *{color:#d04437}**** Assuming we have multi-sig proposal{color}*  ></body> </Action>
<Action id="35761" issue="24486" author="jyellick" type="comment" created="2017-12-04 00:40:27.0" updateauthor="jyellick" updated="2017-12-04 00:40:27.0"> <body><! CDATA Thanks  ~muralisr , the workflow you outline makes the mechanics of this other proposal much more clear.  I'm not convinced though, that accepting a single channel wide endorsement policy for chaincode instantiation is the best idea.  It seems to defeat the purpose of not requiring chaincode to be installed everywhere.  Consider a channel which contains two different orgs, each of which author a chaincode, and each wish to make the chaincode service available on the channel (but importantly, not share the chaincode bytes with the channel).  What would be a secure instantiation endorsement policy in this case?  To make either chaincode available, the default endorsement policy must be a "one of" type policy, which creates a security problem (as an org without the chaincode could trick the network into believe it did).  Instead, if we go the other direction, where all chaincode policy (not only for instantiation, but also for invocation) is defined through a resource transaction, then I think the complexity is reduced, without sacrificing flexibility.  In the proposal from the description, (5) would no longer carry any policy information specified by the client (though a read dependency on the state of the resources tree could be injected by the endorsement).  There is only one place the client need specify chaincode metadata or policies, but the actual lifecycle state of the chaincode remains in the traditional state database.  ></body> </Action>
<Action id="35778" issue="24486" author="muralisr" type="comment" created="2017-12-04 15:01:22.0" updateauthor="muralisr" updated="2017-12-04 15:58:56.0"> <body><! CDATA  ~jyellick   {quote}Consider a channel which contains two different orgs, each of which author a chaincode, and each wish to make the chaincode service available on the channel (but importantly, not share the chaincode bytes with the channel). What would be a secure instantiation endorsement policy in this case? To make either chaincode available, the default endorsement policy must be a "one of" type policy, which creates a security problem (as an org without the chaincode could trick the network into believe it did). {quote} Right, that really is the question: in a channel will there be different subsets of orgs hosting different chaincodes ?  ~binhn  model assumes one subset hosts all the chaincodes so one EP would be crafted with that assumption. This EP could be "one from each org" (as opposed to "any one of these orgs" which, as you point out, is what it'll have to be if we want to keep the one EP _and_ have multiple subsets of peers hosting chaincodes).  To be clear, I'm not suggesting the simpler model is the right one. All I'm saying is that the reduction in complexity at different levels (usability, code maintenance) at least makes it worth finding out if this model will work. If this works most of the times, it might be worth it I think. Maybe we can even try this for 1.1 and if its limiting relax it in the next rev ? {quote}-Instead, if we go the other direction, where all chaincode policy (not only for instantiation, but also for invocation) is defined through a resource transaction, then I think the complexity is reduced, without sacrificing flexibility.- {quote} -I don't think that buys simplicity - not much at least. Moving the Invoke EP from instantiation to definition TX would mean more code to change and more difference to explain. Also, when we upgrade the chaincode we have to send two TXs, correct ? In a way, keeping the configuration all instantiation-specific at least limits the scope of the config TX. When we upgrade the current endorsment policy for instantiation could be used and so the upgrade would just be an endorsement TX (as it is now).-     ></body> </Action>
<Action id="35784" issue="24486" author="muralisr" type="comment" created="2017-12-04 16:03:28.0" updateauthor="muralisr" updated="2017-12-04 16:03:28.0"> <body><! CDATA Strikethru above after chatting with  ~jyellick ... the suggestion was NOT 2 EPs one for instantiation and another for invoke as I understood it but 1 EP for both instantiation and invoke.  Both instantiation and invoke transactions should really be governed by the same endorsement policy and so could be specified once when defining the chaincode with the config TX...so the smart contract is governed by 1 endorsement policy for all its transactions.  This _would_ simplify the model.. instantiation and invokes are treated the same way with just chaincode args and no policy args.\  What do you think  ~binhn  ? This separates out policy from state execution (having two EPs was one of your concerns) and might make more sense to users ?  ></body> </Action>
<Action id="35798" issue="24486" author="christopherferris" type="comment" created="2017-12-04 18:50:46.0" updateauthor="christopherferris" updated="2017-12-04 18:50:46.0"> <body><! CDATA  ~jyellick  wrote: "(but importantly, not share the chaincode bytes with the channel)".   I can certainly see a chaincode bytes/source that is not shared outside the channel, but with members of the channel? Can you provide a use case for this?  How is one to endorse something that they cannot validate?  ></body> </Action>
<Action id="35802" issue="24486" author="jyellick" type="comment" created="2017-12-04 19:28:44.0" updateauthor="jyellick" updated="2017-12-04 19:28:44.0"> <body><! CDATA  ~ChristopherFerris  This was a fairly fundamental architectural change that occurred between v0.x and v1.0.  The chaincode bytes are made available explicitly to peers via the 'install' command which is executed by a local peer administrator.  Not all peers need have the chaincode, and consequently, not all peers are able to endorse for all chaincodes in a channel.  Note, this is nothing new in the new lifecycle proposal in this and the parent issue, this is existing chaincode semantics.  Consider a relatively simple example.  There is a channel with two banks which have some sort of exchange contract established between them, and then a number of large customers for these banks.  The customers will invoke the chaincode on both banks' peers, but, they are not privy to the exact agreement between the banks, nor should they be.  In this case, the customers will want to deploy their own peers in the network (so that they have the audit history, and have own peers performing transaction validation), but those peers do not have the chaincode and could/would not be involved in the endorsement policy for that chaincode.  This comes back to the fundamental principle in v1.0 that all peers may validate transactions by applying the endorsement policy to the endorsements, without any knowledge of the chaincode.  ></body> </Action>
<Action id="35930" issue="24486" author="muralisr" type="comment" created="2017-12-06 14:50:23.0" updateauthor="muralisr" updated="2017-12-06 15:39:48.0"> <body><! CDATA  ~jyellick     Here's another solution that we were discussing - best of both.  # a default "for all chaincodes in a channel" policy created at the time of channel create # a chaincode specific override sent via an config tx if necessary  We don;t have to change the CLI instantiate to do the config+instantiate atomically. If the user wants to override that for a chaincode in the channel, they can send a update config tx with the endorsement policy for the chaincode.   ( ~jyellick  is that something that the resource config tree can accommodate ?)  Also with both default and chaincode specific config, we will go with  ~jyellick  proposal for one endorsement policy for instantiate and invoke.    ~mastersingh24   ~binhn  what do you think ?   ></body> </Action>
<Action id="35939" issue="24486" author="denyeart" type="comment" created="2017-12-06 16:04:01.0" updateauthor="denyeart" updated="2017-12-06 16:04:01.0"> <body><! CDATA For what it's worth, there are other benefits to *consistently* defining the chaincode on the channel prior to instantiation/Init() in my opinion.  * The chaincode definition would be the ideal hook for ledger to create resources required for commits (as well as resources required for endorsements if chaincode is installed). In the case of CouchDB, ledger intends to utilize the chaincode definition config transaction as the trigger for creating state database on all peers, as well as indexes (if chaincode is installed). Init() time may be too late, for example in chaincode upgrade scenarios Init() may require the indexes already be in place for data migration logic. In the case of other state databases such as relational, the new chaincode define step would be an ideal time to create the database schema. No such channel-scoped hook was available previously. * The chaincode definition step could also be used in the future to distribute chaincode, for those networks that want auto-install capability (config tx would have to meet some signature-based installation policy).  I don't mean to distract with other requirements/ideas, beyond pointing out that *consistently* defining chaincode on the channel has additional benefits, now and in future. That's one reason I keep my upvote as written.  ></body> </Action>
<Action id="35956" issue="24486" author="binhn" type="comment" created="2017-12-06 23:36:10.0" updateauthor="binhn" updated="2017-12-06 23:46:50.0"> <body><! CDATA  ~muralisr  I am ok with the compromise by making the default as simple as possible and leave the option available. So I am voting for this item with this modification in implementation.     We should consider the rest of other things out side of this item, such as below:   ~denyeart   {quote}"No such channel-scoped hook was available previously" {quote} Wouldn't channel related ledger activities be done at join-channel time rather than per chaincode in the channel? During Instantiate, the peer and lscc control the entire flow, so I think if we want to set up additional things on the ledger, we have that opportunity.  {quote}The chaincode definition step could also be used in the future to distribute chaincode, for those networks that want auto-install capability {quote} What drives this requirement?  It sounds like feature-creep that we should do our best to avoid.   ></body> </Action>
<Action id="35965" issue="24486" author="denyeart" type="comment" created="2017-12-07 02:40:53.0" updateauthor="denyeart" updated="2017-12-07 02:40:53.0"> <body><! CDATA  ~binhn  Some of the ledger / statedb setup is per channel/chaincode rather than per channel.  We'll see this more and more as additional state database options get added over time.  The first example of this is the many community requests for chaincode-specific CouchDB indexes required to support chaincode queries - see the full explanation in FAB-3067 description.  Again, I don't mean to distract things with discussion of specific feature proposals here, for now my only point is that with built-in and consistent chaincode "definition" on the channel we'll have a solid foundation in place that enables these types of features, now and in the future.    ></body> </Action>
<Action id="36002" issue="24486" author="jyellick" type="comment" created="2017-12-07 22:53:43.0" updateauthor="jyellick" updated="2017-12-07 22:53:43.0"> <body><! CDATA TLDR; I can support the modifications as endorsed by  ~binhn  and  ~muralisr   For more detail, see below.  ---- I had an opportunity to speak directly with  ~muralisr  and then  ~mastersingh24  directly about the modification to this proposal to add 'defaults' for undefined chaincodes.  In short, I'm a little concerned that this proposal is adding an option in an attempt to reduce complexity (and consequently, actually creating complexity).  That being said, from an implementation perspective, adding the ability to enable and specify default chaincode endorsement and validation policies is something that's not terribly difficult to do.  Additionally, since defining the defaults would be optional, for networks which wish to strictly manage their chaincodes, this modification causes those networks no harm.  Because of all of this, I think it's reasonable to adopt this modification and I believe it can be contained as an addition to the existing lifecycle CRs which are presently pending against master.  For use cases like  ~denyeart  for deploying chaincode indices along with chaincode definitions, I would suggest that a stance of "If you want advanced features like indices, you must define your chaincode explicitly."  Of course this is only a suggestion and something that can and should be discussed directly in the proposal for such features.  ></body> </Action>
<Action id="36024" issue="24486" author="elli-androulaki" type="comment" created="2017-12-08 16:48:16.0" updateauthor="elli-androulaki" updated="2017-12-08 16:48:16.0"> <body><! CDATA Hi,  So reading this flow, it seems that a threat model is adopted where instantiation policy is redundant.  It seems to me that in the design above one trusts the endorsement policy to be the right one for that particular chaincode. This trust would derive from the trust one has to the resources/chaincodes mod-policy to properly choose an honest endorsement policy for the chaincode with a specific name and hash (version is implied).  But then Trust Chaincodes mod_policy -> Trust the chaincode is properly instantiated -> Instantiation policy (if exists) would always match based on our assumption that the mode_policy is trusted.  If on the other hand resouces/chaincodes mod_policy is not (completely) trusted, and there is an instantiation policy to protect not-properly authorised chaincodes from being deployed, then I would say that this way of enforcing the honouring of the instantiation policy can be attacked. How to do that is have the endorsement policy controlled partially by the attacker's endorsers which would make step (5) complete successfully, and force the rest of endorsers of the chaincode into setting the instantiation bit of this chaincode to 1.   One could argue now that mod_policy is not trusted but it is the endorsement policy that is trusted for the chaincode proposed to be instantiated. However endorsement policy is not attached to the chaincode, but rather is a chaincode/channel combination, and not sure how a client deciding to invoke that can know that it can trust it.. So two things: * Perhaps how the trust flows in such cases is worth discussing. * Also notice that endorsement policy is only relevant means of protecting the validation of init, for an endorsement policy-based parameterization of vscc that may or may not be the case for custom vsccs.   ></body> </Action>
<Action id="36028" issue="24486" author="christopherferris" type="comment" created="2017-12-08 17:30:12.0" updateauthor="christopherferris" updated="2017-12-08 17:30:12.0"> <body><! CDATA  ~jyellick  I understand all that, but the use case you were describing, in the comment I cited suggested that a channel where Org 1 had chaincode and Org2 had chaincode but that they did not share the bytes. Yes, I totally get that they COULD do this. What I was asking is what possible use case there might be for this shielding of the chaincode. That's kind of like you and I participating in a channel where I execute the transaction *that you cannot see* and me saying "trust me, I didn't skim off some of the profits or add in hidden fees".  Again, I can appreciate that we want to have endorsing and validating peers where we don't need every node in a channel to execute the transaction. What is less clear to me is what use cases would motivate explicitly shielding the code from participants in the channel. It just seems unnecessarily convoluted.  ></body> </Action>
<Action id="36036" issue="24486" author="jyellick" type="comment" created="2017-12-08 19:30:43.0" updateauthor="jyellick" updated="2017-12-08 19:30:43.0"> <body><! CDATA  ~elli-androulaki  I agree, that as presented above, instantiation policy is in many ways redundant now.  My belief was that the instantiation policy was already checked during invocation of {{Init}} so I left that in the proposal above attempting to minimize the changes from the old lifecycle model.  In particular, since chaincodes might have been designed which treated {{Init}} as a privileged operation requiring some specific user to invoke it, it seemed worth preserving the check.  I'm a little concerned with overloading this JIRA with a new thread on instantiation policy -- what would you think of opening a new JIRA about it and posting it here?   ~ChristopherFerris   {quote} Again, I can appreciate that we want to have endorsing and validating peers where we don't need every node in a channel to execute the transaction. What is less clear to me is what use cases would motivate explicitly shielding the code from participants in the channel. It just seems unnecessarily convoluted. {quote}  Some users have expressed the desire to keep their chaincode implementation confidential from other members in the channel.  For this model to work, it generally requires that the channel members place additional trust in the chaincode holder or holders.  Often-times these networks can be thought of as "dictator networks" where one party has much more power than the other participants.  Although the non-chaincode holding members cannot see the implementation, they still have an immutable record of transactions and their validity.  Although hiding the contract logic is perhaps not 'pure blockchain', to my understanding, it is a model which fabric decided to support or v1.   ></body> </Action>
<Action id="36040" issue="24486" author="christopherferris" type="comment" body=" ~jyellick  my concern is that the operational model for supporting this is rather cumbersome and really doesn&apos;t scale. I could see it being an optional governance model (install chaincode on each peer, then instantiate). However, I have been discussing with some the idea that we support a docker registry-based &quot;install&quot; approach where the chaincode image is constructed by the user, uploaded to DTR (could be a private one for the network) and then have the instantiate reference that image. With multi-arch docker support, this should be doable. " created="2017-12-08 20:40:48.0" updateauthor="christopherferris" updated="2017-12-08 20:40:48.0"/>
<Action id="36043" issue="24486" author="yacovm" type="comment" created="2017-12-08 21:51:57.0" updateauthor="yacovm" updated="2017-12-08 21:51:57.0"> <body><! CDATA {quote} ~jyellick  my concern is that the operational model for supporting this is rather cumbersome and really doesn't scale. I could see it being an optional governance model (install chaincode on each peer, then instantiate). However, I have been discussing with some the idea that we support a docker registry-based "install" approach where the chaincode image is constructed by the user, uploaded to DTR (could be a private one for the network) and then have the instantiate reference that image. With multi-arch docker support, this should be doable.  {quote} Now we can actually support that, since we don't bake any TLS certificates anymore into the shim container image, like we did in v1.0.  I agree that the current deployment model, isn't good in the scale aspect. Especially in the part that it takes 15 seconds for the image to be built in the first invocation of the peer. We really need to just build the image at install, and not at instantiate/invoke.  ></body> </Action>
<Action id="36045" issue="24486" author="christopherferris" type="comment" body=" ~yacovm  or have it pre-built and installed into DTR and then just docker pull(ed) at invocation." created="2017-12-08 21:57:24.0" updateauthor="christopherferris" updated="2017-12-08 21:57:24.0"/>
<Action id="36048" issue="24486" author="yacovm" type="comment" body="I meant of course - to either build, or pull it at install. I see no reason to wait for invocation. Having a slow first-invocation only impairs user experience." created="2017-12-08 22:20:27.0" updateauthor="yacovm" updated="2017-12-08 22:20:27.0"/>
<Action id="36049" issue="24486" author="muralisr" type="comment" created="2017-12-08 22:58:01.0" updateauthor="muralisr" updated="2017-12-08 22:58:01.0"> <body><! CDATA  ~ChristopherFerris  The idea of registry-based install is orthogonal to all the approaches to "life-cycle" issues such as endorsement policies  discussed in this JIRA or as implemented currently ? I think it deserves its own JIRA. Should we open one and continue discussion there ?   ></body> </Action>
<Action id="37055" issue="24486" author="jyellick" type="comment" body="For anyone following this thread, there is another proposal in response to this one: FAB-7444." created="2017-12-13 14:43:57.0" updateauthor="jyellick" updated="2017-12-13 14:43:57.0"/>
<Action id="37935" issue="24486" author="jyellick" type="comment" body="Closing this as WON&apos;T FIX as it has been abandoned." created="2018-01-03 18:12:20.0" updateauthor="jyellick" updated="2018-01-03 18:12:20.0"/>
