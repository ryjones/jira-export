<Action id="35792" issue="15648" author="jyellick" type="comment" created="2017-12-04 18:16:12.0" updateauthor="jyellick" updated="2017-12-04 18:16:12.0"> <body><! CDATA This looks good to me.  The piece that stuck out to me as asymmetric is that if the chaincode is installed before it is defined in any channels, then at definition time, the index creation fails; then we will be in a state of having an installed chaincode with bad indices.  Contrast this with the other flow, which is if a chaincode is defined in some channels, and then it is installed on a peer, where the index creation fails; then the chaincode will not install, and the state will differ from above.  Despite the asymmetry, I think this probably the right call, as the administrator who does the install is generally the person who is in a position to fix the error, so making it more obvious in that workflow should help usability.  In summary, this approach has my vote/support.  ></body> </Action>
<Action id="35817" issue="15648" author="manish-sethi" type="comment" created="2017-12-05 00:57:04.0" updateauthor="manish-sethi" updated="2017-12-05 00:57:04.0"> <body><! CDATA  ~jyellick  though this JIRA specifically talks about only index creation but the intention is also to create the database (specific to chaincode) also at the time of processing PEER_RESOURCE_UPDATE transaction (upon finding a new chaincode definition).  We should discuss the behavior if an error happens during the creation of the database. Should the transaction be considered as failed? and result in panic (as we do today if we encounter an error on writing a block or committing to a statedb)? Essentially, what we need to decide is what is the scope of the transaction processing for a PEER_RESOURCE_UPDATE transaction - Only being able to validate, update in memory structures, save to the statedb OR include the creation of artifacts that are necessary to commit the ENDORSER transactions for the chaincode (e.g., creation of the database).  If we agree to include the database creation as part of the transaction processing, then we can follow the same behavior for indexes as well and should not cause the asymmetry that you mentioned - but this is not as important to decide here as is about the overall notion of processing of PEER_RESOURCE_UPDATE transaction.   ~denyeart  This look good to me except that I would not be much inclined for exposing the variable *peer.ledger.state.couchDBConfig.autoDeployChaincodeIndexes* in yaml. This may cause confusion if admin changes its value. For instance, if this is set to false and then again to true, it would be hard to guess why certain indexes are missing (which could have caused when the variable was set to false).  ></body> </Action>
<Action id="35818" issue="15648" author="denyeart" type="comment" created="2017-12-05 02:45:41.0" updateauthor="denyeart" updated="2017-12-05 02:45:41.0"> <body><! CDATA  ~manish-sethi  In my opinion:  PEER_RESOURCE_UPDATE transaction should _return error_ if resources required for _commit_ cannot be created (e.g. couchdb channel_chaincode database). These are must-have have committing blocks.  PEER_RESOURCE_UPDATE transaction should _succeed and only write an error to log_ if resources required for _endorse_ cannot be created (e.g. couchdb indexes). These are not must-have for committing blocks.  Concerning *peer.ledger.state.couchDBConfig.autoDeployChaincodeIndexes*, there must be a way to turn off the auto deploy on the peer, for cases where it is causing a problem or admin simply prefers to manage indexes manually.        ></body> </Action>
<Action id="35819" issue="15648" author="manish-sethi" type="comment" created="2017-12-05 03:50:02.0" updateauthor="manish-sethi" updated="2017-12-05 03:52:39.0"> <body><! CDATA  ~denyeart  yes, we discuss it like this but I am not certain that we can define these categories (i.e., resources required by Committer vs Endorser for future transactions) in black and white.  If you think from one angle, the scope of the transaction `PEER_RESOURCE_UPDATE` is just to define the chaincode. So, as long as peer is able to record that definition, the transaction could be considered processed. Under this approach, we need to create db upon commit of a transaction for the chaincode (or upon receiving endorsement request for the chaincode) - because that particular transaction needs the db (or indexes) and rightly raise the error because that request cannot be served. The argument for this approach would be that it would be a meaningless error (i.e. database could not be created) when someone is just trying to commit the chaincode definition - in other words, failing this transaction for the resource need of future endorser transactions.  From other point of view, it's convenient to create all the artifacts required for future transactions upfront and if does not succeed, fail the processing of `PEER_RESOURCE_UPDATE`.  While I am trying to debate in my head between the two of the above categories, somehow, I certainly do not feel comfortable diving the latter category into further two sub-categories (i.e., fail the transaction for the error in creating resources required by the Committer and don't do so for Endorser resources) - in my opinion, this is going to create a confusion.     The same is what I feel about 'peer.ledger.state.couchDBConfig.autoDeployChaincodeIndexes'. Exposing one more variable in the equation may complicate things further for the admins. We can always add this later if people feel the need. However, this is not as important for now to decide the above one.     ></body> </Action>
<Action id="35831" issue="15648" author="denyeart" type="comment" created="2017-12-05 11:13:10.0" updateauthor="denyeart" updated="2017-12-05 11:13:10.0"> <body><! CDATA  ~manish-sethi  What exactly are you proposing?  That PEER_RESOURCE_UPDATE transaction should succeed regardless of whether couchdb database or index creation succeeds?  Assuming administrator can fix these up later.  That is fine by me.  I still believe there must be a way to disable automatic index deployment on a peer, but we can see what others think.  ></body> </Action>
<Action id="35862" issue="15648" author="manish-sethi" type="comment" created="2017-12-05 13:33:41.0" updateauthor="manish-sethi" updated="2017-12-05 13:33:41.0"> <body><! CDATA yes,  ~denyeart  - this looks fine to me.  In addition, I would like to understand from  ~jyellick  how the listeners to resource tree work. Are these called synchronously? If yes, then we are fine. Else, this may add complication for handling a crash situation.  ></body> </Action>
<Action id="35864" issue="15648" author="jyellick" type="comment" created="2017-12-05 15:36:54.0" updateauthor="jyellick" updated="2017-12-05 15:36:54.0"> <body><! CDATA  ~manish-sethi  Yes, the listeners for any config tree are called synchronously on the committing go routine.  Although as pointed out before, we may be wandering outside of the scope of this issue, but I would always lean towards behaving deterministically and crashing, as opposed to trying to be too clever about errors.  In particular, we cannot have the local state of a peer (say, couch has run out of disk space) cause a tx to be marked invalid while other peers would mark it valid.  ></body> </Action>
<Action id="35873" issue="15648" author="manish-sethi" type="comment" created="2017-12-05 18:06:18.0" updateauthor="manish-sethi" updated="2017-12-05 18:06:59.0"> <body><! CDATA  ~jyellick  - we do not mark a transaction as invalid on any error. Only if a read-write conflict is detected or a custom tx processor returns a specific error of type `{color:#000000}InvalidTxError{color}`, a tran is marked as invalid.  Here we were just trying to figure out whether to fail (not invalid) the PEER_RESOURCE_UPDATE transaction in the both DB and Index creation. That is, raise a general error - which anyways results in a panic (we panic for a general error in the commit path).  In fact, this would be very convenient for us if we can raise the error.  Most likely, we would listen to the events via resource tree listener. Are you OK, if we are to enable a listener to throw an error which is propagated up in the commit go routine?  ></body> </Action>
<Action id="35876" issue="15648" author="jyellick" type="comment" body="Presently, there is no way to propagate errors through the listening interface.  The closest you could do would be to panic, with a recover before the committing go routine calls in.  Obviously it&apos;s just code, so we could potentially enhance the interface for this, but generally speaking, I&apos;m not sure we want to encourage the event listeners to return errors as a matter of course.  As you indicated, the only likely remedy will be panics." created="2017-12-05 18:23:02.0" updateauthor="jyellick" updated="2017-12-05 18:23:02.0"/>
<Action id="35968" issue="15648" author="baohua" type="comment" created="2017-12-07 06:33:05.0" updateauthor="baohua" updated="2017-12-07 06:33:05.0"> <body><! CDATA This change should not block the support of other database backends.  FYI., there's ongoing work to integrate mongodb: https://jira.hyperledger.org/browse/FAB-6263.  ></body> </Action>
<Action id="35999" issue="15648" author="manish-sethi" type="comment" body=" ~baohua  no, it won&apos;t. Thanks" created="2017-12-07 18:55:43.0" updateauthor="manish-sethi" updated="2017-12-07 18:55:43.0"/>
<Action id="37770" issue="15648" author="ppcm" type="comment" created="2017-12-23 10:05:56.0" updateauthor="ppcm" updated="2017-12-23 10:05:56.0"> <body><! CDATA It's great to have something to create easily indexes in database (CouchDB, MongoDB, ...), but the database must be exposed to do that.  What do you think if the index feature is defined in modeling language?  The information could be added in the JSON form for easily define in tools like Composer  ></body> </Action>
<Action id="44262" issue="15648" author="minollo" type="comment" body=" ~denyeart : Is the &quot;future work&quot; described here (additional peer command line options) associated to a JIRA we can track?" created="2018-05-11 15:15:46.0" updateauthor="minollo" updated="2018-05-11 15:15:46.0"/>
