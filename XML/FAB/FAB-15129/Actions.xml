<Action id="59095" issue="39199" author="ales" type="comment" created="2019-04-10 14:29:22.0" updateauthor="ales" updated="2019-04-10 16:04:20.0"> <body><! CDATA h1. Problem  LSCC custom validation was written under the assumption that ledger would only accept read-write sets {code:java} type TxReadWriteSet struct { DataModel            TxReadWriteSet_DataModel `protobuf:"varint,1,opt,name=data_model,json=dataModel,proto3,enum=rwset.TxReadWriteSet_DataModel" json:"data_model,omitempty"` NsRwset                *NsReadWriteSet        `protobuf:"bytes,2,rep,name=ns_rwset,json=nsRwset,proto3" json:"ns_rwset,omitempty"` XXX_NoUnkeyedLiteral struct{}                 `json:"-"` XXX_unrecognized       byte                   `json:"-"` XXX_sizecache        int32                    `json:"-"` } {code} where the {{NsRwset}} array would not contain 2 {{NsReadWriteSet}} entries  {code:java} // NsReadWriteSet encapsulates the read-write set for a chaincode type NsReadWriteSet struct { Namespace             string                          `protobuf:"bytes,1,opt,name=namespace,proto3" json:"namespace,omitempty"` Rwset                   byte                          `protobuf:"bytes,2,opt,name=rwset,proto3" json:"rwset,omitempty"` CollectionHashedRwset   *CollectionHashedReadWriteSet `protobuf:"bytes,3,rep,name=collection_hashed_rwset,json=collectionHashedRwset,proto3" json:"collection_hashed_rwset,omitempty"` XXX_NoUnkeyedLiteral  struct{}                        `json:"-"` XXX_unrecognized        byte                          `json:"-"` XXX_sizecache         int32                           `json:"-"` } {code} with identical {{Namespace}} field. However this assumption is incorrect, it is entirely possible for a read-write set to contain 2 or more {{NsReadWriteSet}} entries in the {{NsRwset}} array with identical {{Namespace}} field, and ledger will commit all writes in all {{NsReadWriteSets}}.  LSCC custom validation does not deal with this scenario because it assumes that there will only be a single namespace for LSCC upon deploy/upgrade. In a scenario with multiple entries for LSCC, the first entry in the array referring to LSCC is properly validated, whereas any subsequent entry is entirely ignored and will be committed as-is without any check.   The endorsement policy of LSCC is hardcoded to allow any org member to write to LSCC, and so any org may forge a transaction with 2 {{NsReadWriteSet}} entries for LSCC, and use the second entry to perform arbitrary writes in the LSCC namespace. h1. Consequences  This issue entirely breaks the endorsement model: any org in the channel may use this attack to overwrite the endorsement policy field of any chaincode definition. They can: # set any endorsement policy to be an accept-all policy, and subsequently modify any ledger key in any namespace directly, bypassing the chaincode # add themselves as members of any collection, triggering reconciliation and possibly learning about all past private data of any org (to be confirmed?)  h1. Proof of concept  Attached is a PoC for the attack using our integration tests. Just apply it on top of master, go to {{integration/nwo/}} and run tests. The PoC shows how a malicious organisation in the channel is able to overwrite the endorsement policy of a chaincode which originally required endorsement of 2 orgs. The endorsement policy is downgraded to an accept-all policy, at which point the malicious organisation is able to write arbitrary data into the chaincode namespace.  ></body> </Action>
<Action id="59097" issue="39199" author="ales" type="comment" body=" ~manish-sethi : I speculated in the consequences section that the malicious user can change collection definitions to their advantage, triggering reconciliation to learn about all private data in the namespace. Is that assumption correct?" created="2019-04-10 14:59:53.0" updateauthor="ales" updated="2019-04-10 14:59:53.0"/>
<Action id="59118" issue="39199" author="manish-sethi" type="comment" body=" ~ales : yes, I do not expect ledger not to process the change in the collection config as a legitimate one - as long as the transaction is marked `valid` by the validator." created="2019-04-11 03:06:32.0" updateauthor="manish-sethi" updated="2019-04-11 03:06:32.0"/>
<Action id="59124" issue="39199" author="mastersingh24" type="comment" created="2019-04-11 11:26:46.0" updateauthor="mastersingh24" updated="2019-04-11 11:26:46.0"> <body><! CDATA Wasn't this one of the reasons for doing the new lifecycle in the first place? I believe it's already possible for a single org to change the endorsement policy for chaincode with the current lifecycle?  ></body> </Action>
<Action id="59130" issue="39199" author="jyellick" type="comment" body=" ~mastersingh24  When you use the default instantiation policy (which all our users seem to do), any org admin can change your chaincode definition.  However, modifications were still prevented by unprivileged users, and if you specified an instantiation policy scoped to a particular org, you could restrict it further.  This attack represents a more fundamental and total break of LSCC, exploiting some of the already known broken-ness.  Because any unprivileged user may deploy a chaincode with an instantiation policy authorizing its own deployment, any user can commit to LSCC.  Combining this with the fact that any commit to LSCC may piggy-back arbitrary writes onto the latter portion of the writeset allows any user to modify any chaincode, bypassing all instanation policy checks which were protecting us to some extent." created="2019-04-11 13:14:22.0" updateauthor="jyellick" updated="2019-04-11 13:14:22.0"/>
<Action id="59160" issue="39199" author="ales" type="comment" created="2019-04-11 16:36:22.0" updateauthor="ales" updated="2019-04-11 16:36:22.0"> <body><! CDATA Exactly, the instantiation policy was there to ensure that only the original instantiator could modify the definition of a chaincode. Note that without the instantiation policy, collection configurations are entirely meaningless because we set a policy that restricts data movement, while allowing anyone to override it. Same for endorsement policies.  This vulnerability entirely bypasses that check, and lets any consortium member modify any chaincode definition (notably, its endorsement policy/collection configuration).  ></body> </Action>
<Action id="59539" issue="39199" author="ales" type="comment" created="2019-04-26 18:30:41.0" updateauthor="ales" updated="2019-04-26 18:30:41.0"> <body><! CDATA Speaking of fixes: the simplest way to fix the issue is to add a fix in the validator code to perform deduplication of the   {code:java} NsRwset                *NsReadWriteSet {code}  array to make sure that no two entries may refer to the same namespace. Clearly the new check can only be deployed  * as part of the 2.0 validator (so that it would be covered by the new 2.0 capability)  * as part of previous validators, gated by a specific capability  ></body> </Action>
<Action id="61319" issue="39199" author="wenjian" type="comment" created="2019-06-27 17:20:15.0" updateauthor="wenjian" updated="2019-06-28 15:16:33.0"> <body><! CDATA v1.4 CR:  https://gerrit.hyperledger.org/r/#/c/fabric/+/32115/   v2.0 CR:  https://gerrit.hyperledger.org/r/#/c/fabric/+/32126/   ></body> </Action>
<Action id="61323" issue="39199" author="wenjian" type="comment" created="2019-06-27 19:48:32.0" updateauthor="wenjian" updated="2019-06-27 19:48:32.0"> <body><! CDATA Below are log messages. Log file is attached as test.log.  ^  91m e ^  36m org1.peer2 ^  0m ^  31m2019-06-27 15:19:24.423 EDT  committer.txvalidator  validateTx -> ERRO 04c^  0m VSCCValidateTx for transaction txId = 6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc returned error: duplicate namespace 'lscc' in txRWSet ^  91m e ^  36m org1.peer2 ^  0m ^  34m2019-06-27 15:19:24.423 EDT  committer.txvalidator  Validate -> INFO 04d^  0m  testchannel  Validated block  3  in 0ms ^  91m e ^  36m org1.peer2 ^  0m ^  33m2019-06-27 15:19:24.423 EDT  valimpl  preprocessProtoBlock -> WARN 04e^  0m Channel  testchannel : Block  3  Transaction index  0  TxId  6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc  marked as invalid by committer. Reason code  ILLEGAL_WRITESET  ^  91m e ^  91m org2.peer2 ^  0m ^  31m2019-06-27 15:19:24.423 EDT  committer.txvalidator  validateTx -> ERRO 049^  0m VSCCValidateTx for transaction txId = 6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc returned error: duplicate namespace 'lscc' in txRWSet ^  91m e ^  35m org1.peer1 ^  0m ^  31m2019-06-27 15:19:24.423 EDT  committer.txvalidator  validateTx -> ERRO 064^  0m VSCCValidateTx for transaction txId = 6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc returned error: duplicate namespace 'lscc' in txRWSet ^  91m e ^  91m org2.peer2 ^  0m ^  34m2019-06-27 15:19:24.423 EDT  committer.txvalidator  Validate -> INFO 04a^  0m  testchannel  Validated block  3  in 0ms ^  91m e ^  35m org1.peer1 ^  0m ^  34m2019-06-27 15:19:24.423 EDT  committer.txvalidator  Validate -> INFO 065^  0m  testchannel  Validated block  3  in 0ms ^  91m e ^  91m org2.peer2 ^  0m ^  33m2019-06-27 15:19:24.423 EDT  valimpl  preprocessProtoBlock -> WARN 04b^  0m Channel  testchannel : Block  3  Transaction index  0  TxId  6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc  marked as invalid by committer. Reason code  ILLEGAL_WRITESET  ^  91m e ^  35m org1.peer1 ^  0m ^  33m2019-06-27 15:19:24.423 EDT  valimpl  preprocessProtoBlock -> WARN 066^  0m Channel  testchannel : Block  3  Transaction index  0  TxId  6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc  marked as invalid by committer. Reason code  ILLEGAL_WRITESET  ^  91m e ^  37m org2.peer1 ^  0m ^  31m2019-06-27 15:19:24.423 EDT  committer.txvalidator  validateTx -> ERRO 049^  0m VSCCValidateTx for transaction txId = 6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc returned error: duplicate namespace 'lscc' in txRWSet ^  91m e ^  37m org2.peer1 ^  0m ^  34m2019-06-27 15:19:24.423 EDT  committer.txvalidator  Validate -> INFO 04a^  0m  testchannel  Validated block  3  in 0ms ^  91m e ^  37m org2.peer1 ^  0m ^  33m2019-06-27 15:19:24.423 EDT  valimpl  preprocessProtoBlock -> WARN 04b^  0m Channel  testchannel : Block  3  Transaction index  0  TxId  6b8ed1053fb8320e0ef6b69f7766ade80e968f5a1f4a5a5d49e7974c3af993dc  marked as invalid by committer. Reason code  ILLEGAL_WRITESET   ></body> </Action>
<Action id="62701" issue="39199" author="denyeart" type="comment" body="Addressed via FAB-15845" created="2019-08-07 19:45:02.0" updateauthor="denyeart" updated="2019-08-07 19:45:02.0"/>
