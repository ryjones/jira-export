<Issue id="27868" key="FAB-8402" number="8402" project="10002" reporter="yacovm" creator="yacovm" type="10001" summary="Make peer CLI hint why the connection attempt failed" priority="3" status="10000" created="2018-02-20 16:28:51.0" updated="2019-09-13 06:47:12.0" votes="2" watches="5" workflowId="35563"> <description><! CDATA In fabric, when the peer CLI is invoked and it fails because of a connection error, the problem is not always because the connection can't be established, but in many cases it's due to incorrect configuration (lack of TLS flag, lack of TLS CA certs, wrong CA certs, etc. etc.)  Consider for example the following error: {code}Error: Error endorsing query: rpc error: code = Unavailable desc = transport is closing - <nil>{code}  This is an error that I made by a peer CLI query when the TLS_ENABLED is missing, and the peer is running with TLS.  The following error: {code} Error: Error getting endorser client chaincode: endorser client failed to connect to foobar:7051: failed to create new connection: context deadline exceeded {code}  Is when the peer CLI tries to connect to an unknown host.  This only gets worse when the server node (orderer/peer) uses mutual TLS because we have more configuration options.  I propose that the wrap the comm package's gRPC client (that has the NewConnection method) with another module (to be used by the peer/orderer/admin clients for the peer CLI) that will have the following behavior:  {code} func (ws *wrapperStruct) NewConnection( ... )  (connection, error) { // calls the inner gRPC client's NewConnection method conn, err := ws.NewConnection( ... ) if err == nil { return conn, nil }  // else, we try to figure out why we weren't able to connect. return ws.TryToFindErrorReason() } {code}  Basically - the peer CLI would just pass the connection attempt to the existing code, but upon failure - it would do more operations, such as: * DNS lookup * TCP probe * In case the peer CLI doesn't use TLS - figure out if the remote node uses TLS. * In case the peer CLI loaded a cert of CA foo, but the remote node's TLS certificate is signed by a TLS root CA of bar - figure it out and output it.  * In case the remote node expects us to use mutual auth but we haven't sent a client certificate, output it.  To figure out why the connection failed, and would pass the more informative error to the user. I think this has the potential to greatly enhance the user experience of using fabric and to prevent un-necessary user frustration. Opinions?    ~denyeart   ~mastersingh24   ~ChristopherFerris   ~jyellick    ~C0rWin   ></description> </Issue>
