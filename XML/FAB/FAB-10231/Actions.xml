<Action id="44742" issue="30415" author="pandrejko" type="comment" created="2018-05-21 15:23:39.0" updateauthor="pandrejko" updated="2018-05-21 15:24:19.0"> <body><! CDATA  ~denyeart  - Just curious why do we need to run the following  steps? Is there a technical reason why we can't just use the existing BYFN network after running ./byfn.sh -m up? (Just trying to save the end users some work here)     ./byfn.sh -m generate  peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem    peer channel join -b mychannel.block  CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel join -b mychannel.block  peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org1MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer channel update -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/Org2MSPanchors.tx --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  FWIW - Ratnaker and I tried the scenario after not running those steps, and so far it is working.     ></body> </Action>
<Action id="44763" issue="30415" author="denyeart" type="comment" body="Right, if you do those steps in BYFN, you don&apos;t have to re-do them for private data.  But if you jump straight to private data sample without running BYFN scenario first you&apos;ll need to run them." created="2018-05-21 17:53:22.0" updateauthor="denyeart" updated="2018-05-21 17:53:22.0"/>
<Action id="44895" issue="30415" author="pandrejko" type="comment" created="2018-05-22 20:38:30.0" updateauthor="pandrejko" updated="2018-05-22 20:38:30.0"> <body><! CDATA  ~denyeart   -- Can you provide a use case for purging private data? This capability seems contradictory to an immutable ledger.   -- How does this affect the auditability of the blockchain if the data disappears?  ></body> </Action>
<Action id="45047" issue="30415" author="c0rwin" type="comment" body=" ~denyeart  IMO, need to mention where one could find the chaincode itself, e.g.: https://gerrit.hyperledger.org/r/#/c/14769/" created="2018-05-24 11:59:35.0" updateauthor="c0rwin" updated="2018-05-24 11:59:35.0"/>
<Action id="45079" issue="30415" author="denyeart" type="comment" body=" ~C0rWin  The sample chaincode has moved to fabric-samples:  https://gerrit.hyperledger.org/r/#/c/22255/ " created="2018-05-24 17:18:22.0" updateauthor="denyeart" updated="2018-05-24 17:18:22.0"/>
<Action id="45152" issue="30415" author="denyeart" type="comment" body=" ~pandrejko  The private data may be transaction details between two parties, that they don&apos;t want to disclose to others on the channel. The private data is stored in private state database (aka side db) at these two organizations, and subsequent chaincode invocations between these two parties can reference or alter their shared private data.  Throughout these transactions, hashes of the private data are stored on the channel&apos;s blockchain. The private data may have a useful life in subsequent chaincode transactions for days or weeks until some logical conclusion of a business process (trade settled, contract fulfilled, etc). After that time, there is no need to keep the private data on their &apos;side dbs&apos; for the purpose of chaincode transactions, and the parties may want the data to disappear to either save space or ensure it doesn&apos;t fall into the wrong hands later.  They will likely keep a copy of the private data in their internal systems regardless. Even after the private data is purged though, the hash of the private data remains on the channel&apos;s immutable blockchain, so if for example the parties get in a dispute at some later point in time, or want to transfer an asset to another party, they can share the private data as needed with the 3rd party, and that 3rd party can take a hash of the private data, and confirm that the hash matches the hash that was recorded on the blockchain.  The hash serves as &apos;evidence&apos; or &apos;proof&apos; that the private data existed between the parties at a certain point in time." created="2018-05-25 19:12:19.0" updateauthor="denyeart" updated="2018-05-25 19:12:19.0"/>
<Action id="45307" issue="30415" author="yuki-kon" type="comment" created="2018-05-30 18:38:36.0" updateauthor="yuki-kon" updated="2018-05-30 18:38:36.0"> <body><! CDATA Hello  ~denyeart . I have a question about the design of Side DB. I added a new test to the current description. I wanted to see the result of the invoke when org2 doesn't have access to collectionMarblePrivateDetails. After installing chaincode and query on peer0.org2, invoke chaincode on peer0.org2.  A function `initMarble` puts two collections: `collectionMarbles`, `collectionMarblePrivateDetails`. peer0.org2 has access to only `collectionMarbles`. According to my test, it seems like that putting data to `collectionMarbles` succeeded and putting data to `collectionMarblePrivateDetails` failed. When a function put 2 public data and one of them fails to update, nothing is committed to the ledger. I wonder why one of the putting data succeeded when using Side DB. Is this the expected behavior of Side DB?  Before executing the following test scenario, I modified endorsement policy because the current endorsement policy has the wrong org name. "OR ('Org0MSP.peer','Org1MSP.peer')" should be updated to "OR ('Org1MSP.peer','Org2MSP.peer')"  Invoke chaincode on peer0.org2. The proposal response returned status code 200. {code:java} $ CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_LOCALMSPID="Org2MSP" CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args": "initMarble","marble2","blue","35","tom","99" }' (snip) 2018-05-30 17:21:30.803 UTC  chaincodeCmd  chaincodeInvokeOrQuery -> INFO 001 Chaincode invoke successful. result: status:200 {code} After invoke on peer0.org2, query on peer0.org2. First query succeeded. Second query failed. {code:java} $ CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarble","marble2" }' (snip) {"docType":"marble","name":"marble2","color":"blue","size":35,"owner":"tom"}  $ CORE_PEER_ADDRESS=peer0.org2.example.com:7051 CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/server.crt peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarblePrivateDetails","marble2" }' (snip) Error: error query chaincode by endorsing: status:500 message:"{\"Error\":\"Failed to get private details for marble2: GET_STATE failed: transaction ID: c4d9f939a7a287eab92a70b72a26f3358663bc8aeec329db97a0b9c07c57e638: Private data matching public hash version is not available. Public hash version = &version.Height{BlockNum:0x5, TxNum:0x0}, Private data version = (*version.Height)(nil)\"}" {code} After that, query on peer0.org1. The result was the same. First query succeeded and second query failed. {code:java} $ peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarble","marble2" }' (snip) {"docType":"marble","name":"marble2","color":"blue","size":35,"owner":"tom"}  $ peer chaincode query -C mychannel -n marblesp -c '{"Args": "readMarblePrivateDetails","marble2" }' (snip) Error: error query chaincode by endorsing: status:500 message:"{\"Error\":\"Failed to get private details for marble2: GET_STATE failed: transaction ID: e01c03346c688ce9b355131b1cf1226836041e3be8a964bbe6e97f201b2fb1b7: Private data matching public hash version is not available. Public hash version = &version.Height{BlockNum:0x5, TxNum:0x0}, Private data version = (*version.Height)(nil)\"}" {code}  ></body> </Action>
<Action id="45314" issue="30415" author="pandrejko" type="comment" created="2018-05-30 21:40:16.0" updateauthor="pandrejko" updated="2018-05-30 21:40:16.0"> <body><! CDATA  ~yuki-kon  I also wanted to let you know I am in the process of drafting a tutorial on this topic. It is similar but not identical to what Dave has here. I added you as a reviewer if you are interested.    https://gerrit.hyperledger.org/r/#/c/22357/      https://logs.hyperledger.org/production/vex-yul-hyp-jenkins-3/fabric-docs-build-x86_64/349/html/private_data_tutorial.html  ></body> </Action>
<Action id="45315" issue="30415" author="yuki-kon" type="comment" body="Thank you,  ~pandrejko . I will check the tutorial." created="2018-05-30 22:09:33.0" updateauthor="yuki-kon" updated="2018-05-30 22:09:33.0"/>
<Action id="48564" issue="30415" author="maddalipadmaja" type="comment" created="2018-08-08 12:57:07.0" updateauthor="maddalipadmaja" updated="2018-08-08 13:01:35.0"> <body><! CDATA There is a subtle discrepancy in the current implementation of marbles private data chaincode. Collections are used to share data among a set of organizations within the channel and also used when transaction data must be kept confidential from ordering service nodes. However, the current chaincode implementation makes it possible for the ordering service node(s) to access the data shared as part of the collection.  The marbles private data sample includes two collections: * collectionMarbles - allows all peers in Org1 and Org2 to store marbles private data 'name, owner, color, size' in their side database * collectionMarblePrivateDetails - allows only peers in Org1 to store marbles private data 'price' in their side database.  As the two collections are included in the chaincode proposal, the private data is also available to the ordering service node(s). To restrict the data access by the ordering service node(s), we have to pass private data (above collections) in the transient field of the chaincode proposal. With this, only the private data hashes will go through orderer and not the private data itself. The use of the transient field guarantees that the private data content will not be part of the transaction payload and hence the private data will not be available to the ordering service node(s).  We modified the existing marbles02_private chaincode to retrieve the transient field values by calling the GetTransient() API inside chaincode invoke functions. Please find attached patch file(patch0.patch) for details.  Apply patch using {code:java} patch -p1 < patch0.patch {code}    Please find modified chaincode invoke commands below  You need to generate marble details(name, color, owner, size and price) as base64 encoded string so that it can be passed as JSON to the peer chaincode invoke's transient parameter.  Transient parameters to create marble {code:java} NAME=$(echo marble1 | base64) COLOR=$(echo blue | base64)  SIZE=$(echo 35 | base64)  OWNER=$(echo tom | base64)  PRICE=$(echo 99 | base64) {code} *Invoke transaction to create new marble:* {code:java} peer chaincode invoke -o orderer.example.com:7050 --tls --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args": "initMarble" }' --transient "{\"NAME\":\"$NAME\",\"COLOR\":\"$COLOR\",\"OWNER\":\"$OWNER\",\"SIZE\":\"$SIZE\",\"PRICE\":\"$PRICE\"}"  {code} *Invoke transaction to transfer marble (assign new owner):*    {code:java} NAME=$(echo marble1 | base64) NEWOWNER=$(echo alice | base64)  peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args": "transferMarble" }' --transient "{\"NAME\":\"$NAME\",\"NEWOWNER\":\"$NEWOWNER\"}" {code}    *Invoke transaction to transfer all marbles of a certain color* {code:java} COLOR=$(echo red | base64) OWNER=$(echo tom | base64)  peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp1 -c '{"Args": "transferMarblesBasedOnColor" }' --transient "{\"COLOR\":\"$COLOR\",\"OWNER\":\"$OWNER\"}"   {code}       *Invoke transaction to delete marble* {code:java} NAME=$(echo marble1 | base64)  peer chaincode invoke -o orderer.example.com:7050 --tls $CORE_PEER_TLS_ENABLED --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n marblesp -c '{"Args": "delete" }' --transient "{\"NAME\":\"$NAME\"}" {code}       ></body> </Action>
<Action id="50730" issue="30415" author="denyeart" type="comment" body=" ~MaddaliPadmaja  That&apos;s correct, in the real world transient field should be used to pass private data from client to chaincode, so that it doesn&apos;t show up in the block.  Private data sample and tutorial will be updated in FAB-12056." created="2018-09-19 17:56:43.0" updateauthor="denyeart" updated="2019-01-23 05:05:51.0"/>
<Action id="50815" issue="30415" author="guillaumetong" type="comment" created="2018-09-20 03:27:53.0" updateauthor="guillaumetong" updated="2018-09-20 03:27:53.0"> <body><! CDATA  ~MaddaliPadmaja  thank you for this example. A small correction however:   You said: {code:java} NAME=$(echo marble1 | base64) COLOR=$(echo blue | base64)  SIZE=$(echo 35 | base64)  OWNER=$(echo tom | base64)  PRICE=$(echo 99 | base64){code} Using echo simply will append a new line to the end of the string output, which can create problems later on in the chaincode (with conversion to numbers for example).  I suggest adding the -n option to echo: {code:java} NAME=$(echo -n marble1 | base64) COLOR=$(echo -n blue | base64)  SIZE=$(echo -n 35 | base64)  OWNER=$(echo -n tom | base64)  PRICE=$(echo -n 99 | base64){code}    ></body> </Action>
<Action id="56070" issue="30415" author="denyeart" type="comment" body=" ~MaddaliPadmaja   ~GuillaumeTong  Private data sample and tutorial has been updated in FAB-12056 to demonstrate passing private data via CLI transient parameter." created="2019-01-23 05:07:32.0" updateauthor="denyeart" updated="2019-01-23 05:07:32.0"/>
