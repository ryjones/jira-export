<Issue id="40360" key="FAB-15613" number="15613" project="10002" reporter="ronenschafferibm" creator="ronenschafferibm" type="10002" summary="Single bi-directional connection management in gossip/comm" priority="3" status="10000" created="2019-06-04 08:34:01.0" updated="2021-04-14 22:27:46.0" votes="0" watches="7" workflowId="53275"> <description><! CDATA The design of gossip communication is to manage a single bi-directional connection between a pair of peers.  When 2 connections are created simultaneously between a pair of peers where both peers initiate a connection to each other there might be a race condition. Currently there are no tests in gossip/comm that reveal this. Although, there are tests in higher layers that reveal the problem, TestLeaderYield() for example. TestBasic() in gossip/comm can be used to reveal the race condition after removing the  sleep |https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/comm_test.go#L444 between the sendings.  The following sequence of events happen on failures (the following diagram might help understand). Comm1 and comm2 open connections to each other simultaneously. Comm1 calls getConnection(). There, it  creates|https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L90  a connection to comm2 (1st connection), and because there are  no existing|https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L105-L113  connections (comm1 receives the connection from comm2 later), it keeps it. Then, when comm1 receives the connection from comm2, comm1 enters onConnected(),  closes |https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L164-L166 1st connection (the connection it opened) and keeps the connection from comm2 (2nd connection). From comm2 perspective, it enters getConnection(). There, between the  first check |https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L82 and the  second check|https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L106 , it receives the connection from comm1 (1st connection). Since it passed the first check, it creates a connection to comm1 (2nd connection). But, because it received the connection from comm1, it doesn’t pass the second check and  closes |https://github.com/hyperledger/fabric/blob/0a9520e9f3bfb8a1246637df14fd770b8f4698f0/gossip/comm/conn.go#L110 the connection it just opened (2nd connection). In conclusion, comm1 closes the connection it opened (1st connection) and comm2 closes the connection it opened (2nd connection) and we end up with no opened connection, so any message sent will fail.  Alternatively, comm1 may fail earlier (before it reaches onConnected()), the same way as comm2. Namely, comm1 enters getConnection() and receives the connection from comm2 (2nd connection) between the two checks for an existing connection. It passes the first check and because of the receiving connection it closes the connection it created (1st connection). The bottom line is the same.     !image-2019-06-04-11-31-14-241.png!  ></description> </Issue>
