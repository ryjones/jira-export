<Action id="28646" issue="19351" author="yacovm" type="comment" created="2017-07-19 10:02:58.0" updateauthor="yacovm" updated="2017-07-19 10:02:58.0"> <body><! CDATA {quote}We need to define explicit interfaces for each type of SCC/plugin and not implement them as generic "chaincode"{quote}  I strongly agree, I also think that the SCC should be more modular and testable: * Right now it basically communicates with the rest of the peer via either singletons or static methods that use global variables.  * The access control of the SCC is built inside the SCC execution flow itself, and I think it needs to be extracted out into separate entities, so that access control could be tested separately, and the operations themselves could be tested separately.    However I think that at first we can have the SCCs that serve user requests (i.e, LSCC or QSCC) support the existing chaincode API for backwards compatibility.   ></body> </Action>
<Action id="28647" issue="19351" author="yacovm" type="comment" created="2017-07-19 10:11:13.0" updateauthor="yacovm" updated="2017-07-19 10:11:13.0"> <body><! CDATA I actually had a few ideas on how we can make certain parts of the peer be more modular- I extracted the SCC part into a separate google doc: https://docs.google.com/document/d/1SWdLkmc3shmKdfG9Azhl13-jcU_IzNrb2AkIw7P20lI/edit  ></body> </Action>
<Action id="28650" issue="19351" author="yacovm" type="comment" body="Also - if this is for v1.1 I think I&apos;d like to take this one. " created="2017-07-19 10:18:45.0" updateauthor="yacovm" updated="2017-07-19 10:18:45.0"/>
<Action id="28938" issue="19351" author="binhn" type="comment" created="2017-07-24 22:24:24.0" updateauthor="binhn" updated="2017-07-24 22:24:24.0"> <body><! CDATA  ~mastersingh24  {quote}We *might* still want to allow running of user chaincode in process (and perhaps we keep the current implementation for that purpose) but we should vet that as part of this item. {quote} I am ok with defining a different interface for a different type of plugins, but system chaincode should remain intact. System chaincodes implement certain behaviors related to chaincode, not a random plug-ins, and  people already use system chaincodes in their production systems.  ></body> </Action>
<Action id="28949" issue="19351" author="angelo.decaro" type="comment" body="As a general comment here, SCC involved in proposal/transaction processing need to be deterministic to avoid forking. I would suggest to keep the flow as simple as possible. I&apos;m already foreseeing the complexity of debugging them especially in situations where it is needed to figure out what caused a fork." created="2017-07-25 02:28:35.0" updateauthor="angelo.decaro" updated="2017-07-25 02:28:35.0"/>
<Action id="28962" issue="19351" author="vukolic" type="comment" body="Whatever code is executed after consensus in Fabric architecture must, indeed, be deterministic. However, I understand this JIRA issue not to go against this, but just to modularize diferrent VSCCs (among other xCCs). This is a good thing IMO - that being said, we must not allow application/chaincode developers to deploy new VSCCs (i.e., endorsement policies) dynamically.  ~mastersingh24   ~yacovm , do you plan here to allow VSCCs to be deployed  dynamically (like chaincode), or not?" created="2017-07-25 11:36:36.0" updateauthor="vukolic" updated="2017-07-25 11:36:36.0"/>
<Action id="28963" issue="19351" author="yacovm" type="comment" created="2017-07-25 12:00:02.0" updateauthor="yacovm" updated="2017-07-25 12:02:18.0"> <body><! CDATA {quote} However, I understand this JIRA issue not to go against this, but just to modularize diferrent VSCCs (among other xCCs).{quote}  That is correct  ~vukolic . The gist of this JIRA and proposal is to address certain aspects: * Essentially we have 2 types of operations in system chaincodes ** operations that are "client facing" - they should have an interface of a chaincode and the peer logic would optimally have a modular way of enforcing access control on them.  Right now we have checks in the code at each part that are "set in stone" and if a user would like these checks to be more severe, or more lenient it can not do so without completely replacing the ESCC or VSCC chaincode, but there are also other chaincode types that are customer facing - and for these you would need to write from scratch the needed chaincode and register it instead of the existing one.  If we could just decouple the data mutation steps from the access control that would not only give customers an easier life, but would also make the code more secure and testable. ** operations that are not client facing and are invoked by other SCCs, such as VSCC obtaining information from LSCC.  These types of operations should not go through a chaincode type of interface. There is no point in doing the marshalling and demarshalling of the data structures if we can instead just pass them by reference. a VSCC is a good example of this. Why do we need the VSCC to have an interface like a user chaincode, if only internal peer operations use it?  * The SCC code is pretty hard to mock and test. Making it modular would fix that. If we could just define each SCC as a function and all access to other SCCs it needs as interfaces - testing would be easier.  {quote}do you plan here to allow VSCCs to be deployed  dynamically (like chaincode), or not?{quote}  So, currently the VSCC name of the chaincode is set at instantiation of the chaincode and when the peer does the validation if fetches the VSCC instance and invokes it. So, if this isn't configured at instantiation - the default built in VSCC comes into play.  A user can override this and put its own VSCC.   ></body> </Action>
<Action id="28969" issue="19351" author="binhn" type="comment" created="2017-07-25 13:24:37.0" updateauthor="binhn" updated="2017-07-25 13:24:37.0"> <body><! CDATA All good discussion here :)  1 thing I want to caution is security of the system (peer in this case) related to plugins – not that I know any specific security holes, but on principles, the more hooks we provide, the more unknown risks we face. So we should tread carefully.  ></body> </Action>
<Action id="29213" issue="19351" author="mne" type="comment" created="2017-07-31 09:07:27.0" updateauthor="mne" updated="2017-07-31 09:07:27.0"> <body><! CDATA I like the idea of having pluggable SCC, just want to point out that Go plugins are currently limited to the Linux release of Go 1.8.  Given that Go plugins are binary, I'm wondering about the debugability of SCC that is provided as a plugin only - has anyone looked into this?  ></body> </Action>
<Action id="29776" issue="19351" author="yacovm" type="comment" body="It seems this was unilaterally repealed, so I am marking this as DONE since there is no other status." created="2017-08-12 13:37:44.0" updateauthor="yacovm" updated="2017-08-12 13:37:44.0"/>
