<Issue id="36357" key="FAB-13416" number="13416" project="10002" reporter="scottz" assignee="dongming" creator="scottz" type="10101" summary="SideDB - Reconciliation when add org and join peer, with two private collections" priority="3" resolution="10002" status="6" created="2018-12-20 22:24:32.0" updated="2019-07-31 21:29:27.0" resolutiondate="2019-07-31 21:29:27.0" votes="0" watches="1" workflowId="47888"> <description><! CDATA This is similar to running 11772 and 11773 together, while using 2 private collections. It is a good candidate for a single regression test to use in future releases to cover most variations of SideDB Reconciliation.  *+*Setup:*+  Network Topology: 1 channel, 5 orgs, 2 peers per org, each peer with CouchDB container for stateDB, 3 kafka, 1 zookeepers, 3 orderers, 2 ca, TLS enabled. +When start network+: * Join all peers in org1,org2,org3,org4 to the channel, and join org5.peer0 too but *do not join org5.peer1 yet*  * Submit the anchor peer updates for all orgs. * Put only the peers in org1,org2,org3,org4 (NOT org5) in both the private collections from the start * set BTL=0 (no purge)  Client Driver: PTE +Traffic patterns+:  Require 2 endorsements (1 peer from any 2 orgs), and send traffic using 16 traffic patterns: # public creates put (without private data), send to org1,org2 with privateCollection1 # sidedb creates putPrivate *push=0, required=0*, send to org1,org2 with privateCollection1 # sidedb creates putPrivate *push=7, required=0*, send to org1,org2 with privateCollection1 # sidedb creates putPrivate *push=7, required=7*, send to org1,org2 with privateCollection1 # public updates getPut (without private data), send to org1,org2 with privateCollection1 # sidedb updates getPutPrivate *push=0, required=0*, send to org1,org2 with privateCollection1 # sidedb updates getPutPrivate *push=7, required=0*, send to org1,org2 with privateCollection1 # sidedb updates getPutPrivate *push=7, required=7*, send to org1,org2 with privateCollection1 AND Duplicate the same 8 traffic patterns but instead use org3,org4 with privateCollection2  +*Test Steps:*+  1) chaincode: install only one chaincode on all peers, https://github.com/hyperledger/fabric/blob/master/examples/chaincode/go/map/map.go Join only the peers in orgs 1-4 to the channel1, plus org5.peer0. Do include all peers in orgs 1-4 (but neither peer in org5) in the privatedb collections definitions, and instantiate on channel1 on org1peer0.  2) Send 16 traffic threads of invokes as defined above, each 10,000 TXs  3) *Add org5 to both of the collections*: * Perform a cc upgrade (instantiate a new chaincode version) along with new privatedb collection files. Org5peer0 is in the channel, so this will cause it to start reconciliation for both private collections.  4) *Add/join a new peer org5peer1 to the channel, which already contains a large chain with large amount of private data history, to force this new peer to catch up all ledger blocks AND start reconciliation for both private collection chains.  5) Simultaneously send transactions to all peers (see the patterns above, plus add some to invoke on org5 peers), WHILE Query ALL types of the transactions on the newly joined org peers   Analyze TPS on all peers, and ensure all queries work (after the reconciliation is done). Note: we may need to use longer pte query timeout values. And/or to configure a reduced timeout value in the peer from 60 secs to 1 or 2 secs to hurry things along (refer to FAB-10599 for details).  +*Report Results in fields TestResult and TestDetails:*+ 1) hardware setup 2) Observe if TPS achieved for queries is too slow, or any other problems 3) CPU and memory usage for the Peers and CouchDB containers  ></description> </Issue>
