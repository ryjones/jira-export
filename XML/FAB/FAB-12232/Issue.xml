<Issue id="34216" key="FAB-12232" number="12232" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10001" summary="Leverage chainID for txvalidator instead of implementing chainExists method" priority="3" resolution="10200" status="6" created="2018-09-28 21:23:10.0" updated="2019-05-15 12:51:01.0" resolutiondate="2019-05-15 12:51:01.0" votes="0" watches="2" workflowId="45542"> <description><! CDATA Currently there is {{chainExists}} method which was introduced in early versions  {code} func (v *TxValidator) chainExists(chain string) bool { 	// TODO: implement this function! 	return true } {code}  which stubbed to always return {{true}} and this is actually fine as validator always intialized in context of committer which is bounded to one channel which is existing. Function aimed to be used during validation, while reading block header to ensure we are working with existing channel:  {code} 		channel := chdr.ChannelId 		logger.Debugf("Transaction is for channel %s", channel)  		if !v.chainExists(channel) { 			logger.Errorf("Dropping transaction for non-existent channel %s", channel) 			results <- &blockValidationResult{ 				tIdx:           tIdx, 				validationCode: peer.TxValidationCode_TARGET_CHAIN_NOT_FOUND, 			} 			return 		}  {code}  In FAB-12030 as part of serviceability enhancement, txvalidator struct was extended with {{ChainID}} field  {code} type TxValidator struct { 	ChainID string 	Support Support 	Vscc    vsccValidator } {code}   As a consequence now we can just leverage this information while unpacking block header to check validator is operating on correct channel, i.e. basically following code could be cleaned up and refactored from:  {code} 		channel := chdr.ChannelId 		logger.Debugf("Transaction is for channel %s", channel)  		if !v.chainExists(channel) { 			logger.Errorf("Dropping transaction for non-existent channel %s", channel) 			results <- &blockValidationResult{ 				tIdx:           tIdx, 				validationCode: peer.TxValidationCode_TARGET_CHAIN_NOT_FOUND, 			} 			return 		} {code}  into  {code} 		channel := chdr.ChannelId 		logger.Debugf("Transaction is for channel %s", channel)  		if v.ChainID != channel { 			logger.Errorf("Dropping transaction for non-expected channel %s", channel) 			results <- &blockValidationResult{ 				tIdx:           tIdx, 				validationCode: peer.TxValidationCode_TARGET_CHAIN_NOT_FOUND, 			} 			return 		}  {code}  eliminating the need of implementing {{chainExists}} function.  ></description> </Issue>
