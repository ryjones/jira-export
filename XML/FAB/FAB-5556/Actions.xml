<Action id="29379" issue="19633" author="angelo.decaro" type="comment" body=" ~binhn , I added Section 2.6 to describe possible incompatibility issues with the MSP related to the support of RSA public keys/signatures." created="2017-08-03 01:06:39.0" updateauthor="angelo.decaro" updated="2017-08-03 01:06:39.0"/>
<Action id="29757" issue="19633" author="jyellick" type="comment" created="2017-08-11 18:39:28.0" updateauthor="jyellick" updated="2017-08-11 19:06:30.0"> <body><! CDATA I think the creation of these sub-tasks is extremely premature.  I am usually a relentless optimist with regards to what we can accomplish in code in a short period of time, but the idea that in 3 weeks, we will have a real, no-holes solution to supporting a mixed-mode v1.0/v1.1 network seems incredibly low, bordering on laughable.  This is a truly hard problem.  We need not only for the system to work in the green path, but we also need to analyze all of the error cases, and all of the attack cases.  Designing the original set of messages took months of effort, and we still found ourselves making necessary last minute changes.  I do not see how we hope to  change these structures to make a true mixed-mode network possible in this short  of a timeframe.  Consider the simple question of "Add Version to the Block".  How does this work? Is the version part of the hash chain? If so, then v1.0 clients cannot compute the hash chain correctly without viewing this field.  If not, what are the security implications of someone being able to modify the version field without breaking the hash chain?  What about the signatures over the metadata which are built on the block header hash? If not in the hash chain, then the version is not signed over, what are the implications of that? What should a peer do when they receive a block of a higher version? Do they retry forever for a block of the current version, or do they give up on the channel until restart?  These are some questions off the top of my head for one version field in one message.  If we cannot immediately answer all of them confidently, IMO we have no business attempting to modify the message to include this field.  As I see it, the best we can do, is to say: "These features are new in v1.1, and we do not support running mixed mode if they are utilized.  Otherwise all changes are backwards compatible."  I think it would be a good idea to backport a fix to 1.0.x to enforce that a v1.0 peer or orderer will not process transactions with a v1.1 channel header.  I'm very wary of us getting any solution which is more complicated done right in 3 weeks.  ></body> </Action>
<Action id="29762" issue="19633" author="yacovm" type="comment" created="2017-08-11 19:16:42.0" updateauthor="yacovm" updated="2017-08-11 19:20:42.0"> <body><! CDATA I agree with Jason on the complexity of the matter and I personally think that the design doc linked should be more elaborate and contain exactly the scenarios and possibilities of what happens if component X from V1.0 comes with interaction with component X from V1.1 Also - we need to keep in mind that we have a 3-tier architecture (clients, orderers, peers) and entities travel between them, etc.  ></body> </Action>
<Action id="29766" issue="19633" author="binhn" type="comment" created="2017-08-11 20:20:56.0" updateauthor="binhn" updated="2017-08-11 20:20:56.0"> <body><! CDATA  ~jyellick   ~yacovm   The document has been and still is open for edit – a whole paragraph right at the beginning telling readers that, and it requires all to contribute. It is not a 1 person effort to work this out. Please spend your valuable time on capturing the thoughts on the design document.     ></body> </Action>
<Action id="29767" issue="19633" author="jyellick" type="comment" body="The fact that we are creating tasks and submitting CRs would imply to me that the design document is complete and there is consensus on its handling all of the possible cases.  Not to speak for  ~yacovm  as well, but I do not believe we would agree that either of these conditions have been met." created="2017-08-11 20:28:56.0" updateauthor="jyellick" updated="2017-08-11 20:29:38.0"/>
<Action id="29772" issue="19633" author="binhn" type="comment" body=" ~jyellick   We are certainly not following a waterfall model. Try something out and see where we end up. " created="2017-08-11 21:00:14.0" updateauthor="binhn" updated="2017-08-11 21:00:14.0"/>
<Action id="30512" issue="19633" author="rickr" type="comment" created="2017-09-05 14:37:19.0" updateauthor="rickr" updated="2017-09-05 14:37:19.0"> <body><! CDATA  https://docs.google.com/document/d/1CbB8dR0GNnHi7UekIDpsySCBXkPTtKk0m53CIzJbU-A/edit#heading=h.4atsg7w1xphx      3.2 Protocol Version The current protocol version is in ChannelHeader.Version. This design will not use this field; however, we will not remove the field just yet. We can deprecate if we don’t actually need it.  Some SDK sets ChannelHeader.Version to 1, but neither the Peer nor Orderer checks this version field, so the SDK may ignore this field in v1.1.     By this I'm taking this to be a _NO-OP_ as a SDK todo.  ></body> </Action>
<Action id="30726" issue="19633" author="rickr" type="comment" body=" ~jyellick  Still not understanding what the impact for the SDKs will be for this on v1.1 delivery.  The version change seemed to be a NOOP.  Last heard it was decided to be not used." created="2017-09-11 14:23:49.0" updateauthor="rickr" updated="2017-09-11 14:23:49.0"/>
<Action id="30739" issue="19633" author="jyellick" type="comment" body=" ~rickr  Since we still don&apos;t have any intended use for the {{version}} field of the transaction nor anywhere else, I see this as a no-op for the SDK." created="2017-09-11 20:09:34.0" updateauthor="jyellick" updated="2017-09-11 20:09:34.0"/>
<Action id="31141" issue="19633" author="christopherferris" type="comment" body="I added to review-needed so that we can come to consensus on our approach for this. there are outstanding CRs but think thathere is still disagreement on implementation strategy. Getting votes will sort that out." created="2017-09-25 16:00:07.0" updateauthor="christopherferris" updated="2017-09-25 16:00:07.0"/>
<Action id="31142" issue="19633" author="kchristidis" type="comment" body="Along the same lines, can we either modify the Google Doc or create a new one that captures exactly what the outstanding CRs implement? (Still early on in the review process, but my understanding is that there&apos;s a delta between the doc and the CRs.)" created="2017-09-25 16:03:18.0" updateauthor="kchristidis" updated="2017-09-25 16:03:18.0"/>
<Action id="31234" issue="19633" author="greg.haskins" type="comment" body="I dont yet have an opinion on what the right mechanism/requirements/behavior should be, but I recognize the importance of the concept." created="2017-09-28 14:01:00.0" updateauthor="greg.haskins" updated="2017-09-28 14:01:00.0"/>
<Action id="31281" issue="19633" author="christopherferris" type="comment" body="This has the requisite votes to proceed." created="2017-09-29 15:59:11.0" updateauthor="christopherferris" updated="2017-09-29 15:59:11.0"/>
<Action id="31282" issue="19633" author="jyellick" type="comment" body="I have taken as a  TODO to update the description of this JIRA to reflect the current design in the CRs and will try to get to it soon." created="2017-09-29 16:50:19.0" updateauthor="jyellick" updated="2017-09-29 16:50:19.0"/>
<Action id="31283" issue="19633" author="jonathanlevi" type="comment" body=" ~jyellick  this will be very helpful (== you rock!)" created="2017-09-29 17:00:17.0" updateauthor="jonathanlevi" updated="2017-09-29 17:00:17.0"/>
<Action id="31295" issue="19633" author="jyellick" type="comment" body="(Done with the update to the description, please feel free to edit and or post questions regarding it here)" created="2017-09-29 23:09:11.0" updateauthor="jyellick" updated="2017-09-29 23:09:11.0"/>
<Action id="35922" issue="19633" author="denyeart" type="comment" created="2017-12-06 13:30:33.0" updateauthor="denyeart" updated="2017-12-06 13:30:33.0"> <body><! CDATA  ~jyellick   ~rickr  brought up a good question.  How should clients such as SDKs determine if a certain peer or orderer is at 1.0 level, at 1.1 level but working in 1.0 compatibility mode due to channel config, or at 1.1 level with 1.1 capabilities enabled?  More specifically,  * Should the SDK ask a peer/orderer its version?  For example if peer is at 1.1 level but 1.1 capabilities have not been enabled on the channel, can the SDK still call new 1.1 features on the peer that are not hidden behind the capabilities config (e.g. the new Deliver API)?  If so I think we'll need an API on peer and orderer to get the version. * Or should SDK simply look at the channel capabilities and treat all peers/orderers based on the enabled capabilities on the channel.  That is, if 1.1 capability is not enabled on channel, treat all peers/orderers as if they are 1.0.  And if 1.1 capability is enabled on channel, treat all peers/orderers as if they are 1.1.  Actually it would not be this simple, as the SDK would have to look at both /Channel capabilities and /Channel/Application capabilities to determine the peer's total capabilities.  Has this been thought through already, or do we need a new "design task" to figure this out?  ></body> </Action>
<Action id="35923" issue="19633" author="yacovm" type="comment" created="2017-12-06 13:38:42.0" updateauthor="yacovm" updated="2017-12-06 13:39:54.0"> <body><! CDATA I would like to piggyback on  ~denyeart  's question and verify that the  peer CLI|https://gerrit.hyperledger.org/r/#/c/15461/45/peer/chaincode/resources.go@129 's approach is OK: It queries the new API from CSCC (get config tree) and if it returns a non error response it means the capability is enabled. I think it is trivial for the peer to check locally if the capability is enabled on the channel and return an error if not.  ></body> </Action>
<Action id="35942" issue="19633" author="jyellick" type="comment" created="2017-12-06 17:10:47.0" updateauthor="jyellick" updated="2017-12-06 17:10:47.0"> <body><! CDATA  ~yacovm  I actually think there is a slight problem in the peer CLI's approach.  The new CSCC API is currently made available regardless of channel config version, and in fact, since CSCC is not channel scoped, I'm not certain that it's possible to do so.  With  ~aambati 's CR, if a peer is queried for the new CSCC {{GetConfigTree}} function, and the peer binary is a v1.1, it will respond successfully.  Of course if the peer is a v1.0 binary, it will respond with an error.  So it's fairly easy to detect a peer which only supports the old mechanism.  The question becomes how to detect a v1.1 peer binary whether the channel is operating in a v1.1 mode.  What clients could do today with no modifications to the peer, is to look at the channel config returned as part of {{GetConfigTree}}, then look at the capabilities defined in the channel, and proceed from there.  This has the benefit of not exposing any new API, but the downside of requiring the client to gain some knowledge of how to extract the capabilities from the channel config.  If we are okay with that approach, then I'm not sure a new design task is warranted.  On the other hand, if we want to add new API surface, I would suggest we open one.  So, with the "no changes" approach, it would be the client's duty to inspect the channel config returned by a v1.1 peer binary to see if the application v1.1 capability is enabled or not.  Then proceed from there.  This is what I would propose.  ></body> </Action>
<Action id="35943" issue="19633" author="yacovm" type="comment" created="2017-12-06 18:03:14.0" updateauthor="yacovm" updated="2017-12-06 18:03:14.0"> <body><! CDATA {quote} ~yacovm  I actually think there is a slight problem in the peer CLI's approach. The new CSCC API is currently made available regardless of channel config version, and in fact, since CSCC is not channel scoped, I'm not certain that it's possible to do so. {quote}   # The CSCC can decide whether to return an error or to return an OK status. The peer CLI parses this and detects if it is an application error or not. # The CSCC isn't channel scoped, but the client passes the channel in the parameter.    {quote}   With  ~aambati 's CR, if a peer is queried for the new CSCC {{GetConfigTree}} function, and the peer binary is a v1.1, it will respond successfully. Of course if the peer is a v1.0 binary, it will respond with an error. So it's fairly easy to detect a peer which only supports the old mechanism. {quote}    Right. I'm saying it needs to be changed to adapt to the channel version too, and it can be done quite easily so.    {quote}   The question becomes how to detect a v1.1 peer binary whether the channel is operating in a v1.1 mode. What clients could do today with no modifications to the peer, is to look at the channel config returned as part of {{GetConfigTree}}, then look at the capabilities defined in the channel, and proceed from there. This has the benefit of not exposing any new API, but the downside of requiring the client to gain some knowledge of how to extract the capabilities from the channel config. If we are okay with that approach, then I'm not sure a new design task is warranted. On the other hand, if we want to add new API surface, I would suggest we open one. {quote}    I honestly don't see why we can't just have the peer return an error if the resource config isn't enabled in the channel? We enable the resource config via a channel config, so it's not like we need that API before we move the channel to the resource config mode.  Also - if the channel isn't in the resource config mode then there is no reason to use that GetConfig API.  What am I missing here?  ></body> </Action>
<Action id="35948" issue="19633" author="jyellick" type="comment" created="2017-12-06 19:06:37.0" updateauthor="jyellick" updated="2017-12-06 19:06:37.0"> <body><! CDATA {quote} I honestly don't see why we can't just have the peer return an error if the resource config isn't enabled in the channel? We enable the resource config via a channel config, so it's not like we need that API before we move the channel to the resource config mode. Also - if the channel isn't in the resource config mode then there is no reason to use that GetConfig API. What am I missing here? {quote}  Sure, if we'd prefer, we could modify the API to return an error if the channel does not have a v1.1 capability.  This would make the current CLI code and current CSCC implementation mesh together just fine.  It was an unfair statement to say there is a problem with the CLI's approach, a more correct statement would have been to say "the current CLI CR and the current CSCC API do not handle the case where the peer binary has been upgraded, but the channel has not."  The reason why I suggested this other approach was to answer Dave's question more directly of "How can the client tell what capabilities are on?"  If the new CSCC API were made available for non v1.1 capable channels (as it is today), then the client could use this to determine the capabilities of even pre-v1.1 capable channels.  ></body> </Action>
<Action id="35953" issue="19633" author="denyeart" type="comment" created="2017-12-06 21:49:45.0" updateauthor="denyeart" updated="2017-12-06 21:49:45.0"> <body><! CDATA Ok, let me write down the generalized logic that SDK and clients in general could utilize for any release. (1.1) could be replaced with any future release number.  ~rickr   ~harrisob@us.ibm.com  Please review:  * For any Fabric release, clients need to understand which of the (1.1) channel 'capabilities' may impact their behavior.  Note, for 1.1 the list is in FAB-5999 and should also get into release notes. As of now, the only known capability that impacts client behavior is the new lifecycle (not yet in FAB-5999 since not yet merged). * For (1.1) capabilities that impact their behavior, the client will call GetConfigTree (on peer) or can retrieve the latest config block via Deliver (on orderer), and inspect the channel config which contains capabilities level (channel, orderer, or application scope depending on the specific capability). Depending on the capabilities level, client interacts accordingly.  * The channel capabilities level can be cached locally in client. If a compatibility-sensitive call starts failing, client can refresh cache by getting channel config (channel may have enabled (1.1) capabilities in the meantime). * An error upon the GetConfigTree call can be interpreted to mean that the peer is a 1.0 binary and therefore no (1.1) capabilities are enabled on the channel. * Client does not need to check each orderer/peer binary level. For new (1.1) server APIs that are not hidden behind channel 'capabilities', the client simply attempts the call on the server.  On down-level (1.0) servers, the call would return an error. Client should handle as any other error.  ></body> </Action>
