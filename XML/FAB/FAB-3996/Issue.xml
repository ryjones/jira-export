<Issue id="16843" key="FAB-3996" number="3996" project="10002" reporter="greg.haskins" assignee="mrkiouak" creator="greg.haskins" type="10004" summary="peer does not invalidate old chaincode containers" priority="3" resolution="10001" status="6" created="2017-05-18 02:13:08.0" updated="2020-01-22 19:11:00.0" resolutiondate="2020-01-22 19:11:00.0" votes="1" watches="7" workflowId="35179"> <description><! CDATA The peer currently has two persistence layers for chaincode: # /var/hyperledger/fabric/peer/chaincodes # docker images  (1) is updated when new chaincode is installed.  (2) is updated when chaincode is instantiated for the first time.  Subsequent instantiate() operations will see that (2) already exists and optimize the build-phase away.  It is possible (and especially easy during development) to get in a situation where one persistence layer is cleaned independently from the other.  For instance, a peer running in docker and with an ephemeral /var will restart from scratch every time the container is launched.  However, the docker-images may continue to persist regardless since the storage for the images is on the peer's host.  The implication of this is that we can get in a situation where chaincode is loaded via install(), but that the instantiate() phase incorrectly optimizes the docker-build away because it detects a hit in the current image inventory.  Note that this detection is based purely on the chaincode name, and not it's contents.  The two impacts here are: # You may or may not get the proper executable.  E.g. there's no guarantee that the chaincode container of the same name is actually related to the code that was submitted. # You may or may not get the proper TLS setup.  The peer certificate is currently injected during the docker-build phase.  It is plausible that the peer may be using a completely different x509 since the container was built, but this is not detected.  While all of these maladies are much more likely to impact development use cases rather than production, it should be noted that it seems both a bit fragile to assume coherence, difficult to detect when it happens,  as well as easy to fix.  Therefore, we should consider enhancing the system to handle this gracefully.  The suggested fix is to invalidate the docker-images cache during the install() operation.  ></description> </Issue>
