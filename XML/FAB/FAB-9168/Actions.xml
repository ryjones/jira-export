<Action id="42451" issue="28897" author="denyeart" type="comment" created="2018-04-02 23:26:13.0" updateauthor="denyeart" updated="2018-04-02 23:26:55.0"> <body><! CDATA  ~manish-sethi   ~jyellick   ~ales   I don't think we'll need a separate chaincode system namespace, we can use a reserved key namespace within existing user chaincode namespace. Let me explain:  Simple keys must not start with null character (0x00), as documented here:  https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/shim/interfaces_stable.go#L88-L95|https://github.com/hyperledger/fabric/blob/release-1.1/core/chaincode/shim/interfaces_stable.go#L88-L95.   Composite keys automatically get prepended with null character (0x00), this is the composite key namespace.  The first part of any composite key (objecttype) must not have a null character (0x00), as the null character is also the separator for composite key parts.  Therefore, we can safely use double null character (0x00 0x00) as a reserved namespace in user chaincodes for system properties such as init status. Some code changes will be required to support this, but I think this is a cleaner approach than having a separate system namespace.     ></body> </Action>
<Action id="42465" issue="28897" author="jyellick" type="comment" body=" ~denyeart  This is great news.  Perhaps we should come up with some convention for subdividing this remaining namespace? Perhaps say... {{\0\0system_}} for this namespace, in case we need an additional namespace in the future?" created="2018-04-03 14:02:42.0" updateauthor="jyellick" updated="2018-04-03 14:02:42.0"/>
<Action id="42473" issue="28897" author="ales" type="comment" created="2018-04-03 16:21:57.0" updateauthor="ales" updated="2018-04-03 16:21:57.0"> <body><! CDATA This approach seems okay, but - just for the record - I don't think fabric will stop me from creating a KVS key which is `string(  byte\{0x00, 0x00, 0x35})`? So in theory, customers might already be writing to this ledger sub-namespace.     Then the question becomes: should we put in code to block writes to such keys in future releases (with exceptions)? If we don't block them, do we consider a transaction that writes to such a key valid if it's endorsed appropriately according to the cc's endorsement policy? And then what happens if a chaincode tries to tamper with some such keys on which the peer depends to enforce some invariants (e.g. atomic `Init`)?  ></body> </Action>
