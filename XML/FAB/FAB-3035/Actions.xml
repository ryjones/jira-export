<Action id="21942" issue="15615" author="yacovm" type="comment" created="2017-04-07 13:10:13.0" updateauthor="yacovm" updated="2017-04-07 13:10:13.0"> <body><! CDATA I don't think that pluggable consensus is good enough of a reason to decouple the orderer from the fabric project. I'd argue the opposite- if you want pluggable consensus, implement an interface that the fabric project declares, and then you could import fabric as a dependency and simply run your orderer with the consensus algorithm of your choice behind the scenes.   Or, alternatively - implement an interface, and have fabric orderer use this consensus implementation as a dependency?  We have lots of common code between the peer and the orderer, and both are written in go. I'd say... decoupling them is error-prone and will be hard to maintain.   ></body> </Action>
<Action id="21943" issue="15615" author="baohua" type="comment" created="2017-04-07 13:32:43.0" updateauthor="baohua" updated="2017-04-07 13:32:43.0"> <body><! CDATA Thanks for the comments, yacov!  Actually, from the design, the orderer should mainly focus on consensus, rather than process txs, hence there would be lots of fabric code not be used in orderer.  The decoupling idea is from functionality. I have to admit that the existing orderer code and fabric peer code are coupled to each other too much, which makes it a little difficult to clear the structure right now.  But this issue would start the discussion and reminder the further design and implementation. How to make the code reusable, how to make the code structure much easier to follow and maintain.  Thanks!  ></body> </Action>
<Action id="66999" issue="15615" author="sykesm" type="comment" body="Stale" created="2020-01-22 19:02:20.0" updateauthor="sykesm" updated="2020-01-22 19:02:20.0"/>
