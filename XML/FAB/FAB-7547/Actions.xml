<Action id="37737" issue="26260" author="ales" type="comment" body=" ~elli-androulaki ,  ~angelo.decaro ,  ~mastersingh24 ,  ~jyellick ,  ~yacovm ,  ~C0rWin  pls weigh in" created="2017-12-22 08:45:39.0" updateauthor="ales" updated="2017-12-22 08:45:39.0"/>
<Action id="37739" issue="26260" author="yacovm" type="comment" created="2017-12-22 09:56:24.0" updateauthor="yacovm" updated="2017-12-22 10:00:08.0"> <body><! CDATA I have a couple of questions before I can weigh in, since I don't understand the all the details: {quote}Also assume that N_A := N_A' || prefix {quote} That means that both N_A' and prefix are less (or equal) than 24 bytes, since (from what I know) the length of the nonce is 24 bytes. It doesn't matter whether we enforce length checks on the nonce in this case, since if we assume that Alice runs correct software - then she generates a 24 byte sized nonce. {quote}Bob contacts its CA and attempts to generate a certificate cert_B that has as a suffix the bytes of cert_A (e.g. cert_B := prefix || cert_A) which is valid under its MSP. {quote}  That's not entirely accurate since cert_A is not a certificate but a SerializedIdentity, right? It contains the MSP_ID and the certificate in PEM encoding. So, it's more like *creator_B := prefix || "mspA" || cert_A* Since the orderer checks Bob's signature and evaluates the identity in order to do that, Bob needs creator_B to be a valid identity.  Now, we already know, that in protobuf - if I encode a message in schema S that has fields:    {code:java} message SerializedIdentity { 	// The identifier of the associated membership service provider string mspid = 1;  // the Identity, serialized according to the rules of its MPS bytes id_bytes = 2;  leftover bytes = 3; }{code} Then a protobuf "reader" that has schema S' that matches the real fabric schema: {code:java} message SerializedIdentity { 	// The identifier of the associated membership service provider string mspid = 1;  // the Identity, serialized according to the rules of its MPS bytes id_bytes = 2; } {code} Would ignore the leftover bytes, however the hashes are taken over all the serialized bytes.  That means that you can actually append any bytes you want to the creator and protobuf would happily consume it.  So, I think Bob acts under the following 4 constraints: # *creator_B := prefix || "mspA" || cert_A* # \|prefix\|< 24 bytes| # substring(creator_B, i) is a valid identity under MSP B for some i between 0 and |creator_B| # substring(creator_B, i) unmarshals to: "B" and cert_B such that cert_B is a valid x509 certificate (or, idemix identity ?) for some i between 0 and |creator_B|  The real question is whether (3) and (4) can be satisfied...?  We know that PEM parsers expect "\-\-\-\-\-BEGIN " which is 11 bytes, to be the prefix of a PEM block.  From the structure of creator_B, we know that  "\-\-\-\-\-BEGIN " must appear inside prefix, and also for the PEM parser to know where to end, it needs "\n\-\-\-\-\-END" which is 10 bytes.  so that leaves 3 bytes of something else to be in prefix... no?     Now, you didn't describe the impact of the attack here. To my understanding - all Bob wants to do is to prevent Alice's transaction to be validated, right? To do this - Bob needs to know Alice's nonce before it gets into the block. That implies one of the 2: * Bob has a conspiring orderer, but then this is an overkill and the orderer can just drop the transaction, no? * Bob has a conspiring peer that received the endorsement, but then - the peer can just produce a signature over a wrong simulation, and the endorsements would not be identical at the client side and the client would not know who's fault it is in case of (i.e) a 2-organization endorsement policy.     I personally don't think that it's cost-effective to introduce a capability only for a denial of service attack that is essentially a front-running attack, and one that requires peers or orderers as collaborators.     ></body> </Action>
<Action id="37776" issue="26260" author="blw" type="comment" created="2017-12-23 18:35:10.0" updateauthor="blw" updated="2017-12-23 18:35:10.0"> <body><! CDATA I see an additional constraint as well. {quote}Also assume that N_A := N_A' || prefix {quote} By the time that Bob has access to N_A, its contents and length are frozen. That means that the only flexibility that Bob has for N_A' || prefix is where to demarcate the string. For example, if N_A := "123456789", then the possible values for N_A' || prefix are: "12345678||9", "1234567||89", "123456||789", etc. So, for a given N_A of length n, there are n+1 possible ways to demarcate N_A, and therefore there are only n+1 possible values for the prefix and N_A'. {quote}Bob contacts its CA and attempts to generate a certificate cert_B that has as a suffix the bytes of cert_A (e.g. cert_B := prefix || cert_A) which is valid under its MSP. {quote} Given, from above, that there are only n+1 possible values for the prefix, and n is a relatively small number (since N_A is probably just a few bytes), it follows that Bob's CA would be forced to find a valid cert in a very small solution space. Continuing the example above, cert_B's possible values would have to be one of: "9||cert_A", "89||cert_A", "789||cert_A", etc. It would be quite difficult for Bob's CA to be able to find a cert that is valid under Bob's MSP in a space of only n+1 possibilities.  ></body> </Action>
<Action id="41963" issue="26260" author="denyeart" type="comment" body="Many issues were bulk moved from v1.0 or v1.1 to v1.2 as part of a cleanup effort, and many of these issues are not high priority or actually intended to be worked for v1.2.  This issue is being bulk moved to Future.  If the issue is indeed high priority for v1.2 and/or very low effort, please move back to v1.2 and add a comment to indicate rationale." created="2018-03-23 05:07:46.0" updateauthor="denyeart" updated="2018-03-23 05:07:46.0"/>
<Action id="42107" issue="26260" author="ales" type="comment" created="2018-03-24 09:11:40.0" updateauthor="ales" updated="2018-03-24 09:11:40.0"> <body><! CDATA Reasons to fix in 1.2: * it's very little code * it would follow a security best-practice * there's talk of re-engineering txids anyway  ></body> </Action>
<Action id="67206" issue="26260" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:22:01.0" updateauthor="sykesm" updated="2020-01-22 22:22:01.0"/>
