<Action id="68160" issue="44387" author="jyellick" type="comment" created="2020-02-28 19:45:22.0" updateauthor="jyellick" updated="2020-02-28 19:45:22.0"> <body><! CDATA In order to allow Raft to re-initialize, we'll need to do a few things:  We need to ensure that the metadata is nil here, in order to trigger the {{isMigration}}  is true|https://github.com/hyperledger/fabric/blob/b78d79ba5ec83e645fec4fc4139479317fb11f59/orderer/consensus/etcdraft/consenter.go#L141-L144 .  And, we'll need to ensure that the WAL is deleted so that {{fresh}}  is false|https://github.com/hyperledger/fabric/blob/master/orderer/consensus/etcdraft/chain.go#L215 .  This will trigger the etcdraft code to  treat the startup as a new channel|https://github.com/hyperledger/fabric/blob/b78d79ba5ec83e645fec4fc4139479317fb11f59/orderer/consensus/etcdraft/node.go#L62-L73 .  The metadata field comes from  here|https://github.com/hyperledger/fabric/blob/b78d79ba5ec83e645fec4fc4139479317fb11f59/orderer/common/multichannel/chainsupport.go#L49  where it is simply unmarshaling a field in the block. The problem we have, is that this is a signed field, and, the peers check that this signature is valid. So, we'll need to decide how we want to handle this.  We could have the orderer re-sign the metadata, but this poses a few different possible problems.  a) There is a corner case, where this OSN got this block via state transfer, for a channel config in which they are not an authorized block writer, and therefore they are not authorized to sign. b) For future BFT support where we need multiple signatures over the metadata, it breaks as well.  So, I think we'll need to signal to the orderer in some other way that this i a reset block. The most obvious way to do this to me, would be to extend the metadata encoding for the field to allow additional unsigned data that the orderer would prefer, if it were present. Or, we could add a new metadata slot in the metadata slice, which would be for such overrides. I'm open to opinions or better options.  ></body> </Action>
<Action id="68163" issue="44387" author="yacovm" type="comment" created="2020-02-28 22:52:15.0" updateauthor="yacovm" updated="2020-02-28 22:52:15.0"> <body><! CDATA {quote}   2 - Restore the peers to a point earlier than the orderers. This doesn't work without work on the user because the orderer will have hashes for private data that the peers no longer have and the peers will keep trying to fetch the data. My understanding is to fix this the user would have to do blind writes to the PDC in their application. {quote}    But if the peers committed the pre-images they should be able to correlate the hashes with the private data.  Am I missing something? Because it seems to me that we just need to ensure that pre-images aren't wiped out as part of ledger reset.     ></body> </Action>
<Action id="68198" issue="44387" author="guoger" type="comment" created="2020-03-03 07:04:47.0" updateauthor="guoger" updated="2020-03-03 07:05:22.0"> <body><! CDATA bq.  And, we'll need to ensure that the WAL is deleted so that fresh is false. I believe you meant "so that fresh is true"?  ~jyellick   i'm not really a fan of rolling back ledger on orderers. I'm trying to understand how that pre-image is being wiped out from network?  ></body> </Action>
<Action id="69402" issue="44387" author="denyeart" type="comment" created="2020-06-05 17:18:05.0" updateauthor="denyeart" updated="2020-06-05 17:18:05.0"> <body><! CDATA For restoring a network, we've decided it is better to utilize peer rollbacks to a prior backed up orderer height, rather than orderer rollbacks.  See proposal at:   https://docs.google.com/presentation/d/10v3cFga-Z5TFaCsgQNKBf7KuXfF1POYVSwGRSrT2muY/edit#slide=id.p1   For now at least, I'll mark this issue as Won't Do.  We could re-open later if it is determined that orderer rollbacks are required.  ></body> </Action>
<Action id="72400" issue="44387" author="JIRAUSER22919" type="comment" created="2022-01-19 22:54:28.0" updateauthor="JIRAUSER22919" updated="2022-01-19 22:54:28.0"> <body><! CDATA Bad blocks caused by certificate installation and configuration problems during rotation events seem to be a good use case for orderer rollback in the event of a crypto material mishap. For example: I had a system that had a certificate expiration problem due to crossing the one year mark, the 8760 hour mark from the default config in `ca.yaml`   I accidentally, rather ignorantly, rotated the following keypairs: * my CA keypair * my CA ECert * my orderer org admin keypair (private key + ECert) * my peer org admin keypair (private key + ECert) * my orderer user keypair (private key + ECert) * my peer user keypair (private key + ECert)  Then I sent a block to the orderer that got the following error:  {code:bash}  timestamp   cauthdsl  deduplicate -> ERRO 045 Principal deserialization failure (the supplied identity is not valid: x509: certificate signed by unknown authority (possibly because of "x509: ECDSA verification failure" while trying to verify candidate authority certificate "kentbull.com")) for identity 0  timestamp   blocksProvider  DeliverBlocks -> ERRO 046  bullyard  Error verifying block with sequence number 1215, due to implicit policy evaluation failed - 0 sub-policies were satisfied, but this policy requires 1 of the 'Writers' sub-policies to be satisfied {code}  Simple setup, one peer, one orderer, two organizations, one CA.  After I couldn't get past this error I reverted the newly rotated material and used the old crypto material (MSP directories and ECerts, etc.) to boot my network up again.   I started from a certificate expiration error and decided to rotate the above crypto material since I didn't know what I was doing and I thought that would help. 13 days later, and a bunch of docs reading and troubleshooting into this (130+ hours), I determined I needed to time-shift backwards, sign a configuration block with the old admin identities, Peer and Orderer, where the new config block contains the ECert of the new Peer and Orderer org admins. Then I would roll to the present, put the new crypto material in the appropriate MSP directories, and start up the newly configured network.   This worked perfectly in dev, staging, and an acceptance test environment. However, production had this weird block that was sent to the orderer with the rotated root of trust and for whatever reason the orderer won't let go of that block. This effectively prevents all installation of chaincode, all transactions, and anything on the peer.  I've tried rollback and reset on the peer though of course that makes no difference since the Orderer pushes the bad block onto the peer.  Maybe I'm just misconfiguring my peer or orderer crypto material. Yet it seems there's something else going on here.    ></body> </Action>
