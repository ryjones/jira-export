<Action id="63955" issue="42413" author="denyeart" type="comment" body=" ~yacovm  Do you have any recommendations for troubleshooting?" created="2019-09-23 03:24:29.0" updateauthor="denyeart" updated="2019-09-23 03:24:29.0"/>
<Action id="63961" issue="42413" author="yacovm" type="comment" created="2019-09-23 05:43:21.0" updateauthor="yacovm" updated="2019-09-23 05:43:21.0"> <body><! CDATA Yes, please follow the following thread on rocket chat  https://chat.hyperledger.org/channel/fabric?msg=vWdkzXhdGLfSEkbzY  ></body> </Action>
<Action id="64407" issue="42413" author="yacovm" type="comment" created="2019-10-08 19:42:18.0" updateauthor="yacovm" updated="2019-10-08 19:42:18.0"> <body><! CDATA  OK I think I cracked it... I managed to reproduce the problem with this test:    {code:java} Describe("gossip", func() { 	It("gossip", func() { 		network = nwo.New(nwo.BasicEtcdRaft(), testDir, client, BasePort(), components) 		network.GenerateConfigTree() 		network.Bootstrap()		orderers := network.OrdererGroupRunner() 		ordererProcesses = ifrit.Invoke(orderers) 		Eventually(ordererProcesses.Ready(), network.EventuallyTimeout).Should(BeClosed()) 		defer ordererProcesses.Signal(syscall.SIGTERM)		var peers   *nwo.Peer 		for _, org := range   string{"Org1", "Org2"} { 			for _, p := range   string{"peer0", "peer1"} { 				peers = append(peers, network.Peer(org, p)) 			} 		}		var peerProcesses   ifrit.Process		launchPeer := func(p *nwo.Peer) ifrit.Process { 			pr := network.PeerRunner(p) 			proc := ifrit.Invoke(pr) 			Eventually(proc.Ready(), network.EventuallyTimeout).Should(BeClosed()) 			return proc 		}		for _, p := range peers { 			pp := launchPeer(p) 			peerProcesses = append(peerProcesses, pp) 		}		defer func() { 			for _, p := range peerProcesses { 				p.Signal(syscall.SIGTERM) 			} 		}()		orderer := network.Orderer("orderer") 		peer := network.Peer("Org1", "peer0")		channel := "testchannel" 		network.CreateAndJoinChannel(orderer, channel)		network.UpdateChannelAnchors(orderer, channel)		assertMembership := func(exected int) { 			peer := network.Peer("Org1", "peer1") 			Eventually(func() int { 				membership := nwo.DiscoverPeers(network, peer, "User1", channel) 				return len(membership()) 			}, network.EventuallyTimeout).Should(Equal(exected)) 		}		By("Waiting for membership to be established") 		assertMembership(4)		By("Taking down a peer") 		peerProcesses 0 .Signal(syscall.SIGTERM) 		Eventually(peerProcesses 0 .Wait(), network.EventuallyTimeout).Should(Receive())		assertMembership(3)		By("Re-Newing its certificate") 		peerDomain := network.Organization(peer.Organization).Domain		peerCACertPath := filepath.Join(network.RootDir, "crypto", "peerOrganizations", 			peerDomain, "ca", fmt.Sprintf("ca.%s-cert.pem", peerDomain)) 		peerCACert, err := ioutil.ReadFile(peerCACertPath) 		Expect(err).NotTo(HaveOccurred())		peerCAKeyPath := filepath.Join(network.RootDir, "crypto", "peerOrganizations", 			peerDomain, "ca", privateKeyFileName(peerCACert))		peerCAKey, err := ioutil.ReadFile(peerCAKeyPath) 		Expect(err).NotTo(HaveOccurred())		peerCert, err := ioutil.ReadFile(network.PeerCert(peer)) 		Expect(err).NotTo(HaveOccurred())		peerNewCert := reNewCertificate(peerCert, peerCACert, peerCAKey)		// Overwrite the old certificate 		err = ioutil.WriteFile(network.PeerCert(peer), peerNewCert, 600) 		Expect(err).NotTo(HaveOccurred())		// Copy the old private key to the new private key name 		peerKey, err := ioutil.ReadFile(filepath.Join(network.PeerLocalMSPDir(peer), "keystore", privateKeyFileName(peerCert))) 		Expect(err).NotTo(HaveOccurred())		err = ioutil.WriteFile(filepath.Join(network.PeerLocalMSPDir(peer), "keystore", privateKeyFileName(peerNewCert)), peerKey, 600) 		Expect(err).NotTo(HaveOccurred())		By("Restarting the peer") 		peerProcesses 0  = launchPeer(peer)		By("Waiting for membership to be re-established") 		assertMembership(4)		time.Sleep(time.Minute * 15) 		Fail("bla") 	}) }) func reNewCertificate(certPEM, caCertPEM, caKeyPEM   byte)   byte { 	keyAsDER, _ := pem.Decode(caKeyPEM) 	caKeyWithoutType, err := x509.ParsePKCS8PrivateKey(keyAsDER.Bytes) 	Expect(err).NotTo(HaveOccurred()) 	caKey := caKeyWithoutType.(*ecdsa.PrivateKey)	caCertAsDER, _ := pem.Decode(caCertPEM) 	caCert, err := x509.ParseCertificate(caCertAsDER.Bytes) 	Expect(err).NotTo(HaveOccurred())	certAsDER, _ := pem.Decode(certPEM) 	cert, err := x509.ParseCertificate(certAsDER.Bytes) 	Expect(err).NotTo(HaveOccurred())	cert.Raw = nil 	cert.NotBefore = time.Now() 	cert.NotAfter = time.Now().Add(time.Hour)	// The CA signs the certificate 	certBytes, err := x509.CreateCertificate(rand.Reader, cert, caCert, cert.PublicKey, caKey) 	Expect(err).NotTo(HaveOccurred())	return pem.EncodeToMemory(&pem.Block{Bytes: certBytes, Type: "CERTIFICATE"}) }{code} Now, indeed the connections started to leak: {code:java} yacovm@~ $ ps -ef | grep peer | grep -v grep | awk '{print $2}' | while read pid; do ls -l /proc/$pid/fd |  grep socket | wc -l; echo $pid; done 12 20146 14 20162 13 20178 23 22348 yacovm@~ $ netstat -nlop | grep 22348 (Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.) tcp        0      0 127.0.0.1:31004         0.0.0.0:*               LISTEN      22348/peer           off (0.00/0/0) tcp        0      0 127.0.0.1:31008         0.0.0.0:*               LISTEN      22348/peer           off (0.00/0/0) tcp        0      0 127.0.0.1:39402         0.0.0.0:*               LISTEN      22348/peer           off (0.00/0/0) tcp6       0      0 :::31005                :::*                    LISTEN      22348/peer           off (0.00/0/0) yacovm@~ $ netstat -an | grep 31004 | grep ESTAB tcp        0      0 127.0.0.1:31004         127.0.0.1:47874         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47956         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47642         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47652         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47380         ESTABLISHED tcp        0      0 127.0.0.1:47394         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47906         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:46972         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47624         ESTABLISHED tcp        0      0 127.0.0.1:47652         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47874         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47340         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47956         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47380         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:46972         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47984         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47340         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:48004         ESTABLISHED tcp        0      0 127.0.0.1:47642         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47314         ESTABLISHED tcp        0      0 127.0.0.1:47536         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47624         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47984         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47906         ESTABLISHED tcp        0      0 127.0.0.1:47952         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47394         ESTABLISHED tcp        0      0 127.0.0.1:46980         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47952         ESTABLISHED tcp        0      0 127.0.0.1:48004         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47322         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:46980         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47536         ESTABLISHED tcp        0      0 127.0.0.1:47314         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:47294         127.0.0.1:31004         ESTABLISHED tcp        0      0 127.0.0.1:31004         127.0.0.1:47294         ESTABLISHED tcp        0      0 127.0.0.1:47322         127.0.0.1:31004         ESTABLISHED {code}    I uploaded this fix:  https://gerrit.hyperledger.org/r/#/c/fabric/+/33907/  I think this also fixed FAB-16699.  You are welcome to try it and see if it works.     ></body> </Action>
<Action id="64411" issue="42413" author="baohua" type="comment" created="2019-10-08 22:00:56.0" updateauthor="baohua" updated="2019-10-08 22:00:56.0"> <body><! CDATA This is very interesting, and drop my thoughts:  1) Is it helpful to expire the old peer quickly?  2) Should we introduce some kicking/replacing mechanism that a new pki-id to take the addr of an existing member?  ></body> </Action>
<Action id="64413" issue="42413" author="yacovm" type="comment" body="Just read the commit message in my change set, you will understand what&apos;s going on and what is the fix." created="2019-10-08 22:52:29.0" updateauthor="yacovm" updated="2019-10-08 22:52:29.0"/>
<Action id="64519" issue="42413" author="yacovm" type="comment" body=" ~nkalichynskyi  we merged this change, you can now check it by building a new peer image yourself (or, i can also build and push it to my docker hub namespace for you to pull, if you want)" created="2019-10-10 07:45:07.0" updateauthor="yacovm" updated="2019-10-10 07:45:47.0"/>
<Action id="64520" issue="42413" author="nkalichynskyi" type="comment" body="Tested the fix locally, the bug is no longer reproducible. Peer maintains proper amount of connections." created="2019-10-10 08:58:32.0" updateauthor="nkalichynskyi" updated="2019-10-10 08:58:32.0"/>
