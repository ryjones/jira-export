<Action id="29943" issue="20221" author="yacovm" type="comment" created="2017-08-17 08:27:00.0" updateauthor="yacovm" updated="2017-08-17 08:46:36.0"> <body><! CDATA  ~manish-sethi  ,  ~denyeart  I could use your help here... it seems like *store_impl.go*'s *getLastCommittedBlockNum* returns true, 0 {code} func (s *store) getLastCommittedBlockNum() (bool, uint64, error) { 	var v   byte 	var err error 	if v, err = s.db.Get(lastCommittedBlkkey); v == nil || err != nil { 		return true, 0, err 	} 	return false, decodeBlockNum(v), nil } {code}  And when *Prepare* happens (as part of the commit) - the *s.nextBlockNum()* would check the *s.isEmpty* and would return 0 and this would fail the commit and crash the peer.  It seems like *lastCommittedBlkkey* doesn't exist in the ledger? Previously this was something like   byte("blkMgrInfo") (I guess it also exists now, right?) and now the private data storage has also: {code} lastCommittedBlkkey =   byte{1} {code} ?  I guess the last committed block key in the private store needs to be derived from the public ledger in case of an upgrade from a v1.0.1 ledger to a v1.1 ledger. Is this correct or am I completely off the course?   ></body> </Action>
<Action id="29960" issue="20221" author="manish-sethi" type="comment" created="2017-08-17 15:50:21.0" updateauthor="manish-sethi" updated="2017-08-17 15:50:21.0"> <body><! CDATA  ~yacovm  - yes, your finding is correct. The separate maintenance of the *lastCommittedBlkkey* for the pvt data is causing this issue. However, the solution may not be as straight as initializing this value from public block storage. This solution will work for the scenario that you are testing for i.e., initializing the peer with existing block storage from 1.0 (because, 1.0 does not contain any pvt data). But for the scenarios, where the underlying block store files are from later versions (current master?), and somehow the pvt data store is not copied over, it would lead to other complications.     One of the potential solutions could be to check this mismatch between *lastCommittedBlkkey* and the max block height available in the public block storage (bcInfo.Height) . If *lastCommittedBlkkey* is found behind bcInfo.Height, the blocks should be parsed to bring *lastCommittedBlkkey* up to date. However, this may require a large number of block parsing and hence some versioning scheme for block file may help in this.     As a short-fix, we can assume that the migration of block files with uninitialized *lastCommittedBlkkey* is because of the upgrade scenario and not because of the fact that the administrator copied block files from somewhere and forgot to copy the pvt data.  I'll fix this and submit a CR.  ></body> </Action>
<Action id="29974" issue="20221" author="manish-sethi" type="comment" body="Submitted a CR - https://gerrit.hyperledger.org/r/#/c/12579" created="2017-08-17 20:24:35.0" updateauthor="manish-sethi" updated="2017-08-17 20:24:35.0"/>
