<Issue id="30044" key="FAB-9955" number="9955" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10001" summary="Optimze distribution of the private data" priority="3" resolution="10000" status="6" created="2018-05-08 19:01:12.0" updated="2018-07-20 18:49:48.0" resolutiondate="2018-05-15 05:36:32.0" votes="0" watches="3" workflowId="42114"> <description><! CDATA While distributing private data, the collection configuration is being looked up with the transient store, for each collection name new query is issued, e.g.  {code} 	for _, pvtRwset := range privData.NsPvtRwset { 		namespace := pvtRwset.Namespace 		for _, collection := range pvtRwset.CollectionPvtRwset { 			collectionName := collection.CollectionName 			cc := common.CollectionCriteria{ 				Namespace:  namespace, 				Collection: collectionName, 				TxId:       txID, 				Channel:    d.chainID, 			} 			colAP, err := cs.RetrieveCollectionAccessPolicy(cc) 			if err != nil { 				logger.Error("Could not find collection access policy for", cc, "error", err) 				return nil, errors.WithMessage(err, fmt.Sprintf("collection access policy for %v not found", cc)) 			}  			colFilter := colAP.AccessFilter() 			if colFilter == nil { 				logger.Error("Collection access policy for", cc, "has no filter") 				return nil, errors.Errorf("No collection access policy filter computed for %v", cc) 			}  			colCP, err := cs.RetrieveCollectionConfigPackage(cc) 			if err != nil { 				logger.Error("Failed to load collection config package, collection criteria", cc, "error", err) 				return nil, errors.WithMessage(err, fmt.Sprintf("collection config package, for %v not found", cc)) 			}  			pvtDataMsg, err := d.createPrivateDataMessage(txID, namespace, collection, colCP, blkHt) 			if err != nil { 				return nil, errors.WithStack(err) 			}  			dPlan, err := d.disseminationPlanForMsg(colAP, colFilter, pvtDataMsg) 			if err != nil { 				return nil, errors.WithStack(err) 			} 			disseminationPlan = append(disseminationPlan, dPlan...) 		} 	} {code}  where for each collection criteria returns same results, therefore no need to repeat query for each collection name and this could be optimized.  {code} 			cc := common.CollectionCriteria{ 				Namespace:  namespace, 				Collection: collectionName, 				TxId:       txID, 				Channel:    d.chainID, 			} {code}  Thus this code could be optimized with respect of query numbers and also additional fact to consider, is possible race condition, where collection config could be update after endorsement, hence it might be a case we are reading configuration which is not relevant for private read-write set in context.  ></description> </Issue>
