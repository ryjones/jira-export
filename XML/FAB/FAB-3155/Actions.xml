<Action id="22605" issue="15742" author="muralisr" type="comment" created="2017-04-17 20:11:44.0" updateauthor="muralisr" updated="2017-04-17 20:12:24.0"> <body><! CDATA  ~ellaki   ~mne   _ensure a chaincode with the same name has not been added to the channel_ Nothing special should have to be done for this.  The chaincode LCCC entry has been added as part of the RW set. If another TX was committed and added the entry the ledger validation will catch this.  _does not overwrite existing chaincode entry_  What does this mean ? I'm assuming overwrite referst to overwriting the chaincode instantiation entry in the LCCC ? If so the previous comment applies.  The thing that has to be done for this (both for instantiate and upgrade) is to get the ChaincodeData from the returned Response object (we could get it from the RW set but would be more painful). Both instantiate and upgrade return ChaincodeData bytes in the returned Response object (see under Invoke in core/scc/lccc.go) and use that for the other two validation mentioned in *Description* section.  ></body> </Action>
<Action id="22622" issue="15742" author="mne" type="comment" body="Part of this overlaps with FAB-2931" created="2017-04-18 11:45:37.0" updateauthor="mne" updated="2017-04-18 11:45:37.0"/>
<Action id="22624" issue="15742" author="elli-androulaki" type="comment" created="2017-04-18 12:28:08.0" updateauthor="elli-androulaki" updated="2017-04-18 12:41:51.0"> <body><! CDATA  ~muralisr , here is the flow for *instantiation* as we were thinking it (please intervene if you think this is not correct):  1. Client -> Endorser: InstantiationRequest(ccName, ccVersion) 2. Endorser: checks  - if ccName exists in LCCC database, and if so it sets Response <- ERR and returns,  - its local (CC installation) database contains a chaincode with ccName and ccVersion, and if not it sets Response <- ERR and returns - retrieves the respective entry of installed chaincode to create a new instantiation entry to the LCCC instantiation table containing   ccName, ccVersion, hash(ccCode), ccInstantiationPolicy    - checks if signedProposal (includes also the creator) satisfies the ccInstantiationPolicy using the channel's MSPs and sets Response <- ERR if not and returns - includes the new instantiation entry as part of the writeSet in the Response with an endorsement on it  3. Endorser -> Client: Response  4. Client: creates a tx  5. Client -> Orderers: tx  6. Orderers -> Committing peers: block including tx 7. Committing peers: Do the validation as follows: - check the creator /creator signature satisfies the writers policy of the channel, and reject if this is not the case - check that the creator of the transaction and its signature satisfy the instantiation policy included in the RW set of the transaction - check that a chaincode with the same name has not been added in the ccInstantiation database of LCCC and reject the transaciton if this is the case   agnostic to how this is done, though the ledger or not, but the check needs to be there  - check if the peer has locally a chaincode with the same id as the one in the instantiation transaction, and "mark it" as active for that chaincode (not sure this is needed)  ~mne , please add if i am missing something :)  8. Client -> endorser: Invocation of the instantiated chaincode 9. Endorser: Checks if the chaincode (name, version) said being active on the chain, are the same as the (name, version) appearing locally, and that the chaincode has been marked as active. If these checks do not pass, we return an error. It otherwise continues with the processing of the proposal. This is the topic of FAB-3156.  Adding  ~binhn , and  ~ales .  See, next comment for upgrade.  ></body> </Action>
<Action id="22625" issue="15742" author="elli-androulaki" type="comment" created="2017-04-18 12:40:24.0" updateauthor="elli-androulaki" updated="2017-04-18 12:42:04.0"> <body><! CDATA  ~muralisr , here is the flow for *upgdade* announcement on the chain as we were thinking it (please intervene if you think this is not correct):  1. Client -> Endorser: UpgradeInstantiationRequest(ccName, ccVersion') 2. Endorser: checks  - if ccName exists in LCCC database, and *if not* it sets Response <- ERR and returns,  - its local (CC installation) database *contains a chaincode with ccName and ccVersion', and if not it sets Response <- ERR and returns* - *retrieves the respective entry of installed chaincode to create a new instantiation entry to the LCCC instantiation table containing   ccName, ccVersion', hash(ccCode'), ccInstantiationPolicy'  , where "'" denotes the newer versions of the entries of this table. Let   ccName, ccVersion, hash(ccCode), ccInstantiationPolicy , denotes the old entries* - checks if signedProposal (includes also the creator) *satisfies the old ccInstantiationPolicy* using the channel's MSPs and sets Response <- ERR if not and returns - includes the new instantiation entry as part of the writeSet in the Response with an endorsement on it  3. Endorser -> Client: Response  4. Client: creates a tx  5. Client -> Orderers: tx  6. Orderers -> Committing peers: block including tx 7. Committing peers: Do the validation as follows: - check the creator /creator signature satisfies the writers policy of the channel, and reject if this is not the case - check that the creator of the transaction and its signature satisfy the *ccInstantiationPolicy of the old instantiation entry of the upgdade chaincode (should be referenced in the Read set of the transaction)* - check that the *read-set only consists the older version of the a chaincode with the same name and reject the transaciton if this is the case*  - check if the peer has locally a chaincode with the same id as the one in the instantiation transaction (id is the hash of name, version, hash of code, and instantiation policy), and "mark it" as active for that chaincode (not sure this is needed)  ~mne , please add if i am missing something :)  8. Client -> endorser: Invocation of the instantiated chaincode 9. Endorser: Checks if the chaincode (name, version) said being active on the chain, are the same as the (name, version) appearing locally, and that the chaincode has been marked as active. If these checks do not pass, we return an error. It otherwise continues with the processing of the proposal. This is the topic of FAB-3156.  Adding  ~binhn , and  ~ales .    ></body> </Action>
<Action id="22658" issue="15742" author="muralisr" type="comment" created="2017-04-18 21:11:36.0" updateauthor="muralisr" updated="2017-04-18 21:15:14.0"> <body><! CDATA  ~ellaki   Let me address the above comment with two comments. * in this comment strike through things that are done so we can focus on the TODOs.  * in the next, look at the TODOs with questions / comments  1. Client -> Endorser: UpgradeInstantiationRequest(ccName, ccVersion') 2. Endorser: checks -if ccName exists in LCCC database, and if not it sets Response < ERR and returns,-   {color:#d04437}_note that there's no "database" ... its a filesystem check.. Done_{color}  -its local (CC installation) database contains a chaincode with ccName and ccVersion', and if not it sets Response < ERR and returns. retrieves the respective entry of installed chaincode to create a new instantiation entry to the LCCC instantiation table containing   ccName, ccVersion', hash(ccCode'), ccInstantiationPolicy'  , where "'" denotes the newer versions of the entries of this table. Let   ccName, ccVersion, hash(ccCode), ccInstantiationPolicy , denotes the old entries- _{color:#d04437}Done{color}_  -checks if signedProposal (includes also the creator) satisfies the old ccInstantiationPolicy using the channel's MSPs and sets Response < ERR if not and returns-  {color:#d04437}_I think this is done via the normal proposal path ? i'd check with  ~ales  and if something more needs to be done specific to instantiation please do that_{color} _{color:#d04437}Done{color}_  -includes the new instantiation entry as part of the writeSet in the Response with an endorsement on it- _{color:#d04437}Done (normal RW set processing from the ledger){color}_  -3. Endorser -> Client: Response- -4. Client: creates a tx- -5. Client -> Orderers: tx- -6. Orderers -> Committing peers: block including tx- 7. Committing peers: Do the validation as follows: check the creator /creator signature satisfies the writers policy of the channel, and reject if this is not the case  check that the creator of the transaction and its signature satisfy the ccInstantiationPolicy of the old instantiation entry of the upgdade chaincode (should be referenced in the Read set of the transaction)  -check that the read-set only consists the older version of the a chaincode with the same name and reject the transaciton if this is the case- _{color:#d04437}This is done as part of the normal RW analysis. There is a "version" check that can be done (over and beyond RW checks) for upgrade but that's not part of this JIRA.{color}_  -check if the peer has locally a chaincode with the same id as the one in the instantiation transaction (id is the hash of name, version, hash of code, and instantiation policy), and "mark it" as active for that chaincode (not sure this is needed)- {color:#d04437}Not needed. The lifecycle will manage start/stop and terminate which has to be on a channel basis.{color}  Matthias Neugschwandtner, please add if i am missing something  -8. Client -> endorser: Invocation of the instantiated chaincode- 9. Endorser: -Checks if the chaincode (name, version) said being active on the chain, - {color:#d04437}Not needed.{color}  -are the same as the (name, version) appearing locally, - Done  -and that the chaincode has been marked as active.- Not needed  If these checks do not pass, we return an error. It otherwise continues with the processing of the proposal. This is the topic of FAB-3156.   ></body> </Action>
<Action id="22659" issue="15742" author="muralisr" type="comment" created="2017-04-18 21:15:55.0" updateauthor="muralisr" updated="2017-04-18 21:21:14.0"> <body><! CDATA Part 2. Security checks that need to be done.   7. Committing peers: Do the validation as follows: check the creator /creator signature satisfies the writers policy of the channel, and reject if this is not the case  {color:#d04437}_Is some of this already done or planned to do as part of any ACL work for SCCs ? Need to check with  ~angelo.decaro _{color} check that the creator of the transaction and its signature satisfy the ccInstantiationPolicy of the old instantiation entry of the upgdade chaincode (should be referenced in the Read set of the transaction)   ></body> </Action>
<Action id="22712" issue="15742" author="elli-androulaki" type="comment" created="2017-04-19 13:56:23.0" updateauthor="elli-androulaki" updated="2017-04-19 13:56:23.0"> <body><! CDATA  ~ales 's CR on this: https://gerrit.hyperledger.org/r/#/c/6421/   ></body> </Action>
<Action id="22776" issue="15742" author="elli-androulaki" type="comment" created="2017-04-20 20:38:48.0" updateauthor="elli-androulaki" updated="2017-04-20 20:38:48.0"> <body><! CDATA Hi CRs to complete this item: https://gerrit.hyperledger.org/r/#/c/8253/,  https://gerrit.hyperledger.org/r/#/c/8299/,  https://gerrit.hyperledger.org/r/#/c/8305/  ></body> </Action>
