<Action id="39963" issue="27602" author="jyellick" type="comment" created="2018-02-09 22:13:00.0" updateauthor="jyellick" updated="2018-02-09 22:13:00.0"> <body><! CDATA Are you certain you are signing this with an ordering admin? From the log:  >  identity 0 does not satisfy principal: This identity is not an admin  ></body> </Action>
<Action id="39964" issue="27602" author="ratnakar" type="comment" created="2018-02-09 22:25:43.0" updateauthor="ratnakar" updated="2018-02-09 22:25:43.0"> <body><! CDATA I am not signing with the ordering admin.  My assumption is that *peer channel update*  command will take care of signing with orderer admin {code:java} peer channel update -f config_update_in_envelope.pb -c "testchainid" -o orderer0.example.com:7050 --tls true --cafile $ORDERER_CA{code}  ></body> </Action>
<Action id="39965" issue="27602" author="ratnakar" type="comment" created="2018-02-09 22:28:19.0" updateauthor="ratnakar" updated="2018-02-09 22:28:19.0"> <body><! CDATA Here are my env variables in the container where I executed the above cli command {code:java} CORE_PEER_LOCALMSPID="OrdererMSP" 	CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem 	CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp{code}  ></body> </Action>
<Action id="39970" issue="27602" author="jyellick" type="comment" body=" ~Ratnakar  According to the environment variables, you are signing as an orderer, not as an orderer admin.  Please try using an identity like: {{crypto-config/ordererOrganizations/example.com/users/Admin\@example.com/}} instead, as you would for instance in enabling the orderer capabilities." created="2018-02-09 22:52:55.0" updateauthor="jyellick" updated="2018-02-09 22:52:55.0"/>
<Action id="39971" issue="27602" author="ratnakar" type="comment" created="2018-02-09 23:30:16.0" updateauthor="ratnakar" updated="2018-02-09 23:30:16.0"> <body><! CDATA  ~jyellick  Thats my bad.  Now after pointing to the right MSP config path , I could successfully update the config block. I verified the latest config block has deleted *orderer2.example.com* address {code:java} "OrdererAddresses": { "mod_policy": "/Channel/Orderer/Admins", "value": { "addresses":   "orderer0.example.com:7050", "orderer1.example.com:7050"   }, "version": "1" } {code} However I could still send the transaction over this orderer *orderer2.example.com.* {code:java} peer chaincode invoke -o orderer2.example.com:7050  --tls --cafile $ORDERER_CA -C mychannel -n mycc -c '{"Args": "invoke","a","b","10" }' .... 2018-02-09 23:24:14.314 UTC  chaincodeCmd  chaincodeInvokeOrQuery -> INFO 00b Chaincode invoke successful. result: status:200 2018-02-09 23:24:14.314 UTC  main  main -> INFO 00c Exiting..... {code} Shouldn't this be failing ?  ></body> </Action>
<Action id="39991" issue="27602" author="scottz" type="comment" created="2018-02-11 18:04:56.0" updateauthor="scottz" updated="2018-02-11 18:04:56.0"> <body><! CDATA Interesting turn of events...  1. Regarding  ~Ratnakar  changing the signature to use an orderer config admin to get it to work... was  ~rohitadivi  using orderer admin to change the batchsize in his tests successfully (in which case we should create a different bug)? Or was he using orderer config admin already?  2. When the config update to remove the orderer2 was accepted by the other orderers, then did orderer2 receive the delivered block? Should orderer2 lose its connection to the kafkas (like the peers of a deleted org would lose their connections to the orderers)? I think that is probably what needs to happen (but did not) - which is the first problem. That way, the broadcast client and deliver clients(peers) could find out because it might lose its connection to the orderer2 (because service-unavailable) and could connect to another orderer.  3. What happens when you ADD another orderer? Can your client broadcast transactions and peers receive/deliver them through the new orderer?  ></body> </Action>
<Action id="39998" issue="27602" author="ratnakar" type="comment" created="2018-02-12 00:53:15.0" updateauthor="ratnakar" updated="2018-02-12 00:53:15.0"> <body><! CDATA Discussed with  ~bmos299 , As per his suggestion would like to provide few more details.  In the CLI flow,  the transaction proposal response from the peer would be sent to the orderer given in the command (connected with option *-o <orderer_name>*). we see the Block height is increased when the transaction is sent to the *ordere2.example.com* which has been deleted though a config update.  To make sure, we stopped the orderer processes *orderer0.example.com* and *orderer1.example.com* aswell ( using command _docker stop orderer0.example.com orderer1.example.com_ ) and sent another invoke transaction to *ordere2.example.com* and observed successful block commit.  NOTE: Validated the transaction using query aswell channel delivery service filtered block.  Enclosed orderer system channels latest config block  ^sys_channel_latest_config_orderer2.pb  , the orderers logs  ^orderer_logs.tar  and event blocks information  ^block_events.tar   Gist of orderer2 logs after the above successful transation. {code:java} kNumber= 13  2018-02-12 00:24:53.430 UTC  orderer/commmon/multichannel  commitBlock -> DEBU a5a  channel: mychannel  Wrote block 13 2018-02-12 00:24:53.431 UTC  fsblkstorage  waitForBlock -> DEBU a5b Came out of wait. maxAvailaBlockNumber= 13  2018-02-12 00:24:53.431 UTC  fsblkstorage  Next -> DEBU a5c Initializing block stream for iterator. itr.maxBlockNumAvailable=13 2018-02-12 00:24:53.431 UTC  fsblkstorage  newBlockfileStream -> DEBU a5e newBlockfileStream(): filePath= /var/hyperledger/production/orderer/chains/mychannel/blockfile_000000 , startOffset= 105296  2018-02-12 00:24:53.431 UTC  fsblkstorage  waitForBlock -> DEBU a5d Came out of wait. maxAvailaBlockNumber= 13  2018-02-12 00:24:53.431 UTC  fsblkstorage  Next -> DEBU a5f Initializing block stream for iterator. itr.maxBlockNumAvailable=13 2018-02-12 00:24:53.431 UTC  fsblkstorage  waitForBlock -> DEBU a60 Came out of wait. maxAvailaBlockNumber= 13  2018-02-12 00:24:53.432 UTC  fsblkstorage  Next -> DEBU a62 Initializing block stream for iterator. itr.maxBlockNumAvailable=13 2018-02-12 00:24:53.432 UTC  fsblkstorage  newBlockfileStream -> DEBU a63 newBlockfileStream(): filePath= /var/hyperledger/production/orderer/chains/mychannel/blockfile_000000 , startOffset= 105296  2018-02-12 00:24:53.432 UTC  fsblkstorage  newBlockfileStream -> DEBU a61 newBlockfileStream(): filePath= /var/hyperledger/production/orderer/chains/mychannel/blockfile_000000 , startOffset= 105296  2018-02-12 00:24:53.432 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a64 Remaining bytes= 4779 , Going to peek  8  bytes 2018-02-12 00:24:53.432 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a65 Returning blockbytes - length= 4777 , placementInfo={fileNum= 0 , startOffset= 105296 , bytesOffset= 105298 } 2018-02-12 00:24:53.432 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a67 blockbytes  4777  read from file  0  2018-02-12 00:24:53.432 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a66 Remaining bytes= 4779 , Going to peek  8  bytes 2018-02-12 00:24:53.432 UTC  common/deliver  deliverBlocks -> DEBU a68  channel: mychannel  Delivering block for (0xc4203ad540) for 172.18.0.6:40202 2018-02-12 00:24:53.432 UTC  fsblkstorage  waitForBlock -> DEBU a6a Going to wait for newer blocks. maxAvailaBlockNumber= 13 , waitForBlockNum= 14  2018-02-12 00:24:53.432 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a69 Returning blockbytes - length= 4777 , placementInfo={fileNum= 0 , startOffset= 105296 , bytesOffset= 105298 } 2018-02-12 00:24:53.433 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a6b blockbytes  4777  read from file  0  2018-02-12 00:24:53.433 UTC  common/deliver  deliverBlocks -> DEBU a6c  channel: mychannel  Delivering block for (0xc4204c7860) for 172.18.0.2:39298 2018-02-12 00:24:53.433 UTC  fsblkstorage  waitForBlock -> DEBU a6d Going to wait for newer blocks. maxAvailaBlockNumber= 13 , waitForBlockNum= 14  2018-02-12 00:24:53.433 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a6e Remaining bytes= 4779 , Going to peek  8  bytes 2018-02-12 00:24:53.433 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a6f Returning blockbytes - length= 4777 , placementInfo={fileNum= 0 , startOffset= 105296 , bytesOffset= 105298 } 2018-02-12 00:24:53.433 UTC  fsblkstorage  nextBlockBytesAndPlacementInfo -> DEBU a70 blockbytes  4777  read from file  0  2018-02-12 00:24:53.434 UTC  common/deliver  deliverBlocks -> DEBU a71  channel: mychannel  Delivering block for (0xc4202cb4e0) for 172.18.0.8:36370 2018-02-12 00:24:53.434 UTC  fsblkstorage  waitForBlock -> DEBU a72 Going to wait for newer blocks. maxAvailaBlockNumber= 13 , waitForBlockNum= 14  {code}    ></body> </Action>
<Action id="40009" issue="27602" author="jyellick" type="comment" created="2018-02-12 04:54:23.0" updateauthor="jyellick" updated="2018-02-12 04:54:23.0"> <body><! CDATA The configuration parameter you changed, {{OrdererAddresses}} is an enumeration of orderer which clients and peers should use to connect to ordering.  It is not an exhaustive list of orderers, and adding and removing nodes from this list has no impact on their participation in ordering.  This is a deliberate feature by design, as it may be desirable to configure hot spare orderers, or to remove an orderer from the list for maintenance, recovery etc.  To disconnect an orderer from Kafka, standard Kafka access control measures may be leveraged, such as TLS CRLs, or firewalling.  If the orderer system and its key material were compromised, its certificate should be added to the orderer's MSP's CRL.  ></body> </Action>
<Action id="40015" issue="27602" author="mastersingh24" type="comment" body="As  ~jyellick  commented above, this is not a bug." created="2018-02-12 09:48:19.0" updateauthor="mastersingh24" updated="2018-02-12 09:48:19.0"/>
<Action id="40019" issue="27602" author="bmos299" type="comment" body=" ~jyellick  agreed.  If the config parm changed was only *OrdererAddresses* than that is not revoking, or removing this orderer from the channel from a security perspective.   Actually it is a nice design feature." created="2018-02-12 13:29:06.0" updateauthor="bmos299" updated="2018-02-12 13:29:06.0"/>
<Action id="40162" issue="27602" author="denyeart" type="comment" body=" ~jyellick  If not a bug, anything else needed here?  Doc update, etc?" created="2018-02-14 16:54:51.0" updateauthor="denyeart" updated="2018-02-14 16:54:51.0"/>
<Action id="40191" issue="27602" author="ratnakar" type="comment" body="Raised another bug  FAB-8240|https://jira.hyperledger.org/browse/FAB-8240  to address the doc update" created="2018-02-14 18:35:40.0" updateauthor="ratnakar" updated="2018-02-14 18:35:40.0"/>
