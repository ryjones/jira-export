<Action id="20821" issue="14700" author="angelo.decaro" type="comment" body="Hi  ~muralisr , I would add also the security of the container. Is it true that if a chaincode is instantiated in multiple chain, anyway there is only one container that chaincode?" created="2017-02-10 13:49:52.0" updateauthor="angelo.decaro" updated="2017-02-10 13:49:52.0"/>
<Action id="20823" issue="14700" author="mne" type="comment" created="2017-02-10 15:58:57.0" updateauthor="mne" updated="2017-02-10 15:58:57.0"> <body><! CDATA The new deployment model changes the threat model in the following way: Different chains belong to different trust domains. By having one chaincode "instance" (i.e. one container) handling two chains, this significantly weakens the isolation between the two chains.  Consider the following scenario: Alice and Bob are on chain A, Mallory is on chain B. The same chaincode has been instantiated to both chain A and B. Mallory's incentive is to find out what data is stored on chain A. Up to now, Mallory's attack surface was limited to the fabric's code, which would handle both chains. Now he has an additional attack vector: the chaincode that handles both chains. Since the chaincode is not part of the fabric, isolation between the chains is now a responsibility of the chaincode developers as well. Possible attack venues are invocation parameters as well as anything stored on chain A and processed by the chaincode. "Full" compromise of the chaincode in terms of code execution is not even necessary, a confused deputy attack is already enough.  From my perspective, the only clean solution at the moment is to have separate container instances per chain.  ></body> </Action>
<Action id="20839" issue="14700" author="binhn" type="comment" created="2017-02-11 14:18:14.0" updateauthor="binhn" updated="2017-02-11 14:21:00.0"> <body><! CDATA bq. From my perspective, the only clean solution at the moment is to have separate container instances per chain.  The premise of this conclusion doesn't seem to hold: It is assuming that the attack is successful at the container, but that would also be true for separate container per channel. That is, if one were able to attack a container, all bet would be off.  I agreed that it would be more invasive in the case of a single container per chaincode but it doesn't change the important of security on container, which is addressed technically not by us but by Docker community.  ></body> </Action>
<Action id="20849" issue="14700" author="mne" type="comment" created="2017-02-13 06:54:48.0" updateauthor="mne" updated="2017-02-13 06:54:48.0"> <body><! CDATA  ~binhn  I have to disagree. One has to carefully differentiate here between container security, chaincode security and security of the new deployment (i.e. one container instance per chaincode). Let's take them one by one: 1) Container security: indeed, for container infrastructure security, i.e. namespaces, cgroups, etc. we can rely on the docker community / Linux kernel community.  2) Chaincode security: the fabric runs chaincode in a docker container. From the perspective of the fabric, the chaincode is not trusted - that's why it runs in a container in the first place. At the same time one has to assume that chaincode can contain vulnerabilities and might be exploited. I want to stress again here that this does not necessarily means that an attacker gains code execution, a successful confused deputy attack is sufficient to serve data from Alice and Bob's chain. 3) Security of the new deployment: if the separate chaincode containers are used for chain A and chain B, even a buggy, compromised chaincode can not return data from users of chain A to users of chain B - by design. If the same container instance is used for both chain A and chain B, this isolation is the responsibility of the chaincode and can no longer be ensured by the fabric.  ></body> </Action>
<Action id="20854" issue="14700" author="greg.haskins" type="comment" created="2017-02-13 13:26:36.0" updateauthor="greg.haskins" updated="2017-02-13 13:27:43.0"> <body><! CDATA I think Matthias is generally correct in this assessment.  The threat being referred to has nothing to do with container security, but everything to do with execution context.  The only part I would disagree with is the notion that sharing a code instance in of itself is inherently less secure.  What makes this insecure in our current implementation is the process model we use for chaincode:  The instance stays running effectively under its own control.  Therefore, a well placed cache, ala:  {code:none} var secrets = make(map string string)  func Invoke(user, params) { secrets user  = params } {code}  may cause the violation I think Matthias is referring to.  This attack surface is indeed exacerbated by the recent update to the model since the execution context has now been broadened.  All this said, I think the real problem is our execution model and it should probably be addressed at this level.  The ideal scenario would be that chaincode is treated like callbacks and the execution environment more tightly controlled by the peer.  If this were the case, then the new model wouldn't be any less secure than it was prior to CR 5555.  We would, in fact, be more secure all around.   ></body> </Action>
<Action id="20855" issue="14700" author="mne" type="comment" body="Thanks Greg, this is a good example of what I meant. Not sure how you want to enforce the execution context though and what it would be comprised of." created="2017-02-13 14:51:57.0" updateauthor="mne" updated="2017-02-13 14:51:57.0"/>
<Action id="20861" issue="14700" author="greg.haskins" type="comment" body="The choice of golang for the chaincode makes this somewhat difficult, as normal hypervisor/kernel controls may adversely impact things like GC.  The only practical solution is probably to start a new process for each invoke.  More research needs to be done." created="2017-02-13 15:15:07.0" updateauthor="greg.haskins" updated="2017-02-13 15:15:07.0"/>
<Action id="20865" issue="14700" author="mne" type="comment" created="2017-02-13 15:47:01.0" updateauthor="mne" updated="2017-02-13 15:47:01.0"> <body><! CDATA One process per chain would already be sufficient for isolating chain access. As pointed out above, this could just be done using one container per chain. Beyond this, I doubt that having one process per invoke would help a lot at the moment. Chaincode developers could still easily persist state (the cache example you described above) on the file system of the container across invocations. So you'd need to reset it in addition before every invocation.  ></body> </Action>
<Action id="20875" issue="14700" author="greg.haskins" type="comment" created="2017-02-13 16:14:44.0" updateauthor="greg.haskins" updated="2017-02-13 16:14:44.0"> <body><! CDATA Sorry, I wasn't clear:  What I meant was a new container per invoke.  I think at this point we should clarify a few terms:  * (docker) image * (docker) container * process  In the system prior to CR 5555, each channel carried its own ChaincodeDeploymentSpec.CodePackage which was compiled into its own _image_ and then started as its own container/process.  I think everyone agrees that the creation of a discrete _image_ for the same CodePackage, regardless of the security context, is wasteful.  We can optimize this without controversy.  Next up is the container/process model.  Personally, I think the notion of having 1 peer-wide image serve N containers/process, 1 per channel is _probably_ ok for some number of channels in the 5k-10k range.  If that model were acceptable, the above security concern (at least w.r.t. cross-channel threats) doesn't exist.  My assumption is that is not what we are talking about here though:  I assume we are trying to further optimize by only running 1 peer-wide container/process to serve N channels.  In that model, the attack surface exists and could be mitigated several ways but the most viable way is probably to effectively restart the container/process per request.  Preliminary experiments show this overhead is in the order of about 250ms/request, which isn't fantastic but it also might be fast enough in the context of blockchain applications (because the consensus convergence time is an order of magnitude higher).  We can probably also get clever to improve this, such as pre-loading the executable, etc.  I digress.  As I said, more research is needed.  So, to rephrase, when I said "start a new process" I meant start a new container/process, in which case the state including filesystem is ephemeral and wouldn't be subject to the persistence issue you mentioned.  We could mitigate this other ways as well, such as locking down write access to the filesystem (via the apparmor and/or fs permissions).   ></body> </Action>
<Action id="20876" issue="14700" author="mne" type="comment" created="2017-02-13 16:48:25.0" updateauthor="mne" updated="2017-02-13 16:48:25.0"> <body><! CDATA Thanks for the clarification. Starting a new container/process per request would improve security beyond the one container/process per channel approach. The decision could also be pushed to the deployer of the fabric by making it a configuration option.  Locking down the container in terms of filesystem access opens up a much broader question: what kind of capabilities are really needed for chaincode (file I/O, network I/O, system calls, etc.)?  ></body> </Action>
<Action id="20879" issue="14700" author="binhn" type="comment" created="2017-02-13 18:35:33.0" updateauthor="binhn" updated="2017-02-13 18:40:55.0"> <body><! CDATA Multichannel on a peer is a deployment option. Nothing prevents people from bringing up an entire new network (or a new set of peers) to support a new channel. Similarly, sharing a chaincode among multiple channels is also optional. Users may deploy a new chaincode for the new channel. In other word, everything can be kept separate as implemented now.  We know that optimization in deployment requires check and balance. One thing that this jira item describes is the ownership of the chaincode, who would sign the chaincode package after it has been reviewed. Honest bugs certainly happen, but I doubt malicious chaincode would enter in this fashion.   We should evaluate and provide appropriate guidelines for our users depending on their needs, including human process to follow.  ></body> </Action>
<Action id="20881" issue="14700" author="mastersingh24" type="comment" created="2017-02-13 19:05:23.0" updateauthor="mastersingh24" updated="2017-02-13 19:05:39.0"> <body><! CDATA So a few things:  1) Chaincode process itself has no requirements on filesystem, etc.  If someone chooses to use the filesystem, they are likely going to get into real trouble since the filesystem is ephemeral and there is no guarantee that a container will not be destroyed, recreated and restarted  2) Chaincode process itself does not directly read from the state store (it does not write either as write's occur during commit after going through ordering).  Each GetXXX call is actually a remote call that goes back to the peer (the peer knows the context of the "call" being made)  Now - on the model - one thing that MIGHT not be apparent here is that if someone so chooses, they could install / instantiate the chaincode on different channels as separate instances (basically when they install the package, they can give it a different name and this will result in it being considered different chaincode even though the package/code bytes are identical).  In terms of security "holes", the only way for someone to *possibly exploit* any of this is to modify the shim and/or peer code.  I/we don't see anyway that in the normal case someone would be able to gain insight about what's happening on another channel  ></body> </Action>
<Action id="20882" issue="14700" author="greg.haskins" type="comment" created="2017-02-13 19:27:47.0" updateauthor="greg.haskins" updated="2017-02-13 19:42:24.0"> <body><! CDATA I feel like we are talking about different things here.  To be clear: I am not talking about some kind of security concern about merely running the same "application" in two different channels (regardless of whether those channels are of the same fabric or not).  Rather, I am talking about the security concern that would arise if the peer applied an optimization when it detects that the same application is instantiated on different channels, and it optimizes the deployment such that one container/process services more than one channel.  In that scenario, the current execution model would be conducive to leaking information between channels (intentionally or not) such as through global variables, threads, of filesystem state that transcends invoke() context.  Gari: regarding your point (1) above, I don't think anyone was suggesting legitimate chaincode _should_ do that.  What we are saying is that malicious chaincode _could_ do that to leak state between security domains IFF one instance was allowed to serve both domains.  ></body> </Action>
<Action id="22744" issue="14700" author="muralisr" type="comment" body="I think we have made quite some progress on securing front. Lots of overlap with other security JIRA items in this space. Will move to  ~ellaki  to address as fit." created="2017-04-20 01:37:02.0" updateauthor="muralisr" updated="2017-04-20 01:37:02.0"/>
<Action id="62445" issue="14700" author="mastersingh24" type="comment" body="Superseded by new lifecycle" created="2019-07-31 03:58:05.0" updateauthor="mastersingh24" updated="2019-07-31 03:58:05.0"/>
