<Issue id="16751" key="FAB-3942" number="3942" project="10002" reporter="vdods" creator="vdods" type="10004" summary="Comment for GetStateByPartialCompositeKey in interfaces.go is wrong" priority="3" resolution="10000" status="6" created="2017-05-15 23:15:38.0" updated="2018-07-20 14:12:47.0" resolutiondate="2017-06-05 11:01:27.0" votes="0" watches="3" workflowId="38535"> <description><! CDATA This bug can be easily resolved by deleting the offending part of the comment for GetStateByPartialCompositeKey in interfaces.go.     The comment for GetStateByPartialCompositeKey states  "This function should be used only for a partial composite key. For a full composite key, an iter with empty response would be returned."  But that is (fortunately) not the case.  Adding the following test to mockstub_test.go proves that the behavior is correct and reasonable.  In particular, a full composite key is still a kind of partial composite key (having all keys specified), and uniquely addresses a single element in the ledger state. {code:java} func TestGetStateByPartialCompositeKeyFull(t *testing.T) { stub := NewMockStub("GetStateByPartialCompositeKeyFullTest", nil) stub.MockTransactionStart("init")  marble1 := &Marble{"marble", "set-1", "red", 5, "tom"} // Convert marble1 to JSON with Color and Name as composite key compositeKey1, _ := stub.CreateCompositeKey(marble1.ObjectType,   string{marble1.Name, marble1.Color}) marbleJSONBytes1, _ := json.Marshal(marble1) // Add marble1 JSON to state stub.PutState(compositeKey1, marbleJSONBytes1)  marble2 := &Marble{"marble", "set-1", "blue", 5, "jerry"} compositeKey2, _ := stub.CreateCompositeKey(marble2.ObjectType,   string{marble2.Name, marble2.Color}) marbleJSONBytes2, _ := json.Marshal(marble2) stub.PutState(compositeKey2, marbleJSONBytes2)  marble3 := &Marble{"marble", "set-2", "red", 5, "tom-jerry"} compositeKey3, _ := stub.CreateCompositeKey(marble3.ObjectType,   string{marble3.Name, marble3.Color}) marbleJSONBytes3, _ := json.Marshal(marble3) stub.PutState(compositeKey3, marbleJSONBytes3)  stub.MockTransactionEnd("init") // should return in sorted order of attributes expectKeys :=   string{compositeKey2} expectKeysAttributes :=     string{{"set-1", "blue"}} expectValues :=     byte{marbleJSONBytes2}  rqi, _ := stub.GetStateByPartialCompositeKey("marble",   string{"set-1", "blue"}) fmt.Println("Running loop") for i := 0; i < 1; i++ { key, value, err := rqi.Next() fmt.Println("Loop", i, "got", key, value, err) if expectKeys i  != key { fmt.Println("Expected key", expectKeys i , "got", key) t.FailNow() } objectType, attributes, _ := stub.SplitCompositeKey(key) if objectType != "marble" { fmt.Println("Expected objectType", "marble", "got", objectType) t.FailNow() } fmt.Println(attributes) for index, attr := range attributes { if expectKeysAttributes i  index  != attr { fmt.Println("Expected keys attribute", expectKeysAttributes index  i , "got", attr) t.FailNow() } } if jsonBytesEqual(expectValues i , value) != true { fmt.Println("Expected value", expectValues i , "got", value) t.FailNow() } } }  {code} (apologies for messed up indentation).     Additionally, empty partial composite keys also work as expected.  Here's a test: {code:java} func TestGetStateByPartialCompositeKeyEmpty(t *testing.T) { stub := NewMockStub("GetStateByPartialCompositeKeyEmptyTest", nil) stub.MockTransactionStart("init")  marble1 := &Marble{"marble", "set-1", "red", 5, "tom"} // Convert marble1 to JSON with Color and Name as composite key compositeKey1, _ := stub.CreateCompositeKey(marble1.ObjectType,   string{marble1.Name, marble1.Color}) marbleJSONBytes1, _ := json.Marshal(marble1) // Add marble1 JSON to state stub.PutState(compositeKey1, marbleJSONBytes1)  marble2 := &Marble{"marble", "set-1", "blue", 5, "jerry"} compositeKey2, _ := stub.CreateCompositeKey(marble2.ObjectType,   string{marble2.Name, marble2.Color}) marbleJSONBytes2, _ := json.Marshal(marble2) stub.PutState(compositeKey2, marbleJSONBytes2)  marble3 := &Marble{"marble", "set-2", "red", 5, "tom-jerry"} compositeKey3, _ := stub.CreateCompositeKey(marble3.ObjectType,   string{marble3.Name, marble3.Color}) marbleJSONBytes3, _ := json.Marshal(marble3) stub.PutState(compositeKey3, marbleJSONBytes3)  stub.MockTransactionEnd("init") // should return in sorted order of attributes expectKeys :=   string{compositeKey2, compositeKey1, compositeKey3} expectKeysAttributes :=     string{{"set-1", "blue"}, {"set-1", "red"}, {"set-2", "red"}} expectValues :=     byte{marbleJSONBytes2, marbleJSONBytes1, marbleJSONBytes3}  rqi, _ := stub.GetStateByPartialCompositeKey("marble",   string{}) fmt.Println("Running loop") for i := 0; i < 3; i++ { key, value, err := rqi.Next() fmt.Println("Loop", i, "got", key, value, err) if expectKeys i  != key { fmt.Println("Expected key", expectKeys i , "got", key) t.FailNow() } objectType, attributes, _ := stub.SplitCompositeKey(key) if objectType != "marble" { fmt.Println("Expected objectType", "marble", "got", objectType) t.FailNow() } fmt.Println(attributes) for index, attr := range attributes { if expectKeysAttributes i  index  != attr { fmt.Println("Expected keys attribute", expectKeysAttributes index  i , "got", attr) t.FailNow() } } if jsonBytesEqual(expectValues i , value) != true { fmt.Println("Expected value", expectValues i , "got", value) t.FailNow() } } }   {code}  ></description> </Issue>
