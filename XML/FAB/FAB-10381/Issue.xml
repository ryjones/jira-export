<Issue id="30623" key="FAB-10381" number="10381" project="10002" reporter="manish-sethi" assignee="manish-sethi" creator="manish-sethi" type="10004" summary="Purge orphaned private keys" priority="3" resolution="10000" status="6" created="2018-05-25 03:42:26.0" updated="2018-07-20 14:16:49.0" resolutiondate="2018-06-07 14:19:47.0" votes="0" watches="1" workflowId="42334"> <description><! CDATA Since, we allow commit with missing pvt data (on the peers that are eligible to receive the pvt data), and the removal of an org from a collection  A following sequence of events is possible on a peer.  (1) The peer receives a pvtKey along with pvtKeyHash in a block  (2) Before the expiry of the keys created in (1), the peer receives another update/delete to the above key but in this update the peer receives only hashed update and the actual pvt key is missing (because of one of the above mentioned configurations)  In the current code, when the expiry schedule created because of (1) is kicked off, a check is performed to detect whether the key is already updated because of (2) and if yes, the expiry schedule acts as noop. However, this decision is taken by comparing  a) 'committing block number' stored in the expiry schedule with b) the most recent commit version of the hashed key.  In the above mentioned scenario, this checks alone is not sufficient and leaves the pvt key create in (1) as an orphaned entry until the key is overwritten in a future event (which may never happen).  While evaluating the effects of the expiry schedule, we need to consider the possibility of the  presence of such orphaned keys and handle accordingly.  ></description> </Issue>
