<Issue id="19210" key="FAB-5288" number="5288" project="10002" reporter="yacovm" assignee="mastersingh24" creator="yacovm" type="10001" summary="Allow peer to override channel configuration (since it is not yet possible to join channel from latest config block)" priority="1" status="10000" created="2017-07-12 10:10:25.0" updated="2020-06-25 10:32:55.0" votes="6" watches="29" workflowId="35249"> <description><! CDATA This JIRA item summarizes issues regarding to addition of new peers and/or new organizations to a channel, and discusses solutions for them and tracks their JIRA items.  Currently, there are several problems with regard to channel reconfiguration, that all stem from the fact that when a peer joins the channel - it is given the first configuration block (the genesis block): # The certificates (TLS or signing identity certificates) of the orderers cannot be changed, otherwise the peer would not be able to connect to any *ordering service node* (hereafter - *OSN*) or verify the blocks from any OSN. # The endpoints of the OSNs shouldn't change much - if all are changed then a peer that joins the channel would not be able to connect to *any* OSN at all, and would have to rely on receiving blocks from other peers in order to obtain the latest configuration block that would connect it to the peers. # When a peer that belongs to an org that wasn't a channel member at channel creation is joined the channel, the gossip layer rejects the join channel and is only updated via direct connection to the ordering service for that peer - FAB-5246 # The delivery service in the peer doesn't support dynamic update of OSN endpoints, and requires a restart in order to do that - FAB-5157 This item doesn't require special architectural change in order to address it ( ~C0rWin  correct me if I'm wrong)  *Possible solution for 1,2,3:* # I think that we should consider instead of joining the channel via the genesis block - joining the channel via the latest configuration block, (and have the MSP and anchor peers being configured with the latest configuration block data), with the following changes: ## A peer that has joined the channel has the latest configuration block *i* would need to obtain blocks *0.. i, i* in order to start servicing requests, since it cannot populate the stateDB until it has a continuous ledger from *0* to *i*, and it also has to validate the raw ledger in an ascending order. I think this is actually a blessing in disguise, because currently, a peer that joins the channel can service clients even though it has old data in its stateDB, and this would prevent the peer from doing that. ## A peer that has joined the channel and obtained the latest configuration block *i* would replicate the missing blocks *0 .. i* from other peers or from the ordering service by pulling blocks in a *descending* order ( i-1, --> i-2, --> ... 2, --> 1, --> 0) and for each block *j<i* it would verify the block by checking the previous hash on block *j+1* (which it would have at that point, since it would pull blocks in a descending order) and checking if the previous hash of block *j+1* matches the computed hash of the newly acquired block *j*. After this is done, the peer would validate the transactions from blocks *0..i* and would compute the stateDB (and the "validated ledger"). After this - the peer would start pulling blocks from the orderer/peers in an ascending order. ## *We could also of course - not do backwards hash chain validation*, and instead - just make the peer use the latest config block and then pull blocks in the regular order from genesis up to the joinChannel block. # Snapshot solution: ~jyellick : I see a few different ways to approach this: ## *Simplest:* Whenever a peer receives a config block for a channel, it takes a copy on write style snapshot of the state database. The CSCC or other exposes some interface to retrieve the hash of this state snapshot, or the state snapshot itself. When joining a new member, the member asks "enough" of the other members for the hash of the state snapshot at the most recent config block, and retrieves a copy of the state snapshot from someone. Then the peer is told to join the channel with the config block, the hash, and the state. The peer loads the state, verifies it against the hash, and is able to process further blocks based on the config block. ## *More complex:* Same as (1), except instead of exposing the state snapshot via CSCC, allow the state snapshot to be gossiped, so that peer need only be bootstrapped with the config block and the hash of the state at that config block. This makes it much much easier to bootstrap a new peer, but, the very significant downside to this is the DoS possibilities, and the fact that it is difficult to handle the byzantine attack of a peer sending bad state. (Yes, you can detect it, but this implies retrieving an entire new copy of the world state, which might be quite large. Therefore, retrieving the state snapshot from multiple members is problematic, as any one can poison the state snapshot with bad data but only the final result is detected to be bad, forcing an entirely new copy to be retrieved). ## *Most complex:* When a config block for a channel is received, the peers take a snapshot, compute its hash, and sign some block metadata about the hash of the world state. The peers then gossip about the hash, collecting eachother's signatures, and including them into their own block metadata. The config block could have a policy added, like "SnapshotStateAttestations", which could be evaluated against the signature set to determine whether the threshold of signatures had been met. Then, to join a channel, the peer would only need the config block (with its additional gossip-ed metadata) which already contains this hash, and a way to retrieve the state (either supplied manually as in (1), or automatically as in (2).                     My gut feeling is that (1) or (3) with gossip of state would be best. IE, with (1) the process is simple to understand, simple to implement, but out of band and fairly manual.                     Or, with (3) + state gossip, the process is a bit magical, and complex, but, it would make joining a peer to 'catch up' as simple as joining one on a new channel.                     Additionally, we could relax the conditions for taking a state snapshot if this is too burdensome, for instance only taking a state snapshot when a particular config property is changed. So long as it is possible to determine if the config block should have a corresponding state snapshot, this is sufficient.     *Problem*: In both cases you have the last config block that is used to join the channel, but it may contain different root CA certs than was used in the past, and so - old blocks that the peer would get from the orderer or from other peers would contain endorsements or signatures on the block that the corresponding certificates no longer have a certificate validation path to the latest config block that was used to join channel with. * I assume that if we could make the validation code (VSCC) in the peer use the config blocks on the chain, and not the config block that was used to call join channel with, it would be solved. * If the state snapshot the joining peer would receive from other peers when it joins a channel would be created at the sequence of the last config block (the join channel block) - that would also solve the problem. But: ** If this is done manually, it would only make the join channel process more complex and also - the state snapshot might be very large and hard to transfer.  ** If this isn't done manually, but via having the joining peer contact other peers and ask for a snapshot to be created, this opens a window for abuse and DOS attacks, unless the snapshot is taken on each config block ** If a snapshot is taken on each config block, that might overload the peers of the system if a user would send several config updates (i.e - one that changes X, one that changes Y, etc.) but I think this should be considered and perhaps with guidelines to users (if you want to reconfigure a channel, do it via a single update and not via several) would be enough to solve the problem.     ~adc   ~ales   ~C0rWin   ~binhn   ~ellaki   ~mastersingh24   ~jyellick   ~kchristidis   ~vukolic   ></description> </Issue>
