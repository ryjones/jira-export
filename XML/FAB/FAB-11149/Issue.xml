<Issue id="31867" key="FAB-11149" number="11149" project="10002" reporter="elli-androulaki" assignee="wenjian" creator="elli-androulaki" type="10000" summary="Token (base support) - Prover Peer: Assemble, List, History" priority="2" resolution="10001" status="6" created="2018-07-13 17:24:12.0" updated="2020-01-13 15:12:30.0" resolutiondate="2020-01-13 15:12:30.0" votes="0" watches="9" workflowId="35948"> <description><! CDATA This is one epic from the many to follow to allow for token management enablement of Fabric.  Current proposal|https://docs.google.com/document/d/1fzxoQYARFPTTIM-eIw8zs6tYkg6t6uRVI6fmnCQJz9I/edit?usp=sharing  for the higher level design.     We define as *prover peer* a peer that is in the trust domain of a client, and helps the client  construct a FabToken transaction according to the client's wishes. More specifically, the prover peer leverages its inherent access to a channel's (and respective FabToken system's) state to construct _token issue, token transfer_ requests on behalf of the client. The client will subsequently integrate these requests into a _FabToken transaction_ as described in FAB-11144. Additionally, the prover peer can answer queries of the client for the list of tokens that are owned by the client, and lookups on other system parameters.   To offer such functionality, the prover peer exposes a GRPC service.  The *motivation* behind the existence of a *prover peer* is essentially convenience, as the construction of such requests require lookups on the ledger, and in some cases intensive computations that would be done by the client. The benefit of the outsourcing of such computations is clearer in the privacy preserving version of FabToken where the construction of both _issue and transfer requests_ entails heavy zero-knowledge proof computations that would otherwise need to be made available to each client code-base (sdk-s).     Adding   ~sykesm ,  ~angelo.decaro ,  ~mathiasb303 ,  ~KaoutarEL ,   ~jyellick ,  ~denyeart .  ></description> </Issue>
