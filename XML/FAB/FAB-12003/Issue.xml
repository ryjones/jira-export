<Issue id="33763" key="FAB-12003" number="12003" project="10002" reporter="guoger" assignee="landleany" creator="guoger" type="10004" summary="Pending envelope may never be cut into block " priority="3" resolution="10000" status="6" created="2018-09-14 08:13:25.0" updated="2018-10-02 14:05:17.0" resolutiondate="2018-10-02 14:05:17.0" votes="0" watches="4" workflowId="45067"> <description><! CDATA In  this case|https://github.com/hyperledger/fabric/blob/release-1.2/orderer/common/blockcutter/blockcutter.go#L62-L63 , batch timer should still take effect and cut pending envelope into block if it fires.  Basically, this test should pass (for solo), and the same goes to kafka: {code:java} func TestPendingMsgCutByTimeout(t *testing.T) { 	support := &mockmultichannel.ConsenterSupport{ 		Blocks:          make(chan *cb.Block), 		BlockCutterVal:  mockblockcutter.NewReceiver(), 		SharedConfigVal: &mockconfig.Orderer{BatchTimeoutVal: 500 * time.Millisecond}, 	} 	defer close(support.BlockCutterVal.Block)  	bs := newChain(support) 	wg := goWithWait(bs.main) 	defer bs.Halt()  	syncQueueMessage(testMessage, bs, support.BlockCutterVal) 	support.BlockCutterVal.CutAncestors = true 	syncQueueMessage(testMessage, bs, support.BlockCutterVal)  	select { 	case <-support.Blocks: 	case <-time.After(time.Second): 		t.Fatalf("Expected first block to be cut because of batch size limit reached but did not") 	}  	select { 	case <-support.Blocks: 	case <-time.After(time.Second): 		t.Fatalf("Expected second block to be cut because of batch timer expiration but did not") 	}  	bs.Halt() 	select { 	case <-time.After(time.Second): 		t.Fatalf("Should have exited") 	case <-wg.done: 	} } {code}  ></description> </Issue>
