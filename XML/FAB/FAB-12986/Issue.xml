<Issue id="35577" key="FAB-12986" number="12986" project="10002" reporter="c0rwin" assignee="c0rwin" creator="c0rwin" type="10003" summary="Each mock chain object should have its own mock ledger instance" priority="3" resolution="10000" status="6" created="2018-11-25 13:00:54.0" updated="2019-03-01 06:53:56.0" resolutiondate="2018-12-11 22:19:20.0" votes="0" watches="1" workflowId="47138"> <description><! CDATA Currently in order to test functionality introduced by {{chain.go}}, there was introduced testing facilities such as mocked network and mocked chains. In particular there is a functionality which mocks ledger, which implemented in the following way:  {code} type network struct { 	leader uint64 	chains map uint64 *chain  	// store written blocks to be returned by mock block puller 	ledger *sync.Map  	// used to determine connectivity of a chain. 	// the actual value type is `chan struct` because 	// it's used to skip assertion in `elect` if a 	// node is disconnected from network, therefore 	// no leader change should be observed 	connLock     sync.RWMutex 	connectivity map uint64 chan struct{} } {code}  and each testing instance of {{chain}} uses it as following:  {code} 	c.support.WriteBlockStub = func(b *common.Block, meta   byte) { 		bytes, err := proto.Marshal(&common.Metadata{Value: meta}) 		Expect(err).NotTo(HaveOccurred()) 		b.Metadata.Metadata common.BlockMetadataIndex_ORDERER  = bytes 		n.ledger.Store(b.Header.Number, b) 	}  	c.puller.PullBlockStub = func(i uint64) *common.Block { 		b, exist := n.ledger.Load(i) 		if !exist { 			return nil 		}  		return b.(*common.Block) 	} {code}  meaning that ledger is shared among all instances of chain struct in {{chain_test.go}}.   As a developer I'd like to have separate instance of the mocked ledger per chain, rather than relying on shared ledger common for all objects. Moreover I'd like to have mocked functionality to stub following APIs:  {code} Block()  Height()  WriteConfigBlock() {code}  ></description> </Issue>
