<Action id="68255" issue="44523" author="kevinxiong1977" type="comment" created="2020-03-09 10:35:55.0" updateauthor="kevinxiong1977" updated="2020-03-09 10:35:55.0"> <body><! CDATA  FAB-17441  approveformyorg should allow update of only package ID https://github.com/hyperledger/fabric/pull/560  ></body> </Action>
<Action id="68280" issue="44523" author="kevinxiong1977" type="comment" created="2020-03-11 09:37:47.0" updateauthor="kevinxiong1977" updated="2020-03-11 09:37:47.0"> <body><! CDATA My personal suggestion is that the following code in core/chaincode/lifecycle/lifecycle.go {color:#FF0000}*should only be executed when --package-id is empty*.{color}  func (ef *ExternalFunctions) ApproveChaincodeDefinitionForOrg(chname, ccname string, cd *ChaincodeDefinition, packageID string, publicState ReadableState, orgState ReadWritableState) error {  …………  // set the package id - whether empty or not. Setting // an empty package ID means that the chaincode won't // be invocable. The package might be set empty after // the definition commits as a way of instructing the // peers of an org no longer to endorse invocations // for this chaincode  if err := ef.Resources.Serializer.Serialize(ChaincodeSourcesName, privateName, &ChaincodeLocalPackage{ PackageID: packageID, }, orgState); err != nil { return errors.WithMessage(err, "could not serialize chaincode package info to state") }  If we {color:#FF0000}*set --package-id to a non-null value*{color}, we need to add it in CommitChaincodeDefinition:  func (ef *ExternalFunctions) CommitChaincodeDefinition(chname, ccname string, cd *ChaincodeDefinition, publicState ReadWritableState, orgStates   OpaqueState) (map string bool, error) { approvals, err := ef.CheckCommitReadiness(chname, ccname, cd, publicState, orgStates) if err != nil { return nil, err }  if err = ef.Resources.Serializer.Serialize(NamespacesName, ccname, cd, publicState); err != nil { return nil, errors.WithMessage(err, "could not serialize chaincode definition") } // -----------------------------------------------  // ef.Resources.Serializer.Serialize(*ChaincodeSourcesName*, privateName, …………  // -----------------------------------------------   return approvals, nil }     ></body> </Action>
<Action id="68435" issue="44523" author="denyeart" type="comment" created="2020-03-19 04:16:30.0" updateauthor="denyeart" updated="2020-03-19 04:16:54.0"> <body><! CDATA  ~KevinXiong1977  Please update Description to clearly indicate difference between Expected Behavior and Current Behavior. And please update first comment to indicate exactly how FAB-17441 is related.  ></body> </Action>
<Action id="68530" issue="44523" author="kevinxiong1977" type="comment" created="2020-03-24 07:41:26.0" updateauthor="kevinxiong1977" updated="2020-03-24 07:41:26.0"> <body><! CDATA Hello, David,  1.Maybe I'm mistaken, it's not related to FAB-17441.  2. When Org1MSP and Org2MSP use "AND ('Org1MSP.member', 'Org2MSP.member')" as endorsement policie, they jointly deploy a contract fabcar ，assuming their package-id is "AAAAAAAAAAAAAAA1".  Org1MSP then unilaterally modified the chaincode and reinstalled the upgrade ，assuming his ackage-id is "AAAAAAAAAAAAAAA2".  Org1MSP then peer lifecycle chaincode approveformyorg --channelID mychannel --name fabcar --version 1.0 --signature-policy "AND('Org1MSP.member','Org2MSP.member')" --init-required *--package-id fabcar:AAAAAAAAAAAAAAA2 (only the --package-id option is modified)*  --sequence 1 --tls true --cafile $ORDERER_CA   *{color:#FF0000}Expected Behavior:{color}*  Need to wait for Org2MSP to also perform approveformyorg operation on *--package-id fabcar:AAAAAAAAAAAAAAA2，*then Org1MSP and Org2MSP perform peer lifecycle chaincode commit together     {color:#FF0000}*Current Behavior：*{color}  In fact, no participation of Org2MSP is required, and the chaincode of Org1MSP upgrade installation can work normally.  ></body> </Action>
<Action id="68537" issue="44523" author="denyeart" type="comment" created="2020-03-24 14:13:05.0" updateauthor="denyeart" updated="2020-03-24 14:14:39.0"> <body><! CDATA I believe this is working as expected. Each organization can use different chaincode packages and update their packages unilaterally. As long as the chaincode 'definition' (endorsement policies, etc) is the same, you don't need to get agreement again or re-commit the chaincode. And as long as the different chaincode packages have the same executions results, transactions can still be endorsed across the different organizations (it is the execution 'results' that are critical to be consistent, not the chaincode per se).  See doc at: https://hyperledger-fabric.readthedocs.io/en/latest/chaincode_lifecycle.html#organizations-install-different-chaincode-packages   ~KevinXiong1977  I'll go ahead and close, but if you still think there is some problem with the code or the doc, please re-open.  ></body> </Action>
