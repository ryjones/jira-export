<Action id="30476" issue="20580" author="mastersingh24" type="comment" body=" ~sudeshrshetty  - What exactly is the point of this?  To have packages pre-installed on the peer&apos;s filesystem (i.e. they got there via some mechanism other than peer chaincode install or using the SDKs to call the install API)?" created="2017-09-03 23:02:23.0" updateauthor="mastersingh24" updated="2017-09-03 23:02:23.0"/>
<Action id="30514" issue="20580" author="sudeshrshetty" type="comment" created="2017-09-05 14:50:15.0" updateauthor="sudeshrshetty" updated="2017-09-05 14:50:15.0"> <body><! CDATA Admin will generate chaincode deployment spec outside peer using any custom packager and will copy output package to chaincode path inside peer (for example: /var/hyperler/production/chaincode/).  When chaincode instantiation looks for package inside chaincode path, it will find it and will upload code package inside deployment spec directly into chaincode docker container without any compilation or any other manipulation.    dockerfile for custom chaincode will look like any other chaincode docker file lie below  {color:#205081}ADD binpackage.tar /usr/local/bin{color}  Where binpackage.tar is ** cds.CodePackage  ></body> </Action>
<Action id="30526" issue="20580" author="greg.haskins" type="comment" created="2017-09-05 19:03:43.0" updateauthor="greg.haskins" updated="2017-09-05 19:03:43.0"> <body><! CDATA  ~sudeshrshetty  This is really just the same proposal your team made for BINARY (which I already rejected), with the same problems, except now its even more awkward because you need an out-of-band installation.  I do understand what you are after.  While I still would prefer to see an $arch neutral solution, I also understand that your team wants to stick with golang.  What I would suggest is, fully commit to docker.  E.g., rather than trying to use golang static binaries and injecting them into a potentially heterogenous peer environment, recognize that docker was designed more or less to handle that heterogeneity (sans perhaps the $arch neutrality, though even that is improving).  Here's what I propose:  1) Come up with a formal design for the interface between peer and chaincode container w.r.t. docker launch.  E.g. right now we have a different launch spec for GOLANG vs CAR vs JAVA vs NODE.  Fix this so they are uniform.  For example, perhaps spec that each one should have its own CMD provided, and a set of environment variables and/or filepaths (e.g. /etc/hyperledger/fabric/peer/tls) for the knobs that the peer needs to pass.  2) Write a CR which implements (1) for the existing types  3) Write a CR that adds a new DOCKER type to the peer.   I am open to the notion that this could follow a "download from a docker registry" model, or an "administrator must pre-install" model.    4) Write a CR that creates a method for generating client-side generation of the docker payload in a deterministic manner (e.g. similar to how  ~troyronda  normalized a build based on golang v1.9 using docker)  (3) and (4) could be the same CR, if appropriate.  I would be supportive of considering such a proposal if you think this satisfies your goals.  ></body> </Action>
<Action id="30584" issue="20580" author="aleksandar.likic" type="comment" created="2017-09-06 21:42:10.0" updateauthor="aleksandar.likic" updated="2017-09-06 21:42:10.0"> <body><! CDATA  ~greg.haskins  Just to make sure I understand exactly what you are saying. Currently, a CC launch spec is really just a set of arguments and environment variables returned by  func (chaincodeSupport *ChaincodeSupport) getArgsAndEnv(...) in chaincode_support.go. Depending on a CC type, this function will return different args and envs. You think this should be refactored by defining a formal launch spec interface and having implementations for each CC type. Then, introduce a new CC type called DOCKER, and provide implementation for all necessary interfaces - the launch spec being one of them. A client utility to generate artifacts required for the launch (e.g. a docker image with the CC binary baked in) is also required. Am I getting it right?  ></body> </Action>
<Action id="30585" issue="20580" author="greg.haskins" type="comment" created="2017-09-06 21:58:46.0" updateauthor="greg.haskins" updated="2017-09-06 21:58:46.0"> <body><! CDATA  ~aleksandar.likic  actually, nothing to do with the CC launch spec.  What I mean specifically is this code right here:      https://github.com/hyperledger/fabric/blob/77cfd8c61f303538da986f93ac77203dac6a7df4/core/chaincode/chaincode_support.go#L406      You can see for GOLANG/CAR, we launch chaincode by effectively doing "docker run ... chaincode --peerAddress XXX"  For JAVA, we effectively are doing "docker run java --jar chaincode.jar  ---peerAddress XXXX"  For NODE, " ... /bin/sh -c node ..."  etc.  We get away with this because the peer essentially controls the entire docker build pipeline (currently).  Despite this, this has bothered me for a while and I've wanted to clean it up.  In theory, the containers could be built in such a way that we can have a uniform launch (e.g. "docker run -ePEER_ADDRESS=XXX") by normalizing the interface.  E.g. maybe the different chaincode environments (golang, java, node, whatever) are abstracted behind ENTRYPOINT/CMD such that peer need not care how the chaincode is launched, but rather just starting the container.  In addition, things like "peer address" parameters or TLS key material could be specified in general terms, such as expressed as environment variables and/for file paths.  Once this spec is established, we could then extricate the peer from the docker-build such that any container that adheres to the spec could be launched by the peer.  This would more or less be a prerequisite to accomplish what i am suggesting above.  The final piece of the puzzle would then be to create a new type ("DOCKER") that basically says to the peer during instantiation "don't try to docker-build this image, docker-pull it instead".  Does this make sense?        ></body> </Action>
<Action id="30589" issue="20580" author="aleksandar.likic" type="comment" body="OK, I understand. I see two independent stories, one to move the knowledge on how the CC is launched into container itself (so the peer can just start the container) and another one to introduce a new CC type, DOCKER. The latter can be done without the former. I agree it would be nice to clean the peer code from the CC type specifics as much as possible." created="2017-09-06 23:41:39.0" updateauthor="aleksandar.likic" updated="2017-09-06 23:41:39.0"/>
<Action id="30590" issue="20580" author="aleksandar.likic" type="comment" body="On the second thought, we do need a generic way to start a CC process in a user-provided docker container, so why not do it for all other CC types as well. A little bit more work, but makes sense." created="2017-09-06 23:59:50.0" updateauthor="aleksandar.likic" updated="2017-09-06 23:59:50.0"/>
<Action id="30612" issue="20580" author="aleksandar.likic" type="comment" created="2017-09-07 12:42:42.0" updateauthor="aleksandar.likic" updated="2017-09-07 12:50:09.0"> <body><! CDATA  ~greg.haskins  Thinking about the way to install/instantiate a CC of type DOCKER: obviously, the CDS (CC deployment spec) has to be extended with information on the target docker image. It should contain information on the target platform, perhaps using the same convention currently used by fabric peer when it calculates the base image name. A peer would be able to validate compatibility at CC install time. This would be applicable only to a DOCKER CC. Code_package in CDS would not be used for a DOCKER CC.  Thinking about a client utility to create a CC specific docker image, the easiest way seems to be just extending 'peer chaincode package' with an option to compile GOLANG source, build a new docker image, and stick the new image information into signed CDS. Essentially, compressing three steps that peer is normally performing for packaging, compilation and instantiation. Compatibility is guaranteed as it is done by fabric itself. Client is responsible to deploy CDS to peers that can handle it.  A more user friendly solution (the one that doesn't require creation of a user CC specific docker image and its out of band handling) is to extends current GOLANG CC type to handle pre-compiled GOLANG code. 'peer chaincode package' would accept an option that means 'pre-compile', first compile the CC, then calculate the base image name, and finally produce a CDS with the CC binary in code_package, and the proper docker base image name that guarantees compatibility. During instantiation the peer would skip CC compilation and calculation of proper image name (image compatibility is validated during CC install) and just create and start docker container as it is done today.  It is assumed that GOLANG compilation by the fabric ccbuild container is deterministic and that the base image name, that contains all peer metadata, assures that an auditor can use the same version of fabric used by the packager to reproduce the build from the same source. This might require sticking the source hash into signed CDS as well.  What do you think?  ></body> </Action>
<Action id="30983" issue="20580" author="aleksandar.likic" type="comment" created="2017-09-18 15:29:05.0" updateauthor="aleksandar.likic" updated="2017-09-18 15:29:05.0"> <body><! CDATA Hi  ~greg.haskins , here is a draft proposal based on your recommendations. Note that after some analysis we think that a docker-centric solution is actually a prerequisite for removing chaincode type specific code from the peer. Otherwise the objective is the same - to make the peer chaincode type agnostic.   https://docs.google.com/document/d/1BLQ0PWKdtpQtIlKewRAkdhjSGkDPWXTXj12Oe1GBw6I/edit#heading=h.9pacqguezrqe   Please comment, we would like to finalize the proposal and start implementation asap. Thanks.  ></body> </Action>
