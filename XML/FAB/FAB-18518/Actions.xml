<Action id="70978" issue="46417" author="JIRAUSER20816" type="comment" created="2020-12-16 14:09:05.0" updateauthor="JIRAUSER20816" updated="2020-12-16 14:09:47.0"> <body><! CDATA *getPrivateDataHash* returns pure data hash bytes instead of a string ( https://hyperledger.github.io/fabric-chaincode-java/master/api/org/hyperledger/fabric/shim/ChaincodeStub.html#getPrivateDataHash-java.lang.String-java.lang.String-  ), therefore retrieving the actual hash would look like this:            _const pdHashBytes = await ctx.stub.getPrivateDataHash(myCollectionName, myPrivateAssetId);_         _const actualHash = pdHashBytes.toString('hex');_   An example of such an implementation can be found in _VS Code IBP_ extension generated private data contract (when creating a new smart contract project), method _verifyMyPrivateAsset_  ></body> </Action>
<Action id="70979" issue="46417" author="icarrascol" type="comment" created="2020-12-16 14:49:17.0" updateauthor="icarrascol" updated="2020-12-16 14:49:17.0"> <body><! CDATA i know i didnt specify my code so here its a small part of it... the thing is i am transforming the bytes to hex for the console logs, i already verified that the hash missmatch is because the object attributes are being reordered, you can check them in couchdb itself. privatedatahash doesnt match the hash of the object in couchdb because the attributes are being reordered for some reason when it is stored.   {code:java} async transfer(ctx, id, dest, collection1, collection2) {    const transientMap = ctx.stub.getTransient();     const hash = crypto.createHash('sha256').update(transientMap.get('asset')).digest('hex');   const dataHash = await ctx.stub.getPrivateDataHash(collection1, id);   console.log(hash); console.log(dataHash.toString('hex'));    ... }{code}    ></body> </Action>
<Action id="71186" issue="46417" author="JIRAUSER20816" type="comment" created="2021-01-11 16:26:05.0" updateauthor="JIRAUSER20816" updated="2021-01-11 19:21:06.0"> <body><! CDATA Private data is hashed before it is stored in couchDB, therefore the order doesn't matter here, however, when it is hashed, spaces are removed, for example:  Instead of  {code:java} `{ "class": "org.pagare", "amount": "100", "id": "125", "owner": "org1" }`{code} we hash the following: {code:java} `{"class":"org.pagare","amount":"100","id":"125","owner":"org1"}`{code}    However, if you hash the object containing spaces, the hash values changes and will not match the one returned by _getPrivateDataHash_  ></body> </Action>
<Action id="71190" issue="46417" author="icarrascol" type="comment" created="2021-01-11 17:24:28.0" updateauthor="icarrascol" updated="2021-01-11 17:24:28.0"> <body><! CDATA i dont think it is possible to have 2 representations of the same javascript object, 1 with spaces and 1 without as it doesnt make sense for the language. when you create any object in js the representation of it should be one and only one to maintain consistency in the language itself. Can you show me a way to create a js object that has spaces and create a js object that doesnt have spaces? {code:java} // when you create an object like this  const obj = new Object(something);  // or like this;  const object = {foo:'bar'}; const object2 = { foo: 'bar' };{code} those 3 ways should get the same end result when you check the bytes or hash the object  ></body> </Action>
<Action id="71203" issue="46417" author="JIRAUSER20816" type="comment" created="2021-01-12 10:09:42.0" updateauthor="JIRAUSER20816" updated="2021-01-12 10:10:05.0"> <body><! CDATA In the first example of your original post, both transient data and privatedata have spaces in the JSON notations, that is why I assume that you may have tried using JSON.stringify on a string instead of an object, and then hashing the string. This would lead to different hash than the one given by _getPrivateDataHash()._  As you can see in the second example, even though the order is different, the hashes are the same.  ></body> </Action>
<Action id="71207" issue="46417" author="icarrascol" type="comment" created="2021-01-12 13:19:51.0" updateauthor="icarrascol" updated="2021-01-12 13:37:04.0"> <body><! CDATA no i use stringify on an object to store the data on the ledger. my second example shows that the order matters for hash values.  The privatedata hash is retrieved using getPrivateDataHash() and as you can see it matches the manual hash of the unordered object.  the privatedata retrieved from the collection is an ordered object, and if you hash it, it wont match its own privatedatahash that is what i am trying to say. you can verify it yourself, i dont know if you tried but: - store an object on a collection or the ledger with some properties like this \{z:'test',a:'test'} (attributes unordered on purpose). - go and check the couchdb register, you will see that the object in couchdb will have its attributes ordered (would be cool if you can post a screenshot of this). - make a chaincode method to retrieve this object and log it on console, you will get something like \{a:'test', z:'test'}  if you hash your original object and the retrieved object the hashes wont match, if you use getprivatedatahash on the key of the stored object, the hash retrieved will be the same as hashing the original object (like my second example shows) and like i said getprivatedatahash doesnt match hashing the stored privatedata itself and that is the error, and its obvious because the order of the attributes matter when you hash something. The objects stored in couchdb are being altered for some reason and they have its attributes ordered.  What you would expect is that hashing the retrieved object from the collection and comparing that to its own getprivatedatahash() would get you matching hash values but it doesnt.  ></body> </Action>
<Action id="71278" issue="46417" author="JIRAUSER20406" type="comment" created="2021-01-15 09:47:23.0" updateauthor="JIRAUSER20406" updated="2021-01-15 09:47:23.0"> <body><! CDATA "What you would expect is that hashing the retrieved object from the collection and comparing that to its own getprivatedatahash() would get you matching hash values but it doesn't."  For the record, I can fully appreciate the expectation and was a little surprised myself when I came across it.  Firstly, let's explain the reason why this occurs.   There are two (at the time of typing) databases that can be used to store the world state, LevelDB and CouchDB. CouchDB is the most often used as it can support richer query - in order to do this the payloads have to be JSON - so when setState/putState-style operations occur the data does need to be marshalled to and from binary - hence this is where the re-ordering occurs.   The hash though is computed on exactly what is sent in.   Note that this only occurs if the payload is JSON, if it where XML for example, then it would be unaffected. (note that the Go JSON parse does not recognise    as a top level JSON element.. only {})  Strictly speaking, of course, JSON doesn't have any defined order - so shouldn't matter - *apart* from in the circumstances such as this where hashes are being used - and that hash is based on a flattened string format. In this case.  Depending on the distribution of the chaincodes in a network and the clients, then there is a chance that JSON ordering becomes important anyway.. there will be a mix of languages, different versions of parsing libraries etc. so there is a real risk of mismatches in the bigger picture.   The best practice is to establish a safe-ordering across the solution and keep to that. This is a part of the ledger API work that was started.  Though in terms of this issue, there isn't anything as such we can fix... there is certainly an action we should take to make the best practice visible in samples etc.   Hope that helps!  ></body> </Action>
<Action id="71279" issue="46417" author="icarrascol" type="comment" body="i understand, i found another issue where people were talking about this non deterministic behaviour of json. i think like you said this needs to be explained maybe in the documentation and also in a js sample where a deterministic stringify is used to fix the order issue. thanks!" created="2021-01-15 12:21:58.0" updateauthor="icarrascol" updated="2021-01-15 12:21:58.0"/>
<Action id="71390" issue="46417" author="pandrejko" type="comment" body="Related Doc Jira is here https://jira.hyperledger.org/browse/FAB-17414" created="2021-02-11 16:44:34.0" updateauthor="pandrejko" updated="2021-02-11 16:44:34.0"/>
<Action id="71494" issue="46417" author="lesleyannj" type="comment" body="Sample changes would make sense; additionally provision better &apos;Best Practice&apos; guides would be useful." created="2021-03-04 15:11:47.0" updateauthor="lesleyannj" updated="2021-03-04 15:11:47.0"/>
<Action id="71703" issue="46417" author="denyeart" type="comment" created="2021-04-23 11:58:34.0" updateauthor="denyeart" updated="2021-04-23 11:58:34.0"> <body><! CDATA Deterministic JSON marshaling is documented here:  https://hyperledger-fabric.readthedocs.io/en/latest/couchdb_as_state_database.html#reading-and-writing-json-data   I agree samples would also help.  ></body> </Action>
<Action id="71923" issue="46417" author="JIRAUSER20406" type="comment" body="Reference for Node.js ... https://www.npmjs.com/package/fast-json-stable-stringify" created="2021-07-05 10:52:46.0" updateauthor="JIRAUSER20406" updated="2021-07-05 10:52:46.0"/>
