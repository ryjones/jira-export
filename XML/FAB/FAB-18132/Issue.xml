<Issue id="45783" key="FAB-18132" number="18132" project="10002" reporter="tock" assignee="tsharris" creator="tock" type="10001" summary="Remove ledger resources asynchronously" priority="3" resolution="10000" status="6" created="2020-08-10 14:26:34.0" updated="2020-11-09 12:39:56.0" resolutiondate="2020-11-09 12:39:56.0" votes="0" watches="2" workflowId="59745" archived="N"> <description><! CDATA In this task FAB-17964 the ledger resources are removed in a synchronous way. This may create problems when the channel's ledger is big. Here we improve upon that by removing the ledger in an asynch fashion. (see review comments  here|https://github.com/hyperledger/fabric/pull/1637#discussion_r462343435   and  here|https://github.com/hyperledger/fabric/pull/1637#discussion_r465503129  ).     The `r.ledgerFactory.Remove(channelID)` operation may take a long time. This operation is performed under the global registrar lock. If this takes even more then a fraction of a second, it will impact the performance of the server on all other channels. This method  // GetChain retrieves the chain support for a chain if it exists.  func (r *Registrar) GetChain(chainID string) *ChainSupport   \{  r.lock.RLock()  defer r.lock.RUnlock()  return r.chains chainID   \}  is called by every client request, through BroadcastChannelSupport  so we can't really hold that lock for too long (for write - exclusive).  What is propose is asynch deletion: * introduce a {{*pendingRemove* map (e.g. map string bool }}) that holds channels that are being removed. * After stopping the channel move the *{{channelID}}* to that map, * and only then delete the ledger, but make the delete async with a different go-routine. * release the lock. * when the delete go-routine finishes, it removes the *{{channelID}}* from the *{{pendingRemove}}* * if the go-routine fails to remove the channel, it sets *{{pendingRemove channelID =false}}* * any attempt to `Join` or `Remove` should also check the *{{pendingRemove}}*  ></description> </Issue>
