<Issue id="28411" key="FAB-8788" number="8788" project="10002" reporter="denyeart" assignee="jyellick" creator="denyeart" type="10002" summary="Design for channel-based access control (ACL)" priority="3" resolution="10000" status="6" created="2018-03-12 04:19:17.0" updated="2018-10-31 06:15:05.0" resolutiondate="2018-03-30 14:21:58.0" votes="2" watches="11" workflowId="41499"> <description><! CDATA v1.1 of Fabric introduced an experimental feature for specifying ACLs. Users who wished to use ACLs would edit their channel creation transaction using {{configtxlator}} and add some entries into the {{isolated_data}} which defined these policy references. This would cause the peer to create a 'resources tree' which included these ACL definitions and policies.  The 'resources' tree is a bit heavyweight, and comes with a lot of code to support it in the peer. The original idea was that other operations like chaincode lifecycle would be handled through this mechanism, but, since that proposal has been abandoned, we're left with a significant maintenance burden with not a lot of benefit. Because the semantics are (purposefully) nearly identical to the channel config, a natural choice is to move these ACLs out of the 'resources tree' and into the standard 'channel config tree'. Rather doing "PEER_RESOURCE_UPDATE" transactions (which, to my knowledge have only been used in dev, never in the wild), updates could be made via standard "CHANNEL_UPDATE" messages.  Since editing channel creation transactions by hand is tedious and error prone, `configtxgen` can be enhanced to create them with the appropriate entries.  Consider a new config value defined at the application level: {noformat} message PeerACLs { map<string>PeerACL acls = 1; }  message PeerACL { string policy_ref = 1; } {noformat} In JSON, this would look like: {noformat} { "CSCC.GetConfigBlock":{"policy_ref":"/Channel/Application/Readers"}, ... "QSCC.GetBlockByNumber":{"policy_ref":"/Channel/Application/Readers"} } {noformat} We can enhance {{configtxgen}} to make specifying these possible as part of channel creation, and users may of course use standard channel reconfiguration tools to modify or add them later. {noformat} Application: ACLs: CSCC.GetConfigBlock: /Channel/Application/Readers ... QSCC.GetBlockByNumber: /Channel/Application/Readers {noformat} Adding the specification into {{configtx.yaml}} is noticeably less useful if users cannot specify channel config policies there as well. So, we can extend {{configtx.yaml}} to specify them as well:  Each element (Such as Channel, Application, Orderer, and Org) can be enhanced to support a {{Policies}} sub-element. Like: {noformat} Application: Policies: Foo: Type: Signature Rule: "Org1.Peer AND Org2.Peer" Bar: Type: ImplicitMeta Rule: "MAJORITY Readers" {noformat} For an existing user to migrate, they would simply need to define the new config element in their channel update transaction when they enable the v1.2 capability. This would provide a seamless transition between the experimental and v1.2 feature.  Finally, the ACL section could reference these by name, like: /Channel/Application/Foo and /Channel/Application/Bar  ></description> </Issue>
