<Issue id="30843" key="FAB-10520" number="10520" project="10002" reporter="yuki-kon" assignee="yuki-kon" creator="yuki-kon" type="10001" summary="Chaincode shim supports get/put/delete key-values per data objectType" priority="3" resolution="10001" status="6" created="2018-06-02 00:09:51.0" updated="2019-09-23 20:50:46.0" resolutiondate="2019-09-23 20:50:46.0" votes="1" watches="6" workflowId="35839"> <description><! CDATA h2. 1 Background  Hyperledger Fabric v1.2/1.3/1.4 supports collection for private data. Collection makes it simple to put/get/delete multiple private data per objectType. A private key-value is unique in a Chaincode under the namespace of a collection. As application developers, we would like to have the same concept for regular channel data. It will be useful because we can save the steps to generate composite keys to make a key-value unique in a Chaincode. The attached shows the image of namespace in a Chaincode. h2. 2 Problem statement  Chaincode developers often implement the same logic manually to put/get/delete key-values per data object.  When a Chaincode has multiple data objectTypes, it is common to use composite keys. To make keys unique in a Chaincode, the name of an objectType and a key are concatenated: _<objectType name>_<Key name>_. Letâ€™s say we have `foo` as a data objectType. `foo` has three keys: f1, f2, f3. The unique composite keys will be: _foo_f1_, _foo_f2_, _foo_f3_. Underscore shows the prefix or separator of composite keys.  When we put or get a key-value, we need 2 steps. 1. Generate a composite key by calling `stub.CreateCompositeKey(objectType, keys)`. 2. put/get a key-value by calling `stub.PutState(key string, value   byte)` or `stub.GetState(key string)`.  The Chaincode looks like the below. {code:java} fooKey, err := stub.CreateCompositeKey("foo",   string{"f1"}) if err != nil { return shim.Error(err.Error()) } err = stub.PutState(fooKey, value) if err != nil { return shim.Error(err.Error()) } {code} If we have the concept like collection for regular public state, each key become unique without using composite keys. h2. 3 Proposal  We propose that Chaincode shim support APIs to put/get/delete key-values per data objectType. Composite key is created in each function and used to call data access handlers. The following shows a proposal of new APIs in Chaincode shim. The proposal of APIs for state-based endorsement and pagination will be added soon. {code:java} // GetStateByCompositeKey returns the value of the specified composite key from // the ledger. The composite key is created from `objectType` and `keys`. // Note that GetStateByCompositeKey doesn't read data from the writeset, which has // not been committed to the ledger. In other words, GetStateByCompositeKey doesn't // consider data modified by PutStateByCompositeKey that has not been committed. // The `objectType` and `keys` are expected to have only valid utf8 strings // and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated // code point). See related functions SplitCompositeKey and CreateCompositeKey. GetStateByCompositeKey(objectType string, keys   string) (  byte, error)  // PutStateByCompositeKey puts the specified composite key and `value` into the // transaction's writeset as a data-write proposal. The composite key is created // from `objectType` and `keys`. PutStateByCompositeKey doesn't effect the ledger // until the transaction is validated and successfully committed. // The `objectType` and `keys` are expected to have only valid utf8 strings // and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated // code point). See related functions SplitCompositeKey and CreateCompositeKey. PutStateByCompositeKey(objectType string, keys   string, value   byte) error  // DelStateByCompositeKey records the specified composite key to be deleted in the // writeset of the transaction proposal. The composite key and its value will // be deleted from the ledger when the transaction is validated and successfully // committed. The composite key is created from `objectType` and `keys`. // The `objectType` and `keys` are expected to have only valid utf8 strings // and should not contain U+0000 (nil byte) and U+10FFFF (biggest and unallocated // code point). See related functions SplitCompositeKey and CreateCompositeKey. DelStateByCompositeKey(objectType string, keys   string) error  // GetStateByObjectType returns a range iterator over a set of composite keys in // the ledger. The iterator can be used to iterate over all composite keys having // a given `objectType`. // However, if the number of keys having the `objectType` is greater than the // totalQueryLimit (defined in core.yaml), this iterator cannot be used // to fetch all keys (results will be capped by the totalQueryLimit). // The keys are returned by the iterator in lexical order. // Call Close() on the returned StateQueryIteratorInterface object when done. // The query is re-executed during validation phase to ensure result set // has not changed since transaction endorsement (phantom reads detected). GetStateByObjectType(objectType string) (StateQueryIteratorInterface, error)  // DelStateByObjectType records all composite keys having a given `objectType` to be // deleted in the writeset of the transaction proposal. The keys and their value will // be deleted from the ledger when the transaction is validated and successfully committed. DelStateByObjectType(objectType string) error  // GetHistoryForCompositeKey returns a history of composite key values across time. // For each historic key update, the historic value and associated // transaction id and timestamp are returned. The timestamp is the // timestamp provided by the client in the proposal header. GetHistoryForCompositeKey(objectType string, keys   string) (HistoryQueryIteratorInterface, error)  // TBD SetStateValidationParameterForCompositeKey(objectType string, keys   string, ep   byte) error  // TBD GetStateValidationParameterForCompositeKey(objectType string, keys   string) (  byte, error)  //TBD GetStateByObjectTypeWithPagination(objectType string, pageSize int32, bookmark string) (StateQueryIteratorInterface, error)  {code} h2. 4 Usage  If we have these APIs, the Chaincode will be like the below. {code:java} err = stub.PutStateByCompositeKey ("foo",   string{"f1"}, value) if err != nil { return shim.Error(err.Error()) } {code} h2. 5 Development plan  This JIRA consists of the following sub-tasks. The first target is Golang Chaincode.  +Define API definitions+  +Develop new APIs in Chaincode shim+ * (Part1) GetStateByCompositeKey, PutStateByCompositeKey, DelStateByCompositeKey * (Part2) GetStateByObjectType, DelStateByObjectType * (Part3) GetHistoryForCompositeKey * (Part4) State-based endorsement (SetStateValidationParameterForCompositeKey, GetStateValidationParameterForCompositeKey) * (Part5) Pagination (GetStateByObjectType)  +Develop mock stub for new APIs+ +Develop sample Chaincode for new APIs+  ></description> </Issue>
