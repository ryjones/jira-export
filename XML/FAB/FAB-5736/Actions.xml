<Action id="29936" issue="20137" author="angelo.decaro" type="comment" created="2017-08-17 00:20:30.0" updateauthor="angelo.decaro" updated="2017-08-17 00:25:06.0"> <body><! CDATA If we allow to export a secret key that would create an incompatibility with the HSM-based BCCSP.  ~elli-androulaki ,  ~ales ,  ~vpaprots@ca.ibm.com ,  ~mastersingh24  what's your take here?  Actually, a possible solution would be to have an opts that allows to generate an exportable secret key, no matter what. Would this be a viable solution also in HSM context?  ></body> </Action>
<Action id="30045" issue="20137" author="elli-androulaki" type="comment" created="2017-08-21 14:39:14.0" updateauthor="elli-androulaki" updated="2017-08-21 14:39:14.0"> <body><! CDATA I agree with you  ~angelo.decaro  that adding an opts field in the call of key-derivation makes sense to accommodate both needs.  We can also set "non-exportable" as default mode for such keys being generated. What do you think?     ></body> </Action>
<Action id="30046" issue="20137" author="smithbk" type="comment" created="2017-08-21 14:52:02.0" updateauthor="smithbk" updated="2017-08-21 14:52:02.0"> <body><! CDATA Yes, so the following will be work, right?  {code} 	bkey, err := csp.KeyGen(&bccsp.AESKeyGenOpts{Temporary: true, Exportable: true}) 	if err != nil { 		return nil, nil, fmt.Errorf("Failed to generate key: %s", err) 	} 	key, err := bkey.Bytes() 	if err != nil { 		return nil, nil, fmt.Errorf("Failed to serialize key: %s", err) 	} {code}  ></body> </Action>
<Action id="30050" issue="20137" author="elli-androulaki" type="comment" body="In terms of BCCSP interface change, yes, I would say so. " created="2017-08-21 16:44:40.0" updateauthor="elli-androulaki" updated="2017-08-21 16:44:40.0"/>
<Action id="30056" issue="20137" author="jonathanlevi" type="comment" body="I&apos;m not sure I understand. Why do we need to export a *private* key?" created="2017-08-21 21:59:22.0" updateauthor="jonathanlevi" updated="2017-08-21 21:59:22.0"/>
<Action id="30057" issue="20137" author="jonathanlevi" type="comment" created="2017-08-21 22:00:28.0" updateauthor="jonathanlevi" updated="2017-08-21 22:00:28.0"> <body><! CDATA  ~smithbk  " I want to pass the keys back to the client and they will be passed to chaincode in the transient data field."  Why would you want to pass the *private* key to the chaincode?  ></body> </Action>
<Action id="30079" issue="20137" author="binhn" type="comment" body="Discussed with Keith yesterday that we should allow the requester to pass in a public key to use for attribute encryption. This would enable the application to control the secret, which may be in HSM. " created="2017-08-22 16:51:56.0" updateauthor="binhn" updated="2017-08-22 16:51:56.0"/>
<Action id="30083" issue="20137" author="vpaprots" type="comment" created="2017-08-22 19:57:01.0" updateauthor="vpaprots" updated="2017-08-22 19:57:01.0"> <body><! CDATA  ~binhn  Were you thinking of a scheme like ECIES for encryption of attributes?  I had discussed this problem of sending private keys in transient data with both  ~smithbk  and  ~mastersingh24  . Not sure if I actually managed to convey my thoughts, it was a while ago and we had plenty of other things to worry about, but here another try.  Yes, exporting a private key as bytes is not something you do. HSM will not let you do that. The closest you can get to 'exporting' private key is a Key-Encrypt-Key (KEK) solution, in which you give the HSM another HSM key to encrypt the key you want. That gets you the encrypted key back which you can now send around. Perhaps its a bit of circular reasoning..  To establish a shared 'master key' for the KEK I was proposing something like ECDHE. One could arrange that to happen as part of enrolment or part of TCert batch request.  I think ECIES is fine too. Its really ECDHE->SHA->AES.. similar to what I was suggesting above.   ~angelo.decaro   ~elli-androulaki  We might need to check with Tamas (and use several of your 'chips' of course ;)) on ECIES implementation with HSM. In particular, output of ECDHE is typically a (public) point rather then a (unconditioned) 'key', but I believe there is a way to overcome that.  ></body> </Action>
<Action id="30085" issue="20137" author="jonathanlevi" type="comment" created="2017-08-22 20:47:27.0" updateauthor="jonathanlevi" updated="2017-08-22 22:07:38.0"> <body><! CDATA Here is an idea. Let's first discuss the problem, and not the proposed solution.  Let's put aside the current proposal to {color:#d04437}*export* {color:#333333}and/or{color}{color} {color:#d04437}*share* *private keys*{color} and/or pass them to the chaincode - something that will not hold water. *{color:#205081}I have objected to such patches/exporting of private keys time and again... the issue is not the HSM incompatibility, the issue is that we don't export private keys. I don't need convincing...{color}* {color:#333333}(and I "betcha" that neither does  ~mastersingh24 ). {color}On that note, let's also bear in mind that some of the good KEK schemes and techniques are heavily patented, some of which have not expired.  We have enough brain/thinking power here. Much more so, when we combine forces. I/others can be a lot more helpful, much more so than when we start from a user-story in the form of: "As a user, I need to export the private key and share it on XYZ. Let's just set: export=true". This already  begins from the wrong starting point.  How about we take a step back, and start with: *What is the actual +problem+ that we are trying to solve?* Can we start with this, and then try to work out a solution or examine a few proposals together?     ></body> </Action>
<Action id="30117" issue="20137" author="jonathanlevi" type="comment" created="2017-08-23 18:10:18.0" updateauthor="jonathanlevi" updated="2017-08-23 18:10:18.0"> <body><! CDATA  ~Clayton Sims  made changes - 10 minutes ago |Labels|Release-planning-1.1|Release-planning-1.2|  Thank you  ~Clayton Sims  ^^^  ></body> </Action>
<Action id="30121" issue="20137" author="vpaprots" type="comment" created="2017-08-23 20:31:43.0" updateauthor="vpaprots" updated="2017-08-23 20:31:43.0"> <body><! CDATA  ~JonathanLevi  Good point.  ~smithbk  you know more about the problem, but I think this is correct.. And most of this is probably stuff you know, Jonathan, but for the benefit of bringing everyone along and making this item make more sense standalone.  CA should encrypt 'properties' into a (T)cert its producing. And give back the certificate requestor (i.e. sdk) a key for decryption. I believe there is a key derivation scheme (based on HMAC, hope you know which I am talking about) so that the key returned by the CA is actually the root key for that batch (or user, depending on the scheme).  The SDK then might 'send' this key to a particular endorsing peer (I believe the plan is to use the transient field). I believe much of this code already existed at some point (either in 0.6 or in unmerged changes?)  So the +actual+ problem is of transport. How to distribute those keys? From the CA to SDK. From SDK to Peer. I believe the claim was that because the keys are sent over TLS, it is fine. Clearly, HSM does not agree..  If I were to take even a larger step back.. the point of attributes. I believe they are crucial to implement 'application-level' permissions? Is that correct? Is this key distribution the only way to accomplish that? Perhaps not the questions to be asking when most of the code is written?  ></body> </Action>
<Action id="30125" issue="20137" author="smithbk" type="comment" created="2017-08-23 21:50:04.0" updateauthor="smithbk" updated="2017-08-23 21:51:10.0"> <body><! CDATA I rewrote this as a story.  See the description section.   A proposal follows.  1) In v1.1, support only unencrypted attributes in ECerts.   For many RBAC (Role-Based Access Control) decisions, I don't think it is necessary to hide the fact that someone has a particular role.  For example, if someone has the attribute "admin" with a value of "true", they would have the "admin" role and need not be hidden.  2) Post v1.1, support encrypted attributes in ECerts.  When the client enrolls with the fabric-ca-server, the client would be required to send a list of <attributeName, publicKey> pairs for each attribute to be encrypted.  The server uses the public key to encrypt the attribute value, place it in the certificate, and signs it.  The chaincode would need access to the private key in order to decrypt the value.   ></body> </Action>
<Action id="50350" issue="20137" author="elli-androulaki" type="comment" body="So a document associated to attribute based access control (edited more than a couple of months ago, is  here|https://docs.google.com/document/d/1ETeoqfUHMK3sisF0k0IIACLEh3E8eVzMiOWagTAQXio/edit?usp=sharing ). Also this item seems to be related to FAB-8794 and to FAB-11602. Shall we include it as part of the epic? " created="2018-09-12 11:18:46.0" updateauthor="elli-androulaki" updated="2018-09-12 11:39:39.0"/>
<Action id="67108" issue="20137" author="sykesm" type="comment" body="Stale" created="2020-01-22 22:01:00.0" updateauthor="sykesm" updated="2020-01-22 22:01:00.0"/>
