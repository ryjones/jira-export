<Action id="20465" issue="14212" author="binhn" type="comment" created="2017-01-21 15:27:01.0" updateauthor="binhn" updated="2017-01-21 15:27:01.0"> <body><! CDATA bq. an new init (instantiate ?) command to associate the chaincode with a channel  So init is really a binding transaction (involving a transaction proposal and a transaction broadcast) allowing the chaincode to run on the specified channel. The user (transactor), who issues this transaction, must be authorized by the chaincode life-cycle policy on the channel.  The SDK should provide option for the application to specify a list of channels rather than a single channel on the API, and the SDK can loop through to bind all channels to the chaincode.  ></body> </Action>
<Action id="20500" issue="14212" author="muralisr" type="comment" created="2017-01-21 16:00:16.0" updateauthor="muralisr" updated="2017-01-21 16:00:16.0"> <body><! CDATA {quote} So init is really a binding transaction (involving a transaction proposal and a transaction broadcast) allowing the chaincode to run on the specified channel. The user (transactor), who issues this transaction, must be authorized by the chaincode life-cycle policy on the channel. {quote}  Yes. That together with the hashcode saved on LCCC per channel provide the means to ensure this can be done securely.   {quote} The SDK should provide option for the application to specify a list of channels rather than a single channel on the API, and the SDK can loop through to bind all channels to the chaincode. {quote}  Sure, but the SDK has to send them out as separate transactions till fabric supports batch transactions. So it would just be convenient wrapper API.  ></body> </Action>
<Action id="20501" issue="14212" author="muralisr" type="comment" body="Also now that we have code/data separation, can we use {{instantiate}} -  as in {{peer chaincode instantiate ...}} -  instead of {{init}} ? " created="2017-01-21 16:02:26.0" updateauthor="muralisr" updated="2017-01-21 16:02:26.0"/>
<Action id="20503" issue="14212" author="mastersingh24" type="comment" created="2017-01-21 17:10:06.0" updateauthor="mastersingh24" updated="2017-01-21 17:17:10.0"> <body><! CDATA I have not decided whether or not I fully agree with this proposal (yet - and want to hear from others), but in keeping with the intent of the proposal, I'd like to suggest the following "adjustments".  #  If we are going to make this type of major change, then we should REALLY make the change ** no longer use the term deploy ** add an API to the peer called "InstallChaincode"  (or something like that) #  Add function "Initialize" to LCCC ** takes "name,hash" as parameters (I assume you invoke LCCC in the context of a channel/chain) ** not sure if you had this in the cases above, but we would need to handle the case where "Initialize" was run on a channel (so there's a tx in the ledger) but the chaincode had not been installed on the peer.  Assuming the chaincode was installed after the fact, I guess similar to the current logic if the peer receives an endorsement proposal for a chaincode, it simply checks LCCC and starts it up  ></body> </Action>
<Action id="20504" issue="14212" author="muralisr" type="comment" created="2017-01-21 17:29:42.0" updateauthor="muralisr" updated="2017-01-21 17:30:02.0"> <body><! CDATA  ~mastersingh24   # Install CC vs deploy - hits the intent spot IMO ! Get's my vote. # About LCCC changes  * Probably we have to do something like that to LCCC. * I think that case of being on the channel but not installed on the peer ... I think that's covered by {{It will fail if it was not deployed on Peer2.}} under Scenario {{I want to invoke a chaincode on a channel on Peer2 when it was instantiated on the channel by Peer1}}.  I'm sure there are other scenarios and will add more.    ></body> </Action>
<Action id="20521" issue="14212" author="elli-androulaki" type="comment" created="2017-01-23 09:01:08.0" updateauthor="elli-androulaki" updated="2017-01-23 09:04:04.0"> <body><! CDATA Hi,   Some more questions & details from my side. So the flow (as far as i understood it) is the one below (?).   1) Command "installChaincode" that runs on the peer has the form of an LCCC deploy proposal? The LCCC would be executed on the proposal's input, i.e., authorization of the proposal's creator against the LCCC chaincode creation policy is checked there. The creator would need to "wait" till it collects "responses" from all the endorsers/peers it asked to install the chaincode from. At installation time, and if confidentiality of the source code is important, then *a secret key should be passed to LCCC* at proposal time, such that the "evidence of the source code" ( code_evidence = HASH (source_code, secret_key)) reveals nothing on the source code content.  2) After collecting responses from "InstallChaincode" commands an LCCC "deploy announcement" is submitted to the chain in the form of transaction. This would contain simulation results of LCCC execution that include (among others) the "code_evidence", the name of the new chaincode, and the endorsement/validation policy for this freshly implemented chaincode. There it could be that VSCC policy is provided as input the peers who have successfully installed this  chaincode. The transaction could contain endorsement responses, on the LCCC deploy announcement /proposal, or solely the creator's signature on the new chaincode's creation simulation results.   3) Orderers receive this transaction and order it.  4) Committing peers who receive this transaction, check that the signature on the transaction comes from a creator that is authorized to create chaincodes or not. If so and the LCCC simulation results pass, then the peers would accept the changes instructed by this transaction. However, they have **no means to check if the chaincode has already been installed** by the peers included in the policy. But one could argue that this falls under the chaincode creator's responsibility.  Now, regarding the naming of the chaincode, we need to keep in mind / discuss whether the following attack is relevant: - admins a and b are authorized to create chaincodes. - admin a wants to include in the blockchain a chaincode CCa - admin b wants to prevent CCa from being included in the blockchain for a couple of blocks Admin b can do the following:  - admin b can guess the name of CCa before it appears in the chain, or waits till tx announcing creation of CCa goes through gossip - admin b uses the name of CCa in a transaction claiming to announce a fake - unexisting chaincode CC'b and manages to have this transaction to appear first in the ordering of chaincode - CCa is annonced but the installation is sort of abandoned, cause CCb' has taken the CCa's name.   Also, regarding the peers who have installed a chaincode, what happens if the application wants to install the chaincode to another peer? Wouldn't this mean that the VSCC should be updated? How would the peer update the state associated to that chaincode? Would it need to retrieve it from the ledger step-by-step?   ></body> </Action>
<Action id="20524" issue="14212" author="elli-androulaki" type="comment" created="2017-01-23 10:30:30.0" updateauthor="elli-androulaki" updated="2017-01-23 11:06:28.0"> <body><! CDATA Another comment, is that this mechanism (sort of a chaincode deduplication mechanism :)) could be used to compromise (to a some extend) the confidentiality of a chaincode, that say exists in only one chain and whose name has been guessed. This would make the whole identity of a chaincode confidential.   This could be implicitly addressed through the control that peers/org administrators of which peer should join which channel. That is, if three peers A, B, and C have the chaincode with "chaincode_evidence" CE installed, these peers should be joining any other channel this chaincode appears in.   However there still is an issue: Say peers A, and B have joined a channel where a peer D is also a participant of. Say A, B, C, belong to Org1, and D belongs to a different organization, Org2. Now Org2 has guessed the identifier CE, and wants to have the same chaincode accessible to the chain where A, C, D share such that it is able to query its logic. Org2 admin has chaincode deploy permissions so LCCC will not object and the peers of Org1 will automatically *by receiving the init* consider this chaincode for the channel that Org1, and Org2 share. Nevertheless, Org2 does not know the content of the chaincode.   This one could be overcome by enforcing that there is an ACL of who can "announce" each already installed chaincode to a chain...   Also we may want to think more on how a chaincode name's uniqueness among all chains is enforced ...   ></body> </Action>
<Action id="20535" issue="14212" author="binhn" type="comment" created="2017-01-23 18:28:07.0" updateauthor="binhn" updated="2017-01-23 18:29:56.0"> <body><! CDATA  ~ellaki  Regarding chaincode names collision, I think that is unavoidable as we require uniqueness, so if admin A from orgA named his chaincode orgA.chaincodeA, and somehow that collided with adminB's (from orgB) chaincode also named orgA.chaincodeA, then I would think the solution would be easy. After all, they are on a permissioned network.  Chaincode names and variable keys are not really private to only endorsers, but everyone on the channel must know through the transactions on those chaincodes. What private to the endorsers are the chaincodes themselves since they are not kept on the ledger.  We said that ACL is based on org cacerts, so if D has access then anyone from D's org2 has access. Now being able to initialize a chaincode on a channel also under the control of the endorsement policy, which would specify only admin of Org1, so org2 would not be able to init the chaincode on other channels.   ></body> </Action>
<Action id="20537" issue="14212" author="elli-androulaki" type="comment" created="2017-01-23 21:15:16.0" updateauthor="elli-androulaki" updated="2017-01-23 21:16:06.0"> <body><! CDATA Hi,   After request from Murali, I list below security threats (and countermeasures) that are relevant for the old and new model of deployment, and the ones that are relevant to the new install/initialize model:  Both models:  *(Un-)authorized chaincode deployment (in old model) or authorization (in new model).* This proper policy configuration to LCCC of chains to restrict deployment (in old model) or initialization (in the new model) of chaincodes to properly authorized clients. Upgrade is to be restricted in a similar fashion to only these entities.  New model:  1. *Naming of a chaincode be unique per blockchain network installation.* In the old model one needed to guarantee a chain-wide unique name per chaincode that was rather straight-forward.  2. *(Un-)authorized initialization of a specific chaincode to a chain*. This aims to account for the case where an authorized chaincode deployer does not have access to a chaincode nor its installation, but (knowing that its likely to be deployed in other chains) it attempts to initialize it in the current chain, to obtain information on its (otherwise confidential) logic.A solution here could be that the chaincode installation is followed by an access policy definition that is hashed with the source code into the chaincode identifier. This identifier is submitted at the chaincode initialization phase (in combination to item 3). In addition, endorsement form all peers listed in the initialized chaincode's endorsement policy should be acquired for initialization. A deeper analysis of what is needed here needs to be done.  3. *Availability of the chaincode.* Here a chaincode may be initialized in a chain without the peers listed in the endorsement policy having installed it. A solution here would be that at initialization phase, requiring endorsements from *all* peers who are listed in the endorsement policy. All these peers would need to process initialization proposals during which they would run the invoker's identity and signature against the chaincode policy provided during installation (see item 2). If the latter policy rejects, endorsement is not provided.    ></body> </Action>
<Action id="20540" issue="14212" author="elli-androulaki" type="comment" created="2017-01-23 22:30:22.0" updateauthor="elli-androulaki" updated="2017-01-24 13:19:33.0"> <body><! CDATA  ~binhn  So for the naming, I see; you are saying we can have namespaces that would avoid collisions. Agreed. But then some naming policy enforcement should take place at LCCC (initialization) phase.   Now for incorporating policies into the chaincode, I think it would solve the problem if *one of the two* would be in place: - at instantiation endorsement time, endorsements from all endorsers in the intended endorsement policy are collected - chaincode policy evaluation is part of the LCCC_VSCC that would need to check first if the creator of the instantiation transaction also had the right to instantiate that specific chaincode.      ></body> </Action>
<Action id="20545" issue="14212" author="angelo.decaro" type="comment" created="2017-01-24 12:28:38.0" updateauthor="angelo.decaro" updated="2017-01-24 12:35:39.0"> <body><! CDATA  ~muralisr ,  ~binhn , may you clarify what is stored on the channel ledger after an instantiate, upgrade and stop? If I got it correctly, there will be a transaction (if the relative proposal gets endorsed) that leaves a trace that can be used later on if someone needs to replay the history, right?  It is clear to me that the install does not leave any trace in any ledger.  ></body> </Action>
<Action id="20546" issue="14212" author="angelo.decaro" type="comment" body="I would like to add the following consideration. In the endorsement process of an instantiate proposal, having a cryptographic proof from the peer that it knows the code for which the instantiate has been requested would solve multiple issues. Such a solution would add some inefficiency to the endorsement process anyway. I will not go into the details here, I wanted just to leave a trace about this approach. " created="2017-01-24 12:44:43.0" updateauthor="angelo.decaro" updated="2017-01-24 12:44:43.0"/>
<Action id="20548" issue="14212" author="vukolic" type="comment" created="2017-01-24 14:55:15.0" updateauthor="vukolic" updated="2017-01-24 14:55:15.0"> <body><! CDATA Hi all,  I think this proposal mixes two things: 1) the first is the replacement of chaincode with a pointer to the chaincode (a hash) - with the goal of speeding up the process of deploying the chaincode, and to simplify the chaincode mgmt in general. The price for this is the non-atomicity in chaincode binding to the channel (instantiation) and the obtaining (installation?) of the chaincode. Let's say this is a reasonable tradeoff to make, and I support the idea. What is perhaps missing is fabric support for (authorized) peers to get that chaincode from somewhere in an automated way (instead of waiting for admin to come and put it on a local FS). To this end endorsement policy pertaining to chaincode binding (instantiation) may be of some help, as well as the endorsement of the instantiate transaction.  TL;DR - I support this part of the proposal  2) using the same pointers to the chaincode for CONFIDENTIALITY WITHIN A SINGLE CHANNEL. This one needs to be done very properly and requires solutions that we in general postponed to after v1 and that brings up concerns that Elli is writing about. In this sense, unless we do properly full-fledged fabric-level support for confidentiality on a single channel - I discourage any partial solutions such as this one.  So my suggestion is to split this JIRA issue into two, as discussed above, putting higher priority on the first part of it and the lower priority to the second part. The second part would need to be done in the context of the more general treatment of confidentiality on a single channel.    ></body> </Action>
<Action id="20552" issue="14212" author="muralisr" type="comment" created="2017-01-24 19:15:42.0" updateauthor="muralisr" updated="2017-01-24 19:30:39.0"> <body><! CDATA  ~marko.vukolic  The proposal's intent was just (1) in your comment. On re-reading most of the Description is about the mechanics of  that. There is no direct reference to confidentiality on a channel though I can see how having chaincode binary outside of channels could influence confidentiality considerations.  Basically, how do you suggest we _split_ the proposal into 2 ? Most of the material seems to be about (1).  ></body> </Action>
<Action id="20553" issue="14212" author="vukolic" type="comment" created="2017-01-24 19:45:51.0" updateauthor="vukolic" updated="2017-01-24 19:45:51.0"> <body><! CDATA  ~muralisr  I may be reading too much into  " There are a few issues with the  current   model # by virtue of the code being on the ledger, all peers in the chain have access to the chaincode. There is no mechanism to selectively disable chaincode on certain peers in the channel"  I was under impression that dissalowing "access" to chaincode goes towards confidentiality. If it does not, and is merely about - not running chaicode on certain peers as they are never endorsers of this chaincode - then fine.    ></body> </Action>
<Action id="20554" issue="14212" author="muralisr" type="comment" created="2017-01-24 19:54:31.0" updateauthor="muralisr" updated="2017-01-24 19:54:31.0"> <body><! CDATA  ~marko.vukolic  I see. I can see how it is open to that interpretation.  _not running chaicode on certain peers as they are never endorsers of this chaincode_ ... that does add clarity and that was the intent (I think... now I'm beginning to wonder if this unconsciously opens way for the stronger interpretation). Let me rewrite that part (thanks!).  ></body> </Action>
<Action id="20727" issue="14212" author="jyellick" type="comment" body="Posted my vote of approval to the associate CR, but I think this solves some problems from an orderer perspective, in particular, having to deal with messages that are many orderers of magnitude different in size (a few hundred KB for a normal Tx, and up to a few hundred MB for a deploy TX) has caused problems in v0.6, so removing the chaincode distribution through the ordering service would be a welcome change." created="2017-02-07 16:09:35.0" updateauthor="jyellick" updated="2017-02-07 16:09:35.0"/>
<Action id="20782" issue="14212" author="dshuffma" type="comment" created="2017-02-08 18:51:32.0" updateauthor="dshuffma" updated="2017-02-08 18:54:13.0"> <body><! CDATA I question the usefulness of yet another isolation level. If someone is concerned with running other member's chaincode, why are they on the same channel? Can't our answer to "I don't want to run/hold irrelevant chaincode" be to make your own channel?  This change would _slightly_ complicated the following scenario too:  Policy says I need 50+% endorsements for tx be accepted.I have a network with 6 orgs (each 1 peer), 3 of them have my chaincode. Everything is fine since I can get 3/6 endorsements on invokes. We invited 1 more org. Without intervention my application is getting only 3/7 endorsements. It will fail.  To fix it I need to: 1) learn about other peers, 2) get an enroll ID and then create a valid enrollment on one of theses other peers. and *3)* deploy the exact same chaincode (this sounds error prone since its left to the masses). Granted this scenario is similar to how things will work already, but the difference is *I* have to deploy the *same* chaincode. exact same. if the application developer accidentally modified the chaincode in the last year, but forgot about it... does it error? what if he completely loses the source due to catastrophe (I know its a bit hyperbolic, but... still).    tldr: this proposal adds a pain point of using the network that didn't exist prior to this proposal.  ></body> </Action>
<Action id="20785" issue="14212" author="binhn" type="comment" created="2017-02-08 21:36:18.0" updateauthor="binhn" updated="2017-02-08 21:36:18.0"> <body><! CDATA  ~dshuffma  The endorsement policy is expressed in terms of endorser's orgs of a chaincode, so adding another peer doesn't change this equation. Adding another org would, but that would force the configuration change, and possibly re-instantiation of the chaincode with a new endorsement policy.  So it doesn't add any more work to the app than the current model.  The key goal is to take the chaincode code out of the channel (ledger).  ></body> </Action>
<Action id="20786" issue="14212" author="dshuffma" type="comment" created="2017-02-08 22:36:04.0" updateauthor="dshuffma" updated="2017-02-08 22:37:51.0"> <body><! CDATA I don't feel you read my post accurately.  I used the terms deliberately.  In the scenario above we added *1 org*. This kicked off the issue and to fix it we need another endorsement which comes from one of the other 4 org's *peers*.  but this is all besides the point! the real point of my post was talking about how it is problematic to assume the user will be always be able to find the chaincode to _install_ it again. we are relying on the most unreliable part of this entire thing, the end user.... this is introducing another failure point that did not exist before.  and again, what are we accomplishing here that we cannot already do by leverage channels. why is "taking the chaincode out of the channel" the priority? the proposal above points to performance issues and size....but can't we already do that with channels?? (meaning if you don't want to run someone's chaincode, don't join their channel)  ></body> </Action>
<Action id="20790" issue="14212" author="muralisr" type="comment" created="2017-02-09 01:46:53.0" updateauthor="muralisr" updated="2017-02-09 01:46:53.0"> <body><! CDATA  ~dshuffma  There will be channels where only certain peers would need the chaincode (say endorsers for the proposals pertaining to those chaincodes) and other peers don't need the chaincode. Also we don't want invokes to be done on those peers that shouldn't be allowed to (and don't care anyway).  We do want all the peers to have the TXs on them, so they do need to be on the channel.  While {{Can't our answer to "I don't want to run/hold irrelevant chaincode" be to make your own channel?}} could be the answer to some of those scenarios, we don't want to box ourselves into a corner where that's the only option.   I won't dwell on reuse over multiple channels and at how at some point pushing bytes around would become a real issue (as  ~jyellick  points out).  Basically, to be able to say "in a channel only a subset of the peers may have the chaincode" is a powerful generalization that would server as a good building block for many scenarios. And the new "install" command is the simple way (and something orgs are typically used to) to accomplish this.  Now you do make a good point about managing the chaincodes. The current model just has the chaincode on the ledger and the managemnte is  simplified. In the new model the org does have to manage. However, I claim this is no different from managing software installs organizations routinely do.  It is true we are introducing a change and we have to strive to not make this harder for the end user. One thing we were thinking was to use the same "proposal" path for installing chaincode on a peer. This would allow the same path (say using SDK) to install chaincode as opposed to having to do it directly on the peer.  (BTW, as an aside, I think the example scenario as stated is misleading... there is at least one more issue with beyond what  ~binhn  stated. If only 3 endorser have the chaincode and you are going to send TXs only to them, you won't say "50% endorsement is needed". You'd say 3 endorsements are needed.  And when a new peer is added if you are still sending TXs to only the 3, it'll still work. However if you want to send to the other one too then, yes, you have to install the chaincode on the new peer and change the policy to 4. The "50% endorsement is needed" would be used when an arbitrary have the chaincode and you will target an arbitrary number of peers for endorsement).  ></body> </Action>
<Action id="20802" issue="14212" author="dshuffma" type="comment" created="2017-02-09 14:17:48.0" updateauthor="dshuffma" updated="2017-02-09 14:17:48.0"> <body><! CDATA  ~muralisr  thanks for addressing my concern =).  I still disagree that the channel isolation method would be boxing ourselves in. Can someone describe an actual real world scenario where orgs wish to share a ledger, yet do not want to run/endorse chaincode tx for each other? Are we planning to not use channels to give us this isolation b/c we are trying to limit the number of channels?  While it _should_ be assumed an organization can manage their own software (chaincode), I hate the idea taking a step backwards from what we have. Today we can do this for the user, its a feature. We might be removing 1 truly handy feature, to make room for something that could have been accomplished alternatively.  As far as the 50% scenario I outlined, it was arbitrary and I used it to make my pain point more visible.  But this install cc pain point exist regardless of my scenario. We can expect orgs to stand up new peers in their life cycle.  ></body> </Action>
<Action id="20805" issue="14212" author="muralisr" type="comment" created="2017-02-09 16:00:11.0" updateauthor="muralisr" updated="2017-02-09 16:00:11.0"> <body><! CDATA  ~dshuffma  {{thanks for addressing my concern =)}} - Absolutely. It is possible we might have become used to the easy answer "lets put chaincodes on the ledger on all peers" but is that right answer ? The questions you raise really is about that I think.  In the current model when a new peer gets added it syncs up and automatically gets the code. Plus and minus with that approach. Plus - it automatically gets the code(less things to manage), minus - it automatically gets the code(everyone has the code, upgrade issues, performance/scalability etc).  {{Can someone describe an actual real world scenario where  orgs wish to share a ledger, yet do not want to run/endorse chaincode tx for each other ?}} In any complex channel,  different peers will be endorsers for different transactions using different chaincodes. However they are all glued together for solving one problem.   Not sure if this too contrived (I hope it is not) but let's take for example a "car consortium" channel with Vehicle Registration, Dealership companies, Insurance companies etc. The common thing is the CarAsset/Owner and everyone will have a CarAssetChaincode. But there will be chaincodes (CarDealerChaincode, InsuranceChaincode etc) which will only be on relevant peers. Everyone will be aware of the TXs but only some can generate them.  {{As far as the 50% scenario I outlined, it was arbitrary and I used it to make my pain point more visible. But this install cc pain point exist regardless of my scenario. We can expect orgs to stand up new peers in their life cycle.}} Right, I understood your main point on the scenario and the 50% was a bit besides the point (but felt that "besides the point" was actually pretty pertinent :-) ).    ></body> </Action>
<Action id="20809" issue="14212" author="dshuffma" type="comment" created="2017-02-09 18:22:04.0" updateauthor="dshuffma" updated="2017-02-09 18:22:04.0"> <body><! CDATA  ~muralisr  thanks a lot for the explanation. I see the point now... SO the other org's need to *see* the transactions, so they want to be on the ledger, but they don't want chaincode interactions (endorsements/query proposals). that's the jump that was missing for me. I didn't think it was important to see tx for cc I don't have.  I'm afraid I'd still question how useful it is... you'd only be able to inspect block's payload instead of inspecting a chaincode's state.. but nonetheless I get it. who knows maybe that's more useful than I think.   ></body> </Action>
<Action id="20812" issue="14212" author="muralisr" type="comment" created="2017-02-09 18:50:40.0" updateauthor="muralisr" updated="2017-02-09 18:51:44.0"> <body><! CDATA  ~dshuffma  thank you too for asking! To be honest  if it turns out for most scenarios it is NOT  {{important to see tx for cc I don't have chincodes for,}} then we are left with current model will suffice for most use cases.  I don't know how COMMON this would be ... I only state the generalization would allow for such scenarios. And that may be enough from a fabric PoV.  {{I'm afraid I'd still question how useful it is... you'd only be able to inspect block's payload instead of inspecting a chaincode's state.. but nonetheless I get it.}}  One important use would be audit-ability and resultant accountability.  ></body> </Action>
<Action id="21036" issue="14212" author="mrshah-ibm" type="comment" created="2017-02-19 10:09:17.0" updateauthor="mrshah-ibm" updated="2017-02-19 10:09:17.0"> <body><! CDATA Maybe I am too late to comment on this, here are my short comments:  Regarding  ~dshuffma 's concern, I agree that if a few parties don't want some other parties on a channel to see their chaincode, they can start their own new channel.  On the other hand regarding  ~muralisr 's concern, I can be a party on a channel where a few useless chaincodes have been deployed and I don't want to waste resources running those chaincodes.  My concern: If deployment of chaincode (or a version of chaincode) lies outside of the ledger, will it still be an audit-able transaction?  Suggestion: Can we have a whitelist (and/or blacklist) of chaincodes that can run on my peer with the current deployment model?  ></body> </Action>
