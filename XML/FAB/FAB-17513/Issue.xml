<Issue id="44373" key="FAB-17513" number="17513" project="10002" reporter="suryalnvs" assignee="wlahti" creator="suryalnvs" type="10004" summary="Unable to get peerAddress and/or tlsRootCertFiles when running peer lifecycle chaincode install-related commands with connection profile " priority="3" resolution="10000" status="6" created="2020-02-18 20:01:38.0" updated="2020-07-08 18:10:53.0" resolutiondate="2020-07-08 18:10:53.0" votes="0" watches="4" workflowId="58281" archived="N"> <description><! CDATA We ran the following commands which we will call commands  A  and  B :  * A :* {code:java} peer lifecycle chaincode install samplecc.tar.gz --connectionProfile ./connection-profile/connection_profile_org1.yaml --tls{code} * B :* {code:java} peer lifecycle chaincode approveformyorg --channelID testorgschannel0 --name samplecc --version v1 --package-id sampleccv1:ecffead355f07b5c0ec7ab090a6bc1b6a86f3a6e99e04e2c3b74e2995ff2fb04 --sequence 1 --waitForEvent --orderer 127.0.0.1:30000 --tls --cafile $PWD/crypto-config/ordererOrganizations/ordererorg1/orderers/orderer0-ordererorg1.ordererorg1/tls/ca.crt --ordererTLSHostnameOverride orderer0-ordererorg1 --connectionProfile ./connection-profile/connection_profile_org1.yaml{code} We will also refer to the  following code snippet as  C , which has two lines marked as  1  and  2  which we will refer to: {code:java} if input.ConnectionProfilePath != "" { networkConfig, err := common.GetConfig(input.ConnectionProfilePath) if err != nil { return err }  1    if len(networkConfig.Channels input.ChannelID .Peers) != 0 { input.PeerAddresses =   string{} input.TLSRootCertFiles =   string{} for peer, peerChannelConfig := range networkConfig.Channels input.ChannelID .Peers { if peerChannelConfig.EndorsingPeer { peerConfig, ok := networkConfig.Peers peer  if !ok { return errors.Errorf("peer '%s' is defined in the channel config but doesn't have associated peer config", peer) } input.PeerAddresses = append(input.PeerAddresses, peerConfig.URL)  2             input.TLSRootCertFiles = append(input.TLSRootCertFiles, peerConfig.TLSCACerts.Path) } } } } {code} When running the `lifecycle chaincode` commands with the --connectionProfile flag, the expectation is the peer CLI will parse the connection profile for the Peer endpoints and TLS information so it need not be provided on the CLI.  When running command ` A ` the peer is unable to parse the endpoint and TLS information as it is gated by line ` 1 ` in the code snippet, in particular, `networkConfig.Channels input.ChannelID .Peers)`. This logic first checks that the Peers object is not empty and indexes base on `input.ChannelID`. The input object is made up of the flags passed on the command line, this command assumes the `channelID` flag was set, even though `install` commands don't take a `channelID` flag. We need to modify the logic not to check the `channelID` exists for commands which do not take the `channelID` flag.  For the command  B , the `peer.tlsCACerts` object can take either the PEM encoded certificate or the path to the certificate file. We can see on line ` 2 ` in the code snippet the there is no logic to handle the `peerConfig.TLSCACerts.Pem` field, the assumption is we are always passing around the file path in the connection profile, instead of the PEM. We have no tests and no example configs which test the PEM path and thus it went under the radar in 2.0 lifecycle. We should add logic to allow the passing of the explicit PEM object. For fabric-test this reduces the overhead of us having to pass the file around everywhere we run commands.  ></description> </Issue>
