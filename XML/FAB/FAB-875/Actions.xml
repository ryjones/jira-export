<Action id="19510" issue="13206" author="cca88" type="comment" created="2016-10-26 14:14:34.0" updateauthor="cca88" updated="2016-10-26 14:14:34.0"> <body><! CDATA Question: What if two invokes for the same chain code are done by different clients relatively close together?  It could be that two endorsers have different states because one has had a deliver from consensus and the other one hasn't.  Answer: Note that the consensus on the order of transactions is necessary to resolve exactly this case of contention. However, if chaincode is programmed in a way where every transaction creates interference with another, this effect may become too frequent and render the system unusable. Therefore one must assume a low level of such  contention or design the application accordingly. For example, instead of each transaction changing a counter that holds a balance, an initial balance state is created once and later transactions merely append records that subtract from the balance (in both cases invariants such as balance >= 0 can be checked and maintained).  Furthermore the there is the mechanism of "anchoring" an endorsement that other endorsers are supposed to follow in the document, whereby a submitter can ask for endorsement of a tx at a given point in time ("anchor"). This does not resolve the concurrency issue if the anchor-producing endorser is behind but helps with the case when the anchor-producing endorser is ahead of others.    ></body> </Action>
<Action id="19895" issue="13206" author="joshhus" type="comment" created="2016-11-29 20:40:40.0" updateauthor="joshhus" updated="2016-11-29 20:40:40.0"> <body><! CDATA I'm in ID, so my comments will lean towards how the design document discusses and presents the Fabric v1.0. In so doing, technical observations are included. Questions pose areas where the document could perhaps be clarified or expanded on - for the authors to judge/decide.   Review of https://github.com/hyperledger/fabric/blob/master/proposals/r1/Next-Consensus-Architecture-Proposal.md  (Suggest adding a title to the document)  1. Paragraph 1: Consensus nodes, or "consenters" are described as distinct from "peers". Section 5.2.2 (GCVP) allows a consenting node to also be a peer. Are these two descriptions in conflict, or can a single node serve both roles? ... If consenters use P2P to communicate with peers, would this make them "peers" also. (Perhaps there are processing peers, endorsement peers and consensus peers. Though consenters don't maintain state or ledger.) 2. Paragraph 2: Scalability - Can we promise more than just v1.0 "may" scale better than v0.6? 3. Paragraph 2: Confidentiality - v0.6 offered "unlinkability" between a user ID and transactions involving that user ID; is that still offered in v1.0?  Sec. 1. System Architecture: 4.  Sec. 1. "The blockchain" (as a noun), though not uncommon, sounds like a single, massive network. Multiple smaller blockchain (as an adj.) networks could be suggested as: "A blockchain network is a distributed (and decentralized) system ..."  5. Sec. 1.1. Transactions: The "document does not yet describe support for ... a) cross-chaincode transactions or b) query transactions." ... Are these functions not supported in v1.0, or just not documented here yet?  6. Sec. 1.2. State: The blockchain state is derived from the raw ledger. The chaincode state is the sum of all transactions run against specific chaincode; where does the chaincode state reside, or is it just part of / derived from the raw ledger? 7. Sec. 1.3.3. Consenters: (TODO noted: add API for fetching specific batches from raw ledger).  Sec. 2 Transaction flow: 8. Sec. 2.4 - Consensus service delivers transactions to peers: When is the consensus algorithm run, such as PBFT, as separate from the endorsement policy checks? ... Sec. 2.3 invokes the consensus fabric - does Sec. 2.4 only occur if a "pass" of consensus algorithm occurred in Sec. 2.3? (i.e. might benefit from more clarity on diffs. between endorsement and consensus.) 9. Sec. 2.4, cont.: Final bullet says any invalid transactions are dropped and not recorded; is this in conflict with all transactions, including invalid transactions, being recorded on the raw ledger? i.e. is this the validated ledger at this point, which is derived from the raw ledger and does not include invalid transactions.  10. Sec. 3.2 Transaction evaluation ... Final paragraph on deterministic: Endorsement is evaluated either by every peer or by every consenting node? ... When would consenting nodes and non-endorsing peers be doing endorsement evaluation. i.e. it seems this is a case where endorsement is already granted by endorsing peers, then consenters and peers would check/verify that endorsement has been achieved. ?  11. Sec. 4 Blockchain data structures: What are the differences between blockchain state and the validated ledger? State is a KVS whereas the ledger is a hashchain? (They both contain only valid transactions, derived from raw ledger.) 12. Sec. 4.1 Consensus output forms the raw ledger; how do invalid transactions "pass" the consensus protocol? Clarify the diff. there; that an invalid transaction could still pass consensus. ?  Sec. 5 State transfer: 13. 5.1 Raw ledger state transfer: (check reference at the end here to Sec. 2.5, which doesn't exist - seems 2.4 is intended.) 14. 5.2 Checkpointing: Pruning the raw ledger of invalid transactions; does pruning have to be done by either all peers or none of them? i.e. if only some do it, problems ahead with syncing raw ledgers?  15. 5.2, cont.: Is the pruning trade-off, in favor of storage space and performance, at the cost of auditing / regulating the network history, worth it? Or is that judgment simply for the network "owners" to decide on. 16. 5.2.2. Valid checkpoints: Here is where (final bullet) the combined peer/consenter is introduced - notable, in that their separation has been notable, to this point.  Hope some of this is helpful ... jh  END --------          ></body> </Action>
<Action id="20159" issue="13206" author="vukolic" type="comment" created="2016-12-19 12:50:02.0" updateauthor="vukolic" updated="2016-12-19 12:50:02.0"> <body><! CDATA Hi Josh - with apologies for delay  1. Consenter (to be renamed to "orderer") can be deployed on the same machine as a peer. The code bases remain separate.  2. I would hate promising hard numbers because this will heavily depend on the underlying network. We will add performance numbers once available. 3. Yes - so long as TCerts are used for signing proposals/transactions.  4. HL Fabric glossary coming soon to complement this document - please see https://jira.hyperledger.org/browse/FAB-1209 (and https://gerrit.hyperledger.org/r/#/c/3227/) 5. cross-chaincode will not be supported in v1 and is post v1. Queries are supported in v1 6. blockchain state is the history of the Raw Ledger. A short representation of the latest version of the state is via a key value store mentioned in the spec.   8. Not sure I understand but let me try - consensus (PBFT) is run post-endorsement phase but before endorsement policy validation. So endorsement pattern --> consensus (ordering) --> endorsement policy validation 9. it should read "..not recorded  on the validated ledger ". Raw ledger still contains invalid tx 10. consensus nodes should not be mentioned there - will fix  11. "state" would be the latest version of the blockchain state, validated ledger is a history of it.  12. I thought this is clear - but will suggest more details 13. ack 14. Pruning can be done by some peers. Notice that pruning is post-v1 feature and the problems you mention should be addressed then (no obvious fundamental problems though - that would prevent an implementation) 15. there is a tradeoff indeed. A deployment admins may decide to never allow pruning. 16. Yes, I will add more details saying that this is a deployment option - to collocate consenters and peers - but certainly not a requirement..   ></body> </Action>
<Action id="20163" issue="13206" author="joshhus" type="comment" body="Much thanks. This helps with the glossary and the 5 page v1.0 Overview that I am drafting. TBA." created="2016-12-19 20:34:11.0" updateauthor="joshhus" updated="2016-12-19 20:34:11.0"/>
<Action id="20167" issue="13206" author="ianj_mitchell@uk.ibm.com" type="comment" created="2016-12-20 16:13:15.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2016-12-21 09:15:38.0"> <body><! CDATA It's still unclear to me what's being said about determinism of chain code...   Section 2 says...  _Remark: Notice that the following protocol does not assume that all transactions are deterministic, i.e., it allows for non-deterministic transactions._  and in 2.2...  _However, endorsing logic may interpret arbitrary functionality, to, e.g., interact with legacy systems with tran-proposal and tx as inputs to reach the decision whether to endorse a transaction or not._  But the 2.2 piece about endorsing logic not the deployed application chain code... I'm still not clear how such logic is deployed.  Neglecting the distinction between chain code and endorsing logic for a moment, the way I read these two statements is that there is an intent to allow what is executed in each endorsing peer to reference state outside of ledger (world) state, and thus may be different in each endorsing peer and is 'relevant' only at the time of reference (ie whatever a peer sees is valid when it sees it and it may never see the same thing again). Thus endorsers can come to different conclusions. Is the distinction between chain code doing it and endorsing logic doing it of any real consequence? What am I missing?  I further take it that the mention of determinism in the last para of 3.2 has nothing to do with the determinism of endorsing logic - rather it is the determinism of the evaluation by the submitting client of the endorsement policy predicate (which is a different animal to the endorsement logic in the endorsing peers). This is (relatively simply) to ensure that the handling of endorsements received back from endorsers is consistently evaluated regardless of where it is done.  Since I'm working on System of Record integration, I need to get this clear in my head. And then there's the whole notion of how the suggested 'interaction with legacy systems' actually happens... eg can all the endorses see (an instance of) the service, the security credentials required to make the call, etc etc  ></body> </Action>
<Action id="20435" issue="13206" author="ianj_mitchell@uk.ibm.com" type="comment" created="2017-01-19 16:00:26.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-01-19 16:00:26.0"> <body><! CDATA my 'trouble' is that I don't see any remaining reason why endorsers can't run application chain code (or even the endorsing logic system chain code) which makes a peer-specific external reference to a service and make the outcome of that service invocation part of its reply to the endorsement request.  This seems to be specifically permitted by the sentence "However, endorsing logic may interpret arbitrary functionality, to, e.g., interact with legacy systems with tran-proposal and tx as inputs to reach the decision whether to endorse a transaction or not." - here I could loosely interpret 'endorsing logic' as either application chain code or the endorsing logic system chain code. As per the first comment here (Christian is quoting an email from me which contained the question), the endorsement phase has no assurance that even the KV store is consistent between different peers, so when evaluating the endorsement results you have to expect different results due to timing of delivery. Different results due to making external references seems effectively no different.  ></body> </Action>
<Action id="20442" issue="13206" author="vukolic" type="comment" created="2017-01-19 18:01:24.0" updateauthor="vukolic" updated="2017-01-19 18:01:24.0"> <body><! CDATA  ~ianj_mitchell@uk.ibm.com  indeed there is no reason "why endorsers can't run... a peer-specific external reference "  Is it said/written anywhere that this is forbidden?  ></body> </Action>
<Action id="20443" issue="13206" author="ianj_mitchell@uk.ibm.com" type="comment" body="I was just after confirmation... since this was a pretty hot topic previously. I&apos;m very glad to be reading this correctly!" created="2017-01-19 19:19:19.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-01-19 19:19:19.0"/>
<Action id="20547" issue="13206" author="ianj_mitchell@uk.ibm.com" type="comment" body="luvin&apos; https://letstalkpayments.com/are-capabilities-of-smart-contracts-overblown/ - I think 1.0 improves his life." created="2017-01-24 13:24:31.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-01-24 13:25:11.0"/>
<Action id="61725" issue="13206" author="mastersingh24" type="comment" body="already implemented the architecture" created="2019-07-12 11:46:50.0" updateauthor="mastersingh24" updated="2019-07-12 11:46:50.0"/>
