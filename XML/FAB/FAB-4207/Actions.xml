<Action id="27377" issue="17233" author="yacovm" type="comment" body="So that&apos;s basically a system chaincode that does filtering on proposals and proposals that pass it - continue to the chaincode simulation, right? " created="2017-06-26 19:00:59.0" updateauthor="yacovm" updated="2017-06-26 19:00:59.0"/>
<Action id="27754" issue="17233" author="mastersingh24" type="comment" created="2017-07-02 17:11:57.0" updateauthor="mastersingh24" updated="2017-07-02 17:11:57.0"> <body><! CDATA Looks like https://github.com/hyperledger/fabric/blob/master/core/endorser/endorser.go#L368  is the entry point to validating a proposal request and that https://github.com/hyperledger/fabric/blob/master/core/common/validation/msgvalidation.go#L70 is the validation function.  If we are solely concerned with signature validation, then https://github.com/hyperledger/fabric/blob/master/core/common/validation/msgvalidation.go#L96 is where to look  ></body> </Action>
<Action id="27894" issue="17233" author="binhn" type="comment" created="2017-07-05 17:47:50.0" updateauthor="binhn" updated="2017-07-05 17:47:50.0"> <body><! CDATA The current architecture for replacing the peer behavior is via system chaincode, so my thought is to replace Endorser.ProcessProposal function with TransactionSystemChaincode (TSCC) that would refactor the ProcessProposal function into multiple subfunctions:  # preprocess the transaction proposal # validate the transaction proposal (check required fields, valid values, etc) # verify signature # check access control # check transaction duplication # exec (simulate) the transaction proposal # endorse the transaction proposal  This would allow to replace or modify any of the steps or the entire TSCC.  The advantage is that when we can use Go plugin, the SCC would fit nicely with that model.   ~troyronda  thoughts?  ></body> </Action>
<Action id="28036" issue="17233" author="troyronda" type="comment" created="2017-07-07 21:58:46.0" updateauthor="troyronda" updated="2017-07-07 21:59:03.0"> <body><! CDATA  ~binhn  - Thanks ... looks good.  (with the clarification that each subfunction can pass along context /objects, and a context /objects can be passed into the chaincode).     ></body> </Action>
<Action id="28645" issue="17233" author="mastersingh24" type="comment" body="This should be based on the updated SCC / plugin work being defined in FAB-5378" created="2017-07-19 09:53:34.0" updateauthor="mastersingh24" updated="2017-07-19 09:53:34.0"/>
<Action id="29132" issue="17233" author="yacovm" type="comment" body="https://docs.google.com/document/d/1dzP7wi_YPS39WASGFc1eXp6ANHShS1EMQ0J_AJ47YMc/edit" created="2017-07-28 09:24:51.0" updateauthor="yacovm" updated="2017-07-28 09:24:51.0"/>
<Action id="29477" issue="17233" author="yacovm" type="comment" created="2017-08-06 15:31:17.0" updateauthor="yacovm" updated="2017-08-06 15:33:15.0"> <body><! CDATA This issue has 5 maintainer votes.  The change sets are in gerrit and can be reviewed starting from https://gerrit.hyperledger.org/r/#/c/12187/ and ending at https://gerrit.hyperledger.org/r/#/c/12203/  https://gerrit.hyperledger.org/r/#/c/12205/ is a sample change set that would be abandoned at the end of this week.    ></body> </Action>
<Action id="29582" issue="17233" author="yacovm" type="comment" body="I made a new design document https://docs.google.com/document/d/1vaWnE4TypKmA9j-2W-gA6YmmPMkco2uFgRx-rtf9PI8/edit?usp=sharing" created="2017-08-09 07:28:36.0" updateauthor="yacovm" updated="2017-08-09 14:39:06.0"/>
<Action id="29626" issue="17233" author="aleksandar.likic" type="comment" created="2017-08-09 18:38:45.0" updateauthor="aleksandar.likic" updated="2017-08-09 18:50:23.0"> <body><! CDATA Would it be possible to add support for plugging in external SCCs (FAB-5688) into authentication chain? An external SCC is, from Fabric point of view, just another SCC, except it's executed outside of the peer process. As a system integrator, I would like to be able to plug in custom logic into authentication flow without modifying the peer code. We could have something like: {code:java} func (r *HandlerLibrary) SCCAuth(sccname string) auth.Filter { // implementation that invokes the sccname SCC } {code} and {code:java} func (r *HandlerLibrary) SCCDecorator(sccname string) decoration.Decorator { // implementation that invokes the sccname SCC }{code} added to core/handlers/library, with the ability to inject sccname via peer configuration or docker-compose, and, of course, to chain multiple instances of SCCAuth/SCCDecorators in the authentication flow.  This is assuming FAB-5688 is accepted into v1.1.  ></body> </Action>
<Action id="30651" issue="17233" author="aleksandar.likic" type="comment" body=" ~mastersingh24   ~yacovm  If we wanted to implement a filter as a go plugin, that would require libtool&apos;s presence in the peer container (to enable dynamic linking). This is currently not the case. Is there a plan to add libtool to the peer container for 1.1 or 1.2? This would also require dynamic compilation of the peer." created="2017-09-07 20:09:17.0" updateauthor="aleksandar.likic" updated="2017-09-07 20:29:07.0"/>
<Action id="30656" issue="17233" author="yacovm" type="comment" body="I thought we can&apos;t even have 1.9 in the container until we merge https://gerrit.hyperledger.org/r/#/c/13219/ and its child and push the new images ?" created="2017-09-07 21:09:42.0" updateauthor="yacovm" updated="2017-09-07 21:11:54.0"/>
<Action id="30659" issue="17233" author="divyank" type="comment" created="2017-09-07 22:50:43.0" updateauthor="divyank" updated="2017-09-07 22:50:43.0"> <body><! CDATA Hi  ~yacovm , I experimented with pluggable filters (by upgrading base image to 1.9 locally) and found that go plugins are not compatible with statically linked golang executables.  Also mentioned here:  https://github.com/golang/go/issues/19569#issuecomment-291955357   (and surrounding discussion)  Removing the -static flag from the makefile and supplying libtool to the peer at runtime allowed me to load endorser filters as .so plugins dynamically.  ></body> </Action>
<Action id="30730" issue="17233" author="divyank" type="comment" created="2017-09-11 15:51:25.0" updateauthor="divyank" updated="2017-09-11 15:51:35.0"> <body><! CDATA Update: I reported the statically linked binary issue with loading plugins and the Go maintainers acknowledged this behaviour (bug report  here|https://github.com/golang/go/issues/21822 ).  The only way to enable plugins is to not build statically.  I'm working on a change set that does so.     ></body> </Action>
