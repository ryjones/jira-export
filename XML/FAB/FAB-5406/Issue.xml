<Issue id="19392" key="FAB-5406" number="5406" project="10002" reporter="yacovm" assignee="yacovm" creator="yacovm" type="10004" summary="Peer&lt;--&gt;Chaincode Mutual TLS" priority="3" resolution="10000" status="6" created="2017-07-20 19:49:10.0" updated="2018-07-20 14:13:49.0" resolutiondate="2017-08-22 10:50:05.0" votes="0" watches="3" workflowId="39505"> <description><! CDATA In order to harden and secure the communication and authentication (specifically - association between the chaincode name to the gRPC stream) between the peer and the chaincode shim - we should use mutual TLS.  I propose the following flow: * The peer chaincode gRPC service would always run on a different port * At peer startup - it will generate a CA cert, and put it into the chaincode gRPC service's TLS CA cert pool * When a chaincode container is launched, the peer would generate a new TLS certificate and private key pair and would sign it with the CA cert's corresponding private key. * The peer would associate the chaincode instance's name with the certificate hash, and start a timer after which the association is deleted from memory. * The peer's chaincode gRPC service would use the configuration -  RequireAndVerifyClientCert|https://golang.org/src/crypto/tls/common.go?s=5991:6014#L175  * The certificate would be passed to the container via either environment variables, or commandline arguments or via some other secure method (  ~ales  /  ~mastersingh24  *  - what is your take on this? which one is better?) * The chaincode shim would connect to the peer using the certificate (and corresponding private key) passed to it upon initialization * The peer would intercept the first message from the chaincode shim (REGISTER <chaincode_name>) and check that the certificate hash extracted from the gRPC stream exists in the in-memory mapping, and also matches the claimed chaincode name sent by the chaincode shim. If it isn't - the peer would not pass the message and block the stream / disconnect it.  ></description> </Issue>
