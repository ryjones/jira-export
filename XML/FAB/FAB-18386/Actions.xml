<Action id="71005" issue="46450" author="yacovm" type="comment" created="2020-12-24 18:10:16.0" updateauthor="yacovm" updated="2020-12-24 18:10:52.0"> <body><! CDATA The reason it happens is that the protobuf received from the node.js shim has a value which is a 0-byte slice but is not nil:  The below code: {code:java} 	raw, _ := base64.StdEncoding.DecodeString("CgNrZXkSABoA") 	ps := &pb.PutState{} 	proto.Unmarshal(raw, ps) 	fmt.Println(ps.Value == nil, ps.Value) 	fmt.Println(ps) {code} prints: {code:java} false    key:"key"  {code} This does not reproduce in Golang chaincode with neither *PutState* of *  byte("")*, or of *nil* or of *  byte{}*.  In golang, the protobuf library puts nil in the Value if it is of 0 length while in node.js it doesn't: {code:java} 	raw, _ := base64.StdEncoding.DecodeString("CgNrZXkSABoA") 	ps := &pb.PutState{} 	proto.Unmarshal(raw, ps) 	fmt.Println(ps.Value == nil, ps.Value) // prints false    	raw2, _ := proto.Marshal(ps) 	fmt.Println(base64.StdEncoding.EncodeToString(raw2)) // prints CgNrZXk= 	proto.Unmarshal(raw2, ps) 	fmt.Println(ps.Value == nil, ps.Value) // prints true    {code}     ></body> </Action>
<Action id="71006" issue="46450" author="yacovm" type="comment" created="2020-12-24 18:25:58.0" updateauthor="yacovm" updated="2020-12-24 18:25:58.0"> <body><! CDATA I would like to say that the below patch, fixes this problem, however I am not that familiar with the ledger code to be sure that there is no further code paths I missed so maybe  ~manish-sethi    or  ~denyeart  can take a look?  Furthermore, while I reproduced the bespoken scenario (with the chaincode provided by  ~CaJIbHuK ), and confirmed that the below patch indeed prevents the panic, fixing it is not enough, as this panic should have never been there in the first place. The reason is that currently, there exist a transaction which the validation code accepts, but the ledger code rejects, and this is wrong by definition.   I argue that we should audit the ledger code and see if we have similar cases where the ledger code assumes transactions have properties which are not validated in the validation code, and panics as a result.  {code} diff --git a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go index ae9cfc9d0..65d6f9899 100644 --- a/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go +++ b/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go @@ -343,7 +343,7 @@ func newProtoVersion(height *version.Height) *kvrwset.Version { }  func newKVWrite(key string, value   byte) *kvrwset.KVWrite { -       return &kvrwset.KVWrite{Key: key, IsDelete: value == nil, Value: value} +       return &kvrwset.KVWrite{Key: key, IsDelete: len(value) == 0, Value: value} }  func newPvtKVReadHash(key string, version *version.Height) *kvrwset.KVReadHash { diff --git a/core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go b/core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go index f1976b57c..73729373a 100644 --- a/core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go +++ b/core/ledger/kvledger/txmgmt/txmgr/lockbased_txmgr.go @@ -612,7 +612,7 @@ func extractStateUpdates(batch *privacyenabledstate.UpdateBatch, namespaces   st nsu.PublicUpdates = append(nsu.PublicUpdates, &kvrwset.KVWrite{ Key:      key, -                                       IsDelete: versionedValue.Value == nil, +                                       IsDelete: len(versionedValue.Value) == 0, Value:    versionedValue.Value, }, )  {code}  ></body> </Action>
<Action id="71007" issue="46450" author="yacovm" type="comment" created="2020-12-24 19:16:31.0" updateauthor="yacovm" updated="2020-12-24 19:16:31.0"> <body><! CDATA Bottom line, this needs to: # Be fixed in *master, LTS* branches # Be mentioned in release-notes.  ></body> </Action>
<Action id="71008" issue="46450" author="yacovm" type="comment" created="2020-12-25 10:16:44.0" updateauthor="yacovm" updated="2020-12-25 10:17:39.0"> <body><! CDATA On 2nd thought, the above code simply fixes the peer endorser path but not the commit path, so an altered peer can create a transaction with a nil value and no delete bit set which will cause a panic.  What we probably need is one of the two:  1. Make the commit path artificially turn zero length slices as deletes: {code:java} diff --git a/core/ledger/kvledger/txmgmt/validation/batch_preparer.go b/core/ledger/kvledger/txmgmt/validation/batch_preparer.go index ee27bcefe..5ebe285cc 100644 --- a/core/ledger/kvledger/txmgmt/validation/batch_preparer.go +++ b/core/ledger/kvledger/txmgmt/validation/batch_preparer.go @@ -8,6 +8,7 @@ package validation  import ( "bytes" +       util2 "github.com/hyperledger/fabric/common/util"  "github.com/hyperledger/fabric-protos-go/common" "github.com/hyperledger/fabric-protos-go/ledger/rwset" @@ -262,6 +263,7 @@ func preprocessProtoBlock(postOrderSimulatorProvider PostOrderSimulatorProvider, containsPostOrderWrites = true } if txRWSet != nil { +                       canonizeIsDelete(txRWSet) txStatInfo.NumCollections = txRWSet.NumCollections() if err := validateWriteset(txRWSet, validateKVFunc); err != nil { logger.Warningf("Channel  %s : Block  %d  Transaction index  %d  TxId  %s "+ @@ -281,6 +283,23 @@ func preprocessProtoBlock(postOrderSimulatorProvider PostOrderSimulatorProvider, return b, txsStatInfo, nil }  +var ( +       hashOfNothing = util2.ComputeSHA256(nil) +) + +func canonizeIsDelete(txRWSet *rwsetutil.TxRwSet) { +       for _, rws := range txRWSet.NsRwSets { +               for _, w := range rws.KvRwSet.Writes { +                       w.IsDelete = w.IsDelete || len(w.Value) == 0 +               } +               for _, hrws := range rws.CollHashedRwSets { +                       for _, w := range hrws.HashedRwSet.HashedWrites { +                               w.IsDelete = w.IsDelete || bytes.Equal(w.ValueHash, hashOfNothing) +                       } +               } +       } +} + func processNonEndorserTx( txEnv *common.Envelope, txid string,  {code}   2. Make the commit path invalidate transactions with empty slices that are not deletes  ></body> </Action>
<Action id="71014" issue="46450" author="mastersingh24" type="comment" created="2020-12-26 08:44:52.0" updateauthor="mastersingh24" updated="2020-12-26 08:47:25.0"> <body><! CDATA Thanks for the analysis  ~yacovm   Given the intended method for _deleting_ keys is to call _Delete_, I think we should mark transactions with nil values as invalid.  We already have too much code which does clever things for users.  We are *lucky* in this case as blocks are not being committed before the panic, so making this change should a simple fix and not require any capability?     ></body> </Action>
<Action id="71019" issue="46450" author="yacovm" type="comment" created="2020-12-26 10:51:58.0" updateauthor="yacovm" updated="2020-12-26 10:51:58.0"> <body><! CDATA {quote}Given the intended method for deleting keys is to call Delete, I think we should mark transactions with nil values as invalid. {quote} The thing is, that the peer code is  doing just that|https://github.com/hyperledger/fabric/blob/37b2bff4b8e449ef9f112d89555f845144cb1f4e/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go#L345 , when it tries to build the read-write set, so unless I'm overlooking something - if you *PutState("key", nil)* in the shim, it will turn into a delete operation. The panic deep down in the ledger code is due to the detection of the incorrect execution of the upper layer (that turns nil writes into deletes).    {quote}We already have too much code which does clever things for users.{quote} The problem is not that the code is doing clever things for users, but that you need clever people to understand it :)  Every time I dive into the validation code I gape at how overly complex it is. If we add another check to the validation code, we might want to make it in a place where the  RWSet is already parsed|https://github.com/hyperledger/fabric/blob/4afc136de48efd9d4ade415c937a71531484f859/core/common/validation/statebased/validator_keylevel.go#L86 , to not further slow down the peer validation.  {quote}We are lucky in this case as blocks are not being committed before the panic, so making this change should a simple fix and not require any capability?{quote}  The panic happens before the block is written to the disk, in the phase where it parses the block and assembles a state update batch so you're correct, any change in the validation code about transactions that are deletes with zero length writes will always be re-executed in all peers, because all peers before the change, always panic.  If the panic would have happened after the block was written to disk, but before the stateDB updates would've been applied, then anyone that has been hit by this problem would still remain in a crash loop, and anyone with an upgraded version would've been invalidated the transaction, so in that sense, consistency would have still be preserved (vacuously) despite the deviation in the validation of these kind of transactions.   ></body> </Action>
<Action id="71047" issue="46450" author="manish-sethi" type="comment" created="2021-01-05 22:32:36.0" updateauthor="manish-sethi" updated="2021-01-05 22:32:36.0"> <body><! CDATA I investigated on this to understand how we reached here and whether we have some constraints on what we can do to fix the problem. As far as I recall, in the very beginning, the intention was to disallow both a `nil` value and a `zero-length byte array`. However, there was a proposal to allow these special values under this  issue|https://github.com/hyperledger-archives/fabric/issues/936 . The consensus built on this issue was to allow `zero-lengh byte array` but not the `nil` value. The  initial code for for read-write set in v1.0.0-alpha|https://github.com/hyperledger/fabric/blob/fa3d88cde177750804c7175ae000e0923199735c/core/ledger/kvledger/txmgmt/rwset/rwset.go#L302  that had custom Marshaling/Unmarshaling, accounted for this. However, it appears that the  chaincode side of changes|https://github.com/hyperledger-archives/fabric/pull/2072  (including a test) were never merged.  In the meanwhile, we decided to replace the custom Marshaling/Unmarshaling code for using proto messages for RWSet. The protobuf in golang does not preserve the difference between a `zero-length byte array` and a `nil`. So, we are here. But good thing is that, as I looked in the code back, up to release-1.0, this problem exists since beginning. In other words, though there was a decision to treat `zero-lengh byte array` as a regular value, it was never fully implemented. Hence, any transaction of this type, processed with any previous version would have also caused a panic. So, we are free to pick any interpretation of `zero-length byte array`.  My preference would be to dump the original feature request and not to allow the special value of `zero-lengh byte array` as it seems that many solutions did not need this over the years. Moreover, the protobuf is not consistent in preserving the `zero-lengh byte array` in golang and hence, this would need us to extend the proto messge with a special flag. So, If we have agreement on this then we can go with the following.  - During simulation, as done in Yacov's patch, treating `zero-length byte array` same as `nil` is an obvious choice. If we had a fresh choice, perhaps returning an error during simulation for both `nil` and `zero-lengh byte array` would have been a better choice. But since, we already over-interpret for `nil` value which is not easy to reverse and for the sake of consistency, it's better to treat `zero-lengh byte array` the same way. - During validation, I tend to prefer to invalidate the transaction if a delete marker is absent and the value is either `nil` or `zero-lenght byte array`(thought, the latter is not possible, given the protobuf behavior in golang; still better to cover the check). Otherwise, there will be two different ways to delete at the commit time and one of them will never be prepared by the simulation code that could cause further confusion.  ></body> </Action>
<Action id="71048" issue="46450" author="yacovm" type="comment" created="2021-01-05 23:35:01.0" updateauthor="yacovm" updated="2021-01-05 23:37:15.0"> <body><! CDATA {quote}the value is either `nil` or `zero-lenght byte array`(thought, the latter is not possible, given the protobuf behavior in golang; still better to cover the check). {quote} I think it's quite possible. As I demonstrated above, the below variable *raw* holds bytes which, when un-marshaled, result in a *PutState* with a *Value* field that is a zero sized byte slice.  The fact that Golang marshaling "skips" zero sized slices, doesn't mean anything about a custom crafted protobuf by an adversary. It's even fairly simple to do - just take an endorsement from a real correct peer code (Golang), open it to extract the read-write-set bytes, and then use javascript protobuf library to marshal the same read-write-set with an empty payload. The resulting read-write set bytes would be different, and when Fabric peers would open it, it would be a zero length slice that is not nil. {code:java} 	raw, _ := base64.StdEncoding.DecodeString("CgNrZXkSABoA") 	ps := &pb.PutState{} 	proto.Unmarshal(raw, ps) 	fmt.Println(ps.Value == nil, ps.Value) // prints false    {code}    I agree with invalidating the transaction as I noted above: {code:java} 2. Make the commit path invalidate transactions with empty slices that are not deletes {code} The big question is where in the validation code do we do that? If we do it too far from the read-write-set processing it would incur a performance penalty so maybe we can do it  somewhere here|https://github.com/hyperledger/fabric/blob/master/core/common/validation/statebased/validator_keylevel.go#L86-L142 ? This code should be common to all versions starting from 1.3 right? (  ~ales  /  ~jyellick  probably know best)  ></body> </Action>
<Action id="71049" issue="46450" author="manish-sethi" type="comment" created="2021-01-06 05:03:38.0" updateauthor="manish-sethi" updated="2021-01-06 05:03:38.0"> <body><! CDATA {quote}The value is either `nil` or `zero-lenght byte array`(thought, the latter is not possible, given the protobuf behavior in golang; still better to cover the check). {quote} When I say this, I mean that its not possible for a rwset prepared by the fabric simulation code. Yes, still the check should be added in the validation for the reason that you mentioned above.  On the location for the fix. The approach I prefer is to add checks at one place and keeping the code close to the rwset related code, so as to make sure that the checks are consistent with what the simulation code produces. For instance, in  this package|https://github.com/hyperledger/fabric/tree/master/core/ledger/kvledger/txmgmt/rwsetutil , we can enhance  this function|https://github.com/hyperledger/fabric/blob/55d651ed0bbbeee468f7a5136ab8de7d33650e3c/core/ledger/kvledger/txmgmt/rwsetutil/rwset_proto_util.go#L166   Other place that we already have one similar check about the legitimacy of the key-values is  here|https://github.com/hyperledger/fabric/blob/55d651ed0bbbeee468f7a5136ab8de7d33650e3c/core/ledger/kvledger/txmgmt/validation/batch_preparer.go#L315 . However, the check for this bug more relates to the structure if rw-set and for this reason, I prefer the former place.  ></body> </Action>
<Action id="71085" issue="46450" author="manish-sethi" type="comment" created="2021-01-08 04:34:56.0" updateauthor="manish-sethi" updated="2021-01-08 04:34:56.0"> <body><! CDATA Upon investigating while working on the fix for this issue, I found that there is a further complexity in the context of private data. In the case of private data, in the current code, the hashed-write-set would contain the appropriate hash of the value as "hash(zero-length byte array)", while the actual write-set would contain a `nil` (due to lossy transformation caused by the marshal-unmarshal cycle of golang protos). Now, the peers that receives the hashed write-set only (either ineligible peers or the eligible peer that does not receive the actual private data during commit), will commit this transaction with no issues. However, the peers (the eligible peer) that receives the actual write-set would panic (just as in the case of public data above). We have following options here, none of these options are perfect but we have to make a call.  1) For both public and private data, treat the `nil` value as legitimate `zero-length byte array` during commit, if the explicit delete marker is absent.  This gives uniform meaning of this type of transaction across public and private data. However, the downside is that this gives different behaviour for chaincode in golang v/s chaincode in node, when the API SetState/SetPrivateData is invoked with `zero-length byte array`. In the golang chaincode, it would be equivalent to invoke DeleteState (like it is today), and in node chaincode it would be equivalent to set the value to `zero-length byte array` (as actually intended). We will document this behavior and discourage folks to use either `nil` or `zero-length byte array` as value.   2) As we decided for the transaction with public data, we invalidate the transaction that contains a hashed write-set, if the hashed write-set contains "hash(zero-length byte array)" and the delete flag is missing. However, the downside is that this change will be retrospective and we will have to issue a note to the community that if some network is using this special value they will need to reset the peers. Though, we don't expect many folks to be affected otherwise, they would have hit the panic while committing the actual private data, either with the transaction or later via reconciliation path for the missing data. But still, it's a retrospective change and warrants a note.  ></body> </Action>
<Action id="71087" issue="46450" author="yacovm" type="comment" body="Manish, I don&apos;t understand why in the first option you can&apos;t just convert both public and private writes with nil values *and* zero length values to delete operations? And isn&apos;t the hash of a nil the same as the hash of a zero length byte array? It should be easily detectable for private data as well." created="2021-01-08 09:20:49.0" updateauthor="yacovm" updated="2021-01-08 09:20:49.0"/>
<Action id="71093" issue="46450" author="manish-sethi" type="comment" created="2021-01-08 14:10:06.0" updateauthor="manish-sethi" updated="2021-01-08 14:10:06.0"> <body><! CDATA Yacov, the problem with interpreting this as delete in the context of private data is somewhat similar to what is listed in (2) - i.e, there is a chance that a tuple <keyHash, valueHash, version> would have already updated in the statedb. In the "real" delete case, the existing tuple is actually deleted. This may again lead to state-forks. However, this option will be cause a relatively milder message than in the option (2), i.e., we can limit our message to rebuild the statedb instead of resetting the peer. Also, as noted before, this will be a special case in the commit path that would never be generated by the simulation code.  Having stated the above, as I mentioned before, none of these are perfect solutions and I am open to any of these that seems least bad, including the delete option, if the above caveats seem better than compared to the previously mentioned two options.  ></body> </Action>
<Action id="71094" issue="46450" author="yacovm" type="comment" body="I see, then why can&apos;t we do (1) with a slight change - when you build the write-set in the peer during simulation, you look if you have a WRITE that is nil, and then you *do not* make it a delete. Won&apos;t this align both node.js and golang shims to the same semantics?" created="2021-01-08 15:23:15.0" updateauthor="yacovm" updated="2021-01-08 15:23:15.0"/>
<Action id="71095" issue="46450" author="manish-sethi" type="comment" body="I considered this but then ruled out because, it redefines the meaning of this for existing golang chaincodes - i.e., suddenly applications start behaving differently. We can bring this similarity (or rather disallow these values altogether and return error) later in 3.0 when we are a bit more flexible in allowing the breaking API changes and tell folks to upgrade their chaincodes." created="2021-01-08 15:45:45.0" updateauthor="manish-sethi" updated="2021-01-08 15:45:45.0"/>
<Action id="71097" issue="46450" author="yacovm" type="comment" body="I personally support option (1) and when (more like if) there will be a Fabric 3.0 we can align golang chaincode semantics to node.js semantics by extending the protobuf to include some flag that makes the peer treat a nil payload with node.js semantics" created="2021-01-08 16:05:57.0" updateauthor="yacovm" updated="2021-01-08 16:05:57.0"/>
<Action id="71101" issue="46450" author="denyeart" type="comment" body="I also agree with #1 as the least bad solution, as it does not change validation status for private transactions and does not change semantics." created="2021-01-08 17:02:10.0" updateauthor="denyeart" updated="2021-01-08 17:02:10.0"/>
<Action id="71244" issue="46450" author="manish-sethi" type="comment" body="Just now, it crossed my mind that one more caveat we will need to keep in mind with our chosen solution (i.e., #1) - which is that even though node based chaincode will be able to write a value of &apos;zero-length byte array&apos; but I don&apos;t think that during GetState it will be able to get it back (because, the golang code will marshal the response, making the value as nil). So, for the chaincode, it is not possible to differentiate whether the key exists or not. Essentially, we will simply have to say that the behaviour for this value is undefined - Any second thought?" created="2021-01-12 18:21:30.0" updateauthor="manish-sethi" updated="2021-01-12 18:21:30.0"/>
<Action id="71276" issue="46450" author="manish-sethi" type="comment" created="2021-01-14 18:03:31.0" updateauthor="manish-sethi" updated="2021-01-14 18:03:31.0"> <body><! CDATA As noted in the above comment, the solution #1 requires significant changes in order to add the support for a zero-length byte array as a legitimate value. The changes may include introducing another API in shim (e.g., Exists(key)) in order for a chaincode to identify the difference between a key does not exist and a key exists with a 'zero-length byte array'. Still, we will have a difference in the semantics for this special value in the chaincodes written in golang v/s chaincodes written in node js and the node solutions cannot use that with upgrading their chaincodes.  Keeping the above in consideration, discussed with Yacov and Dave offline and finalized to go for a simpler approach - i.e., treat the write set for a key with a value 'nil' or 'zero-length byte array' as a delete for the key. This approach is simpler in implementation and brings the common behavior in chaincodes in golang v/s other languages.  However, as noted before, this approach brings a retrospective change for node chaincode users and we will need to mention in the release notes something of the following effects.   This change impacts you, if your solution  1) uses a node chaincode, and 2) the chaincode uses  PutPrivateData API with value as an empty string, and 3) the chaincode uses GetPrivateDataHash API for making a decision in the context of a transaction  If your solution satisfies all 1, 2, and 3, you will need to reset/rebuild the peer. If your solution satisfies 1 and 2 only, you can just rebuild the statedb. Otherwise, you can ignore this message.  On a side note, confirmed further that this issue appears mainly because the node shim uses  protobufjs|https://www.npmjs.com/package/protobufjs  library. The  google-protobuf|https://www.npmjs.com/package/google-protobuf  npm library produces the same bytes similar to golang protobuf implementation.  ></body> </Action>
<Action id="71310" issue="46450" author="manish-sethi" type="comment" created="2021-01-26 20:12:57.0" updateauthor="manish-sethi" updated="2021-01-26 20:12:57.0"> <body><! CDATA https://github.com/hyperledger/fabric/pull/2305 - PR for 'master' https://github.com/hyperledger/fabric/pull/2309 - PR for 'release-2.3' https://github.com/hyperledger/fabric/pull/2310 - PR for 'release-2.2' https://github.com/hyperledger/fabric/pull/2312 - PR for 'release-1.4'  ></body> </Action>
