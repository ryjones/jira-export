<Action id="20093" issue="13803" author="c0rwin" type="comment" created="2016-12-14 16:25:43.0" updateauthor="c0rwin" updated="2016-12-14 16:25:43.0"> <body><! CDATA {quote} For non-channel related messages, the validation strategy can demand validation against any chain the gossip node belongs to. {quote}  Can you please elaborate on how it will work exactly? Also having the fact you are going to support this, what is the additional benefit of extending {{MessageCryptoService}} to include chain info?  ></body> </Action>
<Action id="20100" issue="13803" author="binhn" type="comment" created="2016-12-14 22:12:50.0" updateauthor="binhn" updated="2016-12-14 23:06:55.0"> <body><! CDATA First of all, we are in TLS, so why would gossip trying to verify anything?  It is a transport layer, and as such, the layer above it should do verification as appropriate; ie Endorser, Committer when each receives transactions or blocks, and which must belong to some chain.  That's said. Here is currently what happens:  MSPs, at least on the peer side, are configured/created per chain. There are no MSPs outside of chains, except a single local MSP, which has the peer's crypto material. A peer instantiates and manages chains; each chain has an MSPManager, a ledger, a committer, then tell gossip to join the chain and passing it the committer. See code in core/peer.go.  We should get rid of MessageCryptoService.    ></body> </Action>
<Action id="20101" issue="13803" author="binhn" type="comment" created="2016-12-14 23:12:30.0" updateauthor="binhn" updated="2016-12-14 23:12:30.0"> <body><! CDATA The most important things that I expect out of gossip are: 1) fast 2) scalable  Anything else will be built at layer above.  ></body> </Action>
<Action id="20104" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 07:31:29.0" updateauthor="angelo.decaro" updated="2016-12-15 07:31:29.0"> <body><! CDATA  ~binhn  The fact the TLS is place does not say that the information flying there are valid by any means. A malicious node might send a block that is invalid. The honest recipient then has to check that it accepts only valid things.   ~C0rWin  If an honest node receives a chain-related gossip message that validates against chain A but the gossip message says it should go to chain B, then a conservative approach would recommend the honest node to validate that gossip message against chain B and not chain A. At this point, I would say that  MessageCryptoService should get in input a GossipMessage and validate it following two different strategies depending on the chain/channel field (if it is empty or not). For non-chain-related gossip messages, we need to iterate over all the channels a node belongs to check for signature validity.   ~binhn  My understanding is that MessageCryptoService is a nice abstraction that the gossip component uses to abstract away the security checks. I think this separation is useful. At the end MessageCryptoService will be implemented using MSP anyway.  ></body> </Action>
<Action id="20105" issue="13803" author="c0rwin" type="comment" created="2016-12-15 09:15:50.0" updateauthor="c0rwin" updated="2016-12-15 09:15:50.0"> <body><! CDATA  ~binhn  Well, TLS certificate is not the same certificate peers expected to sign the messages. And from the perspective of being resilient to byzantine environment, the gossip has to verify messages signatures to authenticate peer identity. Therefore I'd add to your list the third property *secure and byzantine tolerant*.   ~angelo.decaro  Gossip takes care of routing, so peer which is not subscribed to channel won't be able to create messages on that channel unless it succeeded to guess/obtain the chain id. All gossip needs is to validate peer identity. From what you are saying is looks like peer might have different certificates for different channels, is that correct?  ></body> </Action>
<Action id="20106" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 10:19:02.0" updateauthor="angelo.decaro" updated="2016-12-15 10:19:27.0"> <body><! CDATA  ~yacovm  ~C0rWin  ~ellaki  ~muralisr  ~binhn  ~mastersingh24  ~jeffgarratt  ~jyellick  ~tuand   After a discussion with Elli, Yacov and Artem, Elli and me came up with the following picture:   !IMG_1004.JPG|thumbnail!   in which we try to describe which checks a goosip node should perform to validate a signature of a channel-related gossip message. There are two nodes, A and B, that belong to the same organization but different channel. A sends a channel-related gossip message to B and B needs to validate it. On the right hand side there a flow diagram that describes how B can take this decision.  What do you think?    ></body> </Action>
<Action id="20107" issue="13803" author="yacovm" type="comment" created="2016-12-15 10:29:31.0" updateauthor="yacovm" updated="2016-12-15 10:44:08.0"> <body><! CDATA We have a much bigger problem here, would really like  ~mastersingh24  and  ~binhn  to comment: So, in gossip we have 3 types of messages that are passed around and that are related to a channel: # Messages regarding pull synchronization: These are not important right now, because they are only passed point-to-point and are not relayed further. They're also not signed because the peer's identity comes from the "session" (since it's point-to-point) # Block messages: these are validated by the MessageCryptoService but not by the verify call Angelo refers to, but by a different call. # StateInfo messages: these messages are relayed to *all peers in the organizations that are part of the channel*. They are signed by the peers, and they simply say "hey, I'm a peer in channel A, this is my ledger-height".  # State transfer messages - for peers that were down for a long time or are new: this is not a problem since they are also point-to-point. We check if a peer is in the right org if it wants to do state-synchronization.   Now, since we agreed with  ~binhn  and  ~mastersingh24  that for each organization, there will be 1 peer (the leader) that would connect to the ordering service and would ask blocks for all channels of that org *on behalf of the channel peers of that org*, if that leader peer is in channels A, B and it obtains a StateInfo message of channel C, if it will call the verify with the parameter of the channel, it won't be able to verify that message at all since it doesn't have the the channel's MSP! This creates a problem and basically breaks down our whole block dissemination apart. Now, it would be *very easy* to fix it if we just could not pass the channel as a parameter and then the signature of that peer would be verified by the local MSP, since both peers are *in the same organization*.  I just want to stress out, that the routing logic in gossip is enforcing channel-related access control, but when we verify a message sent from a peer we *do not care about the channel* but we only care about the peer's organization, and the certificate of the peer (if it's valid, or not).  So,  ~angelo.decaro  - regarding your diagram, what should happen is that that leader peer (it's B) would take the message, and since it is not in the channel, it'll pass it to the local MSP.  This only leaves a specific problem: StateInfo messages are gossiped across organizations, among all peers of the channel.  We *have to do that* because that's how we know from which peers we can replicate information from. So, if we have for example 3 organizations, each of 100 peers and a channel with 10 peers in each org, most StateInfo messages would be simply dropped, and this imposes a serious performance and latency problem for that message dissemination. Another solution for that, would say that we only do state-synchronization between peers of the same organization.   ></body> </Action>
<Action id="20108" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 10:36:14.0" updateauthor="angelo.decaro" updated="2016-12-15 10:36:14.0"> <body><! CDATA Okay, I think we might be quite close. What we say in addition is that node 1 sends a channel-related message, let's say A, to node 2 and both are on A, then node 2 asks the MSP of channel A to verify validate the identity.  What do you think?  ></body> </Action>
<Action id="20109" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 10:42:24.0" updateauthor="angelo.decaro" updated="2016-12-15 10:47:10.0"> <body><! CDATA  ~yacovm  Regarding your last paragraph, which check do you envision? I didn't get that.  But sorry, if the nodes belong to the same channel even though different organizations then it is fine. They will recognize each other.  ></body> </Action>
<Action id="20111" issue="13803" author="yacovm" type="comment" created="2016-12-15 10:59:53.0" updateauthor="yacovm" updated="2016-12-15 10:59:53.0"> <body><! CDATA {quote}Okay, I think we might be quite close. What we say in addition is that node 1 sends a channel-related message, let's say A, to node 2 and both are on A, then node 2 asks the MSP of channel A to verify validate the identity.{quote} Yeah, if they're on the same channel that'll work. But- what if they are not in the same channel, but both are in organizations that are in the channel? then it won't. and there is a use case I described above that needs it to work.   ></body> </Action>
<Action id="20113" issue="13803" author="angelo.decaro" type="comment" body="How can a node tell that who is sending the gossip message belongs to an organization that it is in some channel on which also his organization is on? This sounds weird to me. Please, may you clarify the scenario?" created="2016-12-15 11:58:58.0" updateauthor="angelo.decaro" updated="2016-12-15 11:58:58.0"/>
<Action id="20114" issue="13803" author="yacovm" type="comment" created="2016-12-15 12:02:32.0" updateauthor="yacovm" updated="2016-12-15 12:02:32.0"> <body><! CDATA Of course. Each message is either sent: * Point2Point- and then the sender is associated with its PKI-ID, and each peer maps the PKI-ID to a certificate, and each peer can call the MSP to extract the identity of an organization from a certificate. Once that identity is extracted, and since we have the list of all organizations of a channel, we know if that peer belongs to an organization that is in the channel.  * Gossipped (can be relayed)- and then that message is signed by the peer, and the PKI-ID of the peer is inside the message. The same logic as the previous bullet is applied.   ></body> </Action>
<Action id="20115" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 12:32:52.0" updateauthor="angelo.decaro" updated="2016-12-15 12:32:52.0"> <body><! CDATA This is the question:   A and B belongs to different organizations, org1, org2 respectively.  A sends a message to B.  B ask itself: Does A belong to an organization that has a channel in common with org2? But, how can B answer such a question?  ></body> </Action>
<Action id="20116" issue="13803" author="yacovm" type="comment" created="2016-12-15 12:35:38.0" updateauthor="yacovm" updated="2016-12-15 12:36:44.0"> <body><! CDATA He can simply look at all the MSPs it has, and ask each MSP if it recognizes the certificate or A.  It can also be smart and look at the organization of A, and lookup which MSP are relevant for that org.  ></body> </Action>
<Action id="20117" issue="13803" author="elli-androulaki" type="comment" created="2016-12-15 12:41:37.0" updateauthor="elli-androulaki" updated="2016-12-15 12:41:52.0"> <body><! CDATA > He can simply look at all the MSPs it has, and ask each MSP if it recognizes the certificate or A.   But this will not answer the question of whether channel X is the channel both organizations are part of, but rather that there exists some channel that both  organizations are member of.  > It can also be smart and look at the organization of A, and lookup which MSP are relevant for that org  Organization info is built in to that MSP, that is mapping between orgs and MSPs is assumed to be known by the peers. But then we go back to Angelo's question. How do we know that organization A is a member of channel X.     ></body> </Action>
<Action id="20118" issue="13803" author="angelo.decaro" type="comment" body="Why should B perform such an exhaustive search (which is costly)? Why should B have at all an MSP that can validate org2? There must be some hidden assumption that I&apos;m missing here." created="2016-12-15 12:47:40.0" updateauthor="angelo.decaro" updated="2016-12-15 12:48:02.0"/>
<Action id="20119" issue="13803" author="yacovm" type="comment" created="2016-12-15 12:50:49.0" updateauthor="yacovm" updated="2016-12-15 12:51:33.0"> <body><! CDATA {quote}But this will not answer the question of whether channel X is the channel both organizations are part of, but rather that there exists some channel that both organizations are member of.{quote} I know. And, that is enough, since all the gossip component wants to know if whether a peer's signature is valid. That's all. Nothing to do with a channel.   {quote}Organization info is built in to that MSP, that is mapping between orgs and MSPs is assumed to be known by the peers.{quote} Can you decipher this message please?   {quote}But then we go back to Angelo's question. How do we know that organization A is a member of channel X.{quote} Why would you need to know that? that's my problem, not yours. I just need you to verify a peer's certificate, nothing more.   ></body> </Action>
<Action id="20120" issue="13803" author="yacovm" type="comment" created="2016-12-15 12:53:21.0" updateauthor="yacovm" updated="2016-12-15 12:53:21.0"> <body><! CDATA {quote}Why should B perform such an exhaustive search (which is costly)?{quote} I didn't say it has to. The implementation details is yours to decide on.  You could create a mapping between orgs and lists of MSPs if you want.   {quote} Why should B have at all an MSP that can validate org2? There must be some hidden assumption that I'm missing here.{quote} It may have, and it may not have.  ></body> </Action>
<Action id="20122" issue="13803" author="angelo.decaro" type="comment" created="2016-12-15 13:03:45.0" updateauthor="angelo.decaro" updated="2016-12-15 13:04:36.0"> <body><! CDATA Yacov, a peer only organizes MSP per channel not per organization.  ~binhn  ~ellaki , is this correct?  Moreover, if the probably that B has information about org2 is low, why should we bother at all? Is the scenario you are presenting a common one?  ></body> </Action>
<Action id="20123" issue="13803" author="elli-androulaki" type="comment" body="Correct to my knowledge. There is an MSPManager per chain/channel, plus a local MPS for the peer signing identities needs." created="2016-12-15 13:06:16.0" updateauthor="elli-androulaki" updated="2016-12-15 13:06:16.0"/>
<Action id="20124" issue="13803" author="elli-androulaki" type="comment" created="2016-12-15 13:10:01.0" updateauthor="elli-androulaki" updated="2016-12-15 13:10:26.0"> <body><! CDATA Just for the sake of time, and to make some progress. Shall we go with an approach where we have the channel listed in the verify, and would make things easier for Angelo?  And if we see that it is too slow / conclude that this does not cover our needs we look for alternatives?   ~yacovm ,  ~C0rWin ,  ~binhn ,  ~mastersingh24  what do you think?  ></body> </Action>
<Action id="20125" issue="13803" author="yacovm" type="comment" created="2016-12-15 13:10:57.0" updateauthor="yacovm" updated="2016-12-15 13:10:57.0"> <body><! CDATA {quote}Yacov, a peer only organizes MSP per channel not per organization. Binh NguyenElli Androulaki, is this correct?{quote} But, that's how the data is structured in the code, right? That's not set in stone. If you have that information somewhere and you need it, you should be able to somehow fetch it. At least that's what I think. {quote} Moreover, if the probably that B has information about org2 is low, why should we bother at all? Is the scenario you are presenting a common one?{quote} At least for now, we are asked to replicate ledger blocks (for state transfer, for peers that have been offline for a long time, or new peers) between organizations.  The support for that, at least at this point- requires flooding *all peers in the organizations of the channel* with a certain type of message, which would be dropped with high probability  because of your restriction.  ></body> </Action>
<Action id="20126" issue="13803" author="yacovm" type="comment" created="2016-12-15 13:14:31.0" updateauthor="yacovm" updated="2016-12-15 13:14:31.0"> <body><! CDATA {quote}Just for the sake of time, and to make some progress. Shall we go with an approach where we have the channel listed in the verify, and would make things easier for Angelo? And if we see that it is too slow / conclude that this does not cover our needs we look for alternatives?{quote} yep  ></body> </Action>
<Action id="20129" issue="13803" author="binhn" type="comment" created="2016-12-15 13:55:49.0" updateauthor="binhn" updated="2016-12-15 13:55:49.0"> <body><! CDATA Folks, I repeat again: We can't solve Byzantine problem in 1.0. We have made that decision a long time ago when we switched over to Kafka. There would be 100s of edge cases of Byzantine faults, and gossip alone is not going to solve it. So please focus on the simple things that we need now, and that is, sending a message in a network fast, efficient, and scaleable.  The message signature verification belongs to the layer above gossip (repeating). If we need to blacklist some peer, provide such function interface so that the layer above may control.  ></body> </Action>
<Action id="20130" issue="13803" author="yacovm" type="comment" body="We already have a method that black lists a peer, in the comm layer. " created="2016-12-15 14:48:00.0" updateauthor="yacovm" updated="2016-12-15 14:48:00.0"/>
<Action id="20131" issue="13803" author="yacovm" type="comment" created="2016-12-15 17:08:25.0" updateauthor="yacovm" updated="2016-12-15 17:08:25.0"> <body><! CDATA So, we talked and came to the following course of action:  Each peer would replicate its MSP information to its entire organization, and in that way- if we'll have 2 peers of different organizations, and both organizations are in the same channel, and these 2 peers are not in the same channel, they would eventually get the needed MSP information from peers in their own organization that are in the channel, and that way they could connect with each other.   Are there any objections,  ~angelo.decaro  ,  ~ellaki  ,  ~mastersingh24  ,  ~binhn  ?   ></body> </Action>
<Action id="20146" issue="13803" author="elli-androulaki" type="comment" created="2016-12-16 08:39:03.0" updateauthor="elli-androulaki" updated="2016-12-16 08:39:51.0"> <body><! CDATA  ~yacovm , how would this msp information traverse securely the gossip network?  Assuming that bootstrapping is solved by manual setup of the peer with the initially needed MSPs, how do we make sure that these structures are securely updated? If MSP updates are advertised through the gossip network, i would need to trust the peer who is sending me this information. And if I do trust all peers that are in the same org as i am, then i can use my single local MSP to authenticate the MSPupdate message prior to applying MSP updates.  Would this suffice as a threat model? If so, then I think we could be good to go :)  ></body> </Action>
<Action id="20150" issue="13803" author="yacovm" type="comment" created="2016-12-16 16:51:53.0" updateauthor="yacovm" updated="2016-12-16 16:52:41.0"> <body><! CDATA {quote} how would this msp information traverse securely the gossip network? {quote} You mean medium-wise? The same way we transfer everything, including ledger blocks. gRPC streams over TLS (if enabled). That's for security.  For authenticity we can do something similar we do in identity messages. I think that in the end, we don't really need to grab the MSP and transfer it in bulk, we just need to transfer data such that each peer can build its own missing MSP easily. This needs to be fine tuned but why not send the certificates themselves in separate messages and have each peer reconstruct the MSP with the info? Perhaps we can discuss that next week? {quote}Assuming that bootstrapping is solved by manual setup of the peer with the initially needed MSPs, how do we make sure that these structures are securely updated?{quote} The security part is not a problem since it's done in-memory and by the decision of the peer, the "hard" part is how to make the peer "trust" the certificates it gets, right? But,  ~binhn  said above: {quote}Folks, I repeat again: We can't solve Byzantine problem in 1.0{quote}, so since the certificates are passed only within the org, they can be signed by the peers that gossip them, and thus- can be trusted that they came from inside the MSP of an organizational peer. How does that sound? {quote}If MSP updates are advertised through the gossip network, i would need to trust the peer who is sending me this information {quote} Oh, That's what happens when you process JIRA comments serially and not read the entire comment first. I addressed this above. {quote} And if I do trust all peers that are in the same org as i am, then i can use my single local MSP to authenticate the MSPupdate message prior to applying MSP updates. {quote} Yeah. My thoughts too. {quote}Would this suffice as a threat model? If so, then I think we could be good to go{quote} I think so, but a follow-up question. I understand that we would want to gossip both enrollment certificates and TLS certs, right? Do we have the ability to make the gRPC server and client side (since we do mutual TLS) to an "online-update" of the "certificate verification trust logic"?  I guess this problem stands also when we don't gossip certificates, after all- when a peer joins a channel it gets the root CA cert of the organizations of that channel, right?  Does it somehow make the TLS layer of itself now trust these root CAs?   ></body> </Action>
<Action id="20613" issue="13803" author="angelo.decaro" type="comment" created="2017-01-29 12:15:44.0" updateauthor="angelo.decaro" updated="2017-01-29 12:15:44.0"> <body><! CDATA  ~elli-androulaki , ~ales , ~yacovm , change-set https://gerrit.hyperledger.org/r/#/c/3327/ depends on the implementation of identity.GetOrganizationUnits() and on the enforcement that DeserializeIdentity fails when the mspIDs do not match.  Please, may you comment on how to implement GetOrganizationUnits and how to perform the enforcement without breaking anything?  ></body> </Action>
<Action id="20614" issue="13803" author="elli-androulaki" type="comment" created="2017-01-29 13:54:31.0" updateauthor="elli-androulaki" updated="2017-01-29 14:03:11.0"> <body><! CDATA Ok, here is what I think we can consider having in place (at least for now):   At gossip the recipient of a message always obtains a (creator/signer, signature, signedmessage) triplet within   Is the connection/messages exchanged *chain/channel C scoped*? 1. recipient checks if it has joined channel C and rejects if not 2. recipient retrieves channelReader policy 3. recipients checks that the triplet (creator/signer, signature, signedmessage) with channnelReaders "evaluate" accepts; it rejects the connection if it does not accept.  Is the connection/messages exchanged *organization-scoped*?: two ways (depending on the avilability or not of identity channel): * Option1 - identity channel not available: check the triplet against local MSP and reject if the check fails (that is, deserialize using local msp, and run msp.isMember on the given id, as well as signature verification) * Option2 - the identity channel is in place: check the triplet against the recipient's MSP version inside the identity channel (leverage MSP.isMember(... ) function..); reject if these checks fail  Is the message a *ConnenctionEstablished* message? Here recipient needs to check that it is not a request coming outside the blockchain network. * Option1 - identity channel not available: a couple of way to deal with this 1. iterate across all channels the recipient has joined and evaluate the (creator/signer, signature, signedmessage) against channelReaders, if the check fails, check that the triplet is consistent to recipient's local MSP; reject if all these checks fail, and accept if any of them accepts. 2. keep the triplet and accept the connection, and wait till the type of message that is to be communicated through the established connection; then apply the message authentication methods d described above based on whether the message is organization-scoped or channel-scoped. * Option 2 - identity channel is in place: check the triplet mentioned above against the mspmanager of the identity channel  1. id <- mspmanager.deserialize(creator),  2. id.verify(message, signature) 3. id.validate()  In any case inside the MSP implementation of deserializeIdentity  method, we would need to add a check if the mspidentifier inside the deserialized identity matches the one of the MSP that deserializes it.   ></body> </Action>
<Action id="20615" issue="13803" author="elli-androulaki" type="comment" body="Policies based on OrganizationUnits we can have ass soon as we support the related principals, which we are currently not supporting." created="2017-01-29 14:03:57.0" updateauthor="elli-androulaki" updated="2017-01-29 14:03:57.0"/>
<Action id="20897" issue="13803" author="yacovm" type="comment" body="The method is already there... can we close this? (mark this done) once policies are in, Angelo can just start using them instead of the mock ." created="2017-02-14 21:44:18.0" updateauthor="yacovm" updated="2017-02-14 21:44:18.0"/>
<Action id="20904" issue="13803" author="elli-androulaki" type="comment" created="2017-02-15 09:44:25.0" updateauthor="elli-androulaki" updated="2017-02-15 09:44:25.0"> <body><! CDATA It is done, modulo the check with the chain's readers/writers.  Some of it is here: https://gerrit.hyperledger.org/r/#/c/6001/  ></body> </Action>
<Action id="21078" issue="13803" author="yacovm" type="comment" body="Done in: https://gerrit.hyperledger.org/r/#/c/6251/" created="2017-02-21 09:23:42.0" updateauthor="yacovm" updated="2017-02-21 09:23:42.0"/>
