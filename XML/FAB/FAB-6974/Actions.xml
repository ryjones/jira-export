<Action id="34603" issue="23927" author="clayton sims" type="comment" created="2017-11-14 01:22:00.0" updateauthor="clayton sims" updated="2017-11-14 01:22:00.0"> <body><! CDATA It seems like multiple customers have encountered this - if this is small like yacov says it seems we should consider as part of serviceability for 1.1     ></body> </Action>
<Action id="35203" issue="23927" author="mastersingh24" type="comment" created="2017-11-21 08:38:08.0" updateauthor="mastersingh24" updated="2017-11-21 08:41:40.0"> <body><! CDATA  ~yacovm    I think this change makes sense and will go a long way in terms of consumability.  We had to jump through a few hurdles just to make sure the current setup will work with mutual TLS - so this should definitely help in that respect.  I think that we should still encourage the use of DNS SANs rather than IP SANs especially given the fact that we highly recommend that people use Docker when running their peers.  Of course the nice thing here is that we can expose the chaincode peer endpoint on localhost which will greatly simplify things as now the chaincode containers do not need to be on the same Docker network as the peer container(s).  I also like this because frankly we should separate the chaincode endpoint config entirely from the endorser and event endpoints.  And given that chaincode server is only for peer<->chaincode communication, having the peer fully control it makes sense and greatly reduces the possible configuration errors.  Perhaps we can even move all of our examples to use localhost / 127.0.0.1 for the chaincode endpoint?  ></body> </Action>
<Action id="35204" issue="23927" author="mastersingh24" type="comment" body="TL;DR  -  I support doing this for v1.1" created="2017-11-21 08:42:09.0" updateauthor="mastersingh24" updated="2017-11-21 08:42:09.0"/>
<Action id="35302" issue="23927" author="yacovm" type="comment" created="2017-11-21 13:45:44.0" updateauthor="yacovm" updated="2017-11-21 13:45:44.0"> <body><! CDATA {quote}   I think that we should still encourage the use of DNS SANs rather than IP SANs especially given the fact that we highly recommend that people use Docker when running their peers.  Of course the nice thing here is that we can expose the chaincode peer endpoint on localhost which will greatly simplify things as now the chaincode containers do not need to be on the same Docker network as the peer container(s). {quote}    So I think that since the endpoint that the peer sends to the shim is overriden via an environment variable, if I just make the SAN to be the endpoint that the peer sends to the chaincode shim, it will support localhost natively without doing anything, and the samples could just expose 7052 and also override that environment variable.  ></body> </Action>
<Action id="35311" issue="23927" author="christopherferris" type="comment" body="I added review-needed tag so please vote if you agree this should be in 1.1" created="2017-11-21 15:02:15.0" updateauthor="christopherferris" updated="2017-11-21 15:02:15.0"/>
<Action id="35321" issue="23927" author="muralisr" type="comment" created="2017-11-21 19:32:12.0" updateauthor="muralisr" updated="2017-11-21 19:32:12.0"> <body><! CDATA  ~yacovm  I think this is a good thing to do but not sure if  https://gerrit.hyperledger.org/r/#/c/15427/   is doing the right thing (of course, I could be wrong / misreading something).   Currently things works if we use the same hostname (e.g., *peer0.example.com*) everywhere. We want to cover the general case where the chaincode system is on a different network.     Let's get this behind us first {quote}So I think that since the endpoint that the peer sends to the shim is overriden via an environment variable. {quote} I think you are talking about CORE_PEER_ADDRESS as the overriding env var on the chaincode side ? In the following {quote}CORE_CHAINCODE_ID_NAME=mycc:0 CORE_CHAINCODE_LOGGING_LEVEL=debug CORE_PEER_ADDRESS=*myorg.peer.com*:7052 ./chaincode_example02 --peer.address=*myorg.chaincodelistener.com:*7052 {quote} The passed *--peer.address=myorg.chaincodelistener.com:7052* will override CORE_PEER_ADDRESS. ie, CORE_PEER_ADDRESS will NOT override the passed argument to the CC. (As an aside, I think we should NOT use CORE_PEER_ADDRESS on the chaincode side at all but use the passed address but don't want to digress into this.)  Now, as far as I could tell from the CR, the chaincode listener will listen on *myorg.chaincodelistener.com:7052* with *myorg.peer.com* in the SAN and the chaincode will try to connect to *myorg.chaincodelistener.com:7052*. True ? Will that work ?  Bottom line, don't we want both *myorg.chaincodelistener.com* and *myorg.peer.com* in the SAN ?  ></body> </Action>
<Action id="35323" issue="23927" author="yacovm" type="comment" created="2017-11-21 20:08:45.0" updateauthor="yacovm" updated="2017-11-21 20:08:45.0"> <body><! CDATA No, I am not talking about peer.address.  I am talking about  https://gerrit.hyperledger.org/r/#/c/15217/10/sampleconfig/core.yaml@86   or the listenAddress. And the truth is that it really doesn't matter *HOW* it is computed for my idea to work, what matters is that there is *some* string that the peer passes to the chaincode shim, and this string will be used as a SAN for the TLS certificate, when the peer starts up.    {quote}Bottom line, don't we want both *myorg.chaincodelistener.com* and *myorg.peer.com* in the SAN ? {quote} I don't see why we should have both if only 1 string is passed to the chaincode shim.     ></body> </Action>
<Action id="35324" issue="23927" author="muralisr" type="comment" created="2017-11-21 20:34:29.0" updateauthor="muralisr" updated="2017-11-21 20:34:29.0"> <body><! CDATA looking at  ttps://gerrit.hyperledger.org/r/#/c/15427/|https://gerrit.hyperledger.org/r/#/c/15427/      {code:java} func createChaincodeServer(ca accesscontrol.CA, peerHostname string, endpoint string) (comm.GRPCServer, ccEndpointFunc) { cclistenAddress := viper.GetString(chaincodeListenAddrKey) if cclistenAddress == "" { cclistenAddress = fmt.Sprintf("%s:%d", peerHostname, defaultChaincodePort) logger.Warningf("%s is not set, using %s", chaincodeListenAddrKey, cclistenAddress) viper.Set(chaincodeListenAddrKey, cclistenAddress) } var srv comm.GRPCServer var ccEpFunc ccEndpointFunc config := comm.SecureServerConfig{} if viper.GetBool("peer.tls.enabled") { host, _, err := net.SplitHostPort(endpoint) if err != nil { panic(err) } serverCert, key, err := ca.NewServerCertKeyPair(host) if err != nil { panic(err) } config.RequireClientCert = true config.UseTLS = true config.ClientRootCAs =     byte{ca.CertBytes()} config.ServerCertificate = serverCert config.ServerKey = key config.ServerRootCAs = nil } {code}   The chaincode will be listening on *cclistenAddress* (say, myorg.chaincode.com) while you are adding *host* (say, myorg.peer.com) to the SAN : bq. serverCert, key, err := ca.NewServerCertKeyPair(host)  Is that what we want ?  ></body> </Action>
<Action id="35325" issue="23927" author="yacovm" type="comment" created="2017-11-21 21:08:43.0" updateauthor="yacovm" updated="2017-11-21 21:08:43.0"> <body><! CDATA So, the chaincode service will be listening on some address. It could be the ccListenAddress, but it could be i.e the peer.address if the former is missing, etc.  But - this isn't really relevant here, as I don't aim to change the way the listen address, or the address that is passed to the shim is calculated. (I might move the code around or even refactor it but the calculation logic will not change).  What I aim my change to do, is just to have the peer's TLS cert be generated by the peer, and have the SAN to be the host of the endpoint that is passed to the chaincode shim.  ></body> </Action>
<Action id="35326" issue="23927" author="muralisr" type="comment" created="2017-11-21 21:22:43.0" updateauthor="muralisr" updated="2017-11-21 21:22:43.0"> <body><! CDATA So basically you are saying the CR will change but in the end will do something like this  {code:java}  ccaddress := computeCCAddress(peeraddressProperty, listenaddressProperty,..) ... serverCert, key, err := ca.NewServerCertKeyPair(ccaddress) ... startChaincodeListener(ccaddress, serverCert, key,...)  ... {code}   yes ?  ></body> </Action>
<Action id="35327" issue="23927" author="yacovm" type="comment" body="yes, and that the ccaddress is the string that is passed to the chaincode shim to connect to the peer." created="2017-11-21 21:30:15.0" updateauthor="yacovm" updated="2017-11-21 21:30:15.0"/>
<Action id="35328" issue="23927" author="muralisr" type="comment" created="2017-11-21 21:32:28.0" updateauthor="muralisr" updated="2017-11-21 21:32:28.0"> <body><! CDATA Perfect, thanks  ~yacovm  ... I went literally by the CR, but it was worth it (for me at least :-)).   +1ed  ></body> </Action>
<Action id="35329" issue="23927" author="yacovm" type="comment" body="The needed number of votes is still 5, right? If so - hereby removing the review-needed tag." created="2017-11-21 21:49:10.0" updateauthor="yacovm" updated="2017-11-21 21:49:10.0"/>
<Action id="35334" issue="23927" author="jimthematrix" type="comment" created="2017-11-22 03:28:42.0" updateauthor="jimthematrix" updated="2017-11-22 03:31:39.0"> <body><! CDATA I also agree this is a good improvement and worth making in the v1.1 timeframe.  though I didn't quite understand the comment from  ~mastersingh24 :  bq. now the chaincode containers do not need to be on the same Docker network as the peer container(s)  Is that because the peer address is being discovered from the CA cert's SANs field? but isn't that derived from the peer's endpoint address when that self-signed cert is generated, which was originally passed to the chaincode container via --peer.address? What changed to allow the chiancode containers to not have to run on the same docker network as the peer?  ></body> </Action>
<Action id="35621" issue="23927" author="yacovm" type="comment" created="2017-11-29 12:40:07.0" updateauthor="yacovm" updated="2017-11-29 12:40:07.0"> <body><! CDATA It's  ready for review|https://gerrit.hyperledger.org/r/#/c/15427/  and can be merged after the  change set below it|https://gerrit.hyperledger.org/r/#/c/15801/  is merged.    ~jimthematrix  {quote}  Is that because the peer address is being discovered from the CA cert's SANs field? but isn't that derived from the peer's endpoint address when that self-signed cert is generated, which was originally passed to the chaincode container via --peer.address? What changed to allow the chiancode containers to not have to run on the same docker network as the peer?{quote}  That's simply because the net.Listeners are not the same, but different instances, thus can be bound to different network interfaces.   ></body> </Action>
<Action id="35780" issue="23927" author="jeffgarratt" type="comment" body="This changes the contract between the person configuring the peer.  I do NOT disagree with it.  I just want to highlight the possible impact for administrators." created="2017-12-04 15:29:34.0" updateauthor="jeffgarratt" updated="2017-12-04 15:29:34.0"/>
