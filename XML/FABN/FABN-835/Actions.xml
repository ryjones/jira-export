<Action id="48024" issue="32199" author="davidkhala" type="comment" body="in progress https://gerrit.hyperledger.org/r/#/c/24749/" created="2018-07-27 11:01:46.0" updateauthor="davidkhala" updated="2018-07-27 11:01:46.0"/>
<Action id="48026" issue="32199" author="davidkhala" type="comment" created="2018-07-27 11:17:08.0" updateauthor="davidkhala" updated="2018-07-27 11:17:08.0"> <body><! CDATA Understanding that KeyValueStore and CryptoKeyValueStore should be pluggable, my design is  * For any KeyValueStore, we use 'options' as constructor param. Not to return a confusing Promise in constructor. * For those actions operated in Promise in constructor, I suggest to move them out into `async init()` * For KeyValueStore.getValue and setValue,  implementor class should make sure init() is called before actually action. Use 'lazy loading' design just like ChannelEventHub * Not to use CryptoKeyStoreMixin, separate its logic to either utils.js or CryptoKeyStore itself. * CryptoKeyStore now accept an instance of KeyValueStore as constructor param `_store` as its physical storage interface, and use `proxy` design pattern to redirect `setValue`, `getValue` call to `_store` since CryptoKeyStore itself also extends KeyValueStore * utils.js take care of config 'key-valut-store', creating KeyValueStore instance, and other miscellanea.  * Consider adding an api `destroy()` to KeyValueStore,  it is inspired by CouchDButil in test source codes.        ></body> </Action>
<Action id="65111" issue="32199" author="heatherp" type="comment" body="Hi  ~davidkhala  I&apos;ve been working through the node sdk backlog with the maintainers and came across this, are you still actively working on it?" created="2019-10-29 16:15:20.0" updateauthor="heatherp" updated="2019-10-29 16:15:20.0"/>
<Action id="68005" issue="32199" author="davidkhala" type="comment" created="2020-02-19 09:35:52.0" updateauthor="davidkhala" updated="2020-02-19 09:35:52.0"> <body><! CDATA  ~heatherp  This is a long lasting code style issue I see year(s) ago. LOL, I had proposed a fierce breaking change PR for this. But at that time, maintainers think we'd better not to touch release-1.x first and let me wait till release-2.x. I could rebase (actually rewrite) my proposal to current head of master branch.   Is it now a good time to accept this change?  ></body> </Action>
<Action id="68069" issue="32199" author="heatherp" type="comment" body="Hey  ~davidkhala  so fabric-client has been removed in master (2.0.x) branch, as we&apos;ve refactored it into fabric-common. So the implementation would be slightly different for the two branches. I reckon start with a PR in 2.0.x first. We&apos;re working hard to get a 2.0.0 release out in the next couple of weeks, so if your PR is going to contain breaking changes, getting it reviewed/in this week or next would be ideal. We&apos;re less keen on breaking changes going into the 1.4.x stream. Does this information help?" created="2020-02-24 09:42:22.0" updateauthor="heatherp" updated="2020-02-24 09:42:22.0"/>
<Action id="68103" issue="32199" author="davidkhala" type="comment" created="2020-02-26 07:07:50.0" updateauthor="davidkhala" updated="2020-02-26 07:47:23.0"> <body><! CDATA  ~heatherp  Helpful indeed. I will try to hurry up a PR on master for review this week.  https://github.com/hyperledger/fabric-sdk-node/pull/145  ></body> </Action>
<Action id="68105" issue="32199" author="heatherp" type="comment" body=" ~davidkhala  let us know when you&apos;re ready for us to review :)" created="2020-02-26 09:32:43.0" updateauthor="heatherp" updated="2020-02-26 09:32:43.0"/>
<Action id="68215" issue="32199" author="davidkhala" type="comment" created="2020-03-04 02:22:54.0" updateauthor="davidkhala" updated="2020-03-04 02:22:54.0"> <body><! CDATA https://github.com/hyperledger/fabric-sdk-node/pull/148 as step 2 here.  ></body> </Action>
<Action id="69113" issue="32199" author="bestbeforetoday" type="comment" created="2020-04-29 11:22:20.0" updateauthor="bestbeforetoday" updated="2020-04-29 11:22:20.0"> <body><! CDATA Something to consider... one of the aims of the rework of the v2 implementation carried out by  ~harrisob@us.ibm.com  was to remove persistent state from the lower-level APIs. I believe the intent was for this to include the crypto key store but it was too big a step to entirely remove it. Credentials associated with client identities are instead entirely managed at the _fabric-network_ level, stored in wallets and only passed down to _fabric-common_ at runtime as required.  To avoid runtime conflicts in the tests with both v1.4 _fabric-client_ and v2.x _fabric-common_ loaded, I changed the default crypto keystore implementation to an in-memory store with the implementation identified programmatically only and not obtained from configuration properties. I guess what I am wondering now is, given the aim to remove persistent storage in _fabric-common_, what is the use-case for a pluggable cypto keystore implementation at all? Should the default in-memory implementation be the only one possible in v2.x?  ></body> </Action>
<Action id="69120" issue="32199" author="davidkhala" type="comment" created="2020-04-30 04:02:52.0" updateauthor="davidkhala" updated="2020-04-30 06:39:43.0"> <body><! CDATA  ~bestbeforetoday  Good topic! There are several cases we could discuss - As a stateless enthusiast, I definitely agree with Bret‘s decision to remove persistent state in lower-level sdk. I vote for your proposal that we keep only in-memory cryptoKeyStore in v2. - At the very early days(so early that even Jim Zhang still work in IBM), there is no `fabric-network` on earth or wallet concept. CryptoKeystore worked as an alternative expression of wallet. Now from overview, indeed, for fabric-network user, they may only need a pluggable wallet design, such as couchdb/HSM-based wallet.  - While for developers get used to low-level sdk and could not migrate to fabric-network(I was one of them since we have own implementation similar to fabric-network even before its birth), a pluggable cryptoKeyStore might be a `required legacy`. It is hard to predict and estimate user spectrum. I prefer guiding them to adapt change. Tell them that's what v2 stands for.  -  pluggable via configuration properties is not always a good idea. Global status or variable can introduce chaos. If we insist on pluggable, a provided interface and accepting an instance of a class implementing interface as function parameter are good enough(as java usual design), instead of make sdk to r/w config      ></body> </Action>
