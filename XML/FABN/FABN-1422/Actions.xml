<Action id="66010" issue="43426" author="harrisob@us.ibm.com" type="comment" body="The NodeJS side application should be handling this, we should not be changing the grpc objects" created="2019-12-03 14:26:00.0" updateauthor="harrisob@us.ibm.com" updated="2019-12-03 14:26:00.0"/>
<Action id="66011" issue="43426" author="davidkhala" type="comment" created="2019-12-03 14:32:13.0" updateauthor="davidkhala" updated="2019-12-03 14:32:13.0"> <body><! CDATA  ~harrisob@us.ibm.com  Indeed, it could be fixed by a work around solution. It may look like this:  exports.unsignedTransaction = (proposalResponses, proposal) => { 	const channel = emptyChannel('void');  	proposal = Object.assign({getHeader: () => proposal.header}, proposal); // TODO work around of sdk design 	/** 	 * @type {TransactionRequest} 	 */ 	const request = { 		proposalResponses, proposal,  	}; 	return channel.generateUnsignedTransaction(request); };  And again, it is not related to grpc object, but the way we read property in translated JS object.   ></body> </Action>
<Action id="66018" issue="43426" author="davidkhala" type="comment" created="2019-12-03 15:41:23.0" updateauthor="davidkhala" updated="2019-12-03 15:42:05.0"> <body><! CDATA per our conversion, we could still decode the proposal_bytes back to grpc message( on nodejs server side) as `proposal` which having auto-generated getter/setter.    ></body> </Action>
<Action id="66021" issue="43426" author="harrisob@us.ibm.com" type="comment" body="we need to show how to use the new low level with an example tutorial for off-line signing" created="2019-12-03 16:30:06.0" updateauthor="harrisob@us.ibm.com" updated="2019-12-03 16:30:06.0"/>
