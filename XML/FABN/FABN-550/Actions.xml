<Action id="38917" issue="26950" author="c0rwin" type="comment" created="2018-01-19 23:31:56.0" updateauthor="c0rwin" updated="2018-01-19 23:31:56.0"> <body><! CDATA Based on comments in the code described is the intended behavior, e.g.   {code} 						// Drop read write set from transaction before sending block event 						// Performance issue with chaincode deploy txs and causes nodejs grpc 						// to hit max message size bug 						// Dropping the read write set may cause issues for security and 						// we will need to revist when event security is addressed 						caPayload.Results = nil 						chaincodeActionPayload.Action.ProposalResponsePayload, err = utils.GetBytesProposalResponsePayload(propRespPayload.ProposalHash, caPayload.Response, caPayload.Results, caPayload.Events, caPayload.ChaincodeId) 						if err != nil { 							return nil, nil, "", fmt.Errorf("error marshalling tx proposal payload for block event: %s", err) 						} 						action.Payload, err = utils.GetBytesChaincodeActionPayload(chaincodeActionPayload) 						if err != nil { 							return nil, nil, "", fmt.Errorf("error marshalling tx action payload for block event: %s", err) 						} {code}   See here: https://github.com/hyperledger/fabric/blob/release/events/producer/eventhelper.go#L73  I suggest to change it to improvement rather than bug, since works as expected.  ></body> </Action>
<Action id="38925" issue="26950" author="denyeart" type="comment" created="2018-01-20 18:02:10.0" updateauthor="denyeart" updated="2018-01-20 18:02:10.0"> <body><! CDATA This is working as intended, I don't think changes will be made to the older EventHub.  Going forward, we recommend to use the new deliver service to get block events, which preserves the read/write set.  The new deliver service is available in master and will be part of the upcoming v1.1 alpha.  I believe this JIRA issue can be closed.  ></body> </Action>
<Action id="38952" issue="26950" author="jtracey" type="comment" created="2018-01-22 12:02:00.0" updateauthor="jtracey" updated="2018-01-22 12:02:00.0"> <body><! CDATA Thanks.  Looking at eventhelper.go in the master branch the code still appears to be removing the read/write set. Is this the new deliver service or am I looking in the wrong place?  I'm trying to retrieve the args data posted via ChaincodeInvokeRequest() in the SDK. I believe this is available in the chaincode_proposal _payload section of the Block object but there's no deserializer available in the SDK.  ></body> </Action>
<Action id="38953" issue="26950" author="c0rwin" type="comment" created="2018-01-22 12:20:10.0" updateauthor="c0rwin" updated="2018-01-22 12:20:10.0"> <body><! CDATA You are looking in the wrong place, the eventhelper.go still available to preserve backward compatibility, while new delivery service for the peer side is now available in deliverevents.go. To be more specific the part which handles delivery of the block is:  {code} // Deliver sends a stream of blocks to a client after commitment func (s *server) Deliver(srv peer.Deliver_DeliverServer) error { 	logger.Debugf("Starting new Deliver handler") 	defer dumpStacktraceOnPanic() 	srvSupport := &deliverBlockSupport{ 		Deliver_DeliverServer: srv, 	} 	// getting policy checker based on resources.BLOCKEVENT resource name 	return s.dh.Handle(deliver.NewDeliverServer(srvSupport, s.policyCheckerProvider(resources.BLOCKEVENT), s.sendProducer(srv))) } {code}  which basically utilize the implementation of the delivery handler of ordering service:  {code} func (ds *deliverHandler) deliverBlocks(srv *DeliverServer, envelope *cb.Envelope) error { 	addr := util.ExtractRemoteAddress(srv.Context()) 	payload, err := utils.UnmarshalPayload(envelope.Payload) 	if err != nil { 		logger.Warningf("Received an envelope from %s with no payload: %s", addr, err) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	if payload.Header == nil { 		logger.Warningf("Malformed envelope received from %s with bad header", addr) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	chdr, err := utils.UnmarshalChannelHeader(payload.Header.ChannelHeader) 	if err != nil { 		logger.Warningf("Failed to unmarshal channel header from %s: %s", addr, err) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	err = ds.validateChannelHeader(srv, chdr) 	if err != nil { 		logger.Warningf("Rejecting deliver for %s due to envelope validation error: %s", addr, err) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	chain, ok := ds.sm.GetChain(chdr.ChannelId) 	if !ok { 		// Note, we log this at DEBUG because SDKs will poll waiting for channels to be created 		// So we would expect our log to be somewhat flooded with these 		logger.Debugf("Rejecting deliver for %s because channel %s not found", addr, chdr.ChannelId) 		return sendStatusReply(srv, cb.Status_NOT_FOUND) 	}  	erroredChan := chain.Errored() 	select { 	case <-erroredChan: 		logger.Warningf(" channel: %s  Rejecting deliver request for %s because of consenter error", chdr.ChannelId, addr) 		return sendStatusReply(srv, cb.Status_SERVICE_UNAVAILABLE) 	default:  	}  	accessControl, err := newSessionAC(chain, envelope, srv.PolicyChecker, chdr.ChannelId, crypto.ExpiresAt) 	if err != nil { 		logger.Warningf(" channel: %s  failed to create access control object due to %s", chdr.ChannelId, err) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	if err := accessControl.evaluate(); err != nil { 		logger.Warningf(" channel: %s  Client authorization revoked for deliver request from %s: %s", chdr.ChannelId, addr, err) 		return sendStatusReply(srv, cb.Status_FORBIDDEN) 	}  	seekInfo := &ab.SeekInfo{} 	if err = proto.Unmarshal(payload.Data, seekInfo); err != nil { 		logger.Warningf(" channel: %s  Received a signed deliver request from %s with malformed seekInfo payload: %s", chdr.ChannelId, addr, err) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	if seekInfo.Start == nil || seekInfo.Stop == nil { 		logger.Warningf(" channel: %s  Received seekInfo message from %s with missing start or stop %v, %v", chdr.ChannelId, addr, seekInfo.Start, seekInfo.Stop) 		return sendStatusReply(srv, cb.Status_BAD_REQUEST) 	}  	logger.Debugf(" channel: %s  Received seekInfo (%p) %v from %s", chdr.ChannelId, seekInfo, seekInfo, addr)  	cursor, number := chain.Reader().Iterator(seekInfo.Start) 	defer cursor.Close() 	var stopNum uint64 	switch stop := seekInfo.Stop.Type.(type) { 	case *ab.SeekPosition_Oldest: 		stopNum = number 	case *ab.SeekPosition_Newest: 		stopNum = chain.Reader().Height() - 1 	case *ab.SeekPosition_Specified: 		stopNum = stop.Specified.Number 		if stopNum < number { 			logger.Warningf(" channel: %s  Received invalid seekInfo message from %s: start number %d greater than stop number %d", chdr.ChannelId, addr, number, stopNum) 			return sendStatusReply(srv, cb.Status_BAD_REQUEST) 		} 	}  	for { 		if seekInfo.Behavior == ab.SeekInfo_FAIL_IF_NOT_READY { 			if number > chain.Reader().Height()-1 { 				return sendStatusReply(srv, cb.Status_NOT_FOUND) 			} 		}  		block, status := nextBlock(cursor, erroredChan) 		if status != cb.Status_SUCCESS { 			cursor.Close() 			logger.Errorf(" channel: %s  Error reading from channel, cause was: %v", chdr.ChannelId, status) 			return sendStatusReply(srv, status) 		}  		// increment block number to support FAIL_IF_NOT_READY deliver behavior 		number++  		if err := accessControl.evaluate(); err != nil { 			logger.Warningf(" channel: %s  Client authorization revoked for deliver request from %s: %s", chdr.ChannelId, addr, err) 			return sendStatusReply(srv, cb.Status_FORBIDDEN) 		}  		logger.Debugf(" channel: %s  Delivering block for (%p) for %s", chdr.ChannelId, seekInfo, addr)  		if err := sendBlockReply(srv, block); err != nil { 			logger.Warningf(" channel: %s  Error sending to %s: %s", chdr.ChannelId, addr, err) 			return err 		}  		if stopNum == block.Header.Number { 			break 		} 	}  	if err := sendStatusReply(srv, cb.Status_SUCCESS); err != nil { 		logger.Warningf(" channel: %s  Error sending to %s: %s", chdr.ChannelId, addr, err) 		return err 	}  	logger.Debugf(" channel: %s  Done delivering to %s for (%p)", chdr.ChannelId, addr, seekInfo)  	return nil  }  {code}  as you can see preserves the original read write sets in the block.  ></body> </Action>
<Action id="38976" issue="26950" author="jtracey" type="comment" created="2018-01-22 17:11:43.0" updateauthor="jtracey" updated="2018-01-22 17:11:43.0"> <body><! CDATA Using the current master distribution I'm still seeing an empty read/write set. Any thoughts? Thanks    "results": \{      "data_model": 0,      "ns_rwset":      }  ></body> </Action>
<Action id="38978" issue="26950" author="c0rwin" type="comment" body="Are you using new Events Delivery service or keep using the old approach of v1.0? Please consider to take a look on https://gerrit.hyperledger.org/r/#/c/16919/ to see how you can leverage new events APIs available on master branch now. With respect to the old events system no changes were made, so you  ~jtracey  output is expected." created="2018-01-22 17:45:51.0" updateauthor="c0rwin" updated="2018-01-22 17:45:51.0"/>
<Action id="38981" issue="26950" author="jtracey" type="comment" created="2018-01-22 19:02:09.0" updateauthor="jtracey" updated="2018-01-22 19:02:09.0"> <body><! CDATA    I'm using the node SDK (with the old delivery service as that is the only one documented). The sample code is for go. Is the API available for node? Thanks.  ></body> </Action>
<Action id="38995" issue="26950" author="c0rwin" type="comment" body=" ~jtracey  I&apos;d refer the SDK related question to  ~jimthematrix  or  ~rickr . I know there is work in progress and some CRs already available, while cannot confirm whenever you can base on them." created="2018-01-22 22:05:08.0" updateauthor="c0rwin" updated="2018-01-22 22:05:08.0"/>
<Action id="39002" issue="26950" author="rickr" type="comment" body="Both Node ( ~harrisob@us.ibm.com ) and Java SDK have this merged.  I _assumed_ that the events for full blocks would still have rwsets missing.  The solution for that is to query for the block by it&apos;s block number which would return the rwsets." created="2018-01-23 01:40:12.0" updateauthor="rickr" updated="2018-01-23 01:40:12.0"/>
<Action id="39013" issue="26950" author="c0rwin" type="comment" created="2018-01-23 09:29:02.0" updateauthor="c0rwin" updated="2018-01-23 09:29:02.0"> <body><! CDATA The solution leverages delivery API which was available for AtomicBroadcast RPC on ordering service, there was no plan to handle block delivery any different, hence rwset are not nullified with new API. Here is the new APIs:  {code} service Deliver { // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with Payload data as a marshaled orderer.SeekInfo message, // then a stream of block replies is received. rpc Deliver (stream common.Envelope) returns (stream DeliverResponse) { } // deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with Payload data as a marshaled orderer.SeekInfo message, // then a stream of **filtered** block replies is received. rpc DeliverFiltered (stream common.Envelope) returns (stream DeliverResponse) { } } {code}  Where {{Deliver}} takes care to bring the block exactly as is, without doing any filtration or transformations to the block content, while {{DeliverFiltered}} is more lightweight as aims to bring transaction id with its status and in case of chaincode event the payload as well.  ></body> </Action>
<Action id="39024" issue="26950" author="jtracey" type="comment" created="2018-01-23 14:08:51.0" updateauthor="jtracey" updated="2018-01-23 14:08:51.0"> <body><! CDATA    The eventsclient.go sample code is connecting to the peer service listening port (usually on 7051) rather than the event service port (7053).  Is this the proposed mechanism for receiving 'full' blocks via events? As far as I'm aware there's no provision for this in the node SDK.  As mentioned by  ~rickr  the current implementation (empty read/write set in blocks retrieved via registerBlockEvent()) forces the client app to use queryBlock() to retrieve the missing data, which seems somewhat cumbersome.  ></body> </Action>
<Action id="39036" issue="26950" author="harrisob@us.ibm.com" type="comment" created="2018-01-23 16:36:14.0" updateauthor="harrisob@us.ibm.com" updated="2018-01-23 16:41:40.0"> <body><! CDATA NodeSDK has new API's for the channel-based event service, which is built on the `deliver` service. See NodeSDK master or `npm install fabric-client@unstable`  New API's to get a channel-based event hub are on the `Channel` object and there is a new class `ChannelEventHub`.  ></body> </Action>
<Action id="39051" issue="26950" author="jtracey" type="comment" created="2018-01-24 08:32:06.0" updateauthor="jtracey" updated="2018-01-24 08:32:06.0"> <body><! CDATA Thanks Bret.  I pulled the node SDK master and have got the new event service working. The read/write set is now present in blocks so all is good.  ></body> </Action>
