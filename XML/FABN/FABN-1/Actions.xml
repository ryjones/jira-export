<Action id="26003" issue="17766" author="jimthematrix" type="comment" created="2017-06-12 03:07:49.0" updateauthor="jimthematrix" updated="2017-06-12 03:07:49.0"> <body><! CDATA the stateless design as you described is a legitimate alternative, it would require the user object to be passed to every call that sends requests to the fabric. the v1.0 SDK took a very different (stateful) approach from the very beginning, as evident in the "SDK design spec" https://docs.google.com/document/d/1R5RtIBMW9fZpli37E5Li5_Q9ve3BnQ4q3gWmGZj6Sv4/edit that was published in November 2016. as I explained in an earlier discussion on this subject, we took the view that not every application user needs to have their distinctive signing identity (private key and signing certificate), but instead the application would maintain a relatively small number of signing identities to use with the fabric. as a result you would want a client instance dedicated to a signing identity (say one for the org admin, and one or a small number for a regular org member).  if you have the need to use a large number of signing identities to submit requests to the fabric, then this design is not optimal (although it doesn't prevent you from doing that, you'd just have to create many instances of clients and channels). But since the fabric MSP governs access control and endorsement policies based on organizational units and roles (org1.admin, org1.member), there's really no need to use more than one identity for each role. of course you would want to have accountability of each individual user using the app, but that can be tracked and implemented in the application layer outside of the "fabric identities".  since we are beta, it'd be really difficult if not impossible to make any API changes. in the next major release (say 1.1) we could consider adding the ability to use the clients and channels in a stateless way, such that if the user object is passed with each fabric request call, it'll be used and the client/channel object itself does not require the user context to be set ahead of time. so basically both the stateful and stateless styles can be supported  ></body> </Action>
<Action id="27483" issue="17766" author="crmiles" type="comment" created="2017-06-28 11:41:13.0" updateauthor="crmiles" updated="2017-06-28 11:41:13.0"> <body><! CDATA This is something that I've been wondering about for a while.  I originally hit issues trying to connect with multiple users until I realized that this stateful client was the issue.  As you mention above, I can create multiple client instances (one for each request, or I guess I could cache them by user), but isn't that 'heavy'?  Would I need to also create a new Chain instance for each client, or could I reuse a single Chain instance across multiple Clients?  Just wondering if there are any grpc-related concerns with having too many connections open (or left open)...  Personally, I would prefer the stateless approach – especially because invoking chaincode as a given user is helpful from a security perspective.  I like that I can get the caller cert in my chaincode and know that it was that particular user who was invoking the chaincode (along with retrieving the TCert attributes - when we get TCerts! :) )  ></body> </Action>
<Action id="27587" issue="17766" author="jimthematrix" type="comment" body=" ~crmiles  yes you can definitely re-use Peer, Orderer instances across clients and channel objects to avoid having to create new grpc connections for each new users. About the chaincode getting the creator/caller cert, that always works with either approach." created="2017-06-29 07:06:01.0" updateauthor="jimthematrix" updated="2017-06-29 07:06:01.0"/>
<Action id="37116" issue="17766" author="holocron" type="comment" body=" ~jimthematrix  can we get an update on the current thinking here?" created="2017-12-14 22:46:47.0" updateauthor="holocron" updated="2017-12-14 22:46:47.0"/>
<Action id="41983" issue="17766" author="denyeart" type="comment" body="Many issues were bulk moved from v1.0 or v1.1 to v1.2 as part of a cleanup effort, and many of these issues are not high priority or actually intended to be worked for v1.2.  This issue is being bulk moved to Future.  If the issue is indeed high priority for v1.2 and/or very low effort, please move back to v1.2 and add a comment to indicate rationale." created="2018-03-23 05:07:49.0" updateauthor="denyeart" updated="2018-03-23 05:07:49.0"/>
<Action id="45440" issue="17766" author="davidkhala" type="comment" body="How about in future design, not to use Client but directly use User as its role?" created="2018-06-04 04:44:34.0" updateauthor="davidkhala" updated="2018-06-04 04:44:34.0"/>
<Action id="65144" issue="17766" author="heatherp" type="comment" body="Hi, I&apos;ve been working through the node sdk backlog with the maintainers and as this was raised some time ago, I&apos;m closing.   The high-level node sdk APIs have been available for some time, and this issue may be covered by functionality provided there: https://hyperledger-fabric.readthedocs.io/en/latest/write_first_app.html  Please re-open if this issue is still affecting you, and the functionality is not available in the low-level or high-level node sdk APIs, thanks." created="2019-10-29 16:40:15.0" updateauthor="heatherp" updated="2019-10-29 16:40:15.0"/>
