<Action id="28592" issue="19331" author="jimthematrix" type="comment" body=" ~rickr ,  ~baohua ,  ~grapebaba ,  ~troyronda  can you guys please comment on this proposal for your respective SDK?" created="2017-07-18 15:45:13.0" updateauthor="jimthematrix" updated="2017-07-18 15:48:24.0"/>
<Action id="28596" issue="19331" author="jimthematrix" type="comment" created="2017-07-18 17:32:20.0" updateauthor="jimthematrix" updated="2017-07-18 17:32:20.0"> <body><! CDATA One area that warrants specific discussions is how to handle user identities, specifically the crypto materials. There are several questions:  # at what level of abstraction should we design this. 1) assuming the current MSP implementation based on PKI, namely using certificates to represent identities, or 2) assuming there will be other MSP implementations. Note that MSP is an abstract interface that can be implemented with other crypto technologies than certificates, although at the moment and in the foreseeable future there will not be an alternative implementation available. # I like the concept of a "user store" or "wallet", which is keyed with some combination of the org name and the user name. the value is the materials necessary to build the user object (signing certificate, private signing key or reference of it, etc.) and can be SDK dependent. I think the Composer connection profile's "keyValueStore" setting is likely a better abstraction than balance-transfer's explicit  username  <->  signcert, key  object. This way the application does not need to know any identities at bootstrap time. An added benefit is this will work with different MSP implementations (those that don't use certificates) in the future.  ></body> </Action>
<Action id="28611" issue="19331" author="sstone1" type="comment" created="2017-07-18 20:24:41.0" updateauthor="sstone1" updated="2017-07-18 20:24:41.0"> <body><! CDATA  ~jimthematrix  thanks for raising this!  From a Composer point of view, we need three fields. They are: {code:java} "name": "hlfabric", "description": "Hyperledger Fabric v1.0", "type": "hlfv1" {code} "name" is a unique name for the connection profile  "description" is self explanatory  "type" indicates what Blockchain platform this for; e.g. for Fabric v0.6 we had "hlf" (should have been "hlfv06" and for Fabric v1.0 we had "hlfv1").  We have a Composer "connector" for each Blockchain platform, which is a plugin - a JavaScript module - for Composer that implements the actual interactions with the Blockchain and the deployed Composer smart contract. The "type" property in the connection profile selects which connector module to use.  ></body> </Action>
<Action id="28618" issue="19331" author="dshuffma" type="comment" body="updating marbles section for RC1." created="2017-07-18 20:49:19.0" updateauthor="dshuffma" updated="2017-07-18 20:49:19.0"/>
<Action id="28626" issue="19331" author="davidkel" type="comment" created="2017-07-18 22:07:40.0" updateauthor="davidkel" updated="2017-07-18 22:07:40.0"> <body><! CDATA I would also like to think about how we want to support the different configurations required for different roles, ie * The connection profile for an organisations chaincode installer * The connection profile for the chaincode instantiator * The connection profile for the transactor  Do we want multiple definitions or some way to contain all this information in a single profile ?  Creating connection profiles by hand are not so easy. There is a lot of information required to be entered and it's easy to make a mistake and you need knowledge of the fabric topology as well as configuration information such as tls ca certs so the client can trust the servers to hand. I wonder if there could be some way to determine the fabric topology taking into account endorsement policies for example to auto-generate these profiles ?  I did see somewhere that although not a recommended thing to do, organisations could use more than one msp definition and that could also mean more connection profiles to accommodate and wondered if we should have a definition that is flexible enough for this scenario ?  (May not be common enough to warrant extra work or complexity of the solution though)  ></body> </Action>
<Action id="28738" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-07-20 16:19:25.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-20 20:53:07.0"> <body><! CDATA  ~jimthematrix   ~davidkel   ~dshuffma   ~varadatibm  How about the following for a common config, other fields can be {code} { 	"name": "hlfabric", 	"description": "Hyperledger Fabric v1.0", 	"type": "hlfv1", 	"keyvalue-store" : { 		"path" : "/tmp/hfc-kvs" 	}, 	"crypto-store" : { 		"path" : "/tmp/hfc-cvs" 	}, 	"channels" :   		{ 			"name" : "mychannel", 			"orgs" :   "peerOrg1" , "peerOrg2"  , 			"orderers" :   "orderer.example.com"   		} 	 , 	"organizations" :   		{ 			"name" : "peerOrg1", 			"mspid" : "Org1MSP", 			"peers" :   "peer0.org1.example.com"  , 			"cas":   "ca-org1"  , 			"admin": { 				"key": { 					"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/keystore" 				}, 				"cert": { 					"raw" : "---begin cert--- with the 'raw' tag the actual cert will be here not in a file  ----end cert----" 				} 			} 		}, 		{ 			"name" : "peerOrg2", 			"mspid" : "Org2MSP", 			"peers" :   "peer0.org2.example.com"  , 			"cas":   "ca-org2"  , 			"admin": { 				"key": { 					"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/keystore" 				}, 				"cert": { 					"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/signcerts" 				} 			} 		} 	 , 	"orderers":   		{ 			"name" : "orderer.example.com", 			"url" : "grpcs://localhost:7050", 			"connect-options" : { 				"ssl-target-name-override" : "orderer.example.com" 			}, 			"tls_cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tlscacerts/example.com-cert.pem" 			}  		} 	 , 	"peers" :   		{ 			"name" : "peer0.org1.example.com", 			"url" : "grpcs://localhost:7051", 			"event-url" : "grpcs://localhost:7053", 			"connect-options" : { 				"ssl-target-name-override" : "peer0.org1.example.com" 			}, 			"tls_cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem" 			}  		}, 		{ 			"name" : "peer0.org2.example.com", 			"url" : "grpcs://localhost:8051", 			"event-url" : "grpcs://localhost:8053", 			"connect-options" : { 				"ssl-target-name-override" : "peer0.org2.example.com" 			}, 			"tls_cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem" 			}  		} 	 , 	"certificate-authorities" :   		{ 			"name" : "ca-org1", 			"url" : "https://localhost:7054", 			"connect-options" : { 				"verify" : true 			}, 			"tls_cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem" 			}  		}, 		{ 			"name" : "ca-org2", 			"url" : "https://localhost:8054", 			"connect-options" : { 				"verify" : true 			}, 			"tls_cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/ca/org2.example.com-cert.pem" 			}  		} 	  }  {code}  ></body> </Action>
<Action id="28763" issue="19331" author="baohua" type="comment" created="2017-07-21 01:51:34.0" updateauthor="baohua" updated="2017-07-21 01:51:34.0"> <body><! CDATA Thanks for raising this topic, i believe it will be useful for the sdk.  Here are some thoughts:  a. We may need to split the profile at top level into several folds including: # fabric-network part (e.g., the peer, order connection, topology...) # local part (e.g., the crypto/keyvalue-stores...) # metadata part (e.g., name, version...)  b. Whether we need to support multiple profile inside a single file? Or we restrict each file can only support one profile?     Thanks!  ></body> </Action>
<Action id="28797" issue="19331" author="dshuffma" type="comment" created="2017-07-21 14:11:05.0" updateauthor="dshuffma" updated="2017-07-21 14:12:37.0"> <body><! CDATA For the bluemix service I can only provide a single JSON. Having fields that relate to a file path won't work for them.  An easy fix to Bret's example would be that that we could provide the path OR the actual cert. like:  people that want to use a path use: {code} "key": { 	"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/keystore" } {code}  people that can't use: {code} "key": { 		"pem" : "---begin cert--- etc..........." } {code}  also Brett's example does not include *chaincode* data.  some might argue that this is not a network _connection_ field, but since its been instantiated on a particular channel and is running with a specific peer, I feel it is relevant networking data. actually this brings up something else... should _channels_ be nested inside _peers_.  and then we can add a _chaincode_ field inside _channels_.  may have redundant data, but the hierarchy at least shows what is actually going on.  ugh though you may not have joined your peers to a channel yet, so where would that go...   ></body> </Action>
<Action id="28922" issue="19331" author="davidkel" type="comment" created="2017-07-24 19:12:32.0" updateauthor="davidkel" updated="2017-07-25 08:12:51.0"> <body><! CDATA Looking at the proposal I was trying to see how I might perform the various tasks w.r.t Peer selection * Chaincode install: I would want to install only on Endorsing Peers in my organisation, but I don't know from the above which peers are endorsing peers. * Chaincode instantiate: If I used this topology profile, Currently composer would send it to all peers * Chaincode invoke/query: If I used this topology profile, Currently composer would send it to all peers, but for invoke we would only want to send to endorsing peers. * Chaincode query: Composer would send to all peers, but for a query it would seem that you would trust your own peers more than another organisations so maybe only send the query to a single peer in your organisation  I think we need to update the above to declare which Peers are endorsing peers for invoke (if not specified then default to true ?) and I guess some sort of sensible selection of which peer to make a query request to.  Composer connection profiles only need a single channel definition, if the topology profile contains multiple channels then that would be an issue. Do we need to have multiple channel definitions in the document or could it be on a per channel configuration ? If multiple channel definitions are required, then we would really need to download a topology for a single channel and from a client point of view I only see a need for topology of a specific channel. {code:java} tls_cacerts{code} isn't consistent with the other property names, so I think it should be changed to {code:java} tls-cacerts{code} The following definition isn't relevant to fabric topology {code:java}      "keyvalue-store" : {         "path" : "/tmp/hfc-kvs"     },     "crypto-store" : {         "path" : "/tmp/hfc-cvs"     },{code} and is more specific to the client, so node-sdk examples could support the above whereas Composer would want to support an entry that could encapsulate both. So can I propose these examples as suggestions and leave it up to clients to decide {code:java}     "credential-store" : {          "path" : "/path/to/some/dir"     }      "credential-store" : { "keyvalue-path" : "/path/to/some/dir", "crypto-path": "/path/to/some/dir" }        "credential-store" : {          "wallet" : "wallet-name" }{code}  The wallet being something that describes a concept that can be interpreted by the client side such as a Composer client. We would use this to do non file based storing of crypto material eg object storage or database.  As mentioned above, certificates should be embeddable into the connection definition to make them portable. I liked the idea of storing the PEM as base64 encoded rather than as JSON string of "-----Begin Certificate-----\r\n...." as the \r\n has caused confusion. There is other client connection information we would want to specify, such as timeout, grpc message size limits (send/recv) but again these aren't part of the fabric topology but client side and users would need to add them to the profile by hand but would be good to use common definitions again (I don't see this as individual options on peers and orderers as they would apply to all of them in reality) {code:java} "timeout": 300, "max-send-size": 10, "max-recv-size": 15, "organisation" : "peerOrg1"{code}  From a client point of view they need to declare which organisation they are part of, so for example they won't want to register for events from peers in a different organisation (they won't have credentials to do so) also when enrolling a user or importing crypto material they need to specify the associated msp id.  ></body> </Action>
<Action id="29063" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-07-26 20:14:13.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-26 20:27:52.0"> <body><! CDATA The latest sample config {code} { 	"name": "hlfabric", 	"description": "Hyperledger Fabric v1.0", 	"version": "hlfv1", 	"client" : { 		"org" : "Org1", 		"credential-store" : { 			"path" : "/tmp/hfc-kvs", 			"crypto-store" : { 				"path" : "/tmp/hfc-cvs" 			}, 			"wallet" : "wallet-name" 		} 	}, 	"channels" :   		{ 			"name" : "mychannel", 			"orgs" :   "Org1" , "Org2"  , 			"orderers" :   "orderer.example.com"   		} 	 , 	"organizations" :   		{ 			"name" : "Org1", 			"mspid" : "Org1MSP", 			"peers" :   "peer0.org1.example.com"  , 			"cas":   "ca-org1"   		}, 		{ 			"name" : "Org2", 			"mspid" : "Org2MSP", 			"peers" :   "peer0.org2.example.com"  , 			"cas":   "ca-org2"   		} 	 , 	"orderers":   		{ 			"name" : "orderer.example.com", 			"url" : "grpcs://localhost:7050", 			"connection-options" : { 				"ssl-target-name-override" : "orderer.example.com" 			}, 			"tls-cacerts" :  { 				"pem" : "-----BEGIN CERTIFICATE-----\nMIICNDCCAdqgAwIBAgIRAIBOtq8vZiC0+uLSi2MIS4swCgYIKoZIzj0EAwIwZjEL\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\ncmFuY2lzY28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRQwEgYDVQQDEwtleGFtcGxl\nLmNvbTAeFw0xNzA0MjIxMjAyNTZaFw0yNzA0MjAxMjAyNTZaMGYxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRQwEgYDVQQKEwtleGFtcGxlLmNvbTEUMBIGA1UEAxMLZXhhbXBsZS5jb20wWTAT\nBgcqhkjOPQIBBggqhkjOPQMBBwNCAARD2rvgyAmhn8hpu82kAjX3QUg2iqCUPEe1\nQ5CzD5MVv/dK5wrRgkcoMhJLe4HPxYbjV3rodm5Pwi5m3zMGkqNQo2kwZzAOBgNV\nHQ8BAf8EBAMCAaYwGQYDVR0lBBIwEAYEVR0lAAYIKwYBBQUHAwEwDwYDVR0TAQH/\nBAUwAwEB/zApBgNVHQ4EIgQg6q3lkIfG2X/PNQ6U83rZ8saSu2bxghSM5YlA3nCt\n6c4wCgYIKoZIzj0EAwIDSAAwRQIhAL5Lgy7jZ2W74L6i0B23a3JD0W8TSYlTcqXb\nRMSXlLIoAiB2glBl0wM/ITn5+tnHOnq2wrIGuYIiNbLK5oq2zf+gtA==\n-----END CERTIFICATE-----" 			}  		} 	 , 	"peers" :   		{ 			"name" : "peer0.org1.example.com", 			"url" : "grpcs://localhost:7051", 			"event-url" : "grpcs://localhost:7053", 			"connection-options" : { 				"ssl-target-name-override" : "peer0.org1.example.com" 			}, 			"tls-cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem" 			} , 			"endorsing-peer"   : true, 			"chaincode-query" : true, 			"ledger-query"    : true, 			"event-source"    : true 		}, 		{ 			"name" : "peer0.org2.example.com", 			"url" : "grpcs://localhost:8051", 			"event-url" : "grpcs://localhost:8053", 			"connection-options" : { 				"ssl-target-name-override" : "peer0.org2.example.com" 			}, 			"tls-cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem" 			} , 			"endorsing-peer"   : true, 			"chaincode-query" : false, 			"ledger-query"    : true, 			"event-source"    : false 		} 	 , 	"certificate-authorities" :   		{ 			"name" : "ca-org1", 			"url" : "https://localhost:7054", 			"connection-options" : { 				"verify" : true 			}, 			"tls-cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem" 			}  		}, 		{ 			"name" : "ca-org2", 			"url" : "https://localhost:8054", 			"connection-options" : { 				"verify" : true 			}, 			"tls-cacerts" :  { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/ca/org2.example.com-cert.pem" 			}  		} 	  }  {code}  ></body> </Action>
<Action id="29064" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-07-26 20:29:50.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-26 20:29:50.0"> <body><! CDATA We are thinking that  {code} "timeout": 300, "max-send-size": 10, "max-recv-size": 15 {code} are application type settings and should be handled by the NodeSDK's Config settings   ></body> </Action>
<Action id="29080" issue="19331" author="jimthematrix" type="comment" created="2017-07-27 12:39:35.0" updateauthor="jimthematrix" updated="2017-07-27 12:39:35.0"> <body><! CDATA  ~davidkel ,  ~dshuffma  can you please take a look at the latest design and let us know if they would address all your needs?  Note that we didn't include chaincodes because that would not be very useful without actually describing their programming interface, which would start to introduce programmable schemas. That is not the intention of this connection profile. The goal is this common profile is to eliminate common boilerplate code that all applications have to cook up over and over again. Application specific aspects that either can easily be taken care of with the existing SDK capabilities (like app-wide config settings for timeouts or message sizes), or would require introducing programmable schemas, should be handled inside the app code.  ></body> </Action>
<Action id="29089" issue="19331" author="martinc" type="comment" created="2017-07-27 13:48:23.0" updateauthor="martinc" updated="2017-07-27 13:48:23.0"> <body><! CDATA I am interested in this for the REST API proposal I am working on as it too needs to understand which peers etc to communicate with.  I've reviewed the sample config above and can see a potential problem with the channel definition. Currently the channel defines which orgs are involved and then a user would derive which peers are part of the channel from the org definition. However all the peers belonging to one org do not have to be members of the same channel and I do not see how that scenario can be configured with the current proposal.  To solve this I would recommend having an array, "peers":  "peer1", ...   in the channel definition. Optionally the "orgs" could be removed from the channel definition as the "orgs" could be derived from the participating peers.  Some other comments, * As "endorsing-peer" is within the definition of a peer the "-peer" on the end is redundant. * Consider putting the true/false fields into their own variable "roles" or "capabilities"  ></body> </Action>
<Action id="29090" issue="19331" author="martinc" type="comment" created="2017-07-27 13:56:28.0" updateauthor="martinc" updated="2017-07-27 13:56:28.0"> <body><! CDATA At the moment I am concerned that there seems to be a disjoint in the design between clients having static channel configuration and clients also having the ability to dynamically define channels and add new peers to them.   ~jimthematrix  from a conceptual point of view I would like to understand the long term goal here. Is there an intent that this configuration could be queried by a client from "your own" peer? If there is that intent, then I would suggest that the "client" section is moved into it's own file and how certificates are referenced is looked at so that the network configuration is portable between multiple clients.     ></body> </Action>
<Action id="29092" issue="19331" author="davidkel" type="comment" created="2017-07-27 14:16:19.0" updateauthor="davidkel" updated="2017-07-27 14:52:34.0"> <body><! CDATA {code:java} "timeout": 300, "max-send-size": 10, "max-recv-size": 15 {code} regarding these, from a composer point of view they need to be in the connection profile as there is no other way currently for a composer application to control these values and apart from timeout which is a generic concept, the others refer to fabric specific connections. So curious as to why they should go into a different configuration programmatically ? What is the advantage to doing that over maybe putting them in somewhere appropriate in the connection profile  ></body> </Action>
<Action id="29096" issue="19331" author="davidkel" type="comment" created="2017-07-27 14:44:43.0" updateauthor="davidkel" updated="2017-07-27 14:44:43.0"> <body><! CDATA  {code:java} "endorsing-peer"   : true, "chaincode-query" : true, "ledger-query"    : true, "event-source"    : true {code} I am assuming that if any of these are not specified then they default to true ?  ></body> </Action>
<Action id="29101" issue="19331" author="ianj_mitchell@uk.ibm.com" type="comment" body=" ~davidkel  - I&apos;m struggling with how we know this characteristic &apos;endorsing-peer&apos; when just talking to the Fabric to establish the set of peers. Isn&apos;t that dependent on which peers are in which channels and how the endorsement policy has been defined? You mentioned you&apos;d need to know which peers are endorsers so that chain code can be deployed/installed/instantiated... isn&apos;t it the other way around in that the ability to be an endorser is dependent on having the chain code and being in the endorsement policy?" created="2017-07-27 15:36:19.0" updateauthor="ianj_mitchell@uk.ibm.com" updated="2017-07-27 15:36:19.0"/>
<Action id="29102" issue="19331" author="davidkel" type="comment" body="So from the above I was wondering if we could define what is mandatory and optional in this connection profile ? for example I don&apos;t expect the credential store to be mandatory as we might create some default for where it isn&apos;t specified and directly define it in the client object once instantiated." created="2017-07-27 15:43:30.0" updateauthor="davidkel" updated="2017-07-27 15:43:30.0"/>
<Action id="29103" issue="19331" author="rickr" type="comment" created="2017-07-27 15:46:30.0" updateauthor="rickr" updated="2017-07-27 15:46:30.0"> <body><! CDATA I'm not keen on adding these properties even optionally endorsing-peer, chaincode-query, ledger-peer as they are not strictly needed for creating connections and channels.  This is more like meta data on how the application intends to use those peers.     ></body> </Action>
<Action id="29104" issue="19331" author="rickr" type="comment" body="Think there should be added a top level *version* property so we can in the future bump it up for non compatible updates and the client reading it can better know how to deal with it." created="2017-07-27 15:49:08.0" updateauthor="rickr" updated="2017-07-27 15:49:08.0"/>
<Action id="29106" issue="19331" author="rickr" type="comment" body="In the client section I see *credential-store* I don&apos;t believe this is specific to constructing channels, peers etc.  Isn&apos;t this something specific to the clients configuration ?" created="2017-07-27 15:58:21.0" updateauthor="rickr" updated="2017-07-27 15:58:21.0"/>
<Action id="29107" issue="19331" author="davidkel" type="comment" created="2017-07-27 16:09:07.0" updateauthor="davidkel" updated="2017-07-27 16:09:07.0"> <body><! CDATA  ~ianj_mitchell@uk.ibm.com  I am not totally familar with Peer configuration. I have seen in the past an environment variable dictating whether a Peer is an endorser or not but they not exist for 1.0 any more, but a peer with chaincode installed doesn't have to be an endorser, it could be just for queries. As far as I know endorsement is at an organisation level rather than a peer level ? I am taking the selfish view of mentioning the kind of metadata the connection profile might need in order for composer to try to make decisions on what a peer's role is, for example which peers should have chaincode installed, which peer to send the instantiate request to, which peers to send a transaction to and which peers to send a query request to.   ></body> </Action>
<Action id="29108" issue="19331" author="rickr" type="comment" body="Conversation with  ~jimthematrix  is that these documents would not be shareable between the SDKs.  The *client* section is specific to an SDK implementation.  A connection profile that is written for the Node SDK if given to Java, GO. etc _could_ fail because it does not recognize how to deal with *client* section properties. " created="2017-07-27 16:25:18.0" updateauthor="rickr" updated="2017-07-27 16:25:18.0"/>
<Action id="29109" issue="19331" author="rickr" type="comment" created="2017-07-27 16:32:05.0" updateauthor="rickr" updated="2017-07-27 16:32:05.0"> <body><! CDATA I think for a specific connection like a peer there is only one tls certificate to specify not sure why this is a collection     ?  "tls-cacerts" :  \{  }   ></body> </Action>
<Action id="29110" issue="19331" author="rickr" type="comment" body="Nit pick: but *cas*  are like links to items in *certificate-authorities*   I think the should be *certificate-authority*. Same for orgs organizations. " created="2017-07-27 16:41:44.0" updateauthor="rickr" updated="2017-07-27 16:41:44.0"/>
<Action id="29113" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-07-27 18:56:17.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-27 18:58:08.0"> <body><! CDATA Here is another try at the configuration -- renamed org to organization -- renamed orgs to organizations -- renamed cas to certificate-authorities -- tls-cacerts is no longer a collection -- expanded organizations under channel to have role settings, which aligns well with how fabric uses MSPs for access -- removed role settings from the peers since these really are channel specific -- version was in the previous sample so no change for that comment -- would like to address the timeout and max send/receive, where should they be kept, what level, are they set on per connection, overall application, per channel ? {code} { 	"name": "hlfabric", 	"description": "Hyperledger Fabric v1.0", 	"version": "hlfv1", 	"client" : { 		"organization" : "Org1", 		"credential-store" : { 			"path" : "/tmp/hfc-kvs", 			"crypto-store" : { 				"path" : "/tmp/hfc-cvs" 			}, 			"wallet" : "wallet-name" 		} 	}, 	"channels" :   		{ 			"name" : "mychannel", 			"orderers" :   "orderer.example.com"  , 			"organizations" :   				{  					"name" : "Org1", 					"endorsing-peer"   : true, 					"chaincode-query" : true, 					"ledger-query"    : true, 					"event-source"    : true  				}, 				{ 					"name" : "Org2", 					"endorsing-peer"   : true, 					"chaincode-query" : false, 					"ledger-query"    : true, 					"event-source"    : false 				} 			  		} 	 , 	"organizations" :   		{ 			"name" : "Org1", 			"mspid" : "Org1MSP", 			"peers" :   "peer0.org1.example.com"  , 			"certificate-authorities":   "ca-org1"   		}, 		{ 			"name" : "Org2", 			"mspid" : "Org2MSP", 			"peers" :   "peer0.org2.example.com"  , 			"certificate-authorities":   "ca-org2"   		} 	 , 	"orderers":   		{ 			"name" : "orderer.example.com", 			"url" : "grpcs://localhost:7050", 			"connection-options" : { 				"ssl-target-name-override" : "orderer.example.com" 			}, 			"tls-cacerts" : { 				"pem" : "-----BEGIN CERTIFICATE-----\nMIICNDCCAdqgAwIBAgIRAIBOtq8vZiC0+uLSi2MIS4swCgYIKoZIzj0EAwIwZjEL\nMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNhbiBG\ncmFuY2lzY28xFDASBgNVBAoTC2V4YW1wbGUuY29tMRQwEgYDVQQDEwtleGFtcGxl\nLmNvbTAeFw0xNzA0MjIxMjAyNTZaFw0yNzA0MjAxMjAyNTZaMGYxCzAJBgNVBAYT\nAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQHEw1TYW4gRnJhbmNpc2Nv\nMRQwEgYDVQQKEwtleGFtcGxlLmNvbTEUMBIGA1UEAxMLZXhhbXBsZS5jb20wWTAT\nBgcqhkjOPQIBBggqhkjOPQMBBwNCAARD2rvgyAmhn8hpu82kAjX3QUg2iqCUPEe1\nQ5CzD5MVv/dK5wrRgkcoMhJLe4HPxYbjV3rodm5Pwi5m3zMGkqNQo2kwZzAOBgNV\nHQ8BAf8EBAMCAaYwGQYDVR0lBBIwEAYEVR0lAAYIKwYBBQUHAwEwDwYDVR0TAQH/\nBAUwAwEB/zApBgNVHQ4EIgQg6q3lkIfG2X/PNQ6U83rZ8saSu2bxghSM5YlA3nCt\n6c4wCgYIKoZIzj0EAwIDSAAwRQIhAL5Lgy7jZ2W74L6i0B23a3JD0W8TSYlTcqXb\nRMSXlLIoAiB2glBl0wM/ITn5+tnHOnq2wrIGuYIiNbLK5oq2zf+gtA==\n-----END CERTIFICATE-----" 			} 		} 	 , 	"peers" :   		{ 			"name" : "peer0.org1.example.com", 			"url" : "grpcs://localhost:7051", 			"event-url" : "grpcs://localhost:7053", 			"connection-options" : { 				"ssl-target-name-override" : "peer0.org1.example.com" 			}, 			"tls-cacerts" : { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem" 			} 		}, 		{ 			"name" : "peer0.org2.example.com", 			"url" : "grpcs://localhost:8051", 			"event-url" : "grpcs://localhost:8053", 			"connection-options" : { 				"ssl-target-name-override" : "peer0.org2.example.com" 			}, 			"tls-cacerts" : { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem" 			} 		} 	 , 	"certificate-authorities" :   		{ 			"name" : "ca-org1", 			"url" : "https://localhost:7054", 			"connection-options" : { 				"verify" : true 			}, 			"tls-cacerts" : { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem" 			} 		}, 		{ 			"name" : "ca-org2", 			"url" : "https://localhost:8054", 			"connection-options" : { 				"verify" : true 			}, 			"tls-cacerts" : { 				"path" : "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/ca/org2.example.com-cert.pem" 			} 		} 	  }  {code}  ></body> </Action>
<Action id="29123" issue="19331" author="sstone1" type="comment" created="2017-07-28 00:58:48.0" updateauthor="sstone1" updated="2017-07-28 00:59:03.0"> <body><! CDATA  ~harrisob@us.ibm.com  I think we should be careful about combining the "type" : "hlfv1" property we had at the start and the "version" property.  The "type" property is information used by Composer to know which "Blockchain connector module" we need to load in order to handle the connection profile. In the current case this is "hlfv1" for Fabric v1.0, "embedded" for the embedded runtime, and "web" for the web runtime. However in the future we might end up with a wide range of these connector modules for other Blockchain platforms, for example "hlsv1" for Sawtooth or "corda6" for Corda.  Ideally we would only have a Blockchain connector module for each major version of the Blockchain client SDK (in this case, fabric-client). I want to avoid a "hlfv11" connector, a "hlfv12" connector, etc. That means the "v1" in "hlfv1" refers to fabric-client v1.x.  The version  ~rickr  refers to sounds like the version of the connection profile format used by fabric-client. You might support connection profile versions "1.0", "2.0", "3.0" all in the life cycle of fabric-client v1.x.  TL; DR - we should keep the target Fabric version and the version of the connection profile format as separate properties.  So I would suggest that you have (a Fabric v1.x connection profile, using v4 of the connection profile format): {code:java} "type": "hlfv1" "version": "4.0"{code} The next question for me is what is going on with these properties: {code:java}     "credential-store" : {          "path" : "/path/to/some/dir"     }      "credential-store" : { "keyvalue-path" : "/path/to/some/dir", "crypto-path": "/path/to/some/dir" }        "credential-store" : {          "wallet" : "wallet-name" } {code} What will the fabric-client actually do with the "wallet" property? It's not clear.  FYI - in Composer our keyValStore property sucks for two reasons. 1) nobody knows what a "keyValStore" is, and 2) you have to enter an absolute path. The problem with 2) is that it makes it impossible to move connection profiles between systems which is a common pain point for our users.  Our plan for the "wallet" property in the Composer connection profiles was for it to be optional and for the "wallet" property to default to the name of the connection profile, and for Composer to generate a file system path from the "wallet" property in the users home directory.  For example, "wallet": "foo" would resolve to "wallet": "/Users/sstone1/.composer-wallets/foo". I can then send my connection profile to Dave, and on his system it resolves to "wallet": "C:\dave\.composer-wallets\foo". Dave doesn't have to edit it.  Finally, I'm not sure what kind of validation code you guys are planning on adding, but I strongly recommend that we take a page out of the Swagger book and allow applications to add extra properties to the connection profile format. In Swagger , applications can add any properties they like to a Swagger document, as long as they start with "x-" and any standards compliant Swagger parser will just ignore the "x-" properties.  For example: {code:java} "peer1": { "requests": "grpcs://localhost:7051", "events": "grpcs://localhost:7053", "server-hostname": "peer0.org1.example.com", "tls_cacerts": "peer0.org1.example.com/tls/ca.crt", "x-composer-endorser": true }{code}  It will allow us (Composer) to enhance the connection profile format with additional Composer specific fields if we deem it useful and you guys don't - there is some debate about the "roles" properties above - and the fabric-client can just ignore those properties and move on.  ></body> </Action>
<Action id="29137" issue="19331" author="dshuffma" type="comment" created="2017-07-28 12:02:44.0" updateauthor="dshuffma" updated="2017-07-28 15:05:53.0"> <body><! CDATA I took a stab at it. building off of Bret's and including some of Simons suggestions.  {code} { 	"name": "hlfabric", 	"description": "Hyperledger Fabric v1.0", "type": "hlf", 	"hlf": "^1.0.0", 	"version": "v4.0", 	"client": { 		"organization": "Org1", 		"credentialStore": { 			"path": "/tmp/hfc-kvs", 			"cryptoStore": { 				"path": "/tmp/hfc-cvs" 			}, 			"wallet": "wallet-name" 		} 	}, 	"channels": { 		"mychannel": { 			"orderers":   				"orderer.example.com" 			 , 			"organizations":   				{ 					"name": "Org1", 					"endorsingPeer": true, 					"chaincodeQuery": true, 					"ledgerQuery": true, 					"eventSource": true 				}, 				{ 					"name": "Org2", 					"endorsingPeer": true, 					"chaincodeQuery": false, 					"ledgerQuery": true, 					"eventSource": false 				} 			 , 			"chaincode": { 				"id": "example02", 				"version": "v1" 			}, 			"block_delay": 1000 		} 	}, 	"organizations": { 		"Org1": { 			"mspid": "Org1MSP", 			"peers":   				"peer0.org1.example.com" 			 , 			"certificateAuthorities":   				"ca-org1" 			 , 			"users":   				{ 					"enrollId": "admin", 					"enrollSecret": "adminpw" 				} 			 , 			"adminPrivateKeyPEM": "-----BEGIN PRIVATE KEY----- <etc>", 			"signedCertPEM": "-----BEGIN CERTIFICATE----- <etc>" 		}, 		"Org2": { 			"mspid": "Org2MSP", 			"peers":   				"peer0.org2.example.com" 			 , 			"certificateAuthorities":   				"ca-org2" 			 , 			"users":   				{ 					"enrollId": "admin2", 					"enrollSecret": "admin2pw" 				} 			 , 			"adminPrivateKeyPEM": "-----BEGIN PRIVATE KEY----- <etc>", 			"signedCertPEM": "-----BEGIN CERTIFICATE----- <etc>" 		} 	}, 	"orderers": { 		"orderer.example.com": { 			"url": "grpcs://localhost:7050", 			"connectionOptions": { 				"sslTargetNameOverride": "orderer.example.com" 			}, 			"tlsCaCerts": { 				"pem": "-----BEGIN CERTIFICATE----- <etc>" 			} 		} 	}, 	"peers": { 		"peer0.org1.example.com": { 			"url": "grpcs://localhost:7051", 			"eventUrl": "grpcs://localhost:7053", 			"connectionOptions": { 				"sslTargetNameOverride": "peer0.org1.example.com" 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem" 			}, 			"channels":   				"mychannel" 			  		}, 		"peer0.org2.example.com": { 			"url": "grpcs://localhost:8051", 			"eventUrl": "grpcs://localhost:8053", 			"connectionOptions": { 				"sslTargetNameOverride": "peer0.org2.example.com" 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem" 			}, 			"channels":    		} 	}, 	"certificateAuthorities": { 		"ca-org1": { 			"url": "https://localhost:7054", 			"connectionOptions": { 				"verify": true 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem" 			} 		} 	} } {code}  Changes: - hf compatibility version uses npm syntax - removed many array fields in favor of a dictionary. moved the "name" field to be the key. should be easier to look things up. - added channels array in peers field to show that this peer has joined this channel - camel case instead of dashes, b/c JS - added chaincode filed to channel's instance to show what chaincode is available on the channel - added block delay to channels field, should be used to set timeouts of when to expect a block to be cut. - added enroll ids section called "users" to org instances - added admin private key PEM and cert PEM fields to org instances (these are need to install/instantiate cc)  On this pass I didn't remove anything on purpose, so if a field is gone that was by accident.    ></body> </Action>
<Action id="29142" issue="19331" author="sstone1" type="comment" body="Composer needs to be able to look at the JSON document and read a generic property to see if it&apos;s a Hyperledger Fabric connection profile, or a connection profile for something else - hence the need for the &quot;type&quot; property. I know it may seem redundant to you guys, but please don&apos;t remove it!" created="2017-07-28 13:19:23.0" updateauthor="sstone1" updated="2017-07-28 13:19:23.0"/>
<Action id="29143" issue="19331" author="dshuffma" type="comment" body=" ~sstone1  I did not remove the &quot;type&quot; but I&apos;m suggesting to rename it to &quot;hf&quot; and to use npm like versioning.  so &quot;^1.0.0&quot; would be equal to your &quot;hfv1&quot; (unless i&apos;m missing something).  I agree with your main concern that we should use a scheme that would allow us to NOT need to detect all the variations explicitly. ie hf v1.0.0 / hf v1.0.1." created="2017-07-28 14:11:55.0" updateauthor="dshuffma" updated="2017-07-28 14:12:25.0"/>
<Action id="29144" issue="19331" author="sstone1" type="comment" created="2017-07-28 14:35:11.0" updateauthor="sstone1" updated="2017-07-28 14:35:11.0"> <body><! CDATA  ~dshuffma  you removed the generic property (i.e. a non Hyperledger Fabric specific property) that Composer can use to determine what Blockchain framework the connection profile is targeting.  I would suggest: {code:java} "type" : "hlf" "hlf"  : "^1.0.1"{code}  ></body> </Action>
<Action id="29145" issue="19331" author="dshuffma" type="comment" body="Oh, whoops. I see now. I edited my last json blob above." created="2017-07-28 15:07:33.0" updateauthor="dshuffma" updated="2017-07-28 15:07:33.0"/>
<Action id="29149" issue="19331" author="harrisob@us.ibm.com" type="comment" body="The connection options will be used as is , passed directly in, thus allowing any custom settings to be added. So they name will have to be the name used by the package doing the connection. With the peer and orderer connections over GRPCS we need the &apos;ssl-target-name-override&apos; setting." created="2017-07-28 18:07:16.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-28 18:07:16.0"/>
<Action id="29150" issue="19331" author="harrisob@us.ibm.com" type="comment" body="For path settings do we want to have the ability to have environment or other variable values within the path ... something like {code} ${TEMPDIR}/certs/my.pem {code}" created="2017-07-28 18:10:07.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-28 18:11:09.0"/>
<Action id="29151" issue="19331" author="dshuffma" type="comment" created="2017-07-28 18:46:32.0" updateauthor="dshuffma" updated="2017-07-28 18:46:32.0"> <body><! CDATA  ~harrisob@us.ibm.com  well I have a small issue with that logic. if the point of us is to make an easy to use format we shouldn't be constrained by minor technical under the cover impacts.  why should we break consistency b/c we don't want to map "sslTargetNameOveride" to "ssl-target-name-override" .  I get your point, that you are expecting to be able to dump "connectionOptions" straight into  your gRPC lib, but.... we can still dump the object and translate this key. I dunno, I guess its not a big deal if we want to keep the dashes too.  thoughts?  as for paths I don't have a need for variables, but not sure if others need it.  though if we set a relative path...are they relative to THIS connection profile file?  ></body> </Action>
<Action id="29155" issue="19331" author="harrisob@us.ibm.com" type="comment" body="I was hoping to use the Node &apos;path&apos; package which builds absolute paths from where node is started. So if we make the relativity to somewhere else, we all will have to agree on it so the SDKs can manually calculate the absolute path." created="2017-07-28 19:57:03.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-28 19:57:03.0"/>
<Action id="29156" issue="19331" author="jimthematrix" type="comment" body=" ~dshuffma  I agree with  ~harrisob@us.ibm.com  on the naming rules for the &quot;connectionOptions&quot;, the names are defined by gRPC so it&apos;ll be awkward and error-prone to ask developers to lookup a property in gRPC doc (say, grpc-max-send-message-length) and translate that to a camel case string in order to set properly in the JSON. the most straightforward approach is to keep this section &quot;special&quot; in the naming. Maybe change the name &quot;connectionOptions&quot; to &quot;grpcOptions&quot; to make it more explicit?" created="2017-07-28 20:02:12.0" updateauthor="jimthematrix" updated="2017-07-28 20:02:50.0"/>
<Action id="29157" issue="19331" author="jimthematrix" type="comment" created="2017-07-28 20:11:27.0" updateauthor="jimthematrix" updated="2017-07-28 20:12:19.0"> <body><! CDATA  ~sstone1 ,  ~dshuffma  for the type and version, how about a more npm flavor, so instead of  {code} "type": "hlf", "hlf": "^1.0.0" {code} use a single property: {code} "type": "hlf@^1.0.0" {code} it's more compact and is easier to write and parse. version should be optional.  ></body> </Action>
<Action id="29159" issue="19331" author="dshuffma" type="comment" created="2017-07-28 20:42:38.0" updateauthor="dshuffma" updated="2017-07-28 20:42:38.0"> <body><! CDATA I disagree on the dash vs camel case, but I don't strongly care. why would someone lookup the RFC gRPC doc...?, did you guys look up the RFC for HTTP when you interfaced with an HTTP lib or did you just look at the documentation for the lib you are using... at any rate, I won't hold this up just for that, lets use "grpcOptions" and this object can keep its dashes.  {code} { 	"name": "hlfabric", 	"description": "Hyperledger Fabric v1.0", "type": "hlf@^1.0.0", 	"version": "v4.0", 	"client": { 		"organization": "Org1", 		"credentialStore": { 			"path": "/tmp/hfc-kvs", 			"cryptoStore": { 				"path": "/tmp/hfc-cvs" 			}, 			"wallet": "wallet-name" 		} 	}, 	"channels": { 		"mychannel": { 			"orderers":   				"orderer.example.com" 			 , 			"organizations":   				{ 					"name": "Org1", 					"endorsingPeer": true, 					"chaincodeQuery": true, 					"ledgerQuery": true, 					"eventSource": true 				}, 				{ 					"name": "Org2", 					"endorsingPeer": true, 					"chaincodeQuery": false, 					"ledgerQuery": true, 					"eventSource": false 				} 			 , 			"chaincode": { 				"id": "example02", 				"version": "v1" 			}, 			"block_delay": 1000 		} 	}, 	"organizations": { 		"Org1": { 			"mspid": "Org1MSP", 			"peers":   				"peer0.org1.example.com" 			 , 			"certificateAuthorities":   				"ca-org1" 			 , 			"users":   				{ 					"enrollId": "admin", 					"enrollSecret": "adminpw" 				} 			 , 			"adminPrivateKeyPEM": "-----BEGIN PRIVATE KEY----- <etc>", 			"signedCertPEM": "-----BEGIN CERTIFICATE----- <etc>" 		}, 		"Org2": { 			"mspid": "Org2MSP", 			"peers":   				"peer0.org2.example.com" 			 , 			"certificateAuthorities":   				"ca-org2" 			 , 			"users":   				{ 					"enrollId": "admin2", 					"enrollSecret": "admin2pw" 				} 			 , 			"adminPrivateKeyPEM": "-----BEGIN PRIVATE KEY----- <etc>", 			"signedCertPEM": "-----BEGIN CERTIFICATE----- <etc>" 		} 	}, 	"orderers": { 		"orderer.example.com": { 			"url": "grpcs://localhost:7050", 			"grpcOptions": { 				"ssl-target-name-override": "orderer.example.com" 			}, 			"tlsCaCerts": { 				"pem": "-----BEGIN CERTIFICATE----- <etc>" 			} 		} 	}, 	"peers": { 		"peer0.org1.example.com": { 			"url": "grpcs://localhost:7051", 			"eventUrl": "grpcs://localhost:7053", 			"grpcOptions": { 				"ssl-target-name-override": "peer0.org1.example.com" 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem" 			}, 			"channels":   				"mychannel" 			  		}, 		"peer0.org2.example.com": { 			"url": "grpcs://localhost:8051", 			"eventUrl": "grpcs://localhost:8053", 			"grpcOptions": { 				"ssl-target-name-override": "peer0.org2.example.com" 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem" 			}, 			"channels":    		} 	}, 	"certificateAuthorities": { 		"ca-org1": { 			"url": "https://localhost:7054", 			"grpcOptions": { 				"verify": true 			}, 			"tlsCaCerts": { 				"path": "test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem" 			} 		} 	} } {code}  ></body> </Action>
<Action id="29165" issue="19331" author="jimthematrix" type="comment" created="2017-07-29 03:42:47.0" updateauthor="jimthematrix" updated="2017-07-31 15:35:46.0"> <body><! CDATA I made another pass and made a few changes. Also I changed the sample to YAML format so that documentation can be included inline, which I feel can clarify a lot of questions. YAML and JSON are directly translatable, you can use an online converter to easily go back and forth. This can also be used as the basis for the API doc of this connection document.  I removed block-delay from the schema, it's readily query-able via SDK APIs for channel config.  {code} --- # # The network connection profile provides client applications the information about the target # blockchain network that are necessary for the applications to interact with it. These are all  # knowledge that must be acquired from out-of-band sources. This file provides such a source. # name: "global-trade-network"  # # Describes the type of the backend, "hl-fabric" for Hyperledger Fabric, "hl-stl" for Hyperledger  # Sawtooth Lake, etc. #  # The version string after the @ is following semver rules, describing the  # version range supported by this profile. eg. "hl-fabric@0.6.x" is for a network of HL Fabric 0.6  # nodes, including all the patch versions. "hl-fabric@^1.0.0" is for HL Fabric 1.0 including all # the minor versions (1.1.x, 1.2.x, etc.). The specific parsing rules can be SDK specific: node  # SDK should follow the npm semver support by supporting short-hand strings like "~0.6.0" or  # "0.6.x" for "0.6 and all patch versions", "^1.0" or "1.x" for "1.0 and all minor versions"; gradle # or maven for java have various plugins # type: "hl-fabric@1.0.x" description: "The network to be in if you want to stay in the global trade business" version: v4.0  # # The client section is SDK-specific. The sample below is for the node.js SDK # client: # Which organization does this application instance belong to? The value is the name of an org # defined under "organizations" organization: Org1  # Since the node.js SDK supports pluggable KV stores, the properties under "credentialStore"  # are implementation specific credentialStore: # Specific to FileKeyValueStore.js. Can be others if using an alternative impl. For instance,  # CouchDBKeyValueStore.js would require an object here for properties like url, db name, etc. path: "/tmp/hfc-kvs"  # Specific to the CryptoSuite implementation. Software-based implementations like  # CryptoSuite_ECDSA_AES.js requires a key store. PKCS#11 based implementations does  # not. cryptoStore: # Specific to the underlying KeyValueStore that backs the crypto key store.  path: "/tmp/hfc-cvs"  # Specific to Composer environment wallet: wallet-name  # # Optional but most apps would have this section so that channel objects can be constructed  # based on the content below. If an app is creating channels, then it likely will not need this  # section. # channels: # name of the channel mychannel: # Required. list of orderers designated by the application to use for transactions on this  # channel. This list can be a result of access control ("org1" can only access "ordererA"), or  # operational decisions to share loads from applications among the orderers.  The values must  # be "names" of orgs defined under "organizations/peers" orderers: - orderer.example.com  # Required. list of peers from participating orgs peers: peer0.org1.example.com: # Optional. will this peer be sent transaction proposals for endorsement? The peer must  # have the chaincode installed. The app can also use this property to decide which peers  # to send the chaincode install request. Default: true endorsingPeer: true  # Optional. will this peer be sent query proposals? The peer must have the chaincode # installed. The app can also use this property to decide which peers to send the  # chaincode install request. Default: true chaincodeQuery: true  # Optional. will this peer be sent query proposals that do not require chaincodes, like  # queryBlock(), queryTransaction(), etc. Default: true ledgerQuery: true  # Optional. will this peer be the target of the SDK's listener registration? All peers can  # produce events but the app typically only needs to connect to one to listen to events.  # Default: true eventSource: true  peer0.org2.example.com: endorsingPeer: true chaincodeQuery: false ledgerQuery: true eventSource: false  # Optional. what chaincodes are expected to exist on this channel? The application can use # this information to validate that the target peers are in the expected state by comparing # this list with the query results of getInstalledChaincodes() and getInstantiatedChaincodes() chaincodes: # the format follows the "cannonical name" of chaincodes by fabric code - example02:v1 - marbles:1.0  # # list of participating organizations in this network # organizations: Org1: mspid: Org1MSP  peers: - peer0.org1.example.com - peer1.org1.example.com  # Optional. Certificate Authorities issue certificates for identification purposes in a Fabric based # network. Typically certificates provisioning is done in a separate process outside of the  # runtime network. Fabric-CA is a special certificate authority that provides a REST APIs for  # dynamic certificate management (enroll, revoke, re-enroll). The following section is only for  # Fabric-CA servers. certificateAuthorities: - ca-org1  # Optional. If the application is going to make requests that are reserved to organization  # administrators, including creating/updating channels, installing/instantiating chaincodes, it  # must have access to the admin identity represented by the private key and signing certificate.  # Both properties can be the PEM string or local path to the PEM file adminPrivateKeyPEM: "-----BEGIN PRIVATE KEY----- <etc>" signedCertPEM: "-----BEGIN CERTIFICATE----- <etc>"  # the profile will contain public information about organizations other than the one it belongs to.  # These are necessary information to make transaction lifecycles work. including MSP IDs and  # peers with a public URL to send transaction proposals. The file will not contain private  # information reserved for members of the organization, such as admin key and certificate,  # fabric-ca registrar enroll ID and secret, etc. Org2: mspid: Org2MSP peers: - peer0.org2.example.com  # # List of orderers to send transaction and channel create/update requests to. For the time # being only one orderer is needed. If more than one is defined, which one get used by the # SDK is implementation specific. Consult each SDK's documentation for its handling of orderers. # orderers: orderer.example.com: url: grpcs://localhost:7050  # these are standard properties defined by the gRPC library # they will be passed in as-is to gRPC client constructor grpcOptions: ssl-target-name-override: orderer.example.com grpc-max-send-message-length: 15  tlsCACerts: pem: "-----BEGIN CERTIFICATE----- <etc>"  # # List of peers to send various requests to, including endorsement, query # and event listener registration. # peers: peer0.org1.example.com: # this URL is used to send endorsement and query requests url: grpcs://localhost:7051  # this URL is used to connect the EventHub and registering event listeners eventUrl: grpcs://localhost:7053  grpcOptions: ssl-target-name-override: peer0.org1.example.com grpc.http2.keepalive_time: 15  tlsCACerts: path: peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem  peer0.org2.example.com: url: grpcs://localhost:8051 eventUrl: grpcs://localhost:8053 grpcOptions: ssl-target-name-override: peer0.org2.example.com tlsCACerts: path: peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem  # # Fabric-CA is a special kind of Certificate Authority provided by Hyperledger Fabric which allows  # certificate management to be done via REST APIs. Application may choose to use a standard  # Certificate Authority instead of Fabric-CA, in which case this section would not be specified. # certificateAuthorities: ca-org1: url: https://localhost:7054 # the properties specified under this object are passed to the 'http' client verbatim when # making the request to the Fabric-CA server httpOptions: verify: true tlsCACerts: path: peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem  # Fabric-CA supports dynamic user enrollment via REST APIs. A "root" user, a.k.a registrar, is  # needed to enroll and invoke new users. registrar: - enrollId: admin enrollSecret: adminpw {code}  ></body> </Action>
<Action id="29170" issue="19331" author="harrisob@us.ibm.com" type="comment" body=" ~jimthematrix  line 78, missing &apos;:&apos;" created="2017-07-29 14:57:29.0" updateauthor="harrisob@us.ibm.com" updated="2017-07-29 14:57:29.0"/>
<Action id="29210" issue="19331" author="dshuffma" type="comment" body="I see you shuffled some fields around, no complaints though. this looks good to me." created="2017-07-30 22:11:51.0" updateauthor="dshuffma" updated="2017-07-30 22:11:51.0"/>
<Action id="29212" issue="19331" author="jimthematrix" type="comment" body=" ~harrisob@us.ibm.com  good catch. Edited the yaml to add the fix." created="2017-07-31 02:29:51.0" updateauthor="jimthematrix" updated="2017-07-31 02:29:51.0"/>
<Action id="29214" issue="19331" author="martinc" type="comment" created="2017-07-31 09:08:38.0" updateauthor="martinc" updated="2017-07-31 09:08:38.0"> <body><! CDATA I like the updates that have been made, I think they add more flexibility. I do have some further suggestions.  At the moment the document serves 2 roles, one is defining the network which is common across all clients, and the second is configuring a specific client instance. I propose splitting this file by having the client configuration in a file that references another file containing the network definition configuration.  The scenarios having this split would make better are: * Network changes (new peer, org etc) => only need to update one shared file. * Deploying multiple clients => should be faster and less error prone because network config is common.  The split would also reduce the risk of accidental exposure of private client configuration (such as a private key) when sharing the network definition with another team that is developing a new client for the same network.  ></body> </Action>
<Action id="29227" issue="19331" author="davidkel" type="comment" body="As iterated by Simon, we use the type to determine which connector to load, it&apos;s not related to the version of the connection profile syntax so we would not want it to be merged into 1 field." created="2017-07-31 13:14:06.0" updateauthor="davidkel" updated="2017-07-31 13:14:06.0"/>
<Action id="29231" issue="19331" author="rickr" type="comment" body="Can we avoid npm versioning (Node).. This should be SDK independent." created="2017-07-31 13:42:12.0" updateauthor="rickr" updated="2017-07-31 13:42:12.0"/>
<Action id="29233" issue="19331" author="rickr" type="comment" created="2017-07-31 13:49:22.0" updateauthor="rickr" updated="2017-07-31 13:49:22.0"> <body><! CDATA The version as other have stated I thought should be the the specification of the document itself. In this case I would think all it should be is *version: "1.0.0"*  ></body> </Action>
<Action id="29235" issue="19331" author="rickr" type="comment" body="Under peers : endorsingPeer, chaincodeQuery, eventSource  should be optional." created="2017-07-31 13:53:23.0" updateauthor="rickr" updated="2017-07-31 13:53:23.0"/>
<Action id="29236" issue="19331" author="rickr" type="comment" body="Why are there grpcOptions under _certificateAuthorities_ entities?    Are these not http connections ?" created="2017-07-31 13:58:01.0" updateauthor="rickr" updated="2017-07-31 13:58:01.0"/>
<Action id="29238" issue="19331" author="rickr" type="comment" body="I don&apos;t have a clear understanding what the SDK is to do with the _chaincodes_ section ?  If the chaincodes are not there on the channel throw an exception ?" created="2017-07-31 14:10:49.0" updateauthor="rickr" updated="2017-07-31 14:10:49.0"/>
<Action id="29246" issue="19331" author="jimthematrix" type="comment" created="2017-07-31 15:27:12.0" updateauthor="jimthematrix" updated="2017-07-31 15:27:12.0"> <body><! CDATA  ~MartinC  I agree with your suggestion to support having the network vs. client portions in separate files. But I think the way to make that work is by allowing files that contain partial information (either with only the network portion, or only the client portion) to be loaded separately and have accumulative effect on the client instance configuration. Having a pointer from the client file to the network connection file can be difficult because we can't always assume these are saved in files (the SDKs should use a JSON (or yaml) object as the input to be flexible for different usage situations).   So I would suggest it work like the following: - have a JSON/yaml object or file for the network portion (orgs, orderers, peers, channels), let's call it "networkConfig" - have a separate object or file for the client portion (client), "clientConfig" {code} var myclient = Client.loadFromConfig(networkConfig); myclient.loadFromConfig(clientConfig); {code}  the two separate loadFromConfig() calls are additive (that's why the 2nd call must be done from the instance object). The order to load from networkConfig and clientConfig should not matter, as long as the referenced objects as either described in the config itself or have been loaded into the instance.  ></body> </Action>
<Action id="29247" issue="19331" author="jimthematrix" type="comment" body=" ~davidkel ,  ~rickr  I clarified the intention of the &quot;type&quot; property my modifying the YAML above. that should address both of your questions. basically the &quot;type&quot; field describes the backend only (for Dave&apos;s question) and it only requires following the semver rules and defers specific parsing rules to each SDK (for Rick&apos;s question)." created="2017-07-31 15:29:12.0" updateauthor="jimthematrix" updated="2017-07-31 15:29:12.0"/>
<Action id="29248" issue="19331" author="jimthematrix" type="comment" body=" ~rickr  I modified the YAML above to address your other questions/comments. thanks." created="2017-07-31 15:36:31.0" updateauthor="jimthematrix" updated="2017-07-31 15:36:31.0"/>
<Action id="29249" issue="19331" author="dshuffma" type="comment" created="2017-07-31 15:40:50.0" updateauthor="dshuffma" updated="2017-07-31 15:43:27.0"> <body><! CDATA  ~davidkel  please propose what you want "type" to be. if this is truly composer specific. maybe we should omit it from the spec. in general how do we want to handle 3rd party specific fields? should they be identified with a prefix, but can exist anywhere?  sooo "x-type"   ~rickr  - its NPM _like_ versioning. we aren't dictating that people should use node.js. we are just copying a versioning system that seems to work. - I agree that "endorsingPeer, chaincodeQuery, eventSource  should be optional." - the chaincode section is there b/c we are defining a generic _connection profile_.  an application should know of what chaincode id/version to talk to when connecting to the blockchain network. this should be optional since certain applications will not care.  *edit* crap was too slow. I deleted the yaml i had, see jim's  ></body> </Action>
<Action id="29250" issue="19331" author="jimthematrix" type="comment" body=" ~dshuffma  :) I moved the YAML content to the main description section so it&apos;s easier to see and review/edit." created="2017-07-31 15:55:47.0" updateauthor="jimthematrix" updated="2017-07-31 15:55:47.0"/>
<Action id="29270" issue="19331" author="davidkel" type="comment" created="2017-08-01 09:12:52.0" updateauthor="davidkel" updated="2017-08-01 09:12:52.0"> <body><! CDATA From a Composer point of view, this is the flow we want to support {noformat} Connection Profile Document (generated by fabric toplogy owner) | | V Composer----> retrieves the type of profile document (type="hlfv1") | | V instantiates node module "composer-connector-hlfv1" (all modules are of the form composer-connector-{type}) | | V load npm modules fabric-client, fabric-ca-client (at specific level) | | V pass connection profile to fabric-client, fabric-ca-client (to create the client, channel etc objects) | | V configure client to handle a wallet implementation (credential-store) (If not provided by node sdk) | | V invoke requests as required from Composer clients{noformat} The important thing for us here is that type is defined by the fabric topology owner and that it currently matches the text "hlfv1" but to handle different connection modules that require different dependencies the type is changed to drive that. Version in this context doesn't have meaning and it may be that type is Composer specific but it needs to be mandatory in the profile document in order for Composer to be part of the above chain.           ></body> </Action>
<Action id="29295" issue="19331" author="dshuffma" type="comment" created="2017-08-01 13:51:41.0" updateauthor="dshuffma" updated="2017-08-01 13:51:41.0"> <body><! CDATA well so someone just needs to decide is a _composer required field_ a _connection profile required field_ for Fabric?  if not: - then I get that this is still a critical field for composer, therefore in HSBN vnext we will add this field in our service credentials (and anything else you need). - I'm proposing we build off of Simon's idea of using the swagger like naming convention.  Third party fields could be prefixed with a *x-*.  Therefore `type="hlfv1"` becomes `x-type="hlfv1"`.  if so: - then it stays as  `type="hlfv1"`  ></body> </Action>
<Action id="29377" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-08-03 00:12:59.0" updateauthor="harrisob@us.ibm.com" updated="2017-08-03 00:12:59.0"> <body><! CDATA work in progress https://gerrit.hyperledger.org/r/#/c/12039/  ></body> </Action>
<Action id="29400" issue="19331" author="odowdaibm" type="comment" created="2017-08-03 13:39:56.0" updateauthor="odowdaibm" updated="2017-08-03 13:39:56.0"> <body><! CDATA I'd like to see this feature {color:#000000}concetputalize the idea of a *network* in the SDK. CPs help with this because they abstract away connection details of peers, orderers etc to make the application connection to a coherent  single entity - a network. ** {color}     {color:#000000}I very much like the discussion above in that it maps CPs to channels, though I'd like to see if we could raise the level and map CPs to networks. For this the CP would have to encapsulate the channel as well, and I think that's OK - it's what Composer does today.  We could also have an optional API where the client identified the appropriate channel in the CP. {color}     {color:#000000}So, in (very!) pseudo-code, we could have something like{color}     {color:#000000}     networkConnection = new client.networkConnection(connectionProfileName); {color}     {color:#000000}It would then be a simple matter to get the channel from this object{color}     {color:#000000}   channel = networkConnection.getDefaultChannel(); // gets the default channel, however defined{color}  {color:#000000}   channel = networkConnection.getChannel(channelName); // gets the requested channel, error if not found{color}  {color:#000000}    {color}  {color:#000000}Does this make sense?{color}     ></body> </Action>
<Action id="29412" issue="19331" author="jimthematrix" type="comment" created="2017-08-03 15:34:37.0" updateauthor="jimthematrix" updated="2017-08-03 15:37:46.0"> <body><! CDATA  ~davidkel ,  ~dshuffma  sounds like the value of the "type" field is being used in a special way by composer (suffix of target module to load for processing), which is pretty different than what I had thought. in that case we should treat this field as composer-specific and not a general-purpose one defined by the common schema which we are describing here.  as for naming, using an "x-" prefix makes sense to me. It makes it clear that this is an application-specific field and each application is free to use any name for their special property. The SDK will simply ignore them.  The other point I want to make is that, from discussing with Bret we believe the "version" field should be representing the schema version instead of the revisions of the content. It should work exactly like the "version" field in a docker-compose.yaml, instead of the "version" field of a package.json. The SDKs should use it to determine the expected structure of the document and parsing rules.  I'll update the YAML above to clarify this.  ></body> </Action>
<Action id="29568" issue="19331" author="dshuffma" type="comment" created="2017-08-08 20:42:23.0" updateauthor="dshuffma" updated="2017-08-08 20:44:31.0"> <body><! CDATA I've been trying this format out and came up with one issue:  !screenshot-1.png|thumbnail!   The "caName" which is needed by the SDK to identify which ca to use for the hierarchy CA setup will be the same for multiple CAs.  Since these dictionary keys would collide, I cannot use the "caName" as the key for the "certificateAuthorities" field.  Therefore in my screenshot I've added a new field named "caName" and I'm using a different id for the key field.  The {color:#14892c}Green boxes  {color}are the names i'm using to identify the different running CAS, and the {color:#205081}blue boxes show {color} the "caName" that is needed for each by the SDK.  for reference this is why we need the field at all: https://github.com/hyperledger/fabric-sdk-node/blob/release/fabric-ca-client/lib/FabricCAClientImpl.js#L49  tldr: we need to add a "caName" field, and we cannot simply use the ca's key as this field.  ></body> </Action>
<Action id="29814" issue="19331" author="jimthematrix" type="comment" body="yes makes sense, thanks for catching that  ~dshuffma " created="2017-08-14 17:11:38.0" updateauthor="jimthematrix" updated="2017-08-14 17:11:38.0"/>
<Action id="29838" issue="19331" author="harrisob@us.ibm.com" type="comment" body="Updated the admin credentials of the organization to be the same as the other certs, using the pem or path to indicate the source of the key or cert" created="2017-08-15 10:06:28.0" updateauthor="harrisob@us.ibm.com" updated="2017-08-15 10:06:28.0"/>
<Action id="30080" issue="19331" author="baha-sk" type="comment" body="Added logging level to the client in the standard network config above." created="2017-08-22 18:48:03.0" updateauthor="baha-sk" updated="2017-08-22 18:48:03.0"/>
<Action id="30087" issue="19331" author="baha-sk" type="comment" created="2017-08-22 21:08:29.0" updateauthor="baha-sk" updated="2017-08-22 21:08:29.0"> <body><! CDATA I have two other suggestions to add, but I need feedback first.     1. A missing flag in the config is for the cert's CN name to override it with the host name of the peer/order, I suggest we add:  serverHostOverride  under every tlsCACerts entry to specify the server hostname correctly, an example:  serverHostOverride: "peer0.org1.example.com"  2. we will need a crypto config path to specify the location of crypto keys and certs. example:   cryptoconfig:     path: "$GOPATH/src/github.com/hyperledger/fabric-sdk-go/test/fixtures/channel/crypto-config"  ></body> </Action>
<Action id="30118" issue="19331" author="baha-sk" type="comment" created="2017-08-23 19:23:13.0" updateauthor="baha-sk" updated="2017-08-23 19:23:13.0"> <body><! CDATA added fields mentioned in my previous comment and also the following: {code:java} client: keyfile certile{code} The above is added under  {code:java} certificateAuthorities.ca-org1{code}  ></body> </Action>
<Action id="30157" issue="19331" author="dshuffma" type="comment" created="2017-08-24 14:10:06.0" updateauthor="dshuffma" updated="2017-08-24 14:10:06.0"> <body><! CDATA @ ~Baha-sk   We don't need "serverHostOverride" because we already have "grpcOptions 'ssl-target-name-override' ".  ></body> </Action>
<Action id="30158" issue="19331" author="baha-sk" type="comment" created="2017-08-24 14:33:47.0" updateauthor="baha-sk" updated="2017-08-24 14:33:47.0"> <body><! CDATA Thanks  ~dshuffma   I didn't realize this grpc option serves the same purpose. I've removed serverHostOverride fields from the suggested network config above.  ></body> </Action>
<Action id="30160" issue="19331" author="baha-sk" type="comment" created="2017-08-24 14:47:09.0" updateauthor="baha-sk" updated="2017-08-24 14:47:09.0"> <body><! CDATA is the "path" field under the peers' tlsCACerts supposed to support multiple cert paths?    in our current sdk go config.yaml we had "certfiles" to get a list certs.  ></body> </Action>
<Action id="30165" issue="19331" author="dshuffma" type="comment" body="I think its just the one path.  What is the use for multiple tls certs? If you have a chain of certs, you can combine them into a single file. I believe you just concatenate them. (i&apos;m guessing)" created="2017-08-24 15:17:03.0" updateauthor="dshuffma" updated="2017-08-24 15:17:03.0"/>
<Action id="30167" issue="19331" author="baha-sk" type="comment" body="&quot;certfiles&quot; is used by Fabric CA everywhere. It doesn&apos;t look like it takes multiple files, all the examples show only 1 path in there. So maybe using Path is fine and if we need to set multiple certs, we can concatenate them as you mentioned." created="2017-08-24 15:45:29.0" updateauthor="baha-sk" updated="2017-08-24 15:45:29.0"/>
<Action id="30170" issue="19331" author="baha-sk" type="comment" created="2017-08-24 17:14:08.0" updateauthor="baha-sk" updated="2017-08-24 17:14:08.0"> <body><! CDATA I also believe we need the following "client" fields: {code:java} tls: enabled: true   connection: timeout: peer: endorser: 3s eventHub: 3s eventReg: 3s orderer: 3s   BCCSP: security: enabled: true default: provider: "PKCS11" hashAlgorithm: "SHA2" softVerify: true ephemeral: false level: 256 pin: "12345678" label: "ForFabric" library: /path/to/bccsp/libraries {code}    ></body> </Action>
<Action id="30377" issue="19331" author="jimthematrix" type="comment" body=" ~Baha-sk  note that the connection profile should be dedicated to settings related to the network: topology, identity, behaviors (like timeouts), etc. If we don&apos;t clearly define a boundary then all sorts of stuff could be thrown into it, which the design does accommodate with the &quot;x-&quot; prefix. so given that, I would argue that LOGGING does not belong to this document and I&apos;m removing it from the design doc above." created="2017-08-30 15:39:42.0" updateauthor="jimthematrix" updated="2017-08-30 15:39:42.0"/>
<Action id="30378" issue="19331" author="jimthematrix" type="comment" body="also, I noticed that you didn&apos;t add the &quot;tls/enabled&quot; section, and I agree that&apos;s the right decision because if that&apos;s meant for deciding how the client app itself should be deployed, it&apos;s really not a concern of the program itself, but a deployment configuration." created="2017-08-30 15:44:45.0" updateauthor="jimthematrix" updated="2017-08-30 15:45:10.0"/>
<Action id="30379" issue="19331" author="jimthematrix" type="comment" body=" ~Baha-sk  I don&apos;t understand the need for &quot;certificateAuthorities.ca-org1.client&quot; section, can you clarify?" created="2017-08-30 15:54:47.0" updateauthor="jimthematrix" updated="2017-08-30 15:54:47.0"/>
<Action id="30380" issue="19331" author="aleksandar.likic" type="comment" body=" ~jimthematrix  So, things like &quot;tls/enabled&quot;, which are dictated by the network configuration should also have &quot;x-&quot; prefix although they are not application specific? Also, should the client be able to handle mixed tls/enabled use case, that is, when some peers are configured with tls and some are not? Is it a realistic use case, or we should assume that all peers have the same tls/enabled property?" created="2017-08-30 16:21:15.0" updateauthor="aleksandar.likic" updated="2017-08-30 16:21:15.0"/>
<Action id="30381" issue="19331" author="baha-sk" type="comment" created="2017-08-30 16:37:35.0" updateauthor="baha-sk" updated="2017-08-30 21:05:35.0"> <body><! CDATA  ~jimthematrix , thanks for your comments.     for the first comment above, that's fine, we will use x-loggingLevel  for the second comment above, I believe  ~aleksandar.likic  replied to you above  for the third comment, as the comment says, this is for the client key and cert used for the ssl handshake with fabric CA and each CertificationAuthorities instance can have it's own set of client cert and key. This is similar to our existing config today in the Go SDK.  ></body> </Action>
<Action id="30385" issue="19331" author="jimthematrix" type="comment" created="2017-08-30 19:16:06.0" updateauthor="jimthematrix" updated="2017-08-30 19:16:06.0"> <body><! CDATA  ~aleksandar.likic  ok so "tls/enabled" is meant for describing the target network (not for the client app itself). since we have the full url specified on each endpoint with grpc:// or grpcs://, which is simple and flexible, why would we need to a big-hammer approach like this global switch?   ~Baha-sk  so it's meant to be used for TLS mutual auth. thanks for clarifying that. I'll add a comment to reflect that.  ></body> </Action>
<Action id="30388" issue="19331" author="baha-sk" type="comment" created="2017-08-30 21:09:28.0" updateauthor="baha-sk" updated="2017-08-30 21:09:28.0"> <body><! CDATA  ~jimthematrix , no problem.     As for the your comment on Aleks's note, the SDK needs to know if the tls certs are needed or not, hence the tls/enabled flag. Not sure if grpcs is a valid url protocol.  ></body> </Action>
<Action id="30658" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-09-07 22:38:37.0" updateauthor="harrisob@us.ibm.com" updated="2017-09-07 22:38:37.0"> <body><! CDATA Work done in two parts for NodeSDK   https://gerrit.hyperledger.org/r/#/c/12039/   https://gerrit.hyperledger.org/r/#/c/12577/  ></body> </Action>
<Action id="31049" issue="19331" author="troyronda" type="comment" created="2017-09-20 18:34:46.0" updateauthor="troyronda" updated="2017-09-20 18:34:46.0"> <body><! CDATA Go SDK:   https://gerrit.hyperledger.org/r/#/c/13209/      ></body> </Action>
<Action id="31149" issue="19331" author="baha-sk" type="comment" created="2017-09-25 20:40:58.0" updateauthor="baha-sk" updated="2017-09-25 20:46:59.0"> <body><! CDATA hi  Jim Zhang|https://jira.hyperledger.org/secure/ViewProfile.jspa?name=jimthematrix ,     I think grpcs:// is not a valid GRPC protocol.  For enabling TLS over GRPC, this is the official page  https://grpc.io/docs/guides/auth.html#authentication-api   There are examples for Node.js, Java, C#, etc.   Actually GRPC expects no protocol in the URL.      Currently SDK GO fails if this protocol is passed in the prefix of URLs. This is another reason why we need TLS/enabled under client. Can we add this field to make it clear that the client has TLS enabled? For Fabric SDK GO, this is a much cleaner solution than trimming the protocol in the code. Let me know what you think..     Thanks,  Baha  ></body> </Action>
<Action id="31185" issue="19331" author="dshuffma" type="comment" created="2017-09-26 17:02:08.0" updateauthor="dshuffma" updated="2017-09-26 17:02:08.0"> <body><! CDATA I'm with Jim. grpc:// vs grpcs:// is a good shorthand to indicate if TLS is to be used or not. Adding another flag is redundant and potentially confusing if the two methods are mismatched.   ></body> </Action>
<Action id="31187" issue="19331" author="baha-sk" type="comment" created="2017-09-26 17:26:46.0" updateauthor="baha-sk" updated="2017-09-26 17:26:46.0"> <body><! CDATA  ~dshuffma  but grpcs:// does not exist. It is not recognized by grpc servers.     Not sure how the grpc server calls react in other languages, but in go calls to grpc, we always get an error. in my previous comment I pasted a link on how to get a secure channel over grpc for Node.js, the official grpc document does not mention grpcs:// anywhere  ></body> </Action>
<Action id="31189" issue="19331" author="baha-sk" type="comment" created="2017-09-26 19:13:25.0" updateauthor="baha-sk" updated="2017-09-26 19:13:25.0"> <body><! CDATA also, I'd like to add that tls/enabled in the config entails tls certs must be set during connectivity, if the certs are missing in the config, then a valid error is thrown.  There should be no confusion when it's set to true in the config.     I think using a non existent protocol is more confusing, especially for the Go/GRPC community.  ></body> </Action>
<Action id="31210" issue="19331" author="dshuffma" type="comment" created="2017-09-27 21:37:33.0" updateauthor="dshuffma" updated="2017-09-27 21:37:33.0"> <body><! CDATA when I'm telling people where my resource exists, using a single string that includes the protocol like "grpcs://localhost:7051" seems handy.  though, you have a valid point.  but I think most people will get it.  Its also pretty typical in the evolution of other protocols names: ftp -> ftps http -> https ws -> wss smtp -> smtps  At any rate, I think we agree that we shouldn't do both things.  We can't specify the "protocol" AND have a tls flag.  Its one or the other.  We just need to come to a consensus on which one. How about rock, paper, scissors best of 3? Or we could vote!   ></body> </Action>
<Action id="31211" issue="19331" author="baha-sk" type="comment" created="2017-09-27 21:52:33.0" updateauthor="baha-sk" updated="2017-09-27 21:58:52.0"> <body><! CDATA  ~dshuffma , agreed about not having both tls/enabled and protocol.. in SDK Go, we don't specify the protocol in our URLs, we only set IPaddress:port   This is why I think tls/enabled makes more sense (at least for us). Not sure why GRPC authors don't mention grpcs:// protocol in their server URLs. Maybe to hide the fact the connection is secure?     but if the community thinks it's best to use grpcs:// instead of tls/enabled, I'm ok with it.. I just wanna bring up the fact that it's not an official protocol and the fact that in Go SDK and we will have to manually trim the protocol prefix from our URLs  ></body> </Action>
<Action id="31250" issue="19331" author="rickr" type="comment" body="Prefer to keep it succinct:  grpcs and grpc" created="2017-09-28 19:51:46.0" updateauthor="rickr" updated="2017-09-28 19:51:46.0"/>
<Action id="31251" issue="19331" author="baha-sk" type="comment" created="2017-09-28 19:58:54.0" updateauthor="baha-sk" updated="2017-09-28 19:58:54.0"> <body><! CDATA  ~rickr , fyi, it is not succinct for SDK Go. I am currently parsing Peers and Orderers URLs from the config to verify if they're prefixed with https:// or grpcs:// in order to apply the certs.     tls.enabled was sweet and short in our current version. But that's fine, I'm currently refactoring the Go SDK ..  ></body> </Action>
<Action id="31619" issue="19331" author="baha-sk" type="comment" created="2017-10-04 20:03:34.0" updateauthor="baha-sk" updated="2017-10-04 20:03:34.0"> <body><! CDATA GO SDK now supports grpc:// and grpcs:// URLs   https://gerrit.hyperledger.org/r/#/c/14167/      ></body> </Action>
<Action id="31978" issue="19331" author="dshuffma" type="comment" created="2017-10-10 18:35:39.0" updateauthor="dshuffma" updated="2017-10-10 18:35:39.0"> <body><! CDATA so how do people feel about making the pub/private cert/key fields an array? this would allow 1 org to have multiple key/certs defined.  right now we have:  {code:java} organizations 'PeerOrg1' .signedCert.pem = '<pem here>'; and organziations 'PeerOrg1' .adminPrivateKey.pem: '<pem here>'; {code}  I'm proposing we change the "signedCert" and "adminPrivateKey" fields to an array.  Like:  {code:java}  organizations 'PeerOrg1' .signedCerts  {  pem : '<pem here>' }  ;  organziations 'PeerOrg1' .adminPrivateKeys  {  pem: '<pem here>' }  ; {code}  or maybe combine the two (since the private key and cert are a pair) like:  {code:java} organizations 'PeerOrg1' .crypto =   {  signedCert: { pem : '<pem here>' }, adminPrivateKeys: { pem : '<pem here>' } }   {code}   thoughts?    ></body> </Action>
<Action id="32004" issue="19331" author="baha-sk" type="comment" created="2017-10-11 17:53:46.0" updateauthor="baha-sk" updated="2017-10-11 17:53:46.0"> <body><! CDATA  ~denyeart , not sure why you need crypto.signedCert under Organizations, but for SDK Go we look for the peer assigned to the Organization and look for their certs.     Under the peer, there's tlsCACerts.path that contains the path to it's TLS certificate. If you need multiple certs, you can append them to that path.  Example for a peer, the config is: {code:java} tlsCACerts: # Comma-Separated list of paths path: peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem {code} the value of path is comma separated, so you can add multiple certs if needed.  Are you looking for different cert values for the org?     ></body> </Action>
<Action id="32006" issue="19331" author="denyeart" type="comment" created="2017-10-11 18:24:57.0" updateauthor="denyeart" updated="2017-10-11 18:24:57.0"> <body><! CDATA  ~Baha-sk  I think you intended to direct the last comment to  ~dshuffma .  I'll suggest that  ~harrisob@us.ibm.com  moderate the conversation here (owner of this work item), as we'll want consistency across the various SDKs.  ></body> </Action>
<Action id="32009" issue="19331" author="baha-sk" type="comment" created="2017-10-11 19:28:59.0" updateauthor="baha-sk" updated="2017-10-11 19:28:59.0"> <body><! CDATA  ~denyeart  that's right, my bad, I meant to ask  ~dshuffma  about his last comment.        ></body> </Action>
<Action id="32010" issue="19331" author="dshuffma" type="comment" created="2017-10-11 19:43:38.0" updateauthor="dshuffma" updated="2017-10-11 19:43:38.0"> <body><! CDATA  ~Baha-sk  These certs are not for TLS handshaking, they are for validating the proposals. These are the so called "admin certs" for privileged operations like install/instantiate/etc..  Also i'm not suggesting to move them under "organizations" because they are already there!    My suggestion is to leave them where they are, but convert the field from an object to an array.  I would like to support multiple admin certs per org  ></body> </Action>
<Action id="32014" issue="19331" author="baha-sk" type="comment" created="2017-10-11 20:33:16.0" updateauthor="baha-sk" updated="2017-10-11 20:33:16.0"> <body><! CDATA  ~dshuffma , understood you wanna use this for proposal validations, but there is no 'crypto' middle field under organization. This is why I thought you were suggesting to add a new field.     How about appending cert paths as a string to the 'signedCert' value instead of making them an array? It won't affect our GO SDK if the field has comma separated values.  ></body> </Action>
<Action id="32634" issue="19331" author="rickr" type="comment" body="The adminPrivateKey and signedCert is under an organization.  I think this is the peeradmin credentials that can install and instantiate chaincode.  Can there be as in this example Org1 peers different admins for peer0.org1.example.com and peer1.org1.example.com ?" created="2017-10-18 15:55:10.0" updateauthor="rickr" updated="2017-10-18 15:55:10.0"/>
<Action id="32635" issue="19331" author="rickr" type="comment" created="2017-10-18 15:59:11.0" updateauthor="rickr" updated="2017-10-18 16:00:09.0"> <body><! CDATA name: "global-trade-network"    I don't think would be used directly by the SDKs across the board.  Should this not have a x-name ? as x-type, x-loggingLevel ?  Ditto for description  ></body> </Action>
<Action id="32636" issue="19331" author="rickr" type="comment" body="I really would have preferred to keep this document clean as possible what the SDKs required to define channels and credentials.  Composer, applications other SDKs should have defined in another JIRA their own extensions to this. :(" created="2017-10-18 16:05:11.0" updateauthor="rickr" updated="2017-10-18 16:05:11.0"/>
<Action id="32639" issue="19331" author="rickr" type="comment" created="2017-10-18 16:10:07.0" updateauthor="rickr" updated="2017-10-18 16:10:07.0"> <body><! CDATA #  Optional . what chaincodes are expected to exist on this channel? The application can use     # this information to validate that the target peers are in the expected state by comparing     # this list with the query results of getInstalledChaincodes() and getInstantiatedChaincodes()     chaincodes:       # the format follows the "cannonical name" of chaincodes by fabric code       - example02:v1       - marbles:1.0     I don't think the SDKs should inspect this by default.  If this is an application specific item as stated should it not be  *x-chaincodes*   The SDK have a means to query to find these out and the application can use this as a hint as what to expect.**********  But then again I reall think any "application" should define this in their own extension to this document.  ></body> </Action>
<Action id="32640" issue="19331" author="rickr" type="comment" created="2017-10-18 16:22:24.0" updateauthor="rickr" updated="2017-10-18 16:22:24.0"> <body><! CDATA tlsCACerts:       # Comma-Separated list of paths       path: peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem     Is the comment here wrong ?  I think a server only would have a single certificate from what I know.  *tlsCACert?*  If not, should be changed to *paths*.  ></body> </Action>
<Action id="32642" issue="19331" author="rickr" type="comment" created="2017-10-18 16:26:24.0" updateauthor="rickr" updated="2017-10-18 16:26:24.0"> <body><! CDATA # BCCSP config for the client.   BCCSP:    security:     enabled: true     default:      provider: "SW"     hashAlgorithm: "SHA2"     softVerify: true     ephemeral: false     level: 256     pin: "12345678"     label: "ForFabric"     library: /path/to/bccsp/libraries  What is this ?  If this is HSM configuration it's really generic ?  Not sure I see anything like this in Java     ></body> </Action>
<Action id="32651" issue="19331" author="dshuffma" type="comment" created="2017-10-18 19:01:43.0" updateauthor="dshuffma" updated="2017-10-18 19:01:43.0"> <body><! CDATA  ~rickr  I disagree on your stance on making an application need a separate format than this connection profile.  What is an SDK for after all? Its for the *client* application to communicate and perform operations on the blockchain network.  Anything needed for the client to connect should be a first party thing defined in this so called "connection profile".  so I'd like to keep the "chaincode" field.  I'm not in love with the csv path thing, we are using JSON... why mix things up. but w/e not going to fight this one  the "name" field feels first party to me. its the go to identify of the network.  I will concede its not really useful, since its not needed in any technical way, but its probably useful for a logging message or two.   yes there can be multiple "admins" per org.  therefore there can be multiple admin certs per orgs.  but our format above does not support this, yet.   ~Baha-sk  so comma separating the cert *paths* or *pems* would work... but I find it strange to not do the more JSON thing and make it an array.    ></body> </Action>
<Action id="32656" issue="19331" author="rickr" type="comment" created="2017-10-18 21:03:58.0" updateauthor="rickr" updated="2017-10-18 21:06:12.0"> <body><! CDATA  ~dshuffma  That's fundamentally where we differ or what this document is meant to be targeted for.  The SDK is NOT an application/client its an api. Applications use the SDK to work with hyperledger fabric.  Just like HTTP api/library is NOT an application. So if this is not strictly for the SDK what application/client is it for ? IBM's blockchain's application ? Is so, it should not be defined here at all.  chaincode - what exactly is the sdk todo with that ? Throw an exception if it's not present? Try to deploy it?  There's not enough information there to do that.  The SDKs do NOT need *chaincode*  to connect/communicate to hyperledger fabric.  The SDK care less what chaincode an application has deployed or installed and has nothing to do with communicating with the fabric.  So what application/client is this for exactly ?   We have in the JSDK a balance / transfer example *application* built on the JSDK api it expects to have certain balances to start off with.  Can I add that here ?         ></body> </Action>
<Action id="32659" issue="19331" author="dshuffma" type="comment" created="2017-10-18 21:27:28.0" updateauthor="dshuffma" updated="2017-10-18 21:27:28.0"> <body><! CDATA hmmm well, we are pretty far apart. going to need other voices to weigh in.  I would argue that you are not building an HTTP library, nor a gRPC library. The sdk is not that low of a level, its a fabric connection/transaction library.  Including requirements of a transaction makes sense (like chaincode id/version).  I'm for making the "connection profile" be the single source of all required information needed for an application to connect and use the network. chaincode ids and all...  the inputs to your balance transfer chaincode are not _connection_ related, so that's where the line is.  they don't get to join the connection profile. knowing which chaincode container to talk to however, feels connection-y to me.   ></body> </Action>
<Action id="32808" issue="19331" author="martinc" type="comment" created="2017-10-19 16:08:43.0" updateauthor="martinc" updated="2017-10-19 16:08:43.0"> <body><! CDATA I am working on the fabric-sdk-rest project so I have been keeping an eye on this item as I intend to update it to use the connection profile work when a GA v1.1 SDK is available.  I see the connection profile document as a static definition of dynamic content and so liable to become outdated without a client knowing. In my opinion ideally it would be dynamically discovered but that is a separate issue.  I also expect that within an org the connection profile document will be shared by multiple applications that will be invoking different chaincode on the same ledgers/channels. Therefore I do not think the connection profile should contain configuration specific to a single client application.  Based upon the comment for the "chaincodes" field the usage is describing a single client application's dependencies, so in my opinion it is the wrong place for it, secondly if it does stay, the current format is not expressive enough as it needs to be able to express dependencies in a way that can allow multiple versions, such as at least version 1.1 but not 2.0, otherwise as soon as a piece of chaincode is updated a client application may incorrectly fail.  ></body> </Action>
<Action id="32809" issue="19331" author="rickr" type="comment" created="2017-10-19 16:18:46.0" updateauthor="rickr" updated="2017-10-19 16:18:46.0"> <body><! CDATA {color:#444444}We needed to have a generic language independent configuration document for the SDKs. It should have been kept to an absolute minimum for the SDK to construct channels, the channel artifacts connection properties, and connection credentials in a generic implementation independent means.{color} {color:#444444}Each specific SDK in an independent document, {color}{color:#444444}_{color}_if at all necessary_{color:#444444}_{color}{color:#444444}, should  document  their extension on this document. The same goes for any specific application needs.{color}  ></body> </Action>
<Action id="32906" issue="19331" author="harrisob@us.ibm.com" type="comment" created="2017-10-19 20:47:05.0" updateauthor="harrisob@us.ibm.com" updated="2017-10-19 20:47:05.0"> <body><! CDATA   # Needed to load users crypto keys and certs. cryptoconfig:     path: path/to/fixtures/channel/crypto-config What is `cryptoconfig` , how are the SDK's to use this ?  ></body> </Action>
<Action id="32907" issue="19331" author="harrisob@us.ibm.com" type="comment" body="Can we have the timeouts just be a number and assume they are seconds so we do not have to get into parsing problems" created="2017-10-19 20:51:05.0" updateauthor="harrisob@us.ibm.com" updated="2017-10-19 20:51:05.0"/>
<Action id="32928" issue="19331" author="dshuffma" type="comment" created="2017-10-20 14:11:32.0" updateauthor="dshuffma" updated="2017-10-20 14:11:32.0"> <body><! CDATA  ~rickr  ~MartinC  I would urge you to read the title of this very Jira, as well as the description.  If we are planning to exclude application required details... then what are we doing here.   ~MartinC  if this connection profile was somehow discoverable, that would be great.  we can do that through any blockchain service, but if it was a native peer or orderer feature that would be an improvement.   ~MartinC  the chaincode version is actually not needed to create proposals.  however it is needed to install/instantiate, but for this operation it is a specific version, not a range. plus from the network's perspective we have no idea what chaincode versions are "compatible" .  remember the application doesn't generate the connection profile, he consumes it.   ~harrisob@us.ibm.com  if we assume a field to be seconds, can we add it to the field name. like  `timeout.peerSecs: 3`  using Jira in this way really sucks.  its hard to get to conclusions of one topic, b/c it gets buried under another question/input. I'm wondering if there is a better way?  what if we opened separate issues for each thing we want modified/added? we'd have to have a common tag or something...  ></body> </Action>
<Action id="32972" issue="19331" author="martinc" type="comment" created="2017-10-23 08:58:23.0" updateauthor="martinc" updated="2017-10-23 09:01:25.0"> <body><! CDATA My interpretation of the title is that there would be one common document that defines how an org connects to a blockchain network shared by its multiple client applications.  ~dshuffma  you appear to be proposing each client application would have their own version of the connection profile document, wouldn't that lead to an increased maintenance problem keeping multiple docs up to date as well as increase the risk of errors when a piece of chaincode is upgraded? Each time that happened a peer would not be in the expected state and so implies the client should not use the peer(s).  Quoting from the proposed doc: what chaincodes are expected to exist on this channel? The application can usethis information to validate that the target peers are in the expected state "The expected state" is the expected state of one or more peers from one client application's perspective to ensure that it can use the blockchain network correctly (aka its dependencies). That goal is a good one but I don't think putting the information in the common connection profile is the best way to achieve it because the values of the fields are not common, rather the values are specific to one client application's needs. Is there another use for this information that I have missed?  I think raising a new requirement against the SDKs for a Channel.checkDependencies(peers  ,appDependencies) function which an application could call when it starts would be a better way to achieve that goal.  I agree that raising separate issues that could be related to this one would be a good thing to try to see if it improves discussion.  ></body> </Action>
<Action id="33617" issue="19331" author="christopherferris" type="comment" created="2017-10-31 14:16:48.0" updateauthor="christopherferris" updated="2017-10-31 14:20:55.0"> <body><! CDATA  https://gerrit.hyperledger.org/r/c/14977/    https://gerrit.hyperledger.org/r/c/12039/   https://gerrit.hyperledger.org/r/c/12577/  ></body> </Action>
<Action id="34627" issue="19331" author="denyeart" type="comment" body="Moving back to IN REVIEW since the Java SDK subtask is still going through reviews." created="2017-11-14 18:01:38.0" updateauthor="denyeart" updated="2017-11-14 18:01:38.0"/>
<Action id="35872" issue="19331" author="rickr" type="comment" body="Just to be clear the peers in the organization is a list but the order that they are listed really has no significance.  Applications should use the actual name of the peer if there is any significance to a specific peer – which I don&apos;t know what that may be. Tooling which most like will generate this could with each invocation have that list in any order." created="2017-12-05 17:39:16.0" updateauthor="rickr" updated="2017-12-05 17:39:16.0"/>
<Action id="38412" issue="19331" author="clayton sims" type="comment" body="Bret marking done.   Please let me know if there is addition work to do" created="2018-01-10 23:38:26.0" updateauthor="clayton sims" updated="2018-01-10 23:38:26.0"/>
<Action id="41204" issue="19331" author="dshuffma" type="comment" created="2018-03-05 19:17:41.0" updateauthor="dshuffma" updated="2018-03-05 19:24:08.0"> <body><! CDATA So is the chaincode format an oversight?  The spec above is suggesting an array like:  {code:java} "chaincodes":   "example02:v1", "marbles:1.0"  , {code}  but that seems dumb.  when an application needs the id or version independently it needs to parse it and split on the colon.  seems like a waste when we could just use:  {code:java} "chaincodes":   { "id": "example02":  "version": "v1", }, { "id": "marbles" "version": "1.0"' }  , {code}  also pretty sure `chaincode` is both singular and plural, but I suppose we have to live with that too?  what is the process to improve the spec???  ></body> </Action>
<Action id="42111" issue="19331" author="paul.sitoh" type="comment" created="2018-03-24 16:47:58.0" updateauthor="paul.sitoh" updated="2018-03-24 16:49:27.0"> <body><! CDATA To me the use of "path" properties is extremely confusing, won't it better to provide the PEM itself directly or at least follow the form of URL. For example: {quote}\{\{ certificateAuthorities:}} \{\{ ca-org1:}} \{\{ url:  https://localhost:7054|https://localhost:7054/ }} # {{the properties specified under this object are passed to the 'http' client verbatim when}}  # {{making the request to the Fabric-CA server httpOptions: verify: true tlsCACerts:}}  # {{Comma-Separated list of paths path: peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem}}  # {{Client key and cert for TLS mutual auth with Fabric CA. If the target Fabric CA server}}  # {{does not have TLS mutual auth turned on, then this section is not needed client: keyfile: path/to/tls/fabricca/certs/client/client_fabric_client-key.pem certfile: path/to/tls/fabricca/certs/client/client_fabric_client.pem}}{quote} If you were to deploy your fabric in a cloud, what does path means?  If you have it specified as a URL: you will know that it originates from the server and that way app developer can easily consume the endpoint as a stream. If you are deploying locally in docker, you could just add another container and server this profile as a restful endpoint. And app just needs to consume it as a rest call or in other cloud implementation as environment variable fully compliant to 12-factor app.  As it is now, path suggest that the location of pem is only restricted to local volume and not very volume agnostic.     ></body> </Action>
<Action id="42150" issue="19331" author="dshuffma" type="comment" created="2018-03-26 13:26:57.0" updateauthor="dshuffma" updated="2018-03-26 13:26:57.0"> <body><! CDATA  ~paul.sitoh  It might be an oversight.  Notice that the `org.adminPrivateKey` allows the PEM contents directly or a path value to the pem file.  Originally I interrupted this as any `path` field could be exchanged with the `pem` directly.  But I see now that the spec does not explicitly say this. Though it is what the current IBM Blockchain Platform service does when building it's connection profile.  I agree that a single JSON with everything is very useful.  Blurb from the `org.adminPrivateKey` section: "Both properties can be the PEM string or local path to the PEM file."  ></body> </Action>
<Action id="42160" issue="19331" author="baha-sk" type="comment" created="2018-03-26 15:36:07.0" updateauthor="baha-sk" updated="2018-03-26 19:22:27.0"> <body><! CDATA fyi, in SDK GO, we now support both pem or path formats or load all users from crypto config path. The user gets to choose the right format for their org's users like so: {code:java} organizations: org1: mspid: Org1MSP  # Needed to load users crypto keys and certs for this org (absolute path or relative to global crypto path, DEV mode) users: Admin: key: pem: | -----BEGIN PRIVATE KEY----- private key content here -----END PRIVATE KEY----- cert: pem: | -----BEGIN CERTIFICATE----- public cert content here             -----END CERTIFICATE----- User1: key: path: "/path/to/user1/key/file" cert: path: "/path/to/user1/cert/file" {code} ...  'pem' key for the ADMIN user can be replaced with 'path' and one can add their path value instead of embedding their key/cert just like User1 and vice versa.  the last option is to use the cryptoPath key to load from a pre built cryptoconfig folder created by Fabric's crypto-gen tool (useful in dev mode): {code:java} organizations: org1: mspid: Org1MSP  # This org's MSP store (absolute path or relative to client.cryptoconfig) cryptoPath:  peerOrganizations/org1.example.com/users/{username}@org1.example.com/msp {code} of course the above formats are in yaml, but they can be easily transformed in JSON for other SDKs.  We've done this for other parts of the config as well, for instance "certificateAuthorities" can now be configured with either tlsCACerts.pem or tlsCACerts.path or both(pem takes precedence) and its client.keyfile and certfile fields have been replaced with client.key.pem (or path) and client.cert.pem(or path) respectively.  hope this helps  ></body> </Action>
<Action id="42181" issue="19331" author="paul.sitoh" type="comment" created="2018-03-26 20:36:36.0" updateauthor="paul.sitoh" updated="2018-03-26 20:40:51.0"> <body><! CDATA  ~Baha-sk   ~dshuffma  For my MVP, I can live with the option to send either path or pem for now. But in the long run the "cloudy" client, it makes more sense to be using URL instead as this will enable your client to transition from dev to production without the need to rewrite your code. Cloud apps would find such profile delivered from remote services (such as Redis, ObjectStorage, etc.).  In which case, you won't want sensitive information shown below to be part of your deployment – i.e. you could accidentally check in your configuration.   {quote}adminPrivateKey:  pem: "-----BEGIN PRIVATE KEY----- <etc>"    signedCert: path: "/tmp/somepath/signed-cert.pem"{quote}  ></body> </Action>
<Action id="42184" issue="19331" author="baha-sk" type="comment" created="2018-03-26 21:00:08.0" updateauthor="baha-sk" updated="2018-03-26 21:03:05.0"> <body><! CDATA  ~paul.sitoh , since keys contain sensitive info, we use BCCSP to load them through HSM, we don't embed them in the config or even use path values in PROD. Check the BCCSP library that comes with Fabric. One can plug their own crypto suite into the GO SDK now.  For testing purposes, we embed keys/certs in the config. But for PROD, we use a custom crypto suite.     ></body> </Action>
<Action id="42194" issue="19331" author="paul.sitoh" type="comment" created="2018-03-27 08:34:39.0" updateauthor="paul.sitoh" updated="2018-03-27 08:43:28.0"> <body><! CDATA  ~Baha-sk  noted.  However, I was eluding to a wider point namely, just having the option of either volume based or content based properties: path or pem is somewhat limiting. It it was URL/URI based, then we can support multiple scheme: file, http, https, etc. This would give the client the option to store their keys in service of their choice.  Granted, it would present the SDK client complexity of having to deal with multitude of schemes. Maybe one option for the static method to provide for injection of specialised backing service. For example:        const client = Client.loadFromConfig(process.env.NETWORK_CONFIG, mykeylocation) or        const client = Client.loadFromConfig(<yaml file>, <locator plugin>)  Something along this line. If location plugin not provided, it will assumed file or http) and the client can extract those as is.     ></body> </Action>
<Action id="42206" issue="19331" author="harrisob@us.ibm.com" type="comment" body="I have opened https://jira.hyperledger.org/browse/FAB-9186 to allow for the `path` attribute to be more than a local file." created="2018-03-27 12:42:42.0" updateauthor="harrisob@us.ibm.com" updated="2018-03-27 12:42:42.0"/>
<Action id="42214" issue="19331" author="baha-sk" type="comment" created="2018-03-27 14:16:14.0" updateauthor="baha-sk" updated="2018-03-27 14:16:14.0"> <body><! CDATA  ~paul.sitoh , I think from an SDK config perspective, the value of path for a cert can be anything. It is up to the client application to interpret the value the way it makes sense. In other words, nothing stops the user to set path as a url and in their app's logic, check if the value has a url prefix then load the cert from that url into a temporary local path.   Will it add value to add remote path field in the config? I think a path is a path regardless if it's local or remote, it is meaningless to the SDK but useful for the client.  Just my two cents.     ></body> </Action>
<Action id="42463" issue="19331" author="aatkddny" type="comment" created="2018-04-03 13:19:01.0" updateauthor="aatkddny" updated="2018-04-03 13:19:01.0"> <body><! CDATA There's a small but important difference between the spec and the attachment.  Look at the CA "registrar" field. In the spec a single value is implied, yet in the attachment it's an array. Since at least one supporter of this venture is returning an array in their API, but the java SDK expects a single value, figuring out which it is supposed to be will help everyone long term.   ></body> </Action>
<Action id="42707" issue="19331" author="paul.sitoh" type="comment" body=" ~harrisob@us.ibm.com  is this project  https://jira.hyperledger.org/browse/FAB-9186 superseding this FAB-5363?" created="2018-04-09 08:38:40.0" updateauthor="paul.sitoh" updated="2018-04-09 08:38:40.0"/>
<Action id="59897" issue="19331" author="siddjain" type="comment" created="2019-05-09 23:56:46.0" updateauthor="siddjain" updated="2019-05-09 23:56:46.0"> <body><! CDATA is the client auth portion of this spec not been implemented? we are not able to connect to a ca server that has clientauth enabled. we are using the pattern below.  # Client key and cert for TLS mutual auth with Fabric CA. If the target Fabric CA server # does not have TLS mutual auth turned on, then this section is not needed client: keyfile: path/to/tls/fabricca/certs/client/client_fabric_client-key.pem certfile: path/to/tls/fabricca/certs/client/client_fabric_client.pem  ></body> </Action>
<Action id="59903" issue="19331" author="davidkel" type="comment" body=" ~siddjain I assume you are referring to the node sdk here ? It doesn&apos;t look like it is implemented in the node sdk. " created="2019-05-10 08:15:03.0" updateauthor="davidkel" updated="2019-05-10 08:15:03.0"/>
<Action id="59918" issue="19331" author="siddjain" type="comment" body="Thanks Dave. How will a node app connect to a fabric ca server then that has client auth enabled? " created="2019-05-10 16:08:48.0" updateauthor="siddjain" updated="2019-05-10 16:08:48.0"/>
<Action id="59920" issue="19331" author="davidkel" type="comment" body=" ~siddjain  If it is possible then you would have to use the node-sdk apis directly to build the certificate authority objects, however a quick look through the code suggests that the node-sdk may not support a ca server with client auth enabled. I suggest you raise a specific Jira on the node-sdk about this to get a definitive answer. The java-sdk may support it I haven&apos;t looked." created="2019-05-10 17:03:53.0" updateauthor="davidkel" updated="2019-05-10 17:03:53.0"/>
<Action id="59921" issue="19331" author="siddjain" type="comment" created="2019-05-10 17:18:33.0" updateauthor="siddjain" updated="2019-05-10 17:18:33.0"> <body><! CDATA Thanks Dave. Yes I have done exactly that   https://jira.hyperledger.org/browse/FAB-15430  ></body> </Action>
<Action id="59923" issue="19331" author="davidkel" type="comment" body=" ~siddjain I&apos;ve moved it to https://jira.hyperledger.org/browse/FABN-1234 so it&apos;s now under the node-sdk specific project." created="2019-05-10 17:27:05.0" updateauthor="davidkel" updated="2019-05-10 17:27:05.0"/>
