<Issue id="46945" key="FABN-1714" number="1714" project="10604" reporter="bestbeforetoday" assignee="bestbeforetoday" creator="bestbeforetoday" type="10001" summary="Support persistence of in-flight transactions" priority="3" resolution="10000" status="6" created="2021-06-15 15:10:41.0" updated="2021-06-17 15:22:57.0" resolutiondate="2021-06-17 15:22:57.0" votes="0" watches="1" workflowId="60856" archived="N"> <description><! CDATA *As an* application developer *I want* to persist and reconstruct transactions that I submit *So that* I can workaround failure scenarios where the orderer loses a successfully submitted transactions, even in the event of a client-side application failure  In certain failure situations, a transaction that has been successfully received by the orderer may still be lost before it is committed to a block and distributed to peers. In this case a client application may (after failing to observe a commit corresponding to the submitted transaction ID) resubmit the same transaction to the orderer by simply calling {{submit()}} again on the same Transaction object. The use of the same Transaction object will mean the same transaction ID (and nonce) is used, and so if the first submit attempt does eventually commit, the second will be invalidated due to a duplicate transaction ID and there will be no duplication of committed work on the ledger.  A simplistic example of retrying the transaction submit on a timeout waiting for the commit status might be:  {code:javascript} import { TimeoutError, Transaction } from 'fabric-network';  const transaction = contract.createTransaction('myTxFunction'); const result = await submitWithRetry(transaction, 'one', 'two', 'three');  async function submitWithRetry(transaction: Transaction, ...args: string  ): Promise<Buffer> { for (;;) { try { return await transaction.submit(...args); } catch (error) { if (!(error instanceof TimeoutError)) { throw error; } } } } {code}  However, if the client application terminates during this process, the client-side Transaction object will be lost and there is no mechanism to allow the client application to persist and reconstruct these Transaction objects to enable recovery from this client application termination without potentially losing transaction information.  This story suggests adding a {{serialize()}} method to the Transaction object to serialize its internal state, and a corresponing {{deserializeTransaction()}} method on the Contract to allow a Transaction to be reconstructed from this serialized form. The burden of persisting and resubmitting the transaction to mitigate the unreliability of the orderer still lies with the client application.  ></description> </Issue>
