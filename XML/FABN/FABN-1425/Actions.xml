<Action id="65645" issue="43347" author="bestbeforetoday" type="comment" created="2019-11-20 11:18:37.0" updateauthor="bestbeforetoday" updated="2019-11-20 11:19:59.0"> <body><! CDATA Right now you would achieve this result as follows (in Java and TypeScript respectively): {code:java} Collection<Peer> org1Peers = network.getChannel().getPeersForOrganization("org1"); byte   result = contract.createTransaction("foo") .setEndorsingPeers(org1Peers) .submit(); {code} {code:java} const org1Peers = network.getChannel().getPeersForOrg('org1'); const result = await contract.createTransaction('foo') .setEndorsingPeers(org1Peers) .submit(); {code}    Does adding a *setEndorsingOrganization()* function to the transaction save enough work to be worth the tradeoff of increasing the API footprint?  ></body> </Action>
<Action id="65656" issue="43347" author="ldesrosi" type="comment" created="2019-11-20 16:17:19.0" updateauthor="ldesrosi" updated="2019-11-20 16:17:19.0"> <body><! CDATA When running a transaction *+without+* using the *setEndorsingPeers*, if Service Discovery is enabled, the underlying API will figure out which Orgs needs to endorse and which peers have the chaincode installed.  Calling *getPeersForOrganization* for a specific organization will return every peer, whether they have the chaincode or not.  When requiring the endorsement of 2 organizations you also need to combine both lists into one. Basically, if the network is more complex, figuring out the list of peers to pass to *setEndorsingPeers* will require more work.  The value of *setEndorsingOrganization* would come from having the SDK leverage the Service Discovery to identify the appropriate peers and only send the endorsement request to the selected one.  ** In terms of implementation, it can start simply by having the *setEndorsingOrganization* send a request to all peers returned by the *getPeersForOrganization* call but it would eventually need to be able to select the right peer based on information from the service discovery.      Note that the *setEndorsingOrganization* should be additive... meaning I should be able to do:   {code:java} const result = await contract.createTransaction('foo') .setEndorsingOrganization(org1) .setEndorsingOrganization(org2) .submit(); {code}    ></body> </Action>
<Action id="65658" issue="43347" author="bestbeforetoday" type="comment" created="2019-11-20 16:25:28.0" updateauthor="bestbeforetoday" updated="2019-11-20 16:25:28.0"> <body><! CDATA I am thinking now that having a *setEndorsingOrganizations()* function would allow us (probably at some point in the future) to be smarter about how we go about obtaining endorsements, particularly when using discovery. So although for a first pass the implementation is likely to be as simple as the code I pasted above, it would avoid the need to users to dip down to the low-level API and also to pick up smarter future behaviour without any code change. So this does sound like a good addition to me.  The questions I have are: # What should the API look like. # How should *setEndorsingPeers()* and *setEndorsingOrganizations()* interact with each other?     For the API then perhaps something like:    {code:java} public interface Transaction { /** * Set the organizations that should be used for endorsement of transactions submitted to the ledger using * {@link #submit(String...)}. * @param orgNames Endorsing organization names. * @return this transaction object to allow method chaining. */ Transaction setEndorsingOrganizations(Collection<String> orgNames); }{code}       This is great for variable numbers of endorsing organizations or where the endorsing organizations are already stored in a collection. The only issue with this is if the typical usage pattern will be for the client to know a specific number of endorsing organizations that are going to be existing variables, such as _buyer_ and _seller_ organizations. In which case the API above would require this client code: {code:java} contract.createTransaction("trade") .setEndorsingOrganizations(Arrays.asList(buyerOrg, sellerOrg)) .submit(...); {code} Perhaps a more suitable API for this usage would be: {code:java} public interface Transaction { /** * Set the organizations that should be used for endorsement of transactions submitted to the ledger using * {@link #submit(String...)}. * @param firstOrgName First endorsing organization name. * @param otherOrgNames Additional endorsing organiation names. * @return this transaction object to allow method chaining. */ Transaction setEndorsingOrganizations(String firstOrgName, String... otherOrgNames); } {code} Which gives the following client code: {code:java} contract.createTransaction("trade") .setEndorsingOrganizations(buyerOrg, sellerOrg) .submit(...); {code} On the interaction between *setEndorsingPeers()* and *setEndorsingOrganizations()*, the simplest option is probably to treat them as mutually exclusive and for it to be an error to call both functions for a transaction invocation. If a more complex interaction is desirable, it would be good to have some use cases to drive the discussion, and this might mean re-thinking what the API should look like.  ></body> </Action>
<Action id="66009" issue="43347" author="harrisob@us.ibm.com" type="comment" body="So I will add the *setEndorsingOrganizations(org...)* when not using discovery will get all peers for those orgs and when using discovery will tell the low level to filter the discovered peers with the orgs. As for the interaction of the *setEndorsingPeers* and *setEndorsingOrganizations* I think the best thing to do is have the last one called win." created="2019-12-03 14:22:32.0" updateauthor="harrisob@us.ibm.com" updated="2019-12-03 14:22:32.0"/>
<Action id="66062" issue="43347" author="bestbeforetoday" type="comment" created="2019-12-04 18:02:34.0" updateauthor="bestbeforetoday" updated="2019-12-04 18:02:34.0"> <body><! CDATA I'm thinking that we should just remove *setEndorsingPeers* and replace it with *setEndorsingOrganizations* in v2. The implementation suggested by  ~harrisob@us.ibm.com  sounds great, and is already a win over using *setEndorsingPeers* when using discovery, which should be the typical case.  The only use-case I've heard mentioned that *setEndorsingOrganizations* doesn't cover directly is where the client code wants to manage load balancing of proposal requests across peers. I'm not sure this is a particularly valid use case given that (I think) some randomization of the peers used by the discovery endorsement handler happens anyway but, even if this is something we want to address, I think some future pluggable handler (similar to QueryHandler) is a better solution to that problem than exposing *setEndorsingPeers* in the main API.  ></body> </Action>
<Action id="66518" issue="43347" author="denyeart" type="comment" created="2020-01-07 21:27:03.0" updateauthor="denyeart" updated="2020-01-07 21:36:30.0"> <body><! CDATA  ~harrisob@us.ibm.com   ~bestbeforetoday   ~yacovm   ~andrew-coleman   The ability to have the application pick the endorsing orgs is indeed very important. For example if the app from OrgA is doing a transaction with OrgB, and the endorsement policy requires that the two members involved in the transaction endorse it (some combination of chainocde EP, state based endorsement EP, or private data collection EP), then the application will often inherently know the endorsement should be sent to OrgA and OrgB peers, without needing to consult the Service Discovery endorsement service. This is especially true in private data scenarios.  I just have one question about setEndorsingOrganizations (apologies if all this has been discussed before...). It seems there are two valid approaches when using setEndorsingOrganizations. Which approach is targeted? It seems both may actually be important...  *Approach 1 - no endorsement layout query performed*  Application specifies orgs to endorse. Utilize Service Discovery for peer membership query (org to peer mapping). SDK sends endorsement request to an available peer from each specified org. (In this scenario it is assumed that each peer has the chaincode deployed).  *Approach 2 - endorsement layout query performed*  Application specifies orgs to endorse. Utilize Service Discovery for endorsement layout queries. SDK looks at intersection of returned endorsement layouts and specified orgs. In this case the SD endorsement query takes chaincode deployment into consideration. But there is an additional hit on both peer and client side, especially if the layout combinations are large (e.g. an endorsement policy like "any 3 orgs of 100 channel members" would have many layouts, and if there are too many layouts, not all will be returned to client, which could result in no intersection with the specified orgs).     I think there will be use cases for both patterns. To deal with the problem of too many layout combinations, maybe the Service Discovery endorsement query should take the specified orgs as input in the future?  Note - one motivation of this question is that collection-level endorsement policies have been added in v2.0, but Service Discovery does not yet support it (FAB-17279), therefore I'm curious if Approach 1 is an option in the short term.  ></body> </Action>
<Action id="66520" issue="43347" author="yacovm" type="comment" created="2020-01-07 22:02:26.0" updateauthor="yacovm" updated="2020-01-07 22:02:26.0"> <body><! CDATA {quote}To deal with the problem of too many layout combinations, maybe the Service Discovery endorsement query should take the specified orgs as input in the future? {quote}    Obviously if you have some information that would shrink the number of combinations - it's easy to add some pre-processing for it, however - this is very ad hoc and specific. What if we want to include these orgs in addition to some combination of the EP itself?  I think that if you have a simple EP such as a 3 out of 100, but at the same time you have a state based endorsement that requires you to use specific orgs - then just don't use discovery endorsement queries in the first place (use peer membership queries), since it was decided not to implement support for SBE.  ></body> </Action>
<Action id="66654" issue="43347" author="harrisob@us.ibm.com" type="comment" created="2020-01-13 18:18:31.0" updateauthor="harrisob@us.ibm.com" updated="2020-01-13 18:18:31.0"> <body><! CDATA Going into v2 fabric-network, the high level API we will take a list of orgs and use it to filter the target peers for the submit. The SDK will partially handling both approaches listed by David.  *Approach 1*, If not using discovery: The target list of peers for endorsement will be those peers in the orgs as known  by the channel.  {color:#00875a}Retry and checking to see if the peer has the chaincode installed would need to be added. Also needing to be added is being able to use discovery to initialize the channel but not use it during the submit. {color:#172b4d}The user could use discovery to load the channel (network instance) and then get the list of peers for each org and then build a specific peer target list for the submit, thereby handling it manually.{color}{color}  {color:#de350b}{color:#172b4d}*Approach 2*, If using discovery: The layout peers used for endorsement will be in those in the orgs.{color} {color:#00875a}Since there is a chance that the client will not get all the layouts when the list gets very large, the service discovery query should include orgs to pre-filter the layouts for the client to guarantee that the layouts will contain only peers in the requested orgs. {color}{color}     ></body> </Action>
<Action id="69704" issue="43347" author="denyeart" type="comment" created="2020-07-16 13:14:19.0" updateauthor="denyeart" updated="2020-07-16 13:14:19.0"> <body><! CDATA  ~harrisob@us.ibm.com   I'm not quite understanding the last comment about Approach 1... is Service Discovery peers query still used under the covers? What exactly does the client code need to do? Is this documented in one of the SDK tutorials? I expect we'll use this pattern in the secured agreement asset transfer sample application...  ></body> </Action>
<Action id="69707" issue="43347" author="harrisob@us.ibm.com" type="comment" created="2020-07-16 18:48:40.0" updateauthor="harrisob@us.ibm.com" updated="2020-07-16 18:48:40.0"> <body><! CDATA Approach 1 in v2.2 `fabric-network` will filter the known peers that have been configured with an organization when not using discovery (which is not the usual case) or will filter the peer group list of the endorsement layouts when using discovery.  `fabric-network` would have to be enhanced to create a network using discovery (so it discovers all the peers and mspids) and then not use discovery when submitting a transaction (currently turning network discover on also turns on endorsements with discovery). That way when the user sets the {color:#795e26}transaction.setEndorsingOrganizations( msp1, msp2 );{color} , the endorsement will be sent to a filtered list of discovered peers rather then filtering the endorsement layout group of peers based on the policies.  ></body> </Action>
<Action id="69717" issue="43347" author="denyeart" type="comment" created="2020-07-17 12:07:15.0" updateauthor="denyeart" updated="2020-07-17 13:25:30.0"> <body><! CDATA Thanks  ~harrisob@us.ibm.com  ,  The problem with the approach is the 'endorsing peers' query may return a lot of layouts, and if there are too many, may filter layouts on server side before returning the result to client. Therefore we need an option that uses SD 'peers query' and simply picks available peers based on MSPID.  I've opened FABN-1601  ></body> </Action>
