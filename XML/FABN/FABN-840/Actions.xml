<Action id="48955" issue="31119" author="harrisob@us.ibm.com" type="comment" body="If the client builds the same request and then signs it, why would the signatures be different ?" created="2018-08-16 18:22:07.0" updateauthor="harrisob@us.ibm.com" updated="2018-08-16 18:22:07.0"/>
<Action id="48964" issue="31119" author="yacovm" type="comment" created="2018-08-16 19:48:16.0" updateauthor="yacovm" updated="2018-08-16 19:48:16.0"> <body><! CDATA {quote}If the client builds the same request and then signs it, why would the signatures be different ?{quote}  Because  ECDSA|https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm , the signature scheme that is used in fabric-  involves in generating a random value per signature which affects the output of the signature algorithm  ></body> </Action>
<Action id="49025" issue="31119" author="harrisob@us.ibm.com" type="comment" created="2018-08-17 14:39:47.0" updateauthor="harrisob@us.ibm.com" updated="2018-08-17 14:39:47.0"> <body><! CDATA Then if the signatures are supposed to be different due to the random value, it seems that the fabric should think that having the same signature is a replay attack ?  Â   ></body> </Action>
<Action id="49026" issue="31119" author="yacovm" type="comment" created="2018-08-17 14:58:01.0" updateauthor="yacovm" updated="2018-08-17 17:20:43.0"> <body><! CDATA Let me try to explain and elaborate. * When you sign different messages but use the same randomness to compute a signature, this is not secure and might reveal your private key ( ~angelo.decaro  please correct me if I'm wrong) * Since all practical signature algorithms are stateless (they don't save data between their invocations), those that use random values always roll a new random value for the signature. You're going to hit the same random value only if you have a bad random number generator (bad hardware), or if god really hates you. * What the SDK needs to do, is- given a discovery request *M* , and a signature that the SDK signed on it - *S*, cache *(M, S)* and then if the SDK needs to send *M* again, it will just send *(M, S)* to the peer instead of signing again. The peer, also caches *(M, S)* and if it sees that the same client (identified by the TLS certificate) sent *(M, S)* - it would know that the client was authorized before for the channel, and thus not verify the signature again and waste CPU cycles. ** *Why is it safe for the peer?* Because the client is authenticated with mutual TLS, and the request M contains the client's TLS certificate hash, so the first time the peer authorized the request - it actually also can be sure that the client possesses the private key of the TLS certificate it used to connect to the peer, as well as the private key that signed the TLS certificate's hash. ** *Why is it safe for the client, to send again the same (M, S) and not sign M again every time?* Well - since the client repeats to the peer information that was sent to the peer in the past and nothing more - if there had been some attack, it could have been made without the client sending again the same request with the same signature. * *Why is this not a replay attack?* Assume that some malicious party (client or peer), obtains access to the pair *(M, S)* sent in the past by some other client (the original client) and wants to send it to some peer that would accept *(M, S)* from the real client, and return a discovery response. The discovery request *M*, contains the hash of the TLS certificate of the original client, and thus - assuming the malicious party doesn't possess the private key of the TLS certificate of the original client that creates *(M, S)*,it means it has a different TLS certificate (it has to use mutual TLS) and since the TLS certificate of the malicious party doesn't match the one in M, the peer would reject the query.  ></body> </Action>
<Action id="64985" issue="31119" author="harrisob@us.ibm.com" type="comment" body="The discovery request build by the NodeSDK is cached and may be reused. However the actual signature is not saved individually from the request. " created="2019-10-24 18:17:17.0" updateauthor="harrisob@us.ibm.com" updated="2019-10-24 18:17:17.0"/>
