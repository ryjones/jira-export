<Action id="68564" issue="44635" author="sergey.minaev" type="comment" created="2020-03-25 13:04:08.0" updateauthor="ashcherbakov" updated="2020-03-25 13:10:20.0"> <body><! CDATA  ~dhuseby   ~MikeLodder  thank you for reporting the potential security problem. We (indy team) spent some time analyzing the report, links to the source code and articles. And we are in doubt do we understand the report (or the crypto) correctly. Please take a look at our findings below, and also please note, that we are not cryptographers so *any corrections from you are very appreciated*.  *In short, we can not see any problem neither in BLS nor Revocation (the only exception is probably the out-dated EC BN254) and we hope to receive more guidance from you.* *1) BLS: the only thing in BLS codebase of IndyCrypto depending on CURVE_ORDER is the key generation. And the private key is not a point on the ECC but a number from `Z_n` where n==CURVE_ORDER in amcl.* *2) Other helpers are not used in BLS and belong to CL logic. They are not about EC points operations, but about calculations of `g^x` where g is a generator (EC point), and `x` is a result of a mapping (a+b, a*b. a^b) from Z_n to Z_n, and n=CURVE_ORDER.*  Please find more details below. h2. 2 versions of BLS  As you know indy-crypto is about to be finally archived and replaced in Indy stack. The URSA contains almost the same code for compatibility as an alternative to a new one. So instead of "indy-crypto" vs "URSA" let's define 2 shortcuts for 2 different implementations. I suggest using URSA's features for that.  `bls_bn254` - old implementation based on bn254 curve - single option in indy-crypto  https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/src/bls/mod.rs  - also present in URSA at  https://github.com/hyperledger/ursa/blob/master/libursa/src/bls/mod.rs  `bls_bls12381` - new one implementation in URSA  https://github.com/hyperledger/ursa/blob/master/libursa/src/signatures/bls.rs  (based on new curve). In my chat this Mike he mentioned that it contains correct implementation for EC operations and should be used as a replacement of `bls_bn254`.  `bls_bn254` uses helpers from pair/amcl submodule of URSA and `GroupOrderElement`, `PointG1`, and `PointG2`. The pair/amcl helpers and other amcl related code is based on `amcl` crate 0.2.0  https://crates.io/crates/amcl/0.2.0  As mentioned in the ticket description helpers for the `GroupOrderElement` contains some math operations by module `CURVE_ORDER` (lines 403 and below). As far as I can see, only `new_from_seed` and `new` helpers are used for BLS, other helpers of `GroupOrderElement` are used in CL Revocation only. And `GroupOrderElement` used as a Private Key. All the rest of BLS logic is based on helpers for `PointG1` and `PointG2` structures from the same file. But they are not using CURVE_ORDER, the amcl calls are used directly. E.g. `g1mul` call from `pair` module of external `amcl` crate.  `bls_bls12381` uses amcl_wrapper and the wrapper is based on miracl_amcl 3.2.5  https://crates.io/crates/miracl_amcl/3.2.5  It uses `FieldElement` structure from the `amcl_wrapper` as a Private Key. Also, it uses `G1` and `G2` from the wrapper. So private key is constructed as the following `PrivateKey::random();` there random is  https://github.com/lovesh/amcl_rust_wrapper/blob/master/src/field_elem.rs#L103  and it's based at `get_big_num_from_RAND` function in the same file. As you can see it also uses Curve Order.  https://github.com/lovesh/amcl_rust_wrapper/blob/master/src/field_elem.rs#L335 . *So the key generation part seems the same in `bls_bn254` and `bls_bls12381`.* As far as I can see the multiplication there is implemented by defining the Mul trait of Rust to overload * operator. Internal are based on `scalar_mul_const_time` function  https://github.com/lovesh/amcl_rust_wrapper/blob/master/src/group_elem_g1.rs#L108  and it's miracl_amcl::bls381::ECP::mul  https://github.com/miracl/amcl/blob/master/version3/rust/src/ecp.rs#L1003  h2. Helpers with `% CURVE_ORDER`  Let's define (please correct me in case of ambiguous or wrong terms): E - set of EC points over field F_p (with order p = MODULUS) N = |E| (curve order?) G - additive cyclic subgroup of EC (G1 or G2) there is g_0 - the generator for the subgroup n = |G|, (`CURVE_ORDER` constant in amcl?), so `n * g_0` = 0 Z_n = 0..(n-1) h3. Key generation  Then according to  https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html  Private key is `a` from `Z_n`. And the public key is `h = g_0^a` from G So seems like it should be aligned to `CURVE_ORDER` constant. h3. Other helpers in `GroupOrderElement` of old `bls_bn254`  Seem like the naming in the codebase is misleading. Let me describe my understanding of `pow_mod` helper. ``` /// (GroupOrderElement ^ GroupOrderElement) mod GroupOrder pub fn pow_mod(&self, e: &GroupOrderElement) -> UrsaCryptoResult<GroupOrderElement> { ```  Actually `GroupOrderElement` is not from E or G. It's from Z_n. So these helpers are not about EC point operations. They are about the calculation of expressions like `g_0^x` where `x` is a number from Z_n. And `x` can be an expression like `a+b`, `a*b`, `a^b`, where `a`, `b` in `Z_n`, and the result is in `Z_n` as well. Seems like CURVE_ORDER modulo is the appropriate one here. h2. Hashing  For Indy use cases it seems like not a problem. There is no way for an attacker to measure the signing time itself as it's hidden by consensus algorithm and network delays. By the way, I don't understand how timing attack is possible on that hash. There is a transformation H for an incoming message (M) to point from G. So H(M) = g1 from G. As mentioned in the ticket `H` does SHA256 on the message and checking is it on the EC. So it doesn't related to private key at all. In other words, the timing for the particular message depends on only the Group and the message itself. Could you provide more context, why you are considering timing attack here?  ></body> </Action>
<Action id="68565" issue="44635" author="mikelodder" type="comment" created="2020-03-25 13:21:05.0" updateauthor="mikelodder" updated="2020-03-25 13:21:05.0"> <body><! CDATA Z_n is the curve modulus, not the curve order. Hart Montgomery and three other cryptographers have verified that if you ever you curve order, that is incorrect. You are misunderstanding the Stanford paper with that conclusion. I have already update amcl_rust_wrapper to use the correct modulus here -  https://github.com/mikelodder7/amcl_rust_wrapper/blob/master/src/field_elem.rs.   The modulus is used anytime you do field element arithmetic. It doesn't pertain to points. The hashing of the message can be hidden away using the hash2curve crate at  https://crates.io/crates/hash2curve,  so using shouldn't be an issue.  BLS signatures are created by hashing the message to a curve point then multiplying that point by the private key. So two things can happen if the hash is done incorrectly:     1- If the point is invalid, then the signature will also be invalid and not verify  2- If the point is invalid, then it's theoretically possible to discover the private key.  Notice how neither of those has to do with timing attacks. Because of this alone, I would want to change the algorithms.  Now a timing attack happens when an attacker can submit data to be signed to an endpoint and received back a signature. Based on how much it takes to respond, certain bits of information is leaked. Nadia Heninger, for example, used this very idea to extract TPM keys  https://tpm.fail/tpmfail.pdf.  I hope that helps.     hash2curve crate has been verified by two cryptographers to meet the spec. The algorithms implemented there are constant time and thus not susceptible to timing attacks. The underlying microarchitecture might not have constant time multiplies but there isn't much we can do about that.  ></body> </Action>
<Action id="68570" issue="44635" author="ashcherbakov" type="comment" created="2020-03-25 13:57:28.0" updateauthor="ashcherbakov" updated="2020-03-25 14:03:46.0"> <body><! CDATA We understand that curve order |E(F_p)| (a number of elements) is not the same as the prime order of G1 and G2 cyclic groups (denoted by n) where the private key is in Z_n. We may be wrong, but it looks like amcl uses CURVE_ORDER constant as the prime order of G1 and G2 cyclic groups, and MODULUS as the order of a field F_p the elliptic curve is over (that is p=MODULUS)  If `CURVE_ORDER` is an order of EC (that is the number of elements), then it must be >= than the order n of a cyclic subgroup G1 or G2. But according to https://github.com/miracl/amcl/blob/master/version3/rust/src/roms/rom_bn254_64.rs#L24, `MODULUS` is greater than `CURVE_ORDER`, which means that an order of a subgroup is greater than the order of the group => a contradiction.    bq. Ursa has this fix in its amcl_wrapper crate and implemented at https://github.com/hyperledger/ursa/blob/master/libursa/src/signatures/bls.rs  As it was mentioned, this code (in Ursa master) uses CurveOrder as well: {code} n = BigNum::randomnum(&BigNum::new_big(&CurveOrder), r); {code}  According to your last comment it looks like `bls_bls12381` implementation in the master Ursa needs to have a fix as well (in `amcl_rust_wrapper`)?  ></body> </Action>
<Action id="68572" issue="44635" author="mikelodder" type="comment" created="2020-03-25 14:06:40.0" updateauthor="mikelodder" updated="2020-03-25 14:06:40.0"> <body><! CDATA Yes, I have had an open PR to lovesh's amcl_rust_wrapper crate for a long time but he hasn't responded so I published amcl_wrapper_ml which does have this fix.     Group elements are part of the cyclic group CURVE_ORDER. However, all field element operations MUST be done over the MODULUS. I'm making sure it should be that way everywhere.  ></body> </Action>
<Action id="68573" issue="44635" author="ashcherbakov" type="comment" created="2020-03-25 14:14:01.0" updateauthor="ashcherbakov" updated="2020-03-25 14:14:01.0"> <body><! CDATA {quote}Group elements are part of the cyclic group CURVE_ORDER. However, all field element operations MUST be done over the MODULUS. I'm making sure it should be that way everywhere. {quote} I believe it depends on the operation. If you have two EC (over F_p) points A and B, and perform A+B operation, then it must be over the p=MODULUS.  But if you have a cyclic group G1 of order q (q=CURVE_ORDER) with a generator g0, then a BLS primary key is a number from Z_q (over CURVE_ORDER), not Z_p (over MODULUS). That's how we read  https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html:  {quote}a bilinear pairing e:G0×G1→GT. The pairing is efficiently computable, non-degenerate, and all three groups have prime order q {quote} {quote}choose a random α← Z_q {quote}  ></body> </Action>
<Action id="68575" issue="44635" author="ashcherbakov" type="comment" created="2020-03-25 14:22:47.0" updateauthor="ashcherbakov" updated="2020-03-25 14:22:47.0"> <body><! CDATA And the same for the methods `pow_mod`, `add_mod`, `sub_mod`, `mul_mod` ( https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/src/pair/amcl.rs#L426).  The input parameter `r` there is from Z_q where q is an order of groups G1, G2, please see  https://github.com/hyperledger/indy-crypto/blob/master/libindy-crypto/docs/AnonCred.pdf  An example where `pow_mod` and `add_mod` is used is equation (17) on the page 5: sk+gamma^i is a mapping from Z_q -> Z_q where q=CURVE_ORDER.     ></body> </Action>
<Action id="68576" issue="44635" author="ashcherbakov" type="comment" body="BTW we would be happy to have a call to discuss this in more details." created="2020-03-25 14:23:39.0" updateauthor="ashcherbakov" updated="2020-03-25 14:23:39.0"/>
<Action id="68581" issue="44635" author="ashcherbakov" type="comment" created="2020-03-25 15:59:54.0" updateauthor="ashcherbakov" updated="2020-03-25 15:59:54.0"> <body><! CDATA We had a meeting with Mike L. and Hart M. and came to the following conclusion: * All the mentioned functions are about the exponents only (from Z_q where q=CURVE_ORDER), so it's correct to use mod over CURVE_ORDER. * There is no timing attack related to hashing algorithm used in BLS * However, the current indy algorithm for BLS hashing may produce non-uniform distribution which can be considered as a security bug. However, this is not a critical bug, so that we can plan migration to a new hashing algorithm according to a normal schedule instead of a hot fix deprecating the old algorithm.  Action Item: * There is no serious security vulnerability, so no immediate fixes are needed * We need to improve the documentation for indy-crypto's and Ursa's  `pow_mod`, `add_mod`, `sub_mod`, `mul_mod` calls to explicitly mention that they are done over the exponents from Z_q, not F_p. * Still plan to migrate to a new hashing algorithm and a new Elliptic Curve for BLS in future * Communicate with Mike about the failures observed for some test vectors.     ></body> </Action>
<Action id="68812" issue="44635" author="dhuseby" type="comment" body="This security issue is being handled as a Github Security Advisory as a test of that system. Please continue work on this issue over here: https://github.com/hyperledger/ursa/security/advisories/GHSA-c39v-9xw6-85hr" created="2020-04-13 19:56:47.0" updateauthor="dhuseby" updated="2020-04-13 19:56:47.0"/>
<Action id="68813" issue="44635" author="dhuseby" type="comment" body="Please use the security advisory over on Github: https://github.com/hyperledger/ursa/security/advisories/GHSA-c39v-9xw6-85hr" created="2020-04-13 20:09:29.0" updateauthor="dhuseby" updated="2020-04-13 20:09:29.0"/>
