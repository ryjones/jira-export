<Issue id="32791" key="INDY-1585" number="1585" project="10303" reporter="ashcherbakov" creator="ashcherbakov" type="10001" summary="As Indy Node, I should not process and order client requests for which PoolTimeout was already received" priority="3" status="10200" created="2018-08-13 13:05:07.0" updated="2018-08-17 10:58:34.0" votes="0" watches="1" workflowId="44028"> <description><! CDATA If the pool was busy and slow (that is wasn't able to get clients reqs from transport queues fast enough), so that we are sure clients received PoolLedgerTimeout for a request, then it doesn't make sense to start processing and ordering this request once it's finally got from the transport queue.  It can also solve the issue with a long ordering and processing of stashed (old) requests in the queue after the DDoS.  *Acceptance criteria:* * Check the time of request creation when get it from the queue  *  ** We may need to extend request format to include timestamp there ** We may use  reqId is it's time-based * If the time is less than the PoolLedgerTImeout + some delta, then just discard the request. Do not send anything to the client.     *Concerns:* * PoolLedgerTimeout is currently configruable on the SDK side, so we may not know the exact time clients wait for requests * The client may have different timing than on the node side, that's why we need some delta when check it. * Can we use reqId to get client's timestamp? * What if request is re-sent with the same reqId multiple times? Should we reject before checking that the req with the given digest is already written to the ledger?  ></description> </Issue>
