<Action id="57424" issue="37832" author="toktar" type="comment" created="2019-02-21 15:07:21.0" updateauthor="toktar" updated="2019-02-21 16:35:04.0"> <body><! CDATA *POA:* Add the transaction AUTH_RULE_CHANGE='120' for Config ledger to change authentication rules. In a static validation will be checked:  a correct filling for CONSTRAINT_ID (AND and OR for constraint list and ROLE for a one constraint)  a correct filling for OLD_VALUE (transaction should include this value if AUTH_ACTION == EDIT) an auth key is exited in auth_map.  In dynamic validation is necessary to verify that the sender has the rights to change auth_map. The transaction will have followed structure: {code:java} class ClientAuthRuleChangeOperation(MessageBase): 	 schema = ( 		(TXN_TYPE, ConstantField(AUTH_RULE_CHANGE)), (CONSTRAINT, ConstraintField()), (AUTH_ACTION, ChooseField(ADD_PREFIX, EDIT_PREFIX)), (FIELD, LimitedLengthStringField(max_length=AUTH_FIELD_LIMIT)), (OLD_VALUE, LimitedLengthStringField(max_length=AUTH_FIELD_LIMIT, optional=True)), (NEW_VALUE, LimitedLengthStringField(max_length=AUTH_FIELD_LIMIT)) ) typename = AUTH_RULE_CHANGE 	  class ConstraintField(FieldBase): 	def _specific_validation(self, val): 		pass  class ConstraintListField(MessageValidator): schema = ( (f.CONSTRAINT_ID.nm, ChooseField(e.value for e in ConstraintsEnum)), (f.AUTH_CONSTRAINTS.nm, IterableField(ConstraintField()) ) typename = AUTH_CONSTRAINT_LIST  class ConstraintEntityField(MessageValidator): schema = ( (f.CONSTRAINT_ID.nm, ChooseField(e.value for e in ConstraintsEnum), (f.ROLE.nm, RoleField()), (f.SIG_COUNT.nm, NonNegativeNumberField()), (f.NEED_TO_BE_OWNER.nm, BooleanField(exceptional_values=False, 											optional=True)), (f.METADATA.nm, AnyMapField(exceptional_values={}, optional=True)) ) typename = AUTH_CONSTRAINT  {code} So, a constraint can contain any level of constraints. Example of transaction in JSON: {code:java} {"type": "120", "data": { "constraint_id" : "AND", "auth_constraints":  { "constraint_id" : "ROLE", "role": "0", "sig_count": 1, "need_to_be_owner": false, "metadata": : {} }, { "constraint_id" : "OR", "auth_constraints":  { "constraint_id" : "ROLE", "role": "0", "sig_count": 1, "need_to_be_owner": false, "metadata": : {} }, { "constraint_id" : "ROLE", "role": "0", "sig_count": 1 }   } } } {code} or simpler form {code:java} {"type": "120", "data": { "constraint_id" : "ROLE", "role": "0", "sig_count": 1, "need_to_be_owner": false, "metadata": : {} } } {code} In addition, AuthConstraintChangeHandler should be added to integration later in scope of Pluggable Request Handlers tasks.  ></body> </Action>
<Action id="57707" issue="37832" author="ashcherbakov" type="comment" created="2019-02-28 10:43:35.0" updateauthor="ashcherbakov" updated="2019-02-28 10:43:35.0"> <body><! CDATA Implementation will be continued in the scope of INDY-2006. Validation will be done in the scope of INDY-1995.  ></body> </Action>
