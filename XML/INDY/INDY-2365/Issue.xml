<Issue id="44831" key="INDY-2365" number="2365" project="10303" reporter="swcurran" assignee="swcurran" creator="swcurran" type="10002" summary="Define the anoncreds 2 revocation ledger transactions, content and work required" priority="3" status="10200" created="2020-04-16 17:49:27.0" updated="2020-04-16 17:49:55.0" votes="0" watches="1" workflowId="58750" archived="N"> <description><! CDATA Discussions were held with some folks ( ~redmike7   ~cywolf  and myself) about anoncreds revocation 2.0 (aka Merkle Tree-based revocation) based on the capabilities exposed in Ursa.  We propose that the following attributes and approaches be used in the Indy credential revocation 2.0 instance. * Tree leaves will be indexed bits (vs. bytes) that are either 0 (not revoked) or 1 (revoked). * The Merkle tree will be an 8-ary tree (vs. binary or 4-ary). * Nodes holding the tree leaves will be 64-bit unsigned integers, ** As such, a minimum revocation registry is one layer deep with a root hash and eight 64 bit ints, and hence would be capable of handling 512 credentials. * On creation of a revocation registry, a parameter will be the depth of the tree, with a value of 1 to 7, supporting up to ~134 million credentials in a single registry. ** The table below gives the number of credentials and MByte size of the leaves by the number of layers of the registry. * The two existing revocation-related ledger transactions will continue to be used - REVOC_REG_DEF and REVOC_REG_ENTRY ** REVOC_REG_DEF will contain at least a link to the cred def and the number of layers of the Merkle Tree. Since all the leaves are 0 (all credentials unrevoked), the Merkle Tree itself is not needed. ** REVOC_REG_ENTRY will contain at least a signed Merkle Tree root and a gzip compressed set of leaf nodes in a well-defined configuration. *** Since the distribution of revoked credentials is likely to be skewed one way or the other, the compression rate in the common case is likely to be high. *** For a 7-layer ledger with (unlikely) ineffective compression the worst ledger entry size would be ~16Mb. *** The interior nodes of the Merkle Tree must be calculated from the leaves and the calculated root verified against that in the ledger transaction. **** It may be possible to organize the leaves such that a prover can stream the compressed data, decompressing only the section necessary to construct the proof--the path from the credential leaf to the root. *** A "domain separation" value is needed as well, for reasons to be added here. * As is necessary today, the holder/prover and verifier must read from the ledger the REVOC_REG_DEF and appropriate REVOC_REG_ENTRY values in creating and verifying the proof. ** Unlike today, no tails file is needed by the prover.  To be determined is whether any change is needed to Indy Node to support the transaction content, or whether the current Indy Node code can support the same transaction with different content. Note that Indy Node does not have to do anything with the transaction content other than write it to the ledger and pass it back to any readers.  ></description> </Issue>
