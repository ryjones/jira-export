<Action id="25855" issue="17691" author="ozheregelya" type="comment" body="FYI  ~krw910 ,  ~stevetolman ,  ~tylerq ,  ~ashcherbakov " created="2017-06-09 13:40:29.0" updateauthor="ozheregelya" updated="2017-06-09 13:40:29.0"/>
<Action id="26236" issue="17691" author="danielhardman" type="comment" created="2017-06-14 04:19:45.0" updateauthor="danielhardman" updated="2017-06-14 04:19:45.0"> <body><! CDATA After reading the bug report carefully, I believe we mainly have a problem with the semantics of commands in the CLI–not a problem with the logic enforced on the ledger. I think the CLI is using the last identifier and keypair in ways that are not obvious.  If this theory is true, then the bug is a serious annoyance, but it would not be a show-stopper–EXCEPT that our QA needs reliable behavior in order to test the more important underlying ledger behaviors. So we have to fix the CLI so we can test with confidence.  I asked Lovesh for some insight about the intended behavior of the send NYM transaction, and this is how he clarified:  The CLI has an `activeIdentifier` (DID) which is used while making any transactions (nodes see activeIdentifier as the author of txns). `new key  with seed ` does 2 things, creates a `Signer` object which can be considered a wrapper object over an identifier (a DID) and a keypair and sets the `activeIdentifier` to the identifier of the newly created signer object. So if you run `new key` command 3 times you will have 3 DID+keypairs in your wallet with CLI's `activeIdentifier` set to the identifier of the last created signer object. The ledger till this point does not know of any DIDs that you created locally. Now say you send a read (say GET_NYM) to the nodes, the nodes will see a DID they have not seen before but they dont care about checking the ledger since its a read and service the read, but when CLI sends a write txn (NYM) , nodes see the new DID, check in the ledger, do not find it and reject the txn (edited)  So you still have 3 DIDs+keypairs in your local wallet but nothing on ledger, but if you ask any TrustAnchor to onboard any of these DIDs to the ledger, once he does it you can send write txns from CLI using that DID (by doing `become <did>`) and then your writes will not be discarded.     ></body> </Action>
<Action id="26237" issue="17691" author="danielhardman" type="comment" body="Given Lovesh&apos;s clarification, I would like a programmer to re-analyze Olga&apos;s bug report and see if all behaviors are explained as correct. If yes, the ticket can be closed. If no, please describe where the code logic is going wrong (that is, convert Olga&apos;s external observations into a code diagnosis)–then fix the bug." created="2017-06-14 04:21:41.0" updateauthor="danielhardman" updated="2017-06-14 04:21:41.0"/>
<Action id="26729" issue="17691" author="ozheregelya" type="comment" created="2017-06-19 13:18:05.0" updateauthor="ozheregelya" updated="2017-06-19 13:21:00.0"> <body><! CDATA  ~danielhardman , sorry for late answer, unfortunately I didn't get notification about your comment.  Regarding Lovesh's clarification: I absolutely agree that new key command sets `activeIdentifier` to newly created CID. But in my example I switched on Trustee using command: {code:java} new key with seed 000000000000000000000000Trustee1{code} So, active identifier was changed to known for Ledger Trustee before sending NYM.     As far as I understand, new key  with seed  creates new CID and keypair, not DID and keypair. When I (as Trustee) send following command, {code:java} send NYM dest=FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM{code} I expect that NYM with this CID will be added to Ledger and verkey (equal to identifier) will be also added to Ledger. After that I expect that identity owner will be able to use this identifier. Now this part works as expected, we can verify it by sending GET_NYM as newly created identifier: {code:java} sovrin@test> use identifier FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM Current identifier set to FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM sovrin@test> send GET_NYM dest=FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM Getting nym FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM Current verkey is same as identifier FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM{code} Now Ledger knows this identifier and according verkey. As Identity Owner, I want to change my verkey, but I can't: {code:java} sovrin@test> use identifier FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM Current identifier set to FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM sovrin@test> send NYM dest=FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM verkey=11111111111111111111111111111111111111111111 Adding nym FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM Error: client request invalid: InvalidClientRequest('X3WzhHXupshDbVLJxEtUX6fpkKWKdvgLCnQuPbWDJBf is neither Trustee nor owner of FvpJGZtJ24charRZcx9hpqPziTdDtGy7v4QHHMjjAiqM',){code}  And Identity Owner will not be able to change his verkey until Trustee will send to Ledger his verkey. This logic is correct for DID (because verkey is empty for DID after sending NYM without verkey) but it is wrong for CID.  ></body> </Action>
