<Action id="24895" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-01 08:48:42.0" updateauthor="andrey.goncharov" updated="2017-06-01 08:48:42.0"> <body><! CDATA  ~danielhardman  I proceeded with the merge of migration tool without changing the logic because we needed a stable build with it ASAP.   You say we need to define an original version and a target version as well. But what if a node missed couple upgrades? Say it jumps from 0.3.100 straight to 0.3.102. Migration from 0.3.100 to 0.3.101 won't be applied then. That was the reason I left only original versions in migrations and allowed them to be applied in bulk.   If you think we should disregard the case then we can update the logic.  ></body> </Action>
<Action id="26876" issue="17359" author="danielhardman" type="comment" body="My point is that we shouldn&apos;t support jumping from 0.3.100 to 0.3.102. We should require that all migrations proceed one step at a time. That way our test matrix only has to test one possible transition, not all possible transitions. " created="2017-06-20 18:32:51.0" updateauthor="danielhardman" updated="2017-06-20 18:32:51.0"/>
<Action id="26877" issue="17359" author="danielhardman" type="comment" body="I think it could be legal to do an apt upgrade that skips versions–but when we do, we should replay the migration steps one at a time until the gap has been filled. If we try to make it the case that a migration script can start from any version, it will become far too complex and error prone." created="2017-06-20 18:34:13.0" updateauthor="danielhardman" updated="2017-06-20 18:34:13.0"/>
<Action id="26883" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-20 18:52:38.0" updateauthor="andrey.goncharov" updated="2017-06-20 18:55:19.0"> <body><! CDATA  ~danielhardman  with the current logic the scenario you described is exactly what's going to happen. Source code will be upgraded to the new version and migrations will be applied in sequence one by one.  Example: We upgrade from 0.3.100 to 0.3.103. There are migrations for 0.3.101, 0.3.102. A node gets stopped, source code gets updated to 0.3.103, migration 0.3.101 gets applied, migration 0.3.102 gets applied, the node gets restarted.     ></body> </Action>
<Action id="26884" issue="17359" author="danielhardman" type="comment" created="2017-06-20 18:59:19.0" updateauthor="danielhardman" updated="2017-06-20 18:59:19.0"> <body><! CDATA Okay, then we're not so far apart.  I still think it's problematic to name the script according only to the destination version. If we have a stable build at version 0.3.101 and another stable build at 0.3.104, but NOT a stable build at version 102 or 103, then wouldn't it be smarter to name our migration script something about 0.3.101_to_0.3.104, instead of just 0.3.104, to clarify which version we are starting from?  ></body> </Action>
<Action id="26885" issue="17359" author="danielhardman" type="comment" body="Also, as I read the code, it looks to me like we could have two migration scripts for one version, for example: 0.3.104_subtaskA and 0.3.104_subtaskB. If this is true, then I don&apos;t like it. In such a case, which script has the responsibility for the overall migration working? Answer: neither. I want exactly one script per migration step (where by &quot;migration step&quot; I mean the transition from version X to version Y)." created="2017-06-20 19:02:18.0" updateauthor="danielhardman" updated="2017-06-20 19:02:18.0"/>
<Action id="26888" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-20 19:15:36.0" updateauthor="andrey.goncharov" updated="2017-06-20 19:15:36.0"> <body><! CDATA  ~danielhardman  We name migrations by the version we start from, not destination. It's like an indicator that the code past that point includes some breaking changes and if the migration wasn't applied yet it should be. We can add destination version, I just do not understand its value. Especially in the case when a node misses several upgrades.  As to several scripts per version, yes, we support this in theory. But this is the responsibility of the review not to accept this kind of code. I mean I can easily filter out migrations starting from the same version but this leaves me with a question which ones I should pick? Say, we implement this strict requirement and allow only one migration per version and somehow two migrations for the target version found (0.3.104_subtaskA and 0.3.104_subtaskB), which one should I choose?   ></body> </Action>
<Action id="27104" issue="17359" author="stevetolman" type="comment" body="Andrey, when you have completed this ticket, please send it to Daniel for the code review. I want to be sure there is strong alignment on the approach to solve this problem." created="2017-06-21 05:25:02.0" updateauthor="stevetolman" updated="2017-06-21 05:25:02.0"/>
<Action id="27166" issue="17359" author="danielhardman" type="comment" created="2017-06-21 21:33:32.0" updateauthor="danielhardman" updated="2017-06-21 21:33:32.0"> <body><! CDATA Here are some things about the current mechanism that feel like they need enhancement: * We are assuming a very tight coupling between package versions as manifest in a package manager, and source code. This coupling is going to create problems sooner or later. For example, when we are publishing RPMs and MSI/chocolatey packages, what if the versions that we publish on each OS aren't identical? Imagine that we have 1.deb, 2.deb, and 4.deb; 1.rpm, 3.rpm, and 4.rpm, and 2.msi and 4.msi. If 3.msi has never existed on Windows, should we be running a migration script for it? What if 3.msi existed, but was never considered stable? * Our error handling strategy is unclear and not robust enough. What happens when the third migration script out of 5 fails? Are we distinguishing between recoverable and unrecoverable errors? What is the responsibility of a failed migration script, in terms of cleaning up temporary state that it creates? Is a migration script idempotent? Will migration scripts test preconditions before they begin? * We don't have a plan for how to handle downgrades or how to upgrade to specific versions (as opposed to "latest"). * We don't know how to troubleshoot. Will migration scripts write a log? If so, what will it be named, and what will it contain? Will the log be safe to email to someone, or will it contain private info about system config? * We are depending on human processes to enforce smart behavior, instead of just enforcing it automatically in code.  Regarding naming, the first enhancement I want is to eliminate the possibility that there can be two scripts for the same migration. The flexibility of having two or more scripts that divide a single responsibility is a bug and complication, not a feature, because it makes it unclear how responsibilities will be divided, and because there is no single place that bears responsibility for overall migration success. See  https://codecraft.co/2012/10/17/flexibility-is-no-virtue/  I think we could easily enhance the current system to address this concern, by simply disallowing arbitrary suffixes after a version number, in the regex we use to match migration scripts.  The second enhancement I want is to have each script named by the combination of versions it covers (the version it starts from, and the version it goes to–a template like <start_version>_to_<end_version>). See the graphic I attached. One reason for this is that it facilitates human understanding: I want it to be crystal clear to all developers, testers, and sysadmins who interact with the migration mechanism exactly what the scope of a given migration script might be. The responsibilities of a given migration script are not to accept any start version and go to a single target version, or to start from a specific version and upgrade it to any arbitrary version that's later; rather, its job is to make exactly one transition from version A to version B. This is what must be tested, and the script only applies in that context; it is a cell, not a row or column, in a test matrix.  Adopting the naming convention I'm asking for will also allow us, if we choose, to short-circuit steps. I hope we don't need that flexibility–and I certainly don't want to build support for it right now–but if we needed to have that support in the future (e.g., because an intermediate step is too time-consuming or because it's impossible), then establishing the right naming convention now gives us options. (If I have migration scripts named 1_to_2, 2_to_3, 3_to_4, and 1_to_4, I can do the migrations in one step by running 1_to_4, instead of in 3 steps.) Similarly, if we ever wanted to downgrade, having both versions in the naming convention would tell us which migration scripts need to be undone to get back to a particular version.     ></body> </Action>
<Action id="27167" issue="17359" author="danielhardman" type="comment" created="2017-06-21 21:42:43.0" updateauthor="danielhardman" updated="2017-06-21 21:42:43.0"> <body><! CDATA Regarding error handling and troubleshooting, I suggest that we establish the following contract for migration scripts: # Migration scripts write to stdout only, and they don't write any sensitive data like keys, passwords, etc. # Each migration script writes to stdout a standard message on startup, and another standard message on shutdown. This standard message includes the date, the script name, and any other useful metadata we can think of. The message written on shutdown tells whether the migration script succeeded or failed, and what the exit code from the migration script process will be. # Migration scripts are not allowed to abend (e.g., from an unhandled exception) without writing the message describing the outcome. # Migration scripts return 0 on success, or an error (from errno.h?) on failure. # Migration scripts are idempotent. It is legal to run them over and over, and they detect whether they have any work to do. Once a migration script has successfully completed its job, running it again has no effect. # The code that runs migration scripts is responsible for redirecting stdout to a log file. This allows multiple migrations to be summarized in a single file. The only thing that the migration script runner echoes to the screen is a single line for each migration script, naming the script that's being run, and its outcome (either success or failure).  ></body> </Action>
<Action id="27174" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-22 08:44:11.0" updateauthor="andrey.goncharov" updated="2017-06-22 10:57:56.0"> <body><! CDATA ??We are assuming a very tight coupling between package versions as manifest in a package manager, and source code. This coupling is going to create problems sooner or later. For example, when we are publishing RPMs and MSI/chocolatey packages, what if the versions that we publish on each OS aren't identical? Imagine that we have 1.deb, 2.deb, and 4.deb; 1.rpm, 3.rpm, and 4.rpm, and 2.msi and 4.msi. If 3.msi has never existed on Windows, should we be running a migration script for it? What if 3.msi existed, but was never considered stable???  We have two options here: * We guarantee that releases for different platfoms match * We create different migrations for different platforms  I understand your concerns and suggest to start creating different migration scripts for different platforms. We could create ubuntu, windows, centos folders in migrations folder to separate them.   ??Our error handling strategy is unclear and not robust enough. What happens when the third migration script out of 5 fails? Are we distinguishing between recoverable and unrecoverable errors? What is the responsibility of a failed migration script, in terms of cleaning up temporary state that it creates? Is a migration script idempotent? Will migration scripts test preconditions before they begin???  As of now we create a ZIP archive with .sovrin folder before applying migrations. If anything goes wrong we restore original state of .sovrin from it. It was the easiest thing to do to provide somewhat of a backup strategy. Currently if a third migration out of five fails we will restore .sovrin from a ZIP file and rollback to a version we had before an upgrade. Since there's no easy way to save s state of our whole system before applying a migration I say any migration should clean up after itself in case of failure if it changes anything outside of .sovrin folder. I think for simplicity migration scripts can omit testing preconditions. If they fail to perform original state will be restored from a ZIP file.  ??We don't have a plan for how to handle downgrades or how to upgrade to specific versions (as opposed to "latest").??  We can upgrade to specific versions now. We implemented recursive installation of downstream dependencies so we are not limited by apt-get's rule to prevents installation of not latest dependencies. Yet you're right we do not have a plan on how to handle downgrades. I mean node_control_tool could easily install from older debs now but we would still have, potentially, some migrations applied. I say we leave it up to a trustee. He should check that there were no critical (incompatible) migrations applied before submitting a downgrade.  ??We don't know how to troubleshoot. Will migration scripts write a log? If so, what will it be named, and what will it contain? Will the log be safe to email to someone, or will it contain private info about system config???  ??Migration scripts write to stdout only, and they don't write any sensitive data like keys, passwords, etc.??  ??The code that runs migration scripts is responsible for redirecting stdout to a log file. This allows multiple migrations to be summarized in a single file.??  Currently we use standard sovrin logger from stp core. It writes all logs to NodeX.log file. Since sovrin-node-control is run by systemctl stdout gets captured by journalctl. Do you want to change this behavior?  ??Migration scripts return 0 on success, or an error (from errno.h?) on failure.??  All migration scripts are python modules. In order to execute them we just import them. We catch any exception with an outer catch block. This way we do not need return codes. Do you want to change the logic?  ??Adopting the naming convention I'm asking for will also allow us, if we choose, to short-circuit steps. I hope we don't need that flexibility–and I certainly don't want to build support for it right now–but if we needed to have that support in the future (e.g., because an intermediate step is too time-consuming or because it's impossible), then establishing the right naming convention now gives us options. (If I have migration scripts named 1_to_2, 2_to_3, 3_to_4, and 1_to_4, I can do the migrations in one step by running 1_to_4, instead of in 3 steps.) Similarly, if we ever wanted to downgrade, having both versions in the naming convention would tell us which migration scripts need to be undone to get back to a particular version.??  What if we migrate from 1 to 3 and have scripts 1_to_2 and 2_to_3? Do we apply them one by one? How in this case do we handle the following situations: * We migrate from 1 to 4 and have scripts 1_to_3, 2_to_4? * We migrate from 2 to 4 and have scripts 1_to_3 and 3_to_4?  I suggest we do a simple thing and apply all scripts in alphabetical order that satisfy the condition: (script's first version >= a version we're migrating from) and (script's second version <= a version we're migrating to). This way we're exposed to having invalid behavior in case of overlapping migrations (if we migrate from 1 to 4 and scripts are 1_to_3, 3_to_4 and 1_to_2, all of them will be applied), but it's very simple.  Also I'd like to add one more requirement for migrations: * If you create a migration script X_to_Y, you must create a script Y_to_X to allow downgrades.  What do you think about all of this,  ~danielhardman  ?  ></body> </Action>
<Action id="27233" issue="17359" author="danielhardman" type="comment" created="2017-06-23 00:31:15.0" updateauthor="danielhardman" updated="2017-06-23 00:31:15.0"> <body><! CDATA >> I understand your concerns and suggest to start creating different migration scripts for different platforms. We could create ubuntu, windows, centos folders in migrations folder to separate them.  Let's name the folders by the package type (deb, rpm, msi), rather than by the OS.  >>As of now we create a ZIP archive with .sovrin folder before applying migrations.  This is close to being good enough. However, if migrations fail, it would be desirable to roll back the installed package, not just the ~/.sovrin folder. Maybe that should be a different ticket.  >>Currently we use standard sovrin logger from stp core. It writes all logs to NodeX.log file  Let's say we stick with that for now. We need to clearly delimit events associated with upgrade (and each step of a migration, separately) from the normal operation of the node, so I know which migration script was running when it happened.  >>All migration scripts are python modules. In order to execute them we just import them. We catch any exception with an outer catch block. This way we do not need return codes. Do you want to change the logic?  What happens if an import fails? Is the import inside the try block?  Do we have a timeout for each step in the migration?  >>I suggest we do a simple thing...  We can do this simple thing if we write a ticket for a more sophisticated behavior. The more sophisticated behavior, IMO, would be to compute the shortest possible list of migrations that get you from version X to version Y. So in your example, only 1_to_3 and 3_to_4 would be applied–not 1_to_2.  >>one more requirement for migrations:  This is a good idea, but I think we can postpone it for the time being. Adding support for downgrades can be done as a separate story, deferred until after go live.  ></body> </Action>
<Action id="27247" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-23 07:57:17.0" updateauthor="andrey.goncharov" updated="2017-06-23 10:48:57.0"> <body><! CDATA ??What happens if an import fails? Is the import inside the try block??? ??Do we have a timeout for each step in the migration???  Whole migrate function is inside try catch block, so if anything raises an exception (like broken import) the exception gets caught, migration sequence gets interrupted, original state of .sovrin gets restored and a rollback to original version gets performed.  ??Do we have a timeout for each step in the migration???  We have a timeout for applying all migrations. I will get rid of it and add a timeout for applying each migration.  ??This is close to being good enough. However, if migrations fail, it would be desirable to roll back the installed package, not just the ~/.sovrin folder. Maybe that should be a different ticket.??  We do rollbacks as well. Not only .sovrin is restored but a rollback to original version of source code is done.  ??We can do this simple thing if we write a ticket for a more sophisticated behavior. The more sophisticated behavior, IMO, would be to compute the shortest possible list of migrations that get you from version X to version Y. So in your example, only 1_to_3 and 3_to_4 would be applied–not 1_to_2.??  I proceed with the simple behavior then. I'll create a ticket for implementing a more sophisticated one.      ></body> </Action>
<Action id="27262" issue="17359" author="andrey.goncharov" type="comment" created="2017-06-23 13:09:29.0" updateauthor="andrey.goncharov" updated="2017-06-23 13:09:29.0"> <body><! CDATA  ~danielhardman  please review.  PR:  https://github.com/sovrin-foundation/sovrin-node/pull/191   Implemented: * Updated migrations README * Migration scripts naming convention changed from X_X_X_name to X_X_X_to_Y_Y_Y * Added timeout for each migration * Condition upon which migrations to apply get selected is changed  ></body> </Action>
<Action id="27412" issue="17359" author="andrey.goncharov" type="comment" body=" ~krw910  this ticket will be tested in scope of INDY-200 test scenarios. If you find that ok then reassign it to Vladimir" created="2017-06-27 08:12:21.0" updateauthor="andrey.goncharov" updated="2017-06-27 08:12:21.0"/>
<Action id="28581" issue="17359" author="vladimirwork" type="comment" body="Testing activities were performed in scope of INDY-200." created="2017-07-18 14:27:07.0" updateauthor="vladimirwork" updated="2017-07-18 14:27:07.0"/>
