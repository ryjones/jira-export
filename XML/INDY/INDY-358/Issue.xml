<Issue id="18819" key="INDY-358" number="358" project="10303" reporter="krw910" assignee="danielhardman" creator="krw910" type="10004" summary="Agent and Node code is constantly running &quot;stat&quot; system call in a tight loop" priority="2" resolution="10000" status="10001" created="2017-06-29 14:41:46.0" updated="2019-03-29 20:34:28.0" resolutiondate="2019-03-29 20:34:28.0" votes="0" watches="3" timeoriginalestimate="32400" timeestimate="32400" workflowId="18819"> <description><! CDATA When the agent is running, I am getting the following continuously in the log:  {code} 2017-04-03 21:47:51,794 | INFO     | looper.py            (205) | runOnceNicely | it took 0.575 seconds to run once nicely 2017-04-03 21:47:51,959 | WARNING  | base_events.py       (1308) | _run_once | Executing <Task pending coro=<Looper.runForever() running at /usr/local/lib/python3.5/dist-packages/plenum/common/looper.py:215> wait_for=<Future pending cb= Task._wakeup()  created at /usr/lib/python3.5/asyncio/base_events.py:252> cb= _run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164 > took 0.165 seconds 2017-04-03 21:47:52,948 | WARNING  | base_events.py       (1308) | _run_once | Executing <Task pending coro=<Looper.runForever() running at /usr/local/lib/python3.5/dist-packages/plenum/common/looper.py:215> wait_for=<Future pending cb= Task._wakeup()  created at /usr/lib/python3.5/asyncio/base_events.py:252> cb= _run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164 > took 0.249 seconds 2017-04-03 21:47:53,279 | WARNING  | base_events.py       (1308) | _run_once | Executing <Task pending coro=<Looper.runForever() running at /usr/local/lib/python3.5/dist-packages/plenum/common/looper.py:215> wait_for=<Future pending cb= Task._wakeup()  created at /usr/lib/python3.5/asyncio/base_events.py:252> cb= _run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164 > took 0.330 seconds 2017-04-03 21:47:53,609 | INFO     | looper.py            (205) | runOnceNicely | it took 0.660 seconds to run once nicely 2017-04-03 21:47:54,105 | WARNING  | base_events.py       (1308) | _run_once | Executing <Task pending coro=<Looper.runForever() running at /usr/local/lib/python3.5/dist-packages/plenum/common/looper.py:215> wait_for=<Future pending cb= Task._wakeup()  created at /usr/lib/python3.5/asyncio/base_events.py:252> cb= _run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164 > took 0.496 seconds 2017-04-03 21:47:54,598 | WARNING  | base_events.py       (1308) | _run_once | Executing <Task pending coro=<Looper.runForever() running at /usr/local/lib/python3.5/dist-packages/plenum/common/looper.py:215> wait_for=<Future pending cb= Task._wakeup()  created at /usr/lib/python3.5/asyncio/base_events.py:252> cb= _run_until_complete_cb() at /usr/lib/python3.5/asyncio/base_events.py:164 > took 0.330 seconds {code}  The process is not serving any requests, yet it is almost constantly using anywhere from 10-60% of the CPU (though it occasionally drops to 3.7%). Running the process under {{strace}} reveals it is constantly running the {{stat}} system call in what appears to be a tight loop:  {code} stat("/usr/local/lib/python3.5/dist-packages/sovrin_client/client/client.py", {st_mode=S_IFREG|0644, st_size=12309, ...}) = 0 stat("/usr/lib/python3.5/asyncio/events.py", {st_mode=S_IFREG|0644, st_size=21505, ...}) = 0 stat("/usr/lib/python3.5/asyncio/tasks.py", {st_mode=S_IFREG|0644, st_size=25567, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/plenum/common/looper.py", {st_mode=S_IFREG|0644, st_size=10089, ...}) = 0 stat("/usr/lib/python3.5/runpy.py", {st_mode=S_IFREG|0644, st_size=11394, ...}) = 0 stat("/usr/lib/python3.5/asyncio/base_events.py", {st_mode=S_IFREG|0644, st_size=51862, ...}) = 0 stat("/home/agent/unicorn/unicorn/agent/unicornA.py", {st_mode=S_IFREG|0664, st_size=4135, ...}) = 0 stat("/usr/lib/python3.5/asyncio/coroutines.py", {st_mode=S_IFREG|0644, st_size=9593, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/sovrin_client/agent/agent.py", {st_mode=S_IFREG|0644, st_size=8387, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/sovrin_client/client/client.py", {st_mode=S_IFREG|0644, st_size=12309, ...}) = 0 stat("/usr/lib/python3.5/asyncio/events.py", {st_mode=S_IFREG|0644, st_size=21505, ...}) = 0 stat("/usr/lib/python3.5/asyncio/tasks.py", {st_mode=S_IFREG|0644, st_size=25567, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/plenum/client/client.py", {st_mode=S_IFREG|0644, st_size=26088, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/plenum/common/looper.py", {st_mode=S_IFREG|0644, st_size=10089, ...}) = 0 stat("/usr/lib/python3.5/runpy.py", {st_mode=S_IFREG|0644, st_size=11394, ...}) = 0 clock_gettime(CLOCK_MONOTONIC, {2196, 580780534}) = 0 clock_gettime(CLOCK_REALTIME, {1491257540, 434410645}) = 0 recvfrom(7, 0x30499c0, 2048, 0, 0x7ffdd0d3bbc0, 0x7ffdd0d3bb8c) = -1 EAGAIN (Resource temporarily unavailable) stat("/usr/lib/python3.5/asyncio/base_events.py", {st_mode=S_IFREG|0644, st_size=51862, ...}) = 0 stat("/home/agent/unicorn/unicorn/agent/unicornA.py", {st_mode=S_IFREG|0664, st_size=4135, ...}) = 0 stat("/usr/lib/python3.5/asyncio/coroutines.py", {st_mode=S_IFREG|0644, st_size=9593, ...}) = 0 stat("/usr/local/lib/python3.5/dist-packages/sovrin_client/agent/agent.py", {st_mode=S_IFREG|0644, st_size=8387, ...}) = 0 {code}  In my opinion, this is really bad behavior. There shouldn't be any reason to be constantly checking to see if these files that have already been loaded into memory still exist on disk.  ></description> </Issue>
