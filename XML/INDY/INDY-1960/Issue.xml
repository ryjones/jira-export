<Issue id="36972" key="INDY-1960" number="1960" project="10303" reporter="ashcherbakov" creator="ashcherbakov" type="10002" summary="Signature validation must be in-sync on all nodes" priority="3" status="10200" created="2019-01-21 08:54:28.0" updated="2020-01-08 08:12:31.0" votes="0" watches="1" workflowId="48539"> <description><! CDATA h2. *Problem description* * Signatures are validated by nodes as part of static validation, that is at the time when either a request or a first Propagate is received. * Signature validation depends on the current uncommitted state of the domain ledger, since it's validated against the keys associated with DIDs in domain ledger. * Different nodes may have different domain uncommitted state because of the lags in the network so that some nodes are behind. * So, some nodes may reject (NACK) the request because of invalid signature, and some nodes may accept it (ACK). * Also if request's signature is valid, it will not be re-checked anymore when corresponding Propagates are received.  h2. *Decision matrix*    | |Not propagated to Primary|Propagated to Primary| |Propagated to non-primary|Case 1, 2|OK| |Not propagated to non-primary|Case 3|Case 4, 5|  **    h2. *Consequences* * *Case 1: A request stays in Request queue and not ordered for some time* **  Description: *** A request is accepted (ACK) by a (non-master-primary) Node which is behind the primary (hasn't yet applied the recent uncommitted state where the request is rejected). *** Other nodes reject the request *** So, there is no quorum of PROPAGATEs *** The request on the node which accepted it will not be removed from the requests queue until it's cleared by timeout *** => potential risk of OOM **  Severity *** Low *** There are not so high chances for such situations, and the number of such requests is not significant, so the chances of OOM are pretty low *** Also we have a sanity check to clean the requests queue from time to time  * *Case 2: Unequal number of requests ordered by Master and non-master Instances* **  Description: *** A request is rejected (NACK) by a Node which is behind the master primary (hasn't yet applied the recent uncommitted state where the request is rejected). *** This node is a primary on a backup instance *** Other nodes accept the request *** So, there is a quorum of PROPAGATEs *** The node that rejected the request rejects the PROPAGATEs as well since it's still behind the master primary *** The backup instance where this node is a primary will not order the request, while master will *** => the backup instance is faster **  Severity *** Low *** There are not so high chances for such situations, and the number of such requests is not significant *** However, this is a source of potential false-positive view changes  * *Case 3: A client rotates the key and then sends the txn using the new key, and this txn is rejected with invalid signature* ** Descriptions: *** A request is accepted (ACK) by the Primary (BTW the Primary's uncommitted state is always up-to-date and can be used as a reference when validation signatures) *** The request is rejected (NACK) by n-f non-primaries which are behind the primary (haven't yet applied the recent uncommitted state where the request can be accepted). *** => Client receives a quorum of NACKs and assumes that request is not ordered. ** Severity: *** Medium *** If the client re-sends the same request, the request will be ordered successfully  * *Case 4: Message Requests for Propagates* ** Description: *** A request is accepted (ACK) by the Primary (BTW the Primary's uncommitted state is always up-to-date and can be used as a reference when validation signatures) *** A request is accepted by n-f nodes in total and propagated to n-f nodes including the Primary *** A request is rejected and not propagated to f nodes which are behind the primary (haven't yet applied the recent uncommitted state where the request can be accepted). *** Primary starts ordering the request *** Non-primaries who haven't propagated the request send MessageRequest for the corresponding Propagates *** If the Propagates are received at the time when signature validation passes (the node applied the same state as the Primary), then the node can continue ordering. *** If the Propagates are received at the time when signature is still considered to be invalid (the node hasn't yet applied the same state as the Primary), then the Propagates will not be requested anymore, and the Node stops ordering until the quorum of stashed stable checkpoints and catch-up. ** Severity: *** Low *** The situation is quire rare and the message request saves the node  * *Case 5: Node stops ordering until catch-up* ** Description: *** See Case 4 **  Severity: *** High  h2. *How to fix* * Option1: move signature verification to dynamic validation, so that the same (proposed by the primary) uncommitted state is used ** Cons: *** A source of attacks, so that anyone can send a lot of invalid requests ** Pros: *** Easy to implement *** Fixes all the issues * Option 2: TBD  ></description> </Issue>
