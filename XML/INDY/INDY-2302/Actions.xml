<Action id="65847" issue="43413" author="toktar" type="comment" created="2019-11-28 12:08:14.0" updateauthor="toktar" updated="2019-11-29 11:27:14.0"> <body><! CDATA *PoA:* * Add a handler to restore old transactions from a config ledger to a config state. * Add transaction versioning mechanism. * Bump transactions version  * Add a new transaction TRANSACTION_AUTHOR_AGREEMENT_STATUS to change TAA status.   {code:java} { 'operation': { 'type': '8' 'digest': '6cee82226c6e276c983f46d03e3b3d10436d90b67bf33dc67ce9901b44dbc97c', 'retired': True, },  'identifier': '21BPzYYrFzbuECcBV3M1FH', 'reqId': 1514304094738044, 'protocolVersion': 2, 'signature': '3YVzDtSxxnowVwAXZmxCG2fz1A38j1qLrwKmGEG653GZw7KJRBX57Stc1oxQZqqu9mCqFLa7aBzt4MKXk4MeunVj', }{code} *  ** for disabling TAA: \{ TAA digest, 'retired': True} ** for enabling TAA: \{ TAA digest, 'retired': False} * Add 'retired' to value in state for TAA. 'retired' is False by default and is added to state only with value True * Extend GET_TRANSACTION_AUTHOR_AGREEMENT reply: add the flag 'retired'  * Add TRANSACTION_AUTHOR_AGREEMENT_STATUS  to the documentation and update for GET_TRANSACTION_AUTHOR_AGREEMENT  * Extend tests for GET_TRANSACTION_AUTHOR_AGREEMENT * Add unit and integration tests for a new txn. * Add system, unit and integration tests for versioning mechanism.   *Questions for  ~esplinr :* # Is it ok if a TRANSACTION_AUTHOR_AGREEMENT transaction would not contain a "retired" field? Adding of the field would be logical, but I think, we do not want to change the format of the transaction without necessary. # To identify the TAA that needs to be made inactive, its digest will be used. If I understand correctly, we may also use the version, but I am afraid that this may introduce unnecessary confusion. Can I use only digest?  ></body> </Action>
<Action id="65849" issue="43413" author="toktar" type="comment" created="2019-11-28 13:51:02.0" updateauthor="toktar" updated="2019-11-28 13:56:18.0"> <body><! CDATA We have a new idea by  ~sergey.minaev :  As another option we can add a new not required parameter `active` to TRANSACTION_AUTHOR_AGREEMENT and don't add a new transaction TRANSACTION_AUTHOR_AGREEMENT_STATUS. I think this options will be more understandable for a final user. In fact, we will make TAA available for the editing, not just for the adding.  ></body> </Action>
<Action id="66022" issue="43413" author="esplinr" type="comment" created="2019-12-03 16:32:02.0" updateauthor="esplinr" updated="2019-12-03 16:32:02.0"> <body><! CDATA Your question caused me to think about TAA retirement a bit differently. It isn't so much a boolean (active or retired) as it that the TAA applies during a time period (the creation date until the retired date). I'm not concerned with how exactly TAA retirement is represented on the ledger so long as it is easy to tell when a TAA applies.  Managing the retirement of a TAA by editing the TAA transaction seems reasonable. It is not a requirement that a retired TAA can be "unretired", but the network administrator might appreciate having an easy way to correct a potential mistake.  The version number is more natural to use as a TAA identifier than the digest. When network governance is creating a new transaction author agreement, they attach a version number to it. They then use that version number whenever they talk about the TAA. If we only allow retiring a TAA by the digest, the administrator will have to do a lookup by version number to get the digest to complete the transaction.  ></body> </Action>
<Action id="66046" issue="43413" author="toktar" type="comment" created="2019-12-03 21:18:13.0" updateauthor="toktar" updated="2019-12-03 21:18:13.0"> <body><! CDATA  ~esplinr  Thanks a lot for answer! If a TAA applies during a time period what about time for a TAA signature? I want to say that we changed a way of a signature time validation in the task INDY-2157. How should this change now? We can use: * time of new TAA adding * the first time of TAA activation * TAA activity periods * or other variants  I think all options will take the same time to implementation and testing. So, we can use one that will be more suitable.  ></body> </Action>
<Action id="66047" issue="43413" author="esplinr" type="comment" created="2019-12-03 21:24:30.0" updateauthor="esplinr" updated="2019-12-10 14:21:06.0"> <body><! CDATA The validation of the TAA acceptance time should continue to match INDY-2157: * We only track the date, to avoid correlation attacks * If a timestamp is within a few minutes of the date (before or after), then we attribute it to clock skew, and accept it.  ></body> </Action>
<Action id="66150" issue="43413" author="toktar" type="comment" created="2019-12-06 13:34:52.0" updateauthor="toktar" updated="2019-12-17 15:47:05.0"> <body><! CDATA  ~VladimirWork  System tests: *Test1* * The versioning mechanism: ** start pool on an any(!) previous version (without start upgrades) ** write TAA1 with some text in the field "text" ** write TAA2 with empty "text" ** upgrade pool to the last master version (with apt without POOL_UPGRADE) ** write TAA2 _retired_=timestamp(in the past) ** write TAA3 with _retired_=timestamp, check that the request is rejected *** Cannot create a transaction author agreement with a 'retired' field. ** write TAA3 without _retired_ ** write TAA3 with _retired_=timestamp, check that the request is rejected *** The latest transaction author agreement cannot be retired. ** add a new node, check it writes a new config txns ** send GET_TAA for TAA1, check that reply *** doesn't contain _digest_ *** doesn't contain _ratified_date_ *** doesn't contain _retired_ *** contains version *** contains text ** send GET_TAA for TAA2, check that reply *** contains _digest_ *** contains _ratified_date_ *** contains _retired_ *** contains version *** contains text(empty) ** send GET_TAA for TAA3, check that reply: *** contains  _digest_ *** contains _ratified_date_ *** doesn't contain _retired_ *** contains version *** contains text ** send NYM with signed TAA1 - pass ** send NYM with signed TAA2 - reject (TAA retired) ** send NYM with signed TAA3 - pass ** write TAA2 with _retired_=None ** send GET_TAA for TAA2, check that reply: *** contains  _digest_ *** _contains_ _ratified_date_ *** _doesn't_ contain _retired_ *** contains version *** contains text ** send NYM with signed TAA2 - pass ** send NYM with signed TAA2 (before TAA2 creation data) - reject  *Test2* ** * write TAA1 * write TAA2  * send GET_TAA for TAA1, TAA2 check that replies ** contains  _digest_ ** _contains_ _ratified_date_ ** _doesn't_ contain _retired_ ** contains version ** contains text * send NYM with signed TAA1 - pass * send NYM with signed TAA2 - pass * write TAA2 with retired=timestamp(in the past) * send GET_TAA for TAA2 check that reply ** contains  _digest_ ** _contains_ _ratified_date_ ** contains _retired_ ** contains version ** contains text * send NYM with signed TAA1 - pass * send NYM with signed TAA2 - reject * send TRANSACTION_AUTHOR_AGREEMENT_DISABLE  * send GET_TAA for TAA1, TAA2 check that replies ** contains  _digest_ ** _contains_ _ratified_date_ ** contains _retired_ ** contains version ** contains text * send NYM with signed TAA1 - reject * send NYM with signed TAA2 - reject  ></body> </Action>
<Action id="66156" issue="43413" author="toktar" type="comment" created="2019-12-06 14:45:35.0" updateauthor="toktar" updated="2019-12-06 14:49:12.0"> <body><! CDATA *New PoA:* * versioning mechanism ** old handler *- done* ** txn versioning for all txn types - CURRENT_TXN_VERSIONS *- done* ** add test for the old handler *- done* ** add an integration test: *- in progress* *** patch CURRENT_TXN_VERSIONS - "1" for TAA and use the old handler for a state updating *** write TAA *** unpatch all *** write a new TAA *** add a new node *** write a new TAA *** check that all nodes have same data * change update_state in the TAA handler in indy-plenum ** add _digest_ to value  *- done* ** add _activation_time (txn_time_ if it's the first change of retired from False to True)  *- done* ** add _retired_ if it's _True  *- done*_ ** use _text_ from previous value if it's not contains in the txn  *- done* ** add _taa:active_list_ with list of active TAAs _*- in progress*_ ** add a last TAA from _taa:active_list_ to the key  "latest" if _retired=True *- in progress*_ ** _update unit tests_  _*- in progress*_ * change client request validation in _do_taa_validation()_  _*- in progress*_ ** refactoring for the old method **  ||TAA is required||There are active TAAs||Request contains valid TAA signature||Validation result|| |-|+/-|-| PASS| |-|+/-|+|REJECT| |+|-|-|PASS| |+|-|+|REJECT| |+|+|-|REJECT| |+|+|+|PASS|  ** add unit tests  * Client TAA request ** add _retired_ to client request ** make _text_ optional * add integration test like a system test but without upgrades * update a documentation for TAA and GET_TAA  ></body> </Action>
<Action id="66188" issue="43413" author="sergey.khoroshavin" type="comment" created="2019-12-10 00:22:51.0" updateauthor="sergey.khoroshavin" updated="2019-12-10 15:57:57.0"> <body><! CDATA  ~esplinr  we discussed with team how deferred TAA retirement can be implemented and came to several options. Before discussing them with you I'd like to introduce several *assumptions about requirements* which affect available implementation options and costs. # Nodes should consistently stop accepting write transactions signed with old TAA as soon as retirement date and time has come, based on current primary node time (which is checked by all other validator nodes in pool and is written into ledger with each batch) # It is not important for a client to always be 100% sure that TAA has really expired or not based on just read TAA transaction # One of the following: ## It is okay that GET_TAA(latest) will always return latest TAA, which is not necessarily active (GET_TAA(latest) is an existing txn, which is currently used to get digest of active TAA) ## It is okay that GET_TAA(latest) can sometimes return inactive TAA, but will snap to correct version as soon as somebody attempts write to ledger (including automatic freshness check, if there is no external load at all) ## Retirement date of last submitted TAA should be later than retirement dates of all previous TAAs or marked as "retire immediately" # We need a new GET_TAA_LIST transaction which returns list of digests + retirement dates of TAAs, which can contain both active and some of already retired TAAs, but is eventually garbage collected so it doesn't accumulate all retired TAAs and grow indefinitely # One of the following: ## It is okay to break Indy SDK API so that in order to reliably retrieve active TAA client must explicitly use new GET_TAA_LIST transaction and figure it out himself ## It is NOT okay to break Indy SDK API, this suboption is not compatible with 3.1, and it still can have quirks when combined with 3.2 or 3.3 - see next comment # When retiring last remaining TAA (that is - scheduling turning off TAA) one of the following holds true: ## It is okay for client with skewed clock to have short period of time when it gets rejects after TAA is turned off (it can happen if it thinks TAA is still active, while on pool it is already disabled). This period can be shortened even further when if picking option 3.2 ## It is okay to accept transactions with any TAA digest if TAA is fully disabled on the pool # Newly written TAA takes into effect immediately, there is no deferred "activation time" (after fleshing out other requirements we could actually allow deferred activation time, but some of them can make this feature quire tricky, so I would refrain from implementing it for now)  ></body> </Action>
<Action id="66198" issue="43413" author="esplinr" type="comment" created="2019-12-10 14:26:18.0" updateauthor="esplinr" updated="2019-12-10 14:26:18.0"> <body><! CDATA More conversation about how we manage timestamps. * There are two timestamps: the TAA Acceptance, and the Transaction Submission. * We will check that TAA acceptance is within an acceptable clock skew of when a TAA is submitted on the ledger. * We will not check that TAA acceptance is correctly associated with when a TAA is retired on the ledger, because a transaction signed with a retired TAA will be rejected regardless. * We will not apply a clock skew adjustment when checking if a transaction is signed with a retired TAA because a transaction signed with a retired TAA should always be rejected. Now that there is overlap, users would have had time to accept the new TAA.  ></body> </Action>
<Action id="66205" issue="43413" author="sergey.khoroshavin" type="comment" created="2019-12-10 16:20:14.0" updateauthor="sergey.khoroshavin" updated="2019-12-10 16:20:14.0"> <body><! CDATA I've updated a bit requirements assumptions comment (Option 5.2, basically replaced "try not to break Indy SDK API by doing hacks under the hood" with "do not break Indy SDK").   In the meantime, we've found some more insights: * If going with 3.3 route, which is restricting retirement date of last submitted TAA and avoiding introducing internal TAA_UPDATE transaction - it works for most of cases except deferred retirement of last TAA (in other word - deferred turning off TAA). In that case "latest" state key won't be cleared at all, which can be worked around on node side, but it breaks client-side compatibility (now clients expect that if TAA is inactive then GET_TAA(latest) will return empty value instead of some digest) * If going with 3.2 route, which means introduction of internal TAA_UPDATE transaction - GET_TAA(latest) in some cases still can return digest of already retired TAA for short periods of time (from tens of seconds to 5 minutes range, depending on implementation), but since we already settled on the fact that assumption 2 is okay this should be okay as well   ></body> </Action>
<Action id="66217" issue="43413" author="esplinr" type="comment" created="2019-12-10 23:12:48.0" updateauthor="esplinr" updated="2019-12-10 23:26:06.0"> <body><! CDATA {quote} 1. Nodes should consistently stop accepting write transactions signed with old TAA as soon as retirement date and time has come, based on current primary node time (which is checked by all other validator nodes in pool and is written into ledger with each batch) {quote}  This is correct. No transaction should be accepted with a retired TAA. If a client submits a TAA that it thinks is valid, but the TAA is retired due to clock-skew, the transaction should be rejected an the client should resubmit after accepting an active TAA.  {quote} 2. It is not important for a client to always be 100% sure that TAA has really expired or not based on just read TAA transaction {quote}  This is correct.  It is highly unlikely that we hit one of the edge cases mentioned below. If we hit such an edge case, the client will be expected to query for the active TAA a second time and resubmit the transaction showing acceptance of that TAA.  The newest TAA anchored to the ledger will only be retired if: 1. A TAA should no longer be enforced. In which case there will be no other active TAAs. 2. A mistake is discovered with the TAA on the ledger, so it was retired in order to revert back to the previous version. This would be a temporary case, until the corrected TAA can be added to the ledger. If necessary, the previous TAA could be re-added.  {quote} 3. One of the following: # It is okay that GET_TAA(latest) will always return latest TAA, which is not necessarily active (GET_TAA(latest) is an existing txn, which is currently used to get digest of active TAA) # It is okay that GET_TAA(latest) can sometimes return inactive TAA, but will snap to correct version as soon as somebody attempts write to ledger (including automatic freshness check, if there is no external load at all) # Retirement date of last submitted TAA should be later than retirement dates of all previous TAAs or marked as "retire immediately" {quote}  I dislike the first option. It isn't useful to return a retired TAA. I worry about accidentally entering into a situation where all TAAs are retired and there is no enforced TAA. We need to ensure it is easy to detect this situation if it were to happen.  The second option is acceptable.  The third option is also acceptable.  We won't be able to tell whether the second or third behavior is better until we have some real-world experience. I suggest we do the one that is easiest, and we can evaluate if changes are necessary. We can discuss further if the two are similar in effort.  And, interleaving your most recent comments:  {quote} * If going with 3.2 route, which means introduction of internal TAA_UPDATE transaction - GET_TAA(latest) in some cases still can return digest of already retired TAA for short periods of time (from tens of seconds to 5 minutes range, depending on implementation), but since we already settled on the fact that assumption 2 is okay this should be okay as well {quote}  Correct. This is acceptable.  {quote} * If going with 3.3 route, which is restricting retirement date of last submitted TAA and avoiding introducing internal TAA_UPDATE transaction - it works for most of cases except deferred retirement of last TAA (in other word - deferred turning off TAA). In that case "latest" state key won't be cleared at all, which can be worked around on node side, but it breaks client-side compatibility (now clients expect that if TAA is inactive then GET_TAA(latest) will return empty value instead of some digest) {quote}  I don't understand this comment, but I might be able to help clarify anyway.  The most common scenario is that the latest TAA on the ledger has no retirement date set. When a new TAA is approved and added to the ledger, the retirement date of the previous TAA will be set. It would be unexpected to establish a retirement date without having the new agreement ready. This would encourage people who don't want to follow the current agreement to just wait for the agreement to expire.  Does it simplify the implementation if we add a restriction such that the latest TAA is not allowed to have a retirement date set in the future? There would still need to be a way to retire it immediately and leave the ledger not enforcing a TAA, but that shouldn't be too easy because we don't want it to happen by accident.  {quote} 4. We need a new GET_TAA_LIST transaction which returns list of digests + retirement dates of TAAs, which can contain both active and some of already retired TAAs, but is eventually garbage collected so it doesn't accumulate all retired TAAs and grow indefinitely 5. One of the following: # It is okay to break Indy SDK API so that in order to reliably retrieve active TAA client must explicitly use new GET_TAA_LIST transaction and figure it out himself # It is NOT okay to break Indy SDK API, this suboption is not compatible with 3.1, and it still can have quirks when combined with 3.2 or 3.3 - see next comment {quote}  I agree that this would be useful, but I'm not convinced that we need it at this time. I don't see the use of returning an incomplete list. Searching for historical TAAs is one special case of the larger epic we already have to improve searching the ledger. People can always pull the entire ledger history to see what TAAs were previously on the ledger, the same as any other ledger object.  {quote} 6. When retiring last remaining TAA (that is - scheduling turning off TAA) one of the following holds true: # It is okay for client with skewed clock to have short period of time when it gets rejects after TAA is turned off (it can happen if it thinks TAA is still active, while on pool it is already disabled). This period can be shortened even further when if picking option 3.2 # It is okay to accept transactions with any TAA digest if TAA is fully disabled on the pool {quote}  The first is acceptable.  The second is also acceptable. It is preferable to rejecting transactions that include a TAA digest when there is no TAA enforced.  {quote} 7. Newly written TAA takes into effect immediately, there is no deferred "activation time" (after fleshing out other requirements we could actually allow deferred activation time, but some of them can make this feature quire tricky, so I would refrain from implementing it for now) {quote}  This is correct. There is no requirement at this time for deferring the activation of a TAA that is written to the ledger. As soon as a TAA is approved and written to the ledger, it should be possible for those who want to use it in favor of existing TAAs to do so.  ></body> </Action>
<Action id="66225" issue="43413" author="sergey.khoroshavin" type="comment" created="2019-12-11 14:39:03.0" updateauthor="sergey.khoroshavin" updated="2019-12-11 15:03:02.0"> <body><! CDATA Thanks for clarifications. There are a couple of things left I think.  If we go *3.3 route* (which is just restrict how TAAs could be retired):  bq. Does it simplify the implementation if we add a restriction such that the latest TAA is not allowed to have a retirement date set in the future? There would still need to be a way to retire it immediately and leave the ledger not enforcing a TAA, but that shouldn't be too easy because we don't want it to happen by accident.  Did I understand you correctly that: * you're okay that we cannot schedule stopping enforcing TAAs on the ledger, in other words - if you need to turn off TAA completely you need to send some (special) transaction that will turn it off immediately * you're okay that we either: ** cannot retire immediately last submitted TAA (for example if it was submitted by error) or ** can retire immediately last submitted TAA with restriction that previously submitted TAA doesn't have retirement date set (otherwise we'll end up in situation when last active TAA still have retirement date set in future)  Also, I'd like to discuss *3.1 route* (which is an API breaking change) because: * it looks a bit cheaper than 3.3 on the node side * it is more flexible than 3.3 * seems like I failed to describe it good enough (and we've got some more ideas after yet another discussion with  ~sergey.minaev )  So, updated *3.1* proposal is following: * change return value of GET_TAA(latest) from latest digest to list of digests with optional retirement dates ** this list is guaranteed to contain all currently active TAAs ** this list can contain some of TAAs that were already retired ** this IS a breaking change to Indy Node API * add call "parse_latest_taa" to Indy SDK, which takes a reply from GET_TAA(latest) request ** if empty string or digest is passed that it is returned as is (which means that we're working with old version of node) ** if list is passed then digest which won't be retired the longest is returned (digests without retirement date will always win) ** if all digests are retired according to local clock then empty string is returned, meaning that TAA is no longer enforced on the pool ** applications will need to use that "parse_latest_taa" which IS a breaking change to Indy SDK API, but it is backward compatible and also shouldn't take too much work to update application (just add that parse call before using GET_TAA(latest) result)  Pros of this solution are: * we can schedule TAA retirement as we wish, including scheduling stopping TAA enforcement * we can still apply some safety restriction on how we retire TAAs, but we're not forced to * it should be relatively easy to implement deferred activation date when TAA is posted to the ledger in case we need it * and, again, it looks a bit cheaper than option 3.3 if just Indy Node effort is considered  UPD I'm inclined to discard option *3.2* based on your comment bq. We won't be able to tell whether the second or third behavior is better until we have some real-world experience. I suggest we do the one that is easiest, and we can evaluate if changes are necessary. We can discuss further if the two are similar in effort.  3.2 is the most complex of all options from Indy Node PoV   ></body> </Action>
<Action id="66231" issue="43413" author="esplinr" type="comment" created="2019-12-11 17:34:57.0" updateauthor="esplinr" updated="2019-12-11 17:34:57.0"> <body><! CDATA Responses: * The latest TAA should not be allowed to have a retirement date in the future. This prevents having all the TAAs retire and accidentally leaving a ledger without a TAA when that wasn't intended. A new TAA should be added to the ledger before the previous TAA can be given a retirement date. * There should be a separate transaction to disable the TAA, which will immediately "retire" all the TAAs on the ledger including the latest one. This does not need to be coordinated, because it will not cause client transactions to be rejected (see next point). * If a transaction includes any hash for a TAA, and no TAA is enforced on the ledger, we should accept the transaction. We don't need to check what "agreement" the hash references. Drummond confirmed that users should not be denied write access due to any included TAA information if no TAA is enforced. I recognize that this is a change from the current behavior where the hash must be empty if no TAA is enforced, but will reduce user friction. If it takes extra effort to make this change, we should raise a separate issue. * If a mistake requires that we immediately retire the latest TAA while still enforcing TAAs in general, Drummond confirmed that we can require the network administrator to resubmit the previous TAA so that there is an active TAA on the ledger. We acknowledge that the resubmitted TAA will have a different version number and valid acceptance time. This will require all clients to re-accept the "reverted" TAA. * Simplifying the "reverting" of a TAA, by allowing the latest TAA to be retired if a previous TAA is not retired would be convenient because it would allow the reversion to be transparent to network clients (they would not have to reaccept the TAA). But I think it isn't worth the effort or complexity given that this scenario is unlikely to happen in the wild and we have an agreed process for dealing with it.  ></body> </Action>
<Action id="66232" issue="43413" author="esplinr" type="comment" created="2019-12-11 17:58:26.0" updateauthor="esplinr" updated="2019-12-11 17:58:26.0"> <body><! CDATA After this conversation, I dislike "option 3.1" because: * We want to encourage clients to use the latest TAA on the ledger (the one without the retirement date). Returning just the latest TAA should be the default behavior and we shouldn't require people to parse a list to find it. * Filtering the list to remove retired TAAs that are included simply because the state-proof was not updated should be transparent to the user (though it could be handled internal to a LibIndy call or by implementing a state proof update mechanism as mentioned in "option 3.2"). * The TAA behavior will be the most simple use case for the foreseeable future: one TAA active on the ledger. I want to postpone additional work until we have a real world need to consider. * We need a more complete solution to searching the ledger for all types of transactions: schemas, cred defs, and TAAs. I am suspicious of trying to solve the problem for just TAAs.  Because option 3.2 is the most expensive, I think we should proceed with option 3.3.  ></body> </Action>
<Action id="66237" issue="43413" author="toktar" type="comment" created="2019-12-11 18:57:04.0" updateauthor="toktar" updated="2019-12-12 14:08:21.0"> <body><! CDATA  ~esplinr  Excuse me, a few new questions. 1. Should a node reject or apply a request with signed TAA for a CONFIG or POOL ledgers (where TAA cannot be enabled by design)? 2. Can client enable old TAA with upgrade an old transaction and clean "retired"?  ></body> </Action>
<Action id="66246" issue="43413" author="toktar" type="comment" created="2019-12-12 16:26:39.0" updateauthor="toktar" updated="2019-12-17 08:20:51.0"> <body><! CDATA *New PoA:* * versioning mechanism ** old handler *- done* ** txn versioning for all txn types - CURRENT_TXN_VERSIONS *- done* ** add test for the old handler *- done* ** add an integration test: *- in progress* *** patch CURRENT_TXN_VERSIONS - "1" for TAA and use the old handler for a state updating *** write TAA *** unpatch all *** write a new TAA *** add a new node *** write a new TAA *** check that all nodes have same data * change TAA validation ** for ADDING: *** check that "_retired" is None_ ** _for APDATING:_ *** check that "_text" is the same with the TAA text from the ledger_ *** check that "digest" is not the same with a digest from the last TAA * change update_state in the TAA handler in indy-plenum ** add _digest : str_ to value  *- done* ** add _ratified_date_ _: timestamp (if it's an adding txn_)  *- _in progress_* ** add _retired_ _: timestamp_ if it's _filled*-* *in progress***_ ** use _text_ from previous value if it's not contains in the txn  *- done* ** add _taa:list_ with list of last active TAAs _*- in progress*_ ** for ADDING: *** add a new TAA to the _taa:last_ *** _add a new TAA to the_ _taa:list_ *** _update_ _taa:list - remove_ _retired TAAs_ ** _for APDATING:_ *** _add a new TAA to the_ _taa:list_ *** _update_ _taa:list - remove_ _retired TAAs_ ** _update unit tests_  _*- in progress*_ * change client request validation in _do_taa_validation()_  _*- in progress*_ ** refactoring for the old method **  ||TAA is required||There are active TAAs||Request contains valid TAA signature||Validation result|| |-|+/-|-| PASS| |-|+/-|+|REJECT| |+|-|-|PASS| |+|-|+|PASS| |+|+|-|REJECT| |+|+|+|PASS|  *  ** add a check that sent TAA is active ** add unit tests * add a new transaction TRANSACTION_AUTHOR_AGREEMENT_DISABLE to disable TAA on the pool ** create a new handler: *** set retired in the past for all TAAs from taa:list *** clean taa:list *** clean taa:last ** add unit and integration tests  * Client TAA request ** add _retired_ to client request ** make _text_ optional * add integration test like a system test but without upgrades * update a documentation for TAA, add for TAA_DISABLE  ></body> </Action>
<Action id="66247" issue="43413" author="esplinr" type="comment" created="2019-12-12 18:48:21.0" updateauthor="esplinr" updated="2019-12-12 18:48:21.0"> <body><! CDATA 1. We should be consistent across all transactions in not rejecting transactions that are signed by a TAA unnecessarily. This makes it easier for clients.  2. Two cases: * If a TAA has a retired date, but the date has not yet passed (the TAA is still active), it should be possible to update or clear the retired date. * We expect it to be truly exceptional to "unretire" an old TAA, and the old TAA can always be submitted as a new TAA. However, if it was necessary, it would be nice to be able to bring a TAA out of retirement while preserving the hash (thus avoiding having all users reaccept it). As discussed previously, the decision on the right architecture depends on the engineering complexity to create the feature, test it, and maintain it. It is a nice-to-have, but won't be worth a significant cost.  ></body> </Action>
<Action id="66248" issue="43413" author="esplinr" type="comment" created="2019-12-12 18:52:12.0" updateauthor="esplinr" updated="2019-12-12 18:52:12.0"> <body><! CDATA Other clarifications on TAA behavior: * The TAA is not required for writing to the Pool or Config ledgers, so it isn't required for a transaction that disables enforcing TAA acceptance to include a TAA acceptance. * Adding a retirement date to an existing TAA is the same transaction type as creating a new TAA, but you don't have to specify the text so the transaction will be rejected if there is no existing TAA that matches. In addition, a new TAA is not allowed to have a retirement date. For both of these reasons, it should not be possible to accidentally create a new TAA when updating the retirement date. * When updating the retirement date, the existing TAA to which the transaction applies can be specified with the version number. * Disabling enforcement of the TAA will retire all old active TAAs. * We considered adding an "active date" so that a TAA could be added to the ledger but not immediately enforced. This would allow inspection to ensure that it was correctly encoded as markdown. However, updating the latest TAA in the ledger state after the active date had been triggered would require a state proof, which the discussion in previous comments shows would be problematic.  ></body> </Action>
<Action id="66255" issue="43413" author="lbendixsen" type="comment" created="2019-12-12 22:30:21.0" updateauthor="lbendixsen" updated="2019-12-12 22:30:21.0"> <body><! CDATA  ~esplinr  I have read the rest of the comments here but I still have a few remaining questions/comments about versions for the TAA.   # Will the TAA version number have a prescribed format and will it need to be incremental?  (i.e can the first version be 7.0.2, and the next version be 4 for example?) I would prefer it if you forced a format and also forced it to be incremental to guard against possible mistakeos on my part.   # Can you repeat a version number, or must each be unique?  (In case I forget to manually increment my version string when I do an update) Do you have tests that check for this? # If there is a document describing the expected behavior then please send me a link.  ></body> </Action>
<Action id="66257" issue="43413" author="sergey.khoroshavin" type="comment" created="2019-12-13 09:30:10.0" updateauthor="sergey.khoroshavin" updated="2019-12-13 09:30:10.0"> <body><! CDATA  ~lbendixsen  as of current implementation: # TAA version number doesn't have any prescribed format. It is just string. # Version number must be unique. If you try to send a new TAA with already existing version number it will be rejected. And it is covered by tests (https://github.com/hyperledger/indy-plenum/blob/master/plenum/test/txn_author_agreement/test_txn_author_agreement.py#L62) # There is a document describing TAA: https://github.com/hyperledger/indy-plenum/blob/master/docs/source/transaction_author_agreement.md  ></body> </Action>
<Action id="66329" issue="43413" author="ashcherbakov" type="comment" created="2019-12-20 07:31:39.0" updateauthor="ashcherbakov" updated="2019-12-20 07:31:39.0"> <body><! CDATA PR with implementation: *  https://github.com/hyperledger/indy-plenum/pull/1424  * https://github.com/hyperledger/indy-node/pull/1530  Documentation update: *  https://github.com/hyperledger/indy-plenum/pull/1432  *  https://github.com/hyperledger/indy-node/pull/1543   Debug and testing will be continued in the scope of INDY-2316  ></body> </Action>
<Action id="66361" issue="43413" author="esplinr" type="comment" created="2019-12-20 15:32:08.0" updateauthor="esplinr" updated="2019-12-20 15:32:08.0"> <body><! CDATA As a note, the behavior of the Acceptance Mechanism list has not changed. A transaction must include in the TAA acceptance an indication of which mechanism was used, and that must come from the current latest Acceptance Mechanism List. When a new list is added, the previous list is immediately retired.  This means that:  * TAA version 1 has a list with mechanism A, B, C * When TAA version 2 is approved, it is decided that the mechanism list should be B, C, D * Even though version 1 has not been retired, acceptance validation will be based off of the mechanism list B, C, D.  We believe this is acceptable because the mechanism list will change rarely. If we do decide that a change is necessary we will either need to immediately impact people using the deprecated acceptance mechanisms, or we will need to modify the ledger behavior to smooth the transition. We won't be doing that work unless we see that it is necessary.  ></body> </Action>
