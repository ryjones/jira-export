<Action id="53787" issue="34191" author="anikitindsr" type="comment" created="2018-11-26 11:46:56.0" updateauthor="anikitindsr" updated="2018-11-28 12:06:30.0"> <body><! CDATA h2. *Plan of attack*  *Requirement*  According to the task description we need to modify and extend auth_map structure which will support all existing rules and multi-signature features too. Also, in this case we should modify all auth's tests and write some new.     *What to do*  Summarizing requirements and task's description we need to implement the next steps: * find a "framework like" solution for existing rules and multi-signature features * implement this solution * fix old auth's tests according with new approach of auth rules working  *How to do*  We can divide rules by actions, like: * rules for adding       (adding new steward, or node) * rules for removing  (remove steward) * rules for editing       (demote node)  Therefore, the next classes of rules can be implemented: * AbstractRule(description, txn_type, rule_id, default_auth_сonstraint) * RuleAdd(description, txn_type, rule_id, default_auth_сonstraint) * RuleRemove(description, txn_type, rule_id, default_auth_сonstraint) * RuleEdit(description, txn_type, rule_id, field, prev_value, new_value, default_auth_сonstraint)     _"txn_type"_ is a type of transaction, like NYM, NODE, SCHEMA, etc.  _"field"_ is a field into transaction which can be modified. If it's empty, that means, that all of fields can be modified.  _"prev_value"_ means that sender want to change current value to other or add new transaction (adding new steward for example). The possible choices for this fields are: _empty, '*'*, string. "Empty"_ means that sender can add this transaction. '' - changing existing transcation does not depend on current stored value. If this field is some other string, then sender can change this value only if current is _string._ For example, we can change field "services" to value "  " only if current value is " VALIDATOR ". In that case _prev_value_ should be _"_ VALIDATOR _"_  _"new_value"_ is similar with _prev_value,_ but it can be _empty._  "_rule_id_" may be as a string, like: "txnType_orderOfRule". For example, for "Adding new steward" it's look like: "1_2", where 1 is a NYM constant and 2 is a order of rule.  "_auth_constraint_" is a list of roles with required count of signatures. For example,  'TRUSTEE': 3, 'STEWARD': 7 .  *For storing auth_constraint in the ledger the next format is proposed*:  key:        _rule_id_ value:     _auth_constraint_  *For choosing which constraints will be used, we need to implement the next policies*: * AbstratcAuthPolicy             with get_auth_constraint method * LocalPolicy * ConfigLedgerPolicy  LocalPolicy uses default auth_constraints from source code. ConfigLedgerPolicy uses auth_constraints from config ledger.  Summarizing previous suggestions about policy and auth rules, we need to implement the main class for applying authorization procedure:  Authorizer(auth_map, policy):     def authorize(txn_type, role, old_value, new_value):              rule = self.find_rule(txn_type, role, old_value, new_value)              auth_constraint = self.policy.get_auth_constraint(rule.rule_id)              return self._do_authorize(role, old_value, new_value, rule, auth_сonstraint)     def find_rule(txn_type, role, old_value, new_value) -> AbstractRule    def _do_authorize(role, old_value, new_value, rule, auth_сonstraint) -> bool ( use policy.get_auth_constraint)     ></body> </Action>
<Action id="54287" issue="34191" author="ashcherbakov" type="comment" created="2018-12-04 15:55:05.0" updateauthor="ashcherbakov" updated="2018-12-06 07:33:36.0"> <body><! CDATA I think we may need to do the following to support extension of validation by plugins:  1) *AuthAction* * AbstractAuthAction(txn_tye) ** def get_action_id() * AuthActionAdd(txn_type, field=None, value=None) ** action_id: ADD_(txnType|*)_(field|_*_)_(value|*) * AuthActionEdit(txn_type, field, old_value, new_value) ** action_id: EDIT_(txnType|*)_(field|_*_)_(old_value|*)_(new_value|*)  2) *AuthConstraint* (they don't have a code for validation, just definition of constraints): * AbstractAuthConstraint ** def get_id() * AuthConstraint(role, sig_count, metadata) ** id: ROLE * AuthConstraintAnd(auth_constraints) ** id: AND * AuthConstraintOr(auth_constraints) ** id: OR  3) *AuthConstraintParser* (for future) * Support a simple grammar with OR only: ** action_id1:\{role1, sig_count1, metadata1} || action_id1:\{role1, sig_count1, metadata1} * Can use a simple split based on || for now * Consider using _antlr_ and more complex grammar for future  3) *AuthMap* * static map * has the following structure: ** action_id -> default_auth_constraint ** actiomn_id may comtain * meaning 'any value' * allows to add new auth rules by Plugins  4) *AuthConstraintStrategy* * AbstractAuthConstraintStrategy ** def get_auth_constraint(action_id) ** def find_auth_constraint_key(action_id, action_ids) *** finds a key in auth_map matching the given action_id *** gets an action_id from the list of ids matching the given action_id *** takes into account * (any value) * LocalAuthConstraintStrategy ** gets default rules from  the auth map * ConfigLedgerAuthConstraintStrategy ** get from the config ledger ** uses AuthConstraintParser to parse the constraint ** TBD  5) *Authorizers*  * Authorizer interface ** def authorize(req, auth_action, auth_constraint)  * Plugins can implement their own authorizers * There are a number of default Authorizers: ** *RolesAuthorizer* *** has access to `idr_cache` *** def authorize(req, auth_action, auth_constraint: AuthConstraint) **** gets the role from the request **** may need to take either a real submitter role, or a trusted submitter (TBD) **** gets the number of signatures for this role from the request **** checks if the role is valid **** checks if the number of signatures is valid ** *CompositeAuthorizer(authorizers*) *** def register_authorizer(authorizer, auth_consraint_id=ROLE) **** auth_constrauint_id -> List Authorizer  *** def authorize(req, auth_action, auth_constraint: AuthConstraint) **** for authorizer in authorizers.get(auth_constraint.id): ***** if not authorizer.authorize((req, auth_action , auth_constraint) - raise Exceptionwith validation error ** *AndAuthorizer*(*CompositeAuthorizer*) *** def authorize(req, auth_action, auth_constraint: AuthConstraintAnd) **** for authorizer in auth_constraint.authorizers: ***** if not super().authorize() - raise Exceptionwith validation error ** *OrAuthorizer*(*CompoisteAuthorizer*) *** def authorize(req, auth_action, auth_constraint: AuthConstraintOr) **** for authorizer in auth_constraint.authorizers: ***** if not super().authorize() - continue **** If all False - raise Exception with description  6) *WriteRequestValidator(**CompositeAuthorizer**)* * Has a number of registered authorizers (plugins can register custom ones) * Has the following registered by default: ** ROLE ->  RolesAuthorizer  ** AND ->  AndAuthorizer  ** OR ->  OrAuthorizer   * Has *AuthConstraintStrategy* (either local or config ledger) * def validate(req, auth_actions: List AuthAction ): ** for auth_action in auth_actions: *** action_id = auth_action .get_action_id() *** auth_constraint = auth_constr_strategy.get_auth_constraint(action_id) *** super().authorize(req, auth_action, auth_constraint)   7) Changes in ReqHandlers: * A req handler validate method define what AuthActions are being done, and creates corresponding Action instances ** Example for promotion with changes of IP address: *** actions =  AuthActionEdit(NODE, "services",   ,  VALIDATOR ,   AuthActionEdit(NODE, "node_ip", "ip1", "ip2")  * A req handler  calls WriteRequestValidator.authorize(req, actions)     ></body> </Action>
<Action id="54403" issue="34191" author="ashcherbakov" type="comment" body="The PoA is created and implementation is started in the scope of https://github.com/hyperledger/indy-node/pull/1060" created="2018-12-06 06:48:12.0" updateauthor="ashcherbakov" updated="2018-12-06 06:48:12.0"/>
<Action id="54404" issue="34191" author="ashcherbakov" type="comment" body="Implementation will be continue in the scope of INDY-1729, INDY-1730." created="2018-12-06 06:48:40.0" updateauthor="ashcherbakov" updated="2018-12-06 06:48:40.0"/>
