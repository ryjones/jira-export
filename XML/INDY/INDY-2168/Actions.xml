<Action id="62504" issue="40973" author="andkononykhin" type="comment" created="2019-08-01 09:48:03.0" updateauthor="andkononykhin" updated="2019-08-01 12:36:06.0"> <body><! CDATA  ~esplinr   ~ashcherbakov   ~sergey.khoroshavin   While working on that task and learning GitLab CI/CD I've encountered some facts that might block any transition to that CI engine.  Please check the following docs and related issues on GitLab ticket tracking: # Gitlab CI/CD doesn't support pipeline triggering for GitHub PRs from forks: **  https://docs.gitlab.com/12.1/ce/ci/merge_request_pipelines/index.html#requirements-and-limitations  **  https://gitlab.com/gitlab-org/gitlab-ee/issues/5667  # GitLab CI/CD doesn't have good support merge requests from GitLab repositories forks as well: CI status for merge requests form forks are not trusted since pipelines are run on forked projects infrastructure for security reasons. The links: **  https://docs.gitlab.com/12.1/ce/ci/merge_request_pipelines/#important-notes-about-merge-requests-from-forked-projects  **  https://docs.gitlab.com/12.1/ce/ci/merge_request_pipelines/pipelines_for_merged_results/index.html#requirements-and-limitations  **  https://gitlab.com/gitlab-org/gitlab-ee/issues/11934   +When it might be changed+ * There are a set of tasks related to that and some of them are in progress and attached to coming milestones (in optimistic scenario - in a few months).  +Current possible workarounds (for GitHub PRs from forks)+ * Mentioned  Issue 5667|https://gitlab.com/gitlab-org/gitlab-ee/issues/5667   refers to a set of workarounds that might help: ##  the first|https://gitlab.com/gitlab-org/gitlab-ee/issues/5667#note_144850858 : requires manual efforts ##  the second|https://gitlab.com/gitlab-org/gitlab-ee/issues/5667#note_144893904 :  more automated, introduces bot, requires bot configuration and deployment efforts ##  the third|https://gitlab.com/gitlab-org/gitlab-ee/issues/5667#note_146778387 :  also a bot, seems the most promising * BUT the strong concern mentioned there regarding all workarounds is about the security: secrets (usually exposed for CD pipeline) might be disclosed and shared hardware might be impacted by "bad" PRs from untrusted forks  Thus, my vision: * GitLab CI/CD for now is not enough ready to support Continuous Integration (I mean exactly that only: integration of changes in scope of any kind of change requests) OSS projects since it can't securely serve PRs from forks (even with mentioned workarounds) * CD pipelines (with all their secrets) can't be combined with CI on GitLab CI/CD since they would share resources and I currently don't see (understand) ways to separate them  I see only one option with GitLab CI/CD for now: * keep repositories on GitHub, move only CI for indy projects keeping CD on Jenkins, requires: ** apply some workaround to support PR from GitHub forks   ~esplinr   : * does Sovrin Foundation is aware of that blockers? * do they have any better workarounds / plans to overcome that?  ></body> </Action>
<Action id="62538" issue="40973" author="andkononykhin" type="comment" created="2019-08-02 09:24:21.0" updateauthor="andkononykhin" updated="2019-08-02 09:24:21.0"> <body><! CDATA  ~SteveGoob   ~ashcherbakov   ~sergey.khoroshavin   Even with mentioned workarounds for CI it's not safe to run pipelines for untrusted PRs when any secrets are exposed or protected runners are set up: GitLab server uses single yaml file for all stages (test, deploy) and all kind of triggers (branch, PR). A  link|https://docs.gitlab.com/12.1/ce/ci/merge_request_pipelines/index.html#important-notes-about-merge-requests-from-forked-projects .  Until GitLab fixes that I think we should consider one more option as an addition to one mentioned in the previous comment: * I think it might be reasonable to use two GitLab CI/CD  separate instances for CI and CD ** CI server: *** its tokens for runners are published *** doesn't expose any env variables with secrets *** processes merge requests only ** CD server: *** only trusted runners are attached *** works with secrets defined in the project/server settings (not in a yaml which is a part of the repository code) *** uses custom path to GitLab yaml file: a  link|https://docs.gitlab.com/12.1/ce/user/project/pipelines/settings.html#custom-ci-config-path  *** processes branches only  ></body> </Action>
<Action id="62539" issue="40973" author="ashcherbakov" type="comment" created="2019-08-02 10:58:40.0" updateauthor="ashcherbakov" updated="2019-08-02 11:00:18.0"> <body><! CDATA I would like to summarize our security concerns.  There are two main groups of concerns: # *Untrusted code runs in a protected environment with an access to protected data, so that secrets can be leaked and compromised, or malicious artifacts can be produced.*   *  ** We must make sure that this never happens ** We need to make sure that a random (potentially malicious) PR from community fork on GitHub is never executed by protected runners on GitLab CI, and it can never get access to secretes regardless of how badly yaml file is changed in the PR  # *Untrusted code runs in unprotected environment, so that it can temporarily or forever crash an unprotected runner* ** This has less priority than the first, but may also be dangerous, since it may lead to all unprotected runners broken/unavailable because of changes in yaml and malicious scripts ** It looks like there is no protection against this since Gitlab CI always used a a versions of yaml changed in the PR (see https://gitlab.com/gitlab-org/gitlab-ce/issues/20826). There are some workarounds (need to try) to allow running by trusted contributors only, but it may be not so convenient for community and a bit against CI purpose.  ></body> </Action>
<Action id="62561" issue="40973" author="stevegoob" type="comment" created="2019-08-02 22:22:17.0" updateauthor="stevegoob" updated="2019-08-02 22:22:17.0"> <body><! CDATA  ~andkononykhin ,  ~ashcherbakov ,  ~esplinr ,  I spent the last 4 hours writing up responses to your questions, my findings, and references on the security issues this project entails, but Jira just refreshed and I lost my entire response. >: ( I might write it up again later but for now, I'm just going to summarize my findings:  * We can properly protect credentials using protected runners and defining secrets in environment variables in the local configurations of trusted runners. * Assuming the above, we can prevent credentials from being leaked in logs. * Cache poisoning on CI is a valid concern and is unavoidable, given that both the runners and code are untrusted. * Arbitrary code execution on runners through the gitlab-ci.yml file is a concern on CI, but assuming it is protected on protected branches using the above fixes, this should not affect our delivery pipelines. To protect CI runners, we must use sandboxed environments everywhere (yes, including MacOS and Windows). That topic requires further investigation, (kubernetes, virtualbox runners, etc).  * We cannot solve the impersonation problem without splitting up our CI/CD into separate repos. (A malicious community runner can be selected for CD instead of just CI). However, assuming the above fixes, we can keep them from directly accessing the secrets required to publish packages. * Because of the impersonation problem, we are vulnerable to cache poisoning attacks in CD. Disabling cache/artifacts could be a solution, but one that would require a large amount of duplicated work in the pipeline. Artifact signing could also be used to verify the authenticity of the artifact, but adds a lot of extra complexity to the pipeline.   Most of the remaining problems are solved by splitting up the repos for CI and CD (most solutions get easier as well). I am in favor of this approach, personally. However, arbitrary code execution via gitlab-ci.yml and cache poisoning in the CI pipeline will still be security issues. If we can properly set up sandboxing, and restrict creation of community runners to trusted members of the community, then we should be greatly reduce the risk of tampering in the project and potential damage to community runners.   It is worth mentioning that the cache poisoning problem would be an issue for literally any CI system when considering the addition of community runners. It is not Gitlab specific.  ></body> </Action>
<Action id="62562" issue="40973" author="stevegoob" type="comment" body="*Note:* this all assumes that we solve the github PR problem, as  ~andkononykhin  mentioned." created="2019-08-02 22:23:18.0" updateauthor="stevegoob" updated="2019-08-02 22:23:18.0"/>
<Action id="62563" issue="40973" author="stevegoob" type="comment" body="I believe the way forward would be to first construct a new CD pipeline on Gitlab and then leave Jenkins to do CI in the meantime. This avoids the PR problem and shenanigans with untrusted pipeline code and runners. What are everyone else&apos;s thoughts?" created="2019-08-02 22:25:31.0" updateauthor="stevegoob" updated="2019-08-02 22:25:31.0"/>
<Action id="62575" issue="40973" author="ashcherbakov" type="comment" created="2019-08-05 06:17:36.0" updateauthor="ashcherbakov" updated="2019-08-05 06:17:36.0"> <body><! CDATA {quote}construct a new CD pipeline on Gitlab and then leave Jenkins to do CI in the meantime {quote}  ~SteveGoob  I would prefer to do the opposite. We are facing a critical issue on Jenkins CI when testing SDK, since the current agents are not powerful enough.  So, moving to GitLab CI (assuming that we have more runners, and these runners are more powerful), is a very high priority.  Another options would be to improve the current agents on Jenkins....  As for the next steps to try, I would try to run it with GitHab PRs from forks. As for security concerns, it really depends on how these forks will work, and whether CI can run on unprotected runners only (we need to double-check this, since protected concept is GitLab specific, and we need to make sure it works properly with GitHub forks).  ></body> </Action>
<Action id="62669" issue="40973" author="stevegoob" type="comment" created="2019-08-06 20:37:10.0" updateauthor="stevegoob" updated="2019-08-06 20:37:10.0"> <body><! CDATA  ~ashcherbakov , that's a fair point. However, if replacing the Jenkins CI is such an urgent task, it would make sense to omit the community runner functionality for the initial deployment, in order to simplify development and get it moved over sooner.   So how's this for the plan: # Enable PR mirroring in from Github to Gitlab # Build a "trusted" CI pipeline # Reach feature parity for the pipeline. (Test what's being tested in Jenkins and successfully report to github) # Switch to Gitlab for CI.  Then we can move forward from there. Sound good to everyone?   cc.  ~andkononykhin ,  ~esplinr  ~sergey.khoroshavin   ></body> </Action>
<Action id="62714" issue="40973" author="ashcherbakov" type="comment" created="2019-08-08 11:22:25.0" updateauthor="ashcherbakov" updated="2019-08-08 11:22:25.0"> <body><! CDATA Sounds like a good plan. I agree that we should start with enabling PRs mirroring and make them working (items 1 - 3 from the plan). However not sure that we should do the 4th item (switching to GitLab) without having (or being able to have) more runners.  Nevertheless, I think that `community runner functionality` task doesn't have a lot of risks, this is rather a technical work, so we can postpone it. Supporting PRs from GitHub has some risk, so I would do it first as proposed by the plan.  ></body> </Action>
<Action id="62889" issue="40973" author="esplinr" type="comment" created="2019-08-14 13:45:26.0" updateauthor="esplinr" updated="2019-08-14 13:45:26.0"> <body><! CDATA We have done the research expected by this story, and will raise future issues for additional research into our future CI pipeline.  An additional topic for investigation would be figuring out how to use GitHub Actions to integrate with GitLab CI. cc  ~SteveGoob   ></body> </Action>
