<Action id="24349" issue="17100" author="danielhardman" type="comment" created="2017-05-25 16:35:36.0" updateauthor="danielhardman" updated="2017-05-25 16:35:36.0"> <body><! CDATA This is great work,  ~alexander.shekhovcov ! I had a look at your PR, and I am really pleased. Thank you.  I made some notes as I read the code, and wanted to be sure that I sent them to you:  ~jlaw 1  >>  1. It looks like this mechanism does schema-style validation, where I can describe a canonical message, and I find out whether the incoming message conforms to the template. This is great; I’m delighted. However, in the world of document validation, there is another level of validation beyond this. Schemas typically test well-formedness, not correctness. For example, I could have a perfectly well formed driver’s license but have values for particular fields that make no sense whatsoever (e.g., a birthdate 1000 years in the future, a name for the issuing state that is in a foreign language, etc). So: is the scope of concern for this mechanism just well-formedness? (That could be a good answer; I haven’t pondered deeply, but I’m wondering what’s “right”.) If we receive a message that references a sequence number of a public key that doesn’t exist, the message is well-formed, but invalid; should errors in such cases resemble (or be emitted by) the same validation that does other testing?  2. Where can I go to see a list of all validation messages? I want to review the text and see them all in one place.  3. I would like a detailed comment, somewhere in the code, that explains how the mechanism is expected to work. This is not a granular comment about a specific class or method—it’s 4-8 paragraphs of text explaining to a developer how to use and maintain the validation mechanism.  4. What is the equivalent mechanism in libsovrin? Will Evgeniy’s work harmonize and build upon this? We need to guarantee that validation is the same in both places. << ~gudkov  and << ~ashcherbakov   5. There are some TODO items that feel important, such as a validator or two that exist but always return valid, and a bunch of skipped tests.  6. It appears that we are rejecting messages with unknown fields. Should we be? (If we disallow unfamiliar fields, doesn’t that break our ability to have old node code work with newer clients, or vice versa?)  7. What about versioning? Presumably in the future we will accept version 1 messages, version 2 messages, version 3 messages, etc. How do we say, when we emit a message, “this is a ‘version 1’ message”? And how does the validation mechanism represent the possibility that a message could be V1, V2, or V3—and branch its validation logic by reacting to the declared version?  ></body> </Action>
<Action id="24365" issue="17100" author="alexander.shekhovcov" type="comment" created="2017-05-25 18:38:09.0" updateauthor="alexander.shekhovcov" updated="2017-05-26 09:24:49.0"> <body><! CDATA  ~danielhardman  thank you for comment!   1.  {quote}For example, I could have a perfectly well formed driver’s license but have values for particular fields that make no sense whatsoever (e.g., a birthdate 1000 years in the future, a name for the issuing state that is in a foreign language, etc). So: is the scope of concern for this mechanism just well-formedness? {quote} This validation can validate that a birthdate not in the future, and a driver licence is well-formedness (XXX-XXX...) but does not check what the licence was issued by authorities.   It is supposed that we are going to have two levels of the validation: * message level (scope of the ticket): validate that a birthdate not in the future, a driver licence is well-formedness (XXX-XXX...) * "business" level (already implemented in the code): licence was issued by authorities  2. For now there are 3 places which contain the messages: * plenum/common/types.py * plenum/common/messages/client_request.py * sovrin_common/types.py  It is not a final layout. I am going to merge all plenum messages in one place.   3. Sure. I am going to do that after #5. It will be helpful for me too.   5. Agree. Those TODOs are quite urgent. Victor is implementing those rules.  6-7. Great point! If we implement the message versioning we would be able reject unknown fields and do not have problems with old/new clients/nodes. Rejecting unknown fields looks quite useful when a client misprinted during typing CLI command (for example extra white space after field name 'node_port ' ).        ></body> </Action>
<Action id="24449" issue="17100" author="alexander.shekhovcov" type="comment" created="2017-05-26 13:43:53.0" updateauthor="alexander.shekhovcov" updated="2017-05-26 13:43:53.0"> <body><! CDATA (/)  I can declare the basic validation is implemented. We are going to continue in the tickets:  https://jira.hyperledger.org/browse/INDY-35  https://jira.hyperledger.org/browse/INDY-72  and in the validation tickets with tag "Input Sanitization"  *How to test:*  The plenum master pipeline is green.  Actual testing will be done by the case tickets with tag "Input Sanitization".  For example:  https://jira.hyperledger.org/browse/INDY-9  https://jira.hyperledger.org/browse/INDY-37  https://jira.hyperledger.org/browse/INDY-38  https://jira.hyperledger.org/browse/INDY-39                 ></body> </Action>
<Action id="24529" issue="17100" author="krw910" type="comment" body=" ~aleksey-roldugin  work with  ~spivachuk  on steps to manually test this ticket." created="2017-05-26 21:12:17.0" updateauthor="krw910" updated="2017-05-26 21:12:17.0"/>
<Action id="25640" issue="17100" author="aleksey-roldugin" type="comment" body="Since INDY-9, 37-39 are fixed this ticked is tested." created="2017-06-07 13:06:33.0" updateauthor="aleksey-roldugin" updated="2017-06-07 13:06:33.0"/>
