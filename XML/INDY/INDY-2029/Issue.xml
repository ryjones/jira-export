<Issue id="38632" key="INDY-2029" number="2029" project="10303" reporter="ashcherbakov" creator="ashcherbakov" type="10002" summary="Leverage Consistency Proof feature when deciding the transaction a catchup needs to be performed to" priority="3" resolution="10001" status="10001" created="2019-03-21 07:23:52.0" updated="2019-10-09 08:14:10.0" resolutiondate="2019-10-09 08:14:10.0" votes="0" watches="1" workflowId="50277"> <description><! CDATA *Problem:* * The first step in the catchup logic (which is with a presence of audit ledger is done for the Audit ledger only) is to decide how many transactions need to be caughtup. * ConsistencyProof message containing ledger size and consistency proof is used for this ** see  https://github.com/hyperledger/indy-plenum/blob/master/docs/source/catchup.md#ledger-catchup-steps  **  https://github.com/hyperledger/indy-plenum/blob/master/docs/source/diagrams/catchup-procedure.png  * As of now, *f+1 equal* ConsistencyProofs are required. * It can be hard to get exactly equal consistency proofs during a high load. * Example: ** NodeA sent ConsistencyProof(seqNoEnd=100) ** NodeB sent ConsistencyProof(seqNoEnd=101) ** NodeC sent ConsistencyProof(seqNoEnd=102) * Here we don't have equal ConsistencyProof. * Why it works during the load, is because there is a logic to request missing consistency proofs explicitly.  In this example the catching up node will request ConsistencyProof(seqNoEnd=101) (sine it requests a median value). So, eventually we get f+1 equal ConsistencyProofs. * *But this is very inefficient, especially during high load*     *Acceptance Criteria* * Change the ConsistencyProofs processing logic to not require equal ConsistencyProof, but get the transaction number to catchup from the merkle tree associated with received ConsistencyProofs  ** Each `ConsistencyProof` msg has `hashes` field which is actually a Consistency Proof that a merkle tree with the given root extends the original tree. ** The client needs to create a tmp tree from all the valid `ConsistencyProof` msgs (for which `hashes` is a valid proof) ** The client needs to get f+1 results forming the highest tree ** The result txn_count is the minimum among these f+1  `ConsistencyProof` msgs * Cover by unit tests * Cover by integration tests        ></description> </Issue>
