<Action id="54720" issue="35923" author="sergey.khoroshavin" type="comment" created="2018-12-12 14:52:37.0" updateauthor="sergey.khoroshavin" updated="2018-12-12 14:52:37.0"> <body><! CDATA Some results of *preliminary analysis*: * while INSTANCE_CHANGE messages implemented in plenum don't have ID, however they have viewNo (which isn't explicitely required by RBFT paper) * RBFT paper states, that INSTANCE_CHANGE ID should be incremented only when _n-f_ messages with current ID are collected * however the very same event (_n-f_ INSTANCE_CHANGE messages) triggers start of a view change, which increments _viewNo_ * so current implementation with _viewNo_ actually does the same thing as RBFT paper requires * and it doesn't prevent incidents like INDY-1903  However we could try to come up with a different algorithm for assigning IDs to INSTANCE_CHANGE messages, which would fix an issue. Description already contains some of options which can be tried. One more option is to actually instantiate some binary byzantine agreement protocol (not unlike ABA subprotocol from HoneyBadger) to make sure that enough nodes actually came to agreement before starting a view change, but this also requires research.  So, *current plan of attack* is: * implement simple testable models of different strategies to assign IDs to INSTANCE_CHANGE messages * implement a number of randomized stress tests for these models * exercise tests on models to pick the most suitable one (or find that no model is robust enough) * if good enough model is found describe it here and implement it in main codebase  ></body> </Action>
<Action id="56263" issue="35923" author="sergey.khoroshavin" type="comment" created="2019-01-28 14:00:49.0" updateauthor="sergey.khoroshavin" updated="2019-01-28 14:00:49.0"> <body><! CDATA 1. Adding additional ID to INSTANCE_CHANGE and discarding messages with id < current_id - 1 leads to following failure scenario: * network outage between primary and Node2 happens ** Node2 broadcasts INSTANCE_CHANGE(view_no=1, id=0) ** Node2 sets current_id to 1 * primary is restarted ** Node2 broadcasts INSTANCE_CHANGE(view_no=1, id=1) ** Node2 sets current_id to 2 ** Node3 and Node4 broadcast INSTANCE_CHANGE(view_no=1, id=0) ** Node3 and Node4 set current_id to 1 ** Node2 discards INSTANCE_CHANGE from Node3 and Node4 because its current_id is already 2 ** Node3 and Node4 start view change because they have enough INSTANCE_CHANGE messages (from Node3, Node4 and old message from Node2) * Two nodes are in view change, two are not - consensus lost  2. Not discarding INSTANCE_CHANGE messages with too low IDs restores old failure case: * network outage between primary and Node2 happens ** Node2 broadcasts INSTANCE_CHANGE(view_no=1, id=0) * Node3 is restarted, discarding INSTANCE_CHANGE from Node2 * primary is restarted ** Node2 broadcasts INSTANCE_CHANGE(view_no=1, id=1) ** Node3 and Node4 broadcast INSTANCE_CHANGE(view_no=1, id=0) ** Node2 and Node4 start view change because they have enough INSTANCE_CHANGE messages (from Node3, Node4 and old message from Node2) ** Node3 doesn't start view change * Two nodes are in view change, two are not - consensus lost  3. Idea with incrementing current_id and broadcasting INSTANCE_CHANGE upon receiving INSTANCE_CHANGE with id higher that current_id might work, however this makes it possible to trigger view change by just one node (which is a serious security breach) and greatly increases chance of view change: * some node broadcasts INSTANCE_CHANGE(id=1000) * all other nodes find id greater than their current_id, increment it and also broadcast INSTANCE_CHANGE(id=1000) * view change happens, triggered by just one node  4. Attempt to mitigate situation in 3 by requiring f+1 quorum of INSTANCE_CHANGE messages with high id is almost equivalent to allowing just f+1 INSTANCE_CHANGE messages to start a view change for reasons described in 3. Further increasing required quorum to n-f INSTANCE_CHANGE messages with high id doesn't make sense because if we already got this many messages then we should start view change anyways.    All in all, this (together with previous comment) leads to following *conclusions*: * current implementation is equivalent to what is described in RBFT paper * just adding some additional id to INSTANCE_CHANGE won't help, and can actually make system less stable * however if >f and <n-f nodes start view change then ordering will be halted, which theoretically should trigger view change on remaining nodes, however this was not the case in INDY-1903. Ordering halt detection should be reliably addressed by INDY-1911 * if we need to _reliably_ decide by all honest to either start a view change or not without relying on some "primary" then some form of Asynchronous Byzantine Binary Agreement should be implemented, like ones in Honeybadger or Algorand, however this is quite complex task and out of scope of this issue  ></body> </Action>
<Action id="56367" issue="35923" author="ashcherbakov" type="comment" created="2019-01-30 07:12:37.0" updateauthor="ashcherbakov" updated="2019-01-30 07:12:37.0"> <body><! CDATA {quote}3. Idea with incrementing current_id and broadcasting INSTANCE_CHANGE upon receiving INSTANCE_CHANGE with id higher that current_id might work, however this makes it possible to trigger view change by just one node (which is a serious security breach) and greatly increases chance of view change: {quote} Why other nodes broadcast INSTANCE_CHANGEÂ  if they don't think that view change needs to be triggered? IIRC, Instance Change is broadcasted on receiving Instance Change from another node only if the receiver think that the view change needs to happen. Another possible condition is if the receiver gets n-f instance changes.  ></body> </Action>
<Action id="56374" issue="35923" author="sergey.khoroshavin" type="comment" created="2019-01-30 10:14:36.0" updateauthor="sergey.khoroshavin" updated="2019-01-30 10:14:36.0"> <body><! CDATA {quote}Why other nodes broadcast INSTANCE_CHANGE  if they don't think that view change needs to be triggered?{quote}  Because of this requirement  {quote}Check and send INSTANCE_CHANGE to others if INSTANCE_CHANGE ID is greater than the current one{quote}  Yes, probably I missed "check" part, I'll improve tests and see how it goes.    ></body> </Action>
<Action id="56433" issue="35923" author="sergey.khoroshavin" type="comment" created="2019-01-31 10:44:51.0" updateauthor="sergey.khoroshavin" updated="2019-01-31 10:50:35.0"> <body><! CDATA After implementing  {quote}Check and send INSTANCE_CHANGE to others if INSTANCE_CHANGE ID is greater than the current one{quote} the following failure case was found: * Network outage between primary and Node4 happens ** Node4 broadcasts INSTANCE_CHANGE(view_no=1, id=0) and sets current_id to 1 * Primary gets restarted ** Node2 and Node3 broadcast INSTANCE_CHANGE(view_no=1, id=0) and set current_id to 1 ** Node4 broadcasts INSTANCE_CHANGE(view_no=1, id=1) and set current_id to 2 ** Node2 and Node3 get each others INSTANCE_CHANGE(view_no=1, id=0) message, have quorum (due to old INSTANCE_CHANGE from Node4) and start a view change, incrementing their view_no ** Node4 discards INSTANCE_CHANGE(view_no=1, id=0) messages from Node2 and Node3 because it already sent INSTANCE_CHANGE(view_no=1, id=1) ** Node2 and Node3 discard INSTANCE_CHANGE(view_no=1, id=1) message from Node4 because they are already in a view change * Two nodes are in view change, two are not - consensus lost  ></body> </Action>
<Action id="56483" issue="35923" author="ashcherbakov" type="comment" created="2019-02-01 07:49:56.0" updateauthor="ashcherbakov" updated="2019-02-01 07:50:08.0"> <body><! CDATA The result of this research, is that in order to have really predictable and BFT way of starting a view change, we need to implement at least a simple version of Binary Byzantine Agreement. We created INDY-1973 for this  ></body> </Action>
<Action id="56492" issue="35923" author="sergey.khoroshavin" type="comment" body="Also some failure cases were already covered by tests in https://github.com/hyperledger/indy-plenum/blob/master/plenum/test/view_change/test_view_change_with_different_ic.py" created="2019-02-01 09:47:16.0" updateauthor="sergey.khoroshavin" updated="2019-02-01 09:47:16.0"/>
