<Action id="68091" issue="44359" author="sergey.khoroshavin" type="comment" created="2020-02-25 14:18:09.0" updateauthor="sergey.khoroshavin" updated="2020-02-25 14:18:09.0"> <body><! CDATA *What is IBC and what it is good for* * IBC is a generic reliable transport protocol between state machines. *It is not limited to blockchains* * IBC doesn't require any low-level transport protocol, instead it relies on: ** Relayer processes, that can read and communicate state between machines ** Participating machines performing verification themselves, in order to withstand arbitrary behavior (including byzantine) of relayers. It means that in case of blockchains *all participants must implement IBC-related transactions on-chain*. ** Easy verification and non-repudiability of state, so that machines can trust data forwarded by relayers without direct communication with other machines, and without replicating full state of other machines. It means that in case of blockchains *all participants must allow light clients* * IBC can be used to implement arbitrary cross-machine logic, including (according to authors  claims|https://github.com/cosmos/ics/blob/master/ibc/2_IBC_ARCHITECTURE.md ) cross-chain token transfer and sharding between different blockchains.  Â *IBC implementation state* * There is a growing number of RFC-like  documents|https://github.com/cosmos/ics/tree/master/spec  (called ICS - InterChain Standards) describing IBC protocol: ** They range from general concepts and interfaces to concrete implementations of interfaces (like light clients for solo machines or tendermint blockchains), as well as example applications on top of tendermint (token transfer and interchain accounts) ** All ICSs are in draft state currently, although there is already quite a lot of work put into them (first PRs date back to March 2019) ** However these ICSs are also compiled into fancy PDF stating that this is  IBC spec 1.0.0-rc5|https://github.com/cosmos/ics/blob/master/spec.pdf  (as of Feb 25, 2020), so probably they are nearing some kind of release * There is a  pinned issue|https://github.com/cosmos/ics/issues/42  to formalize IBC security properties in some proof assistant, targeting version 1.1. This is both bad (they don't have auto-verifiable formal proofs yet) and good (they are at least seriously planning to get that level of security). * Cosmos SDK has separate actively developed branch  ics-alpha|https://github.com/cosmos/cosmos-sdk/tree/ibc-alpha  with IBC implementation   ></body> </Action>
<Action id="68121" issue="44359" author="sergey.khoroshavin" type="comment" created="2020-02-26 17:01:04.0" updateauthor="sergey.khoroshavin" updated="2020-02-27 00:14:27.0"> <body><! CDATA A bit more info.  Pretty good introduction to IBC can be found either here:  https://github.com/cosmos/ics/tree/master/ibc  (which is also a repository where IBC  specs|https://github.com/cosmos/ics/tree/master/spec  live) or here:  https://cosmos.network/intro  (actually this is a generic Cosmos ecosystem overview, but it contains a pretty good section on IBC).  State of IBC in Cosmos roadmap can be found here:  https://cosmos.network/roadmap   *Main conclusions* * IBC spec is still in draft state, and implementation is not in Cosmos SDK master yet * IBC technology looks very promising for Indy use cases: ** can be used to implement cross-chain token transfer ** can be used to implement cross-chain protocols (including fee payments) ** can be used to implement blockchain sharding for better scalability ** is not limited to blockchains, and can be applied to any state-machine, given some prerequisites ** it looks like it may make sense to implement  Peer DIDs|https://openssi.github.io/peer-did-method-spec/index.html  on top of IBC * *As of now IBC cannot be used to connect Tendermint and Stellar pools directly* without heavy modification of Stellar ** Stellar needs to implement IBC-related low-level transactions ** Stellar needs to support light client for its own state * Some articles mention possibility of so-called "peg-zones" which are special adaptor blockchains built to communicate with incompatible blockchains, so *it might be possible to connect Tendermint and Stellar pools through custom-built peg zone*, however: ** there are no mentions of peg zones in current specifications ** peg zone validators must be reputable enough so that clients actually trust them enough to use it ** implementing peg zone for Stellar looks like quite a big undertaking: *** as of now only adaptor to Etherium has some implementation, and it looks quite complex *** there are some articles mentioning that Etherium adaptor is relatively easy, since Etherium already has light client support and even EVM to run some smart contracts on-chain, and that implementing similar adaptor for Bitcoin would be much more complex task *** Stellar doesn't have light client support and smart contracts, and on top of that its state is much more complex than Bitcoin (~15 different transaction types vs just UTXOs), so most probably implementing adaptor for Stellar it is even more complex  ></body> </Action>
<Action id="68129" issue="44359" author="sergey.khoroshavin" type="comment" created="2020-02-27 01:09:46.0" updateauthor="sergey.khoroshavin" updated="2020-02-27 01:09:46.0"> <body><! CDATA Also I think it is worth separately mentioning possibility of using IBC as a basis for  Peer DIDs|https://openssi.github.io/peer-did-method-spec/index.html , or at least using at as some inspiration. Thoughts which led to that idea are following: * Peer DIDs introduce idea of actors having some state, which is changed through a sequence of applied deltas, and even mention microledger term. At the same time IBC allow working with any state machine, and even have a specification for light client of a solo machine maintaining transaction log: https://github.com/cosmos/ics/tree/master/spec/ics-006-solo-machine-client  * Peer DIDs expect different actors exchange deltas of their state and hope to reach eventual consistency using CRDTs. However conflicts are still possible in case of malicious behavior, and protocol itself looks quite complex. IBC has several pros here: ** it splits transport and application layer, so that application layer protocols can be much less complex thanks to encapsulated complexity in lower-level common transport layer ** by requiring signing "outgoing datagrams" from state machines IBC allows explicit detection of state machine misbehavior (if we get two different correctly signed deltas for same seq no we know for sure that something bad has happened) and handles it on transport layer (basically it freezes communication with that client and requires a new handshake to connect again) * As of now Peer DIDs doesn't have any formal proofs of correctness to the best of my knowledge - and this is quite a big task. On the other hand in IBC there is already an ongoing work on formally proving transport layer safety using automatic proof assistance system (it looks like they went with Agda) * I might be wrong, but for me it looks like Peer DIDs require their actors to actively communicate with each other. On the other hand IBC explicitely introduce relayer processes, which do actual relaying packets between state machines (this is possible because of signatures) and allow state machines to be just state machines. In my opinion this greatly increases flexibility, and allows more complex scenarios, like having connection to some blockchain acting as a witness to many individual actors without introducing additional methods of communication.   ></body> </Action>
