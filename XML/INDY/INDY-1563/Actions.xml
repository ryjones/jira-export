<Action id="48689" issue="32680" author="ashcherbakov" type="comment" created="2018-08-10 07:44:01.0" updateauthor="ashcherbakov" updated="2018-08-10 07:44:14.0"> <body><! CDATA {quote}The value of the field will be a DID that will be set by the controller before it is written to the ledger. {quote} If the controller (Issuer) has a DID on the Ledger, then why can't he send the CLAIM_DEF by himself? Is it because he may be not a Trust Anchor? BTW there is a new feature ANYONE_CAN_WRITE which is False by default, but if set (by Indy-Node-based applications such as Sovrin) to True, then anyone can create new NYMs and CRED_DEFs, so there will be no need to send CRED_DEF by someone else. {quote}In the current proof format, the schema sequence number is provided for each claim, but the cred def sequence number is not. {quote} Both proof request and proof contain references to both SCHEMA and CRED_DEF. Please note, that this is not seq_no, but an ID (in fact the key in the state), so verifier can retrieve SCHEMA and CLAID_DEF using GET_SCHEMA and GET_CLAIM_DEF requests. Please search for `indy_prover_create_proof` in  https://github.com/hyperledger/indy-sdk/tree/master/doc/design/002-anoncreds|https://github.com/hyperledger/indy-sdk/tree/master/doc/design/002-anoncreds,   ></body> </Action>
<Action id="48724" issue="32680" author="mgbailey" type="comment" created="2018-08-10 14:53:03.0" updateauthor="mgbailey" updated="2018-08-10 14:53:03.0"> <body><! CDATA  ~ashcherbakov  thanks for the information on GET_CLAIM_DEF.  I will look into using that.  The need is for a proof to come from the processor, but appear to the verifier to come from the controller.  I have this working.  The additional need is that for audit purposes, in some circumstances the verifier must also be able to determine that the proof was actually sent by the processor.  Thus we need the additional field in the cred def where the controller is able to show that he has delegated proof issuance to the processor (who actually holds the private keys to the cred def).  ></body> </Action>
<Action id="49851" issue="32680" author="mgbailey" type="comment" created="2018-09-04 20:03:10.0" updateauthor="mgbailey" updated="2018-09-04 20:03:48.0"> <body><! CDATA Just to clarify, this story is not about spam prevention or fees in any way - it is about delegated authority. In this case the usual 3-party story (issuer, prover, and verifier) is modified into a 4-party story, where the issuer is split into 2, the controller and the processor. Both will need DIDs on the network, so that the verifier is able to see that the credential is from the controller, by means of the processor. If the controller is able to write a new cred def to the ledger sometime in the future, which updates it so that a different processor is designated, that would be a good modification to the concept.  ></body> </Action>
<Action id="50010" issue="32680" author="derashe" type="comment" created="2018-09-06 14:41:35.0" updateauthor="derashe" updated="2018-09-06 14:41:35.0"> <body><! CDATA Taking into account possible approach and comments around this task, we've decided to make appropriate plan of attack. It includes described example with Controller (owner of txn) and Processor (mediator between owner and ledger) # *There are two possible approaches for delegating authority:* ** Controller doesn't have his did on ledger. In that case, Controller give full control over adding, changing, revoking of his transactions to Processor (including control over private keys) . Also Controller won't have possibility to change Processor to another. For now, node already have functionality that allows to process such a scenario. ** Controller have his did on ledger. In that case, when by some reason (Controller has inappropriate role or he don't want to deal with ledger credits/fees), Controller can't write txns in ledger by itself. But he can use Processor's service (who must have rights to write txns in ledger), in a way, that: *** Controller stays the only one who can add, change or revoke any of "his" data in the ledger *** In any time Controller can use another Processor's service *** Controller avoid credit/fees system # *The second approach seems more appropriate for distributed system, so changes below will be described with this approach as a precondition*. Assuming this, we've planned such a design: ** We are need to restructure few txns, such as: SCHEMA, CRED_DEF, REVOC_REG_DEF, REVOC_REG_ENTRY, ATTRIB(?) in a way, that owner of DID_1 can delegate this txns to be sent to the ledger by another owner DID_2, which has appropriate role. And DID_1 can choose which DID_2 he wants to interact with ** In the same time, DID_2 cannot modify this txn, and don't need any of private data of DID_1 to send txn ** In the same time, when txn is written in ledger, it must contain veritable information about DID_1 and DID_2, which was used during this txn. And that information must be availiable to be taken from ledger state. # *To satisfy such a requirements, we need to make few changes in request structure.* ** We are planning to do that backward compatible way. Actual protocol version for now is "2". We are planning make some changes in request, and upgrade protocol version for such a request to "3". But updated node will correctly handle both protocol versions ("2", "3"), because new functionality will be optional ** So, if we want to create request with new format we need to make such a changes: *** Add filed "submitter" to common request structure, this field will stand for did of Processor *** Use multisignature mechanism instead of solo signature, i.e. "signature" field will be replaced by "signatures" ** To implement such functionality we need: *** SDK: Support new format of txn. Make an option to create requests in a new way: **** append submitter field **** set multisignature field instead of usual signature and sign it **** increment protocol version to 3 *** Node: Make validation for correctly handling of two different version **** left same validation for protocol version 2 **** add validation for new fields in protocol version 3, which described in SDK part # *How would this work* ** Controller, using sdk create the request he needs. He match that he wants to use some Processor for this and specify that Processor's DID and *sign that request.* After this noone can change data in this request without breaking the signature. Then he send this request to Processor he chose ** Processor get Controller's txn, if he agreed to write your txn to pool, he sign this txn too (in a multisignature field), and send it to the pool ** Controller ask ledger if his txn was written  ></body> </Action>
<Action id="50022" issue="32680" author="mgbailey" type="comment" created="2018-09-06 16:32:12.0" updateauthor="mgbailey" updated="2018-09-06 16:32:12.0"> <body><! CDATA Reading the above comment, I am missing some details for the primary use case, which is the processor issuing credentials in behalf of the controller. The key ledger transaction for this is the cred def, with its keys.  The processor must have the private keys for the cred def. How does the above satisfy this?   I also don't see how the added complexity of multi-sig helps with this problem. The only signature needed on the ledger is that of the controller, since it is the authorizing party.  Are we changing it so that a controller can write a new cred def to the ledger for a given schema, in order to change or revoke a processor?  ></body> </Action>
<Action id="50029" issue="32680" author="derashe" type="comment" created="2018-09-06 17:06:25.0" updateauthor="derashe" updated="2018-09-06 17:06:25.0"> <body><! CDATA  ~mgbailey   As far as i understand (correct me if i'm wrong) the key goal is that: * Only Controller must have full controll of his credentials and he can send it to Processor. * Only Processor can send txns in ledger   Answering your questions:  >> The processor must have the private keys for the cred def. How does the above satisfy this?   I thought that only Controller have controll over his private keys. If Processor have them, then he can write/edit anything by the name of Controller. Clarify pls, if i am wrong  >>I also don't see how the added complexity of multi-sig helps with this problem  You wrote: "...verifier must also be able to determine that the proof was actually sent by the processor...", so for correctly determining who was the Processor, we need his signature also.  >>Are we changing it so that a controller can write a new cred def to the ledger for a given schema, in order to change or revoke a processor?  I'm not sure that i understand you right. In the way, that we offered, you can choose any processor to process your messages.      ></body> </Action>
<Action id="50037" issue="32680" author="mgbailey" type="comment" created="2018-09-06 18:03:22.0" updateauthor="mgbailey" updated="2018-09-06 18:03:22.0"> <body><! CDATA The desire is not for the processor to be able to post transactions to the ledger, it is for the processor to be able to issue credentials to users under the authority of the controller. The prover and verifier should see that the credential came from the controller by means of the processor. In order for this to happen, # The processor must have the cred def private keys to be able to issue credentials # There must be a record of the delegation that is accessible by the verifier. # Ideally, the controller should be able to modify or revoke the delegation, perhaps by means of a new cred def written to the ledger.     ></body> </Action>
<Action id="50057" issue="32680" author="ashcherbakov" type="comment" created="2018-09-07 06:28:44.0" updateauthor="ashcherbakov" updated="2018-09-07 08:54:50.0"> <body><! CDATA  ~mgbailey   ~esplinr  I believe the use case you describe is not about Ledger transaction, but rather about crypto (HDKeys, DKMS, etc.). The current crypto doesn't support this use case. However, the proposed solution can support this use case, Artem will provide more details.  ></body> </Action>
<Action id="50069" issue="32680" author="derashe" type="comment" created="2018-09-07 10:49:44.0" updateauthor="derashe" updated="2018-09-07 11:08:27.0"> <body><! CDATA  ~mgbailey   *For the last requirements comment we can suggest such a scenario to be implemented:* * controller make a deal with some processor and send him public and private keys, which controller will use for CRED_DEF * controller sending CRED_DEF txn with a new field "processor", which stands for processor's DID * after that, processor can issue new credentials for this CRED_DEF * controller sending usual REVOC_REG_DEF txn * after that, processor can send REVOC_REG_ENTRY thxns in case if he needs to revoke some credentials  In case if controller want to cancel delegation, he just send txn to change CRED_DEF's public keys and processor DID.  For implementing such case, we need change validation process: * For creating:  ** REVOC_REG_ENTRY can be created by identifier's and processor's DIDs of it's CRED_DEF * For editing: ** Still only identifier can edit CRED_DEF (including changing processor's did field)  ** REVOC_REG_ENTRY can be edited by identifier's and processor's DIDs of it's CRED_DEF  *For implementing feature that we've described earlier (about mediator):*  This feature can be actual when ANYONE_CAN_WRITE set to FALSE.   This means that None role users won't be able to write new txns, but will be able to edit them. Than case, described above will looks like that (Assuming submitter is Trust Anchor, and controller/processor is None role) : * controller make a deal with some processor and send him public and private keys, which controller will use for CRED_DEF * controller creating CRED_DEF txn with a new field "processor" and a new field "submitter", also he adds his signature to multisignature field * controller send this txn to submitter * submitter send this txn to ledger * processor can issue new credentials for this CRED_DEF * controller send REVOC_REG_DEF txn with new field submmiter and multisig to submitter * submitter send this txn to ledger * controller/processor send REVOC_REG_ENTRY with new field submmiter and multisig to submitter * submitter send this txn to ledger * After this controller or processor can send REVOC_REG_ENTRY txns in ledger without submitter  ></body> </Action>
<Action id="50083" issue="32680" author="mgbailey" type="comment" body="I think we are on the right track. Thanks." created="2018-09-07 13:54:51.0" updateauthor="mgbailey" updated="2018-09-07 13:54:51.0"/>
<Action id="50088" issue="32680" author="ashcherbakov" type="comment" body="I think we can close the PoA ticket then and create a bunch of technical tasks to implement the feature." created="2018-09-07 14:27:32.0" updateauthor="ashcherbakov" updated="2018-09-07 14:27:32.0"/>
<Action id="50237" issue="32680" author="gudkov" type="comment" body=" ~esplinr   ~danielhardman  I looks like significant change that can affect the all existing Indy-based software stack include Evernym and BcGov. Should we start more public procedure of these PoA approval like Hipe creation?" created="2018-09-11 10:48:24.0" updateauthor="gudkov" updated="2018-09-11 10:48:24.0"/>
<Action id="50282" issue="32680" author="devin-fisher" type="comment" created="2018-09-11 16:02:02.0" updateauthor="devin-fisher" updated="2018-09-11 16:02:16.0"> <body><! CDATA {quote}controller make a deal with some processor and send him public and private keys, which controller will use for CRED_DEF {quote} This sounds like sharing keys. Sharing keys is almost always a bad idea. We can't just pass this off. Strong justification would be required to justify two idenpendent parties to both know the private keys.  ></body> </Action>
<Action id="50283" issue="32680" author="danielhardman" type="comment" created="2018-09-11 16:17:40.0" updateauthor="danielhardman" updated="2018-09-11 16:17:40.0"> <body><! CDATA I find this ticket title and the story in the first line of the comments to be incredibly confusing. I believe I understand Mike's intent–that it should be possible to issue credentials as a data processor (in the GDPR definition), where the "owner" of the cred def is a data controller (also in the GDPR definition). But I am totally confused about how that is supposed to relate to trust anchor status. I am agreeing with  ~gudkov  that this needs HIPE, or at very least a doc. The comment stream does not clarify things for me.  The sentence that Devin called out is flat-out unacceptable; it violates a fundamental tenet of Indy security, which is that private keys are never shared. The controller doesn't send the processor private keys. Rather, the processor generates a key pair and tells the controller what the public key is.     ></body> </Action>
<Action id="50457" issue="32680" author="esplinr" type="comment" body="The team produced a good POA for these requirements, and the resulting conversation has me questioning the requirements. I&apos;m going to do more research with stakeholders in the Sovrin Foundation, and open a new ticket for us to clarify the design before we schedule work." created="2018-09-14 13:40:29.0" updateauthor="esplinr" updated="2018-09-14 13:40:29.0"/>
<Action id="50466" issue="32680" author="mgbailey" type="comment" body=" ~esplinr  please revert this ticket (or make a new one) to the original, very limited, ask: add a field to Cred Def where a controller can write a processor DID. This does not preclude later developments that are more comprehensive." created="2018-09-14 15:14:47.0" updateauthor="mgbailey" updated="2018-09-14 15:14:47.0"/>
<Action id="52928" issue="32680" author="esplinr" type="comment" body="The original ask is being tracked as INDY-1708. It was incorrect for me to conflate the two sets of requirements." created="2018-11-01 22:20:41.0" updateauthor="esplinr" updated="2018-11-01 22:20:41.0"/>
