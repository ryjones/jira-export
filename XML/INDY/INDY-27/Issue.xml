<Issue id="17095" key="INDY-27" number="27" project="10303" reporter="lovesh" assignee="stevetolman" creator="lovesh" type="10002" summary="Analyze attack vectors in catchup process" priority="3" resolution="10000" status="10001" created="2017-05-25 06:10:17.0" updated="2019-03-29 20:36:59.0" resolutiondate="2019-03-29 20:36:59.0" votes="0" watches="3" workflowId="17099"> <description><! CDATA The catchup process can be exploited to do a DoS attack on nodes by requesting them proofs or transactions, a trivial way to counter this is to throttle catchup requests (*ConsistencyProof*, *CatchupReq*) on a per node basis. Also putting a limit on the number of transactions that can be requested in *CatchupReq* is one option, the limit can be either static or be approx. *(ledger size/count of caught up nodes)* since the protocol ensures that the lagging nodes distribute catchup requests to all nodes.   Also the *CatchupReq* needs to be optimised, there needs to be a minimum size of catchup requests so if a node is trying to catchup only 50 txns from 10 nodes, each of thise 10 nodes will servce 5 txns and prepare a consistency proof for other txns. This is bad for the node catching up as it involves more network traffic and more computation to verify so many consistency proofs and for the node serving catchup reqs. But if the node sent only 2 catchup requests the network traffic greatly reduces and 25 txns can be read of a single chunk probably (if txns dont span across multiple chunks). A practical value of this "minimum size" is some multiple of chunk size of the ledger  ></description> </Issue>
