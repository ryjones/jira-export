<Action id="50926" issue="33952" author="sergey.khoroshavin" type="comment" created="2018-09-21 10:50:45.0" updateauthor="sergey.khoroshavin" updated="2018-09-21 10:50:45.0"> <body><! CDATA This bug is caused by fundamental problem - request authentication accesses uncommitted state outside of ordering. This looks like: * client send request rotate keys to pool * this request reaches some (in fact one is enough) nodes, they verify it against current uncommitted state and propagate to other nodes * some propagates reach other nodes and are also authenticated against current uncommitted state (client requests are still in flight) * propagates achieve quorum, so primary sends preprepare, and non-primary receive it, which modifies their uncommitted state (and client requests are still in flight) * client requests finally reach nodes, but state is already updated with new key, so they fail authentication and REQNACKs are sent * other propagates with this request also reach nodes, and also fail authentication leading to nodes raising suspicion on each other * ordering finishes successfully (so keys in ledger are updated), but client thinks that request was rejected and key was not updated  The most bullet-proof solution to this problem is to move authentication into dynamic validation. I'm not going to propose this now, because it will greatly simplify DDoS attacks (lots of invalid requests will get to propagate phase), but I'm leaving it for future reference in case all other solutions fail to solve the problem.  Much more practical solution is following: * implement INDY-1649, which is basically authentication cache * probably move check if request is already ordered BEFORE authentication  This will lead to following scenario: * client send request rotate keys to pool * this request reaches some (in fact one is enough) nodes, they verify it against current uncommitted state, store the fact that request is already successfully verified in cache and propagate it to other nodes * some propagates reach other nodes and are also authenticated against current uncommitted state, updating auth cache (client requests are still in flight) * propagates achieve quorum, so primary sends preprepare, and non-primary receive it, which modifies their uncommitted state, but auth cache is intact (and client requests are still in flight) * client requests finally reach nodes, and due to auth cache are successfully authenticated * other propagates with this request also reach nodes, and auth cache shows they are correctly authenticated * ordering finishes successfully (so keys in ledger are updated), and client knows it  Still, there is edge case: if we clean auth cache upon ordering request (and we want to do that, otherwise memory requirements are unbounded) client might be unlucky enough for it's request to reach the node when auth cache is already cleared, resulting in REQNACK. However, this is possible only when node already ordered request, which means it already sent REPLY to client (this happens on successful ordering even if given node didn't receive anything from client), so in worst case client will receive REPLY followed by REQNACK, which is confusing, but client still can figure out that key was updated. To battle this we need to move check if request is already ordered before authentication, in this case node will send two identical REPLYs. However implications of this second change are probably better be researched a bit more.    ></body> </Action>
<Action id="51290" issue="33952" author="ashcherbakov" type="comment" body="Needs to be re-tested as INDY-1649 is done" created="2018-09-27 17:48:19.0" updateauthor="ashcherbakov" updated="2018-09-27 17:48:19.0"/>
<Action id="51419" issue="33952" author="zhigunenko.dsr" type="comment" created="2018-10-01 10:34:06.0" updateauthor="zhigunenko.dsr" updated="2018-10-01 10:34:06.0"> <body><! CDATA *Environment:* indy-node 1.6.619 indy-plenum 1.6.553 indy-cli 1.6.6~759  *Steps to Reproduce:* 1. Create Docker pool with 4 nodes 2. Connect to pool and rotate default Trustee key many times 3. run  traffic_shaper.sh|https://docs.google.com/document/d/1swLE5FwYY0tQXWpcge7KNQ5oosiz4P57Iz9843e7uHY/edit#  with default latencies 4. try to rotate key few times 5. try to send NYM  *Expected results:* CLI guarantees consistency between keys in ledger and in local storage  *Actual Results:* On step 2 keys successfully changed in ledger On step 4 keys successfully changed in CLI, but ledger response falls in timeout On step 5 error appears: _Transaction has been rejected: client request invalid: InsufficientCorrectSignatures(0, 1)_  ></body> </Action>
<Action id="51623" issue="33952" author="zhigunenko.dsr" type="comment" created="2018-10-03 14:12:31.0" updateauthor="zhigunenko.dsr" updated="2018-10-03 14:12:31.0"> <body><! CDATA *Reason to Close:* Cause has located on CLI side. Moved to IS-1022  ></body> </Action>
