<Action id="57264" issue="36812" author="derashe" type="comment" created="2019-02-18 17:31:55.0" updateauthor="derashe" updated="2019-02-18 17:31:55.0"> <body><! CDATA *PoA:*  We need to define how would we save and load view number for node and seq_no for primary replica from audit ledger.  *Save*  Saving will be performed by request ordering. During apply process, called from master replica, we will pass view number and seq_no and save txn to audit ledger.  *Load*  For now, we have a mechanism of restoring view_number, using CurrentState message, when new node connects to pool. We can replace it with restoring view_number from last audit txn as we finish catchup. Restoring must be performed as if view_change happened.  But CurrentState message also contains logic for restoring correct primaries, so we must take into account PoA of https://jira.hyperledger.org/browse/INDY-1720. (option #3)  ></body> </Action>
<Action id="57447" issue="36812" author="derashe" type="comment" created="2019-02-22 09:33:13.0" updateauthor="derashe" updated="2019-02-22 13:00:54.0"> <body><! CDATA For correct primary setting and avoid problems, mentioned in 1720, we'll organize primary selection as follows: * select_primaries - function, that recalculate primaries, basing on our current pool state. If node have some existing primaries set, this function will not touch it. It will adjust primaries that needed. ** called when pool started, to set initial primaries ** called when node promotion/demotion lead to increacing/reducing replicas count ** called when view_change happened * apply_primaries_from_audit - function that applies primaries from last audit ledger txn to current state ** called at the end of catchup, if this catchup wasn't part of cases described in the paragraph above  This solves problem INDY-1720, because recalculation of primaries can be done only at in-sync nodes.   *Note.* In select primaries method, existing state case will work only in one case. This case is node demotion/promotion. Other cases intend that replicas restored and their primaries flushed before start of selection.  ></body> </Action>
<Action id="57449" issue="36812" author="derashe" type="comment" body="For purpose of reducing ledger size, audit ledger will store primaries list or seq_no DELTA between current txn and last txn with primaries list." created="2019-02-22 11:12:32.0" updateauthor="derashe" updated="2019-02-22 11:12:32.0"/>
<Action id="57450" issue="36812" author="derashe" type="comment" created="2019-02-22 11:24:07.0" updateauthor="derashe" updated="2019-02-22 11:24:07.0"> <body><! CDATA *Tests.* As for now, we are planning to implement folowing tests: * Tests for correct functionality of storing primaries field * Tests for nodes connectivity ** pool start (and correct state after start) ** catchup after node "turned off" and activated in the same view (with/without txns made during this node abscence) ** catchup after node "turned off" and activated with on/few view_changes happened (with/without txns made during this node abscence) ** "turned off" - expands to three cases - shotdown, network disconnection from pool,demotion * Tests for correct view setting (probably only change behaviour in existing view setting tests)  ></body> </Action>
<Action id="57576" issue="36812" author="ashcherbakov" type="comment" created="2019-02-26 07:44:15.0" updateauthor="ashcherbakov" updated="2019-03-15 13:02:00.0"> <body><! CDATA *Low-level PoA*  1) Add `on_catchup_done` method into PrimarySelector - DONE 2) instead of calling `select_primaries` at the end of `allLedgersCaughtup`, do the following - DONE:  - if audit ledger is empty, then     - `select_primaries`    - viewNo=0    - lastOrdered=(0, 0)  - else    - `select_primaries_after_catchup`    - set viewNo from the audit ledger    - set lastOrdered from the audit ledger 3) remove propagate_primary logic from ViewChanger and other places - DONE 4) call propagate primary logic (like setting watermarks etc.) at the end of the first catch-up - DONE 5) add a 3d condition to send a 3PC batch into `create_3pc_batch` in Replica (in addition to common ordering and freshness), so that a 3PC batch with new primaries will be sent once primaries are changed - DONE 6) add information about primaries into audit ledger - DONE 7) do `select_primaries` after any changes of the number of replicas (not only adding new replicas, but also removing) - DONE 8) remove the code related to recovering of  last ordered during catch-up (see `three_phase_key_for_txn_seq_no`) since it will be recovered from the audit ledger instead. - DONE  9) If a Pool txn is applied (in PrePrepare creation or processing) which leads to changes of the number of instances (and hence re-selection), then preliminary calculate the new primaries for each replica and add them to the corresponding audit txn - DONE 10) Use primaries from the corresponding audit txn when creating Ordered msg - DONE 11) do view change once the number of replicas has changed - DONE     ></body> </Action>
<Action id="57577" issue="36812" author="ashcherbakov" type="comment" created="2019-02-26 07:58:29.0" updateauthor="ashcherbakov" updated="2019-03-15 13:01:19.0"> <body><! CDATA *Tests*  0) Make sure existing tests pass - IN PROGRESS, will be continued in INDY-2025 1) update unit tests for audit ledger handler taking into account the new field - DONE 3) integration test: correct primaries, viewNo and ppSeqNo after catchup - DONE 4) integration test: correct primaries, viewNo and ppSeqNo after changing of number of replicas - DONE 5) integration test: correct primaries, viewNo and ppSeqNo after view change - DONE 6) integration test: start catchup of a node when there were no ordering, but a couple of freshness updates (check that catchup is successful, primaries, viewNo and ppSeqNo restored properly, and the node can participate in consensus) - DONE 7) integration test: check that correct primaries are put into audit when applying stashed batches during catchup - DONE Case1: - Apply a PP1 for 3PC with pool txn changin F (adding 7th node) - do not order it yet! - Apply a PP2 for 3PC with a domain txn - do not order it yet! - Create ordered msg for PP1 - do not execute (commit) by Node yet! - Create ordered msg for PP2 - do not execute (commit) by Node yet! - Start catchup (so that uncommitted state reverted) - make sure that forceOrdered is called and both Ordered msgs are processed, that is they are -reapplied and committed - make sure that the state and ledger is equal and correct on all nodes  Case1: - Apply a PP1 for 3PC with pool txn changin F (adding 7th node) - do not order it yet! - Apply a PP2 for 3PC with a domain txn - do not order it yet! - Order and execute (commit) for PP1 - Create ordered msg for PP2 - do not execute (commit) by Node yet! - Start catchup (so that uncommitted state reverted) - make sure that forceOrdered is called and PP2's Ordered, that is it is re-applied and committed - make sure that the state and ledger is equal and correct on all nodes     8) unit tests for primary selection in PrePrepare - DONE     ></body> </Action>
<Action id="58187" issue="36812" author="ashcherbakov" type="comment" created="2019-03-15 13:02:55.0" updateauthor="ashcherbakov" updated="2019-03-15 13:02:55.0"> <body><! CDATA PR:  https://github.com/hyperledger/indy-plenum/pull/1096   The PR contains implementation and most of the test fixes.  There are still some failures of tests (~10-15). Fixing of the tests and validation will be continued in https://github.com/hyperledger/indy-plenum/pull/1096  ></body> </Action>
