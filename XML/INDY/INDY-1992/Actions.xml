<Action id="56920" issue="37528" author="andkononykhin" type="comment" created="2019-02-12 13:29:26.0" updateauthor="andkononykhin" updated="2019-02-12 13:29:26.0"> <body><! CDATA A kind of summary of INDY-1652 design adapted for  indy-node and indy-plenum h2. Drawbacks of current process h3. branching and tags # *Stable branch is merged with not yet QA verified code* (QA test release candidate when release branch has been already merged into stable) # *Heve to bother with hotfixes in case of multiple release candidates to not freeze the master during release time*  (if release fails we need to create new rc branch, fix master and repeat the process, thus if we want to have just fixes we have to freeze master until release is finished, otherwise new rc might include some other changes besides fixes) # *There is no way to group git tags of the same release process* (multiple release candidates for the same release: they refer to different will refer to different release versions because of jenkins build number)  h3. Build numbers mess things: # *source code itself can’t be correlated with the version* (except you has checkouted by tag) # *Master and stable versions are loosely correlated* (Hard to say how to apply release notes to master) # *Master and stable have quite big diff* (which mostly is caused by different namings for migrations scripts which include version numbers in their names) # *Have to use different package names for master and stable indy-plenum*  h3. Release notes chaos # *Both indy-plenum and Indy-node changes are mixed and documented in sovrin-foundation/sovrin* # *No separate changelog for indy-plenum and indy-node*  h2. What we want to keep * indy-node should be easily linked to indy-plenum version for both dev and stable code * there should be clear relation between artifacts and code * keep the development and release processes simple ** there should be as less manual work as possible ** all branching (and other GitHub) routine should be very straightforward to reduce number of human mistakes  h2. What we want to improve h4. versioning * all parts of version related to source code have to presented in the source code repository * 3rd number of the version should have a real patch meaning (follow semver) * build related numbers shouldn't be presented in the source code repository * versions of different branches of the code should be clearly related * stable should include only code that is really tested using auto tests and accepted by QA * codebase shouldn't be change between QA approval and final release steps (git tagging, official artifacts publishing)  (nice to have) * each installed package should be self-explained regarding its version * Jira integration (names of branches, commit comments)  h2. Proposed changes h3. branching * master: development * release (rc): release preparation and testing * stable: releases  h3. tags * created only for stable and rc  h3.  versioning * X, Y, Z - MAJOR, MINOR, PATCH * N - source revision number (release candidate number, master increment for merges) ** starts from 1 ** not for stable ** incremented each (and ONLY) time related source code base branch receives update * R - package revision number ** incremented each time packaging process replayed * B - pipeline build number * SHA1 - sha1 for accordant source code state  h3. source code: semver - master: X.Y.0-N - rc: X.Y.Z-rc.N - stable: X.Y.Z  h3. packaging: semver compartible (as close as package repository type allows) - PyPi: ** master: X.Y.0.devN ** rc: X.Y.Z.rcN ** stable: X.Y.Z - debian: ** master: X.Y.0~N ** rc: X.Y.Z~rc.N ** stable: X.Y.Z  h3. indy-node & indy-plenum correlation - indy-plenum is released independently (doesn't wait for QA approval) - indy-node refers only to 'indy-plenum' package as python dependency  h3. development workflow - version: X.Y.0-N ** ??? N starts from 1 and is incremented automatically each time new merge to master happens ** Z is 0 since usually we don't expect that all changes in next release are about bugfixes only, thus we increment at least Y (X is possible as well if major changes are planned) compared to last release  - development cycle ** start: *** initial commit: version is bumped to X.Y.0-1 ** in-progress: *** PRs are merged *** N is incremented automatically for each commit by bot user from pipeline (commits from bot user are skipped) *** changelog is updated in top 'dev' part ** finish: *** no finalization is expected, new development cycle just starts with initial commit  h3. release workflow - version: X.Y.0 -rc.N  ** ??? N starts from 1 and might be incremented automatically for release branches (as for master) ** Z is 0 meaning initial release for X.Y, Z > 0 implies hotfix workflow which is slightly different and is described below  - release process: ** initial phase *** initial commit tomaster for new development cycle is created *** branch `release-X.Y.0` is created from the master's SHA1 previous to the just created *** initial commit for release: bump version to X.Y.0-rc.1 *** changelog is updated: dev replaced with X.Y.0 *** tag is created: vX.Y.0-rc.1 ** QA phase, repeatable *** CD: rc packages are published *** QA approves/denies *** if issues: **** PRs are created to release branch **** release notes are updated in X.Y.Z header **** finally version is invremented: X.Y.0-rc.(N+1) **** new tag is created: vX.Y.0-rc.(N+1) **** repeate QA phase *** else: **** done here, go to final phase ** Final phase *** merge release branch to stable with fast-forward only: --ff-only X.Y.0-rc.N *** bump version to X.Y.0 *** add tag vX.Y.0 *** push to origin: *** PR would be marked as merged *** stable CD should be triggered and packages are created and published *** merge to master (resolve possible conflicts in changelog and version) *** delete release branch  h3. hotfix workflow   - version: X.Y.(Z+1)  -rc.N   ** ??? N starts from 0 since no changes have been pushed yet - release process: ** initial phase *** branch `hotfix-X.Y.0` is created from tag X.Y.Z *** initial commit for release: bump version to X.Y.(Z+1)-rc.0 *** changelog is updated: X.Y.(Z+1) is added *** tag is not created *** push to origin ** bugfixing phase *** fix commits are added (TODO PRs or not) *** release notes are updated in X.Y.(Z+1) *** when ready for QA: **** version is bumped to X.Y.(Z+1)-rc.1 **** tag vX.Y.(Z+1)-rc.1 is created ** QA phase, repeatable *** the same as for release workflow ** Final phase *** the same as for release workflow  h2. Migration from current state   h3. indy-plenum # synchronize master and stable ** migrations should keep stable numbers ** new version should be 1.7.0 (to decrease possibility of messing master and stable versions) # adjust metadata file for new version scheme #  changelog: add and start to manage  h3. indy-node # synchronize master and stable ** indy-plenum dependency should keep name from stable ('indy-plenum') # adjust metadata file for new version scheme # changelog: add and start to manage  ></body> </Action>
<Action id="56927" issue="37528" author="andkononykhin" type="comment" created="2019-02-12 14:21:08.0" updateauthor="andkononykhin" updated="2019-03-07 04:03:25.0"> <body><! CDATA (Keeping in mind the comment above)  *PoA*: # *jenkins shared library* ** packages versioning (N - source code revision number, B - jenkins build number): *** PyPI: **** master X.Y.0.devB **** release candidate X.Y.Z.rcN (N starts with 1) **** stable X.Y.Z *** debian: **** master X.Y.0~devB **** rc X.Y.Z~rcN **** stable X.Y.Z ** tags for master are not created (INDY-1733) #  *indy-plenum* ## improve metadata: *** bumps indy-plenum version to one that is higher than both current master's and stable's (1.7) *** adds 3rd PATCH number (1.7.0) *** adds pre-release part to use for master and rc to distinguish it from stable (e.g. 1.7.0.dev0) ## improve release nodes managements: *** -add CHANGELOG.md- (not needed for now) *** dev as top header, would receive updates related to merged changes ## improve CD pipeline: *** corresponds to changes in shared library # *indy-node* ## improve metadata: *** the same as for plenum, except CHANGELOG.md is presented already *** (plus) name for indy-plenum package in setup.py should become 'indy-plenum' for both master and stable ## adjust upgrade logic to support upgrade from debian repo's rc and master ## changes for CD pipeline *** corresponds to changes in shared library # *development releases* ** for any push to master CD is triggered ** CD pipeline: *** (optionally) tests *** bumps version to replace 0 with job build number B: X.Y.0.devB *** publich to PiPY as X.Y.0.devB *** publish to debian as X.Y.0~devB # *release process (indy-plenum)* ** similar to indy-node (see below) with only difference: no QA approval step # *release process (indy-node)* ** option 1: *** during release candidate preparation: **** need to set pre-release part for rc in metadata (X.Y.Z.rc1) **** need to update changelog: add header  'X.Y.Z - date' below 'dev' *** hotfixes (second and further release candidates) should increment N (source code release revision number) and update changelog below 'dev' header *** after QA approval: **** stable merges changes using fast-forward only strategy **** pre-release part is removed from metadata **** changes are pushed to origin **** new packages are published to PyPI and debian ** option 2: *** the same as option 1 but: **** pre-release metadata is removed at the beginning of the release process, thus: **** rc packages are published with rc suffixes anyway **** stable merges release candidate without any additional commits  ** option3: *** maintainer (have write access to GitHub repo) creates new branch release-X.Y.0 from master *** any contributor create a PR to that branch with the following changes: **** stable is merged in **** version is bumped to X.Y.0.rc1 **** changelog is finalized *** once PR is passed CI and merged CD pipeline starts and does: **** (optionally) tests **** prepare package ***** adds manifest file **** (optionally) publish to PyPI as X.Y.0.rc1 **** bumps version to X.Y.0 **** does git commit with release comment **** publish to debian as X.Y.0~rc1 **** wait for QA **** if denied: ***** new turn of release candidate starting with new PR to release-X.Y.0 that contains version bump X.Y.0.rcN and necessary changes required by QA **** if approved: ***** (optionally) set tag X.Y.0 ***** push to release-X.Y.0 ***** (merge option 1, if bot has rights) fast-forward merge to stable and push *** maintainer: **** merge option 2: ***** create PR to stable ***** merge after CI is passed **** merge options 3: ***** do merge to stable with --ff-only option without PR *** CD pipeline for stable is triggered and does: **** repack debian X.Y.0~rc.1 and publish as X.Y.0 **** publish to PyPI *** PR to master for back merge *** hotfix release process is similar but with the following differences: **** release-X.Y.Z is created from stable commit X.Y.(Z-1) **** master is not merged into  Seems Option 3 is the best one: * it solves the problem with non-stable code merged in to stable: stable receives changes only after QA approval * it keeps the same codebase in debian artifacts between rc and stable (debian repack) * we can (if needed) publish to PyPI different packages for rc and stable  Drawbacks: * master's source code version doesn't follow the development progress (pre-release part is always '-0'), hard to understand which version of the code is installed withing python program     ></body> </Action>
<Action id="57913" issue="37528" author="andkononykhin" type="comment" created="2019-03-06 04:15:17.0" updateauthor="andkononykhin" updated="2019-03-14 12:34:00.0"> <body><! CDATA ||Subtask||Status|| |-(indy-plenum) python and shell API for version management-|done| |-(indy-node) python and shell API for version management-|done| |-(indy-plenum/indy-node) abstracts for version objects with API to parse and compare different version schemes (PyPI, SemVer, Debian)-|done| |(indy-node) make changes in upgrade logic to support new versioning scheme and operate with newly created version abstracts|code-review| |(jenkins-shared) update scripts to use new shell / python API for version management * bump version using python API * for dev releases: bump version to set tilde and build number X.Y.0~devB * for rc release: bump version to set tilde X.Y.Z~rc2|in-progress (70%)| |(jenkins-shared) split general pipeline to branches and adjust according to PoA|todo| |-(jenkins-shared) add re-pack logic for release candidate debian artifacts-|done| |-(testing) set up local jenkins and test GitHub repos to test new API and new release logic in a sandbox-|done| |(testing) debug API and new release logic in a sandbox environment|in-progress| |(testing) debug API and new release logic on the production build server|todo|  ></body> </Action>
<Action id="58179" issue="37528" author="andkononykhin" type="comment" created="2019-03-15 09:48:48.0" updateauthor="andkononykhin" updated="2019-03-15 09:48:48.0"> <body><! CDATA Problem reason:  * versioning logic doesn't follow SemVer * coming release version is not 100% predictable since depends on build server specific  Changes:    * added abstracts version to encapsulate validation and presentation * separated upstream (source code) and package versioning * made related changes for node upgrade logic * tests coverage  PRs: * indy-plenum:  **  https://github.com/hyperledger/indy-plenum/pull/1110  **  https://github.com/hyperledger/indy-plenum/pull/1116|https://github.com/hyperledger/indy-plenum/pull/1110  **  https://github.com/hyperledger/indy-plenum/pull/1119|https://github.com/hyperledger/indy-plenum/pull/1110  * indy-node ** https://github.com/hyperledger/indy-plenum/pull/1771   Risk factors: - upgrade logic was impacted  Risk:  - Med  Covered with tests: - yes  Recommendations for QA * new logic of versioning and build pipelines for release is not activated yet since it needs additional testing and debugging and will be done in scope of INDY-2019 * validation here is necessary mostly to check stability of upgrade/restart logic     ></body> </Action>
