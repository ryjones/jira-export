<Action id="42932" issue="26733" author="danielhardman" type="comment" body="I don&apos;t agree with the premise of this ticket. That is, I&apos;m not convinced that ZMQ is a bad technology. It is entirely possible that I&apos;m wrong, but I want to see some data to that effect, not just an assertion that it&apos;s necessary to make such a profound change." created="2018-04-13 23:10:46.0" updateauthor="danielhardman" updated="2018-04-13 23:10:46.0"/>
<Action id="45219" issue="26733" author="ashcherbakov" type="comment" created="2018-05-29 08:30:42.0" updateauthor="ashcherbakov" updated="2018-05-29 08:30:42.0"> <body><! CDATA Proofs and links on why we need it can be found here:  https://docs.google.com/document/d/1XghaJtCrBmql-HdhNtKyof-MTaZUVJ5akJ-Tjlc2bfg/edit#|https://docs.google.com/document/d/1XghaJtCrBmql-HdhNtKyof-MTaZUVJ5akJ-Tjlc2bfg/edit  * ZMQ (and hence Indy-Node) can not drop client connections from the server side if the client doesn’t close it on her side. ** https://jira.hyperledger.org/browse/INDY-1087 ** https://jira.hyperledger.org/browse/INDY-1252 **  https://github.com/zeromq/libzmq/issues/2877  * So, If there are a lot of open connections from clients to pool, then the pool will not be able to accept any new clients/connections.  ></body> </Action>
<Action id="53107" issue="26733" author="benjsmi" type="comment" created="2018-11-06 23:15:06.0" updateauthor="benjsmi" updated="2018-11-06 23:15:06.0"> <body><! CDATA I'd like to add my +1 to this point.  One of the biggest things that influences the adoption of any technology is the ease with which a developer can get started with it.  Not how *powerful* or *performant* it is, but how easy it is *to get started*. People have short attention spans.  Most legit services use REST APIs these days, and given that we know security is concern, I don't see why anybody would have problems with either client-key authentication or maybe even something like JWTs or similar. Eventually, you'd probably want to manage a command and control list of apps/services that have access to your node, and that doesn't work well when they all share the same key ;)  I have used the Evernym (soon to be Indy) agent, and it's great.  It helps out a lot with the various procedures you need to do to issue and verify credentials, but I think the idea behind this post is that even when you've got the agent, you _still_ have to talk to it using the evernym-sdk or libindy or... all ZMQ under the covers. That's fine, but it decreases the number of places/ways in which a developer can deploy and use the agent, or the network.  The key thing in my opinion, is the reliance on an SDK and its dependencies. I give Indy major points for at least having language bindings such that it's usable for potentially any language, but what's wrong with well-secured REST?  ></body> </Action>
<Action id="62005" issue="26733" author="esplinr" type="comment" created="2019-07-22 13:53:47.0" updateauthor="esplinr" updated="2019-07-22 14:11:16.0"> <body><! CDATA Additional requirements: * Given that users of Indy have moved to production with their solutions, this transition needs to be done in a backwards compatible way. ** Indy SDK can drop support for ZeroMQ once networks have been upgraded. ** Indy Node will need to retain support for ZeroMQ client communication for an extended period of time to allow all clients the ability to upgrade. * Indy Node will need to be extended to listen on more than one port in order to allow connections over ZeroMQ and HTTP transport. * System tests, integration tests, and load tests need to be migrated to the new communication transport. The old communication transport does not need to be extensively tested once it is deprecated.  ></body> </Action>
<Action id="62024" issue="26733" author="danielhardman" type="comment" created="2019-07-22 16:39:57.0" updateauthor="danielhardman" updated="2019-07-22 16:47:12.0"> <body><! CDATA I strongly agree with the suggestion in the original post for the issue, that we use agent-to-agent (now "didcomm") as the governing paradigm for the solution.  This means we need to design and implement what Aries RFCs would call a "protocol"; see Aries RFC 0003.  We can implement the protocol with HTTP being the only supported transport, if we like. This would address some of the sentiments expressed by  ~benjsmi  above. However, we have to wrestle one important impedance, which is the intersection with certificates. Ben suggested a "properly secured" REST endpoint. That is usually code for TLS, and that means certificates.  The reason this gives me heartburn is that Indy is meant to replace certificates and CAs, because the trust of such mechanisms is fundamentally centralized. Having its major API surface depend on certs therefore feels problematic. It also means that every steward has to get a cert and keep it from expiring–and that every client has to automatically accept the certs from dozens, maybe hundreds, of validator nodes.  An alternative is to use plain HTTP, not HTTPS. If we are using DIDComm, plain HTTP can be secure, depending on how the client encrypts messages. This would eliminate cert management from steward concerns and cert acceptance from client code. ( ~kdenhartog  has recently had a conversation about whether plain HTTP with DIDComm is ever a good idea and may want to say something here.)  ></body> </Action>
