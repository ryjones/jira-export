<Action id="63929" issue="42433" author="swetharepakula" type="comment" created="2019-09-20 18:53:31.0" updateauthor="swetharepakula" updated="2019-09-20 19:01:55.0"> <body><! CDATA I outlined what I understood of the implementation from the patches:    https://gerrit.hyperledger.org/r/#/c/fabric-chaincode-evm/+/33599/     https://gerrit.hyperledger.org/r/#/c/fabric-chaincode-evm/+/33600/   t is the transaction being submitted E(tx) is signing & encoding done using an ethereum identity where tx is a transaction, while dE(tx) is decoding of the transaction using the ethereum identity F(tx) is signing done using an fabric identity where x is a transaction, while dF(tx) is the decoding of the transaction using the fabric identity  A user will submit E(t) to fab3 using eth_sendRawTransaction, fab3 then will decode the transaction dE(E(t)) to get the original t. Then it will submit the original t to the fabric network F(t) with the exception that the from address is now whatever is provided in t, which is different from the signing identity associated with fab3  I have some concerns with this approach: * The implementation does not remove the trust placed in fab3 to hold a signing identity, which I understood as one of the reasons for eth_sendRawTransaction. And in terms of the Fabric network all transactions placed will be traced to the identity associated with fab3. * The from address no longer corresponds to a particular identity in the Fabric system, which means for someone who is looking at the Fabric network without the evm lens, would not be able to distinguish the people who are submitting transactions. Since addresses are data only within the evmcc, the argument can be made whatever is done in the chaincode is up to the chaincode designer. However I feel that though we used a chaincode to implement evm support, we should try to design it so that the EVM smart contracts are almost the same as other chaincodes. * On the evmcc side, the chaincode will accept whatever is submitted as the from address without any validation, which means for those who are submitting transactions outside of fab3 have the ability to spoof addresses as there is no check on the address  ></body> </Action>
<Action id="63950" issue="42433" author="conanoc" type="comment" created="2019-09-23 01:45:29.0" updateauthor="conanoc" updated="2019-09-23 01:45:29.0"> <body><! CDATA ??The implementation does not remove the trust placed in fab3 to hold a signing identity, which I understood as one of the reasons for eth_sendRawTransaction.??  eth_sendRawTransaction removes the trust placed in the Dapps which are connected to the fab3. But I agree that fab3 also is better to be removed from the trust. We could do that by doing dE(tx) in evmcc not in fab3.  ??The from address no longer corresponds to a particular identity in the Fabric system, which means for someone who is looking at the Fabric network without the evm lens, would not be able to distinguish the people who are submitting transactions.??  I think fabric-chaincode-evm can be viewed as two different systems. One is the subsystem which enables fabric users can develop chaincode using solidity. The other is the enterprise ethereum built on fabric. eth_sendRawTransaction is essential if it's the ethereum system. eth_sendRawTransaction will do no harm if it's fabric with solidity because it's up to the solidity developers to decide which tools they use and they will control what to use for the "from address".  ??On the evmcc side, the chaincode will accept whatever is submitted as the from address without any validation, which means for those who are submitting transactions outside of fab3 have the ability to spoof addresses as there is no check on the address??  Right. As I mentioned above, we'd better do dE(tx) in evmcc not in fab3.  ></body> </Action>
<Action id="63962" issue="42433" author="conanoc" type="comment" body="dE(tx) is moved to evmcc with this patch:  https://gerrit.hyperledger.org/r/c/fabric-chaincode-evm/+/33660 " created="2019-09-23 09:55:57.0" updateauthor="conanoc" updated="2019-09-23 09:55:57.0"/>
<Action id="63977" issue="42433" author="swetharepakula" type="comment" created="2019-09-23 18:01:45.0" updateauthor="swetharepakula" updated="2019-09-23 21:28:13.0"> <body><! CDATA  ~conanoc  Would you be willing to resubmit your patch as a Github PR? We are in the middle of moving from gerrit to Github. You will have to wait until we make the change, which we are hoping to do in the next couple days and you can submit a PR which will allow you to submit a branch with both commits than each commit separately.  In regards to the discussion: * _"eth_sendRawTransaction removes the trust placed in the Dapps which are connected to the fab3. But I agree that fab3 also is better to be removed from the trust. We could do that by doing dE(tx) in evmcc not in fab3."_ ** Moving dE(tx) does not remove the trust required for fab3. Fab3 is still signing the transaction, which means that the Fab3 identity is still required. At that point you are still placing trust in Fab3 to handle the signing identity.  ** In terms of implementation, we should find a way not to introduce Fab3 into the evmcc. We want the imports to go one direction. I will leave a note on the patch as well about this. * _"I think fabric-chaincode-evm can be viewed as two different systems. One is the subsystem which enables fabric users can develop chaincode using solidity. The other is the enterprise ethereum built on fabric. eth_sendRawTransaction is essential if it's the ethereum system. eth_sendRawTransaction will do no harm if it's fabric with solidity because it's up to the solidity developers to decide which tools they use and they will control what to use for the "from address"."_ ** I think both approaches are different and should be kept different. I don't think a user should be able to have accounts that are ethereum based and then have accounts that are fabric based. That isn't consistent. I think it needs to be an either/or situation. One option here is offering that choice to whomever is deploying and making a decision at the initialization. If we do go through that approach, we also need to think about how fab3 needs to be changed to deal with that change. Most of the apis assume a certain tx structure which would change with raw tx. We would need a different way to deal with regular transactions and we would need to be able to attach an ethereum identity to fab3. Even with the two versions however, there needs to be discussion of what the fab3 identity should be, as that is still necessary to communicate with the network. ** I also am still trying to understand the value of having an ethereum identity that is not connected to fabric. I have seen people wanting to be able to use wallets, but I see that more as an argument to have a MSP that supports ethereum certs. What is the use case you are trying to address with this change? ** One of the initial things discussed on rocket chat about this was about eliminating the trust between dApp and Fab3, but that can be done without introducing a new identity, just by using encryption and generating the from address from the signing identity. We can support raw transactions in two ways without introducing a new account design *** Fab3 is used to build the tx that the dapp can inspect and then it will sign that tx and pass it to fab3 which will pass it back to the evmcc. In this method there is only one type of system and all transactions will look the same. *** The other option is having the encryption that the dapp encrypts the transaction and fab3 will have to sign it and then pass it to the evmcc which decrypts it but still uses the fab3 signing identity as the submitter. There would need to be a sort of format here though to ensure that the transactions again structured in the same way. *** The second option still places trust on those submitting transactions through fab3 as the fab3 signing identity is the one used. So I would think fab3 still needs to be local relative to the application.  ></body> </Action>
<Action id="64005" issue="42433" author="mhbauer" type="comment" body=" ~swetharepakula  fyi, eip-155 is what I meant when we previously discussed network id being used in a calculation. https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md ChainID is not the same thing as network ID, but it is often the same value." created="2019-09-24 01:44:21.0" updateauthor="mhbauer" updated="2019-09-24 01:44:21.0"/>
<Action id="64006" issue="42433" author="mhbauer" type="comment" created="2019-09-24 02:03:58.0" updateauthor="mhbauer" updated="2019-09-24 02:03:58.0"> <body><! CDATA My limited understanding of whats going on here doesn't seem to include handling signing anything with the fabric creds.  The implementation here takes a substantially different form from all other functions. As implemented here this looks more like a representation of a totally alternate fork of fab3/evmcc.  There should be an external tool using fabric credentials to create a signed transaction to submit for passthrough directly to evmcc. As far as I can tell, evmcc itself should not have to change at all to handle any of this functionality.  We should be unifying the credential support, not splitting it up into separate worlds.  ></body> </Action>
<Action id="64007" issue="42433" author="conanoc" type="comment" created="2019-09-24 02:44:43.0" updateauthor="conanoc" updated="2019-09-24 02:44:43.0"> <body><! CDATA  ~swetharepakula  Okay. I will resubmit my patches as a github PR. And I think I have a rough idea of the way you think. I think you are assuming the dapp and the fab3 are in one-to-one relation. I assumed that they are one-to-many relation as many ethereum wallets use one ethereum node.  Let's think of a service which provide a simple ERC20 token for any purpose. Users of the service may use ethereum wallets like metamask or some other mobile apps which works as wallets. I am calling the wallets and mobile apps as dapps. I may have misused the term. They may have been called just wallets and we may call the ERC20 contract as the dapp. Here, the wallets connects to fab3. They have their own accounts and send signed transaction to the fab3. Users send their tokens to others and they manage their own accounts. Mobile apps which implement a game in which tokens are used as game items can be called a kind of wallets.   ~swetharepakula ,  ~MHBauer  If we assume one-to-one relation and a fab3 serves only one account, I agree that eth_sendRawTransaction is not necessary and I think E(tx) is not necessary either. But, this would restrict the utility of fabric-chaincode-evm.  ></body> </Action>
<Action id="64076" issue="42433" author="swetharepakula" type="comment" created="2019-09-24 16:29:46.0" updateauthor="swetharepakula" updated="2019-09-25 00:42:35.0"> <body><! CDATA fab3 was designed with a one-to-one relation and fab3 is not a node. Since it is not a node, I don't see why people would share a proxy. Only the peers in the networks are nodes, fab3 is just a proxy to help dapps uses web3.js & other ethereum libraries to communicate with the fabric network. It also acts as the wallet as it needs to have an identity associated submit transactions.  Can you expand on why having to run a fab3 per app/per user would restrict the utility? Typically people will have to run both their wallet/metamask as well as their dapp and then connect to an existing node. In this case fab3 acts as the wallet as well as the web3 provider.  To make fab3 one to many, it needs to not have any identity associated with it which means then E(tx) is not enough as fab3 still has F(t) connected. As long as an identity is needed for fab3 it can not be shared amongst users. I think once we can support signing fabric transactions separately (currently not implemented in the go sdk), then we would be able to remove the identity from fab3. I am familiar with the one-to-many relation that wallets have with an ethereum node, but in this case I consider fab3 the wallets and the peer the node. So in Fabric its many fab3 to a single Fabric node.  ></body> </Action>
<Action id="64088" issue="42433" author="swetharepakula" type="comment" body=" ~conanoc  You can resubmit your pull requests" created="2019-09-24 17:33:35.0" updateauthor="swetharepakula" updated="2019-09-24 17:33:35.0"/>
<Action id="64106" issue="42433" author="conanoc" type="comment" created="2019-09-25 01:54:31.0" updateauthor="conanoc" updated="2019-09-25 01:54:31.0"> <body><! CDATA ??Can you expand on why having to run a fab3 per app/per user would restrict the utility? Typically people will have to run both their wallet/metamask as well as their dapp and then connect to an existing node. In this case fab3 acts as the wallet as well as the web3 provider.??  People usually have their own wallets but they do not have their own node to connect. I mentioned an example dapp called ERC20 token above. Token owners only have their metamask wallets installed on their browser and do not have their own ethereum nodes. Voting can be another example. In one-to-one case, voters need their own fab3 client. If they want to vote with their mobile phone, they have to run their fab3 on some computers which can connect to fabric nodes.  ??To make fab3 one to many, it needs to not have any identity associated with it which means then E(tx) is not enough as fab3 still has F(t) connected.??  I'm not sure what you mean. Is there any problem if fab3 has its own fabric account while it serves many ethereum accounts which have no relation with the fabric account? In case of Ethereum, a node is a wallet itself which has it's own account but it also acts as a proxy which serves other anonymous wallet's JSPN-RPC requests.     ></body> </Action>
<Action id="64108" issue="42433" author="swetharepakula" type="comment" created="2019-09-25 04:51:22.0" updateauthor="swetharepakula" updated="2019-09-25 04:51:22.0"> <body><! CDATA I think one big difference here is that fab3 is not a node. It uses the fabric go sdk and essentially is a fabric wallet. We do not have an equivalent tool of metamask in Fabric. I understand the use case of the phone you mention above, however I still think we need to wait until the fabric go sdk supports signing fabric transactions offline. Once that happens we would have to come up with a similar workflow as metamask, but it would be a fabric wallet connected to a fabric identity which removes the need for an identity in fab3.  In Fabric, identity is not anonymous. Each fabric identity is tied to a specific person that is known in the network, which is different from how identity is treated in Ethereum. There is no way for Fab3 to act purely as a proxy, because of the lack of ability to do offline signing in the go sdk. So fab3 has to sign the transaction and in the Fabric ledger, it will be noted as the identity associated with the fab3 instance is the submitter of the transaction. The ethereum identity if used would just be in the payload of the transaction. If you consider the EVM purely as an application on Fabric then the argument can be made that it is okay that from the Fabric side it seems like all transactions are coming from one person if that is what the chaincode deployer/user wants to do. But I don't view the EVM as an application, but another runtime that should be following Fabric rules of identity and consensus.  This discussion has given me an idea of creating something like a metamask equivalent for a Fabric identity that would be able to be used as an injected web3 provider that connects to a fab3 instance. I have to investigate more what this would look like. But if we are able to build that, we are still limited in fab3 because there is no offline signing allowed in the go sdk. The actual offline signing part is not a difficult problem to solve. The issue is how to use the go sdk to submit a transaction that has been signed outside as that logic is not exposed to the user as of yet. I have a few thoughts on what we could possibly do but would need to think more about a possible design.  ></body> </Action>
<Action id="64109" issue="42433" author="conanoc" type="comment" created="2019-09-25 05:45:54.0" updateauthor="conanoc" updated="2019-09-25 05:45:54.0"> <body><! CDATA ??But I don't view the EVM as an application, but another runtime that should be following Fabric rules of identity and consensus.??  Yeah. I think this was the key difference btw us. It's a problem of a policy not of a technical issue. And I wonder why you think it's a better view. If you view the EVM as an application, more existing dapps of ethereum could run on this EVM. Existing ethereum wallets also could be used. Fabric is providing the foundation for this blockchain to run in a permissioned environment. I can see no downside with this view and this seems to be quite close to the enterprise ethereum system which EEA is looking for.     ></body> </Action>
<Action id="64110" issue="42433" author="swetharepakula" type="comment" created="2019-09-25 07:25:12.0" updateauthor="swetharepakula" updated="2019-09-25 07:25:12.0"> <body><! CDATA I think the design choices that have been made in the past make EVM a runtime and not an application. We chose to have accounts associated with Fabric identities and not to create a token as part of this work. If we want to approach the EVM as an application, the entire code base would need to be rewritten as I explained above that the current implementation of sendRawTransaction introduces two systems of identity and accounts that make using the EVM confusing. Fab3 APIs need to be rewritten to understand the new kind of transactions. Any type of querying such as transaction receipts, getting blocks or logs would not work as is with this implementation of rawTransaction because it creates a new system that does not work with what has already been built. I do think this is a technical issue, because rawTransaction means applications that use it can only send those kind of transactions and have no ability to query information about current state. This can be fixed, but it is essentially a rewrite of most of the codebase.  ~MHBauer  makes a similar statement in his comment above. I also think this implementation of sendRawTransaction takes away the ability for us to add functionality when offline signing is enabled in the fabric-sdk-go.  I agree that making fab3 purely a proxy is a good idea and that implementing eth_sendRawTransaction to allow a users to manage and sign transactions how they fit makes sense. However I think it needs to adopt Fabric principles of identity because that is one of the features of Fabric. From your implementation I am still confused at how people are expected to handle both fabric identity and the ethereum identity. If both are needed it needs to be clear what role each identity plays. From a Fabric perspective, identity is plays a critical role in permissioning and I believe that if people choose Fabric then they are picking that permissioning model. If we use ethereum identities, there is no way to trace who that identity belongs to on chain. This pseudo-anonymity is okay in an ethereum based system because I think that is one of the features of those blockchains, but since it is deliberately not a feature of Fabric I don't think we should be designing the EVM to follow that pattern.   Now if using the ethereum identity is the blocker, I think the right approach is to implementing a new MSP which supports ethereum certificate algorithms. Then you would be able to use metamask with certs that are be registered in the Fabric system. In this situation we would still have to wait for offline signing support on the fabric-go-sdk to make fab3 identity free.  One question I have is why does the approach of having a fabric version of metamask and then using fab3 purely as a proxy not solve the problem you highlight in your use case? I think it is a reasonable ask that if you move to Fabric you are expected to use a fabric identity.  ></body> </Action>
<Action id="64114" issue="42433" author="conanoc" type="comment" created="2019-09-25 09:05:56.0" updateauthor="conanoc" updated="2019-09-25 09:05:56.0"> <body><! CDATA I'd like to explain my view in more detail.  we don't have to mix the identities of the two different systems. Fabric identities will be used as before to identify who can run clients like fab3, who can run peers, who can run orderers. Companies who participate in this permissioned EVM will be controlled with these fabric identities. I mean the fabric identity is for managing the participants who run the nodes not for managing the end users of the service on top of it. Here, EVM accounts don't have to have any relation with the fabric identities. End users can view this EVM, fabric-chaincode-evm, as another ethereum fork run on different port number. They can use the same wallets and same apps with changed port number. EVM accounts are created on behalf of the end users purpose. Users may create accounts to receive tokens or to receive game items or to sign up for a service.  And this view works as is. We don't have to rewrite the code. I could deploy, in fabric-chaincode-evm with my patch, an ERC20 contract with the account created in my metamask wallet and could send the token to another account. We can host existing ethereum dapps with very little change on this permissioned system controlled by fabric identities. Is there any drawbacks then your view?   ></body> </Action>
<Action id="64137" issue="42433" author="mhbauer" type="comment" created="2019-09-25 21:00:55.0" updateauthor="mhbauer" updated="2019-09-25 21:00:55.0"> <body><! CDATA I think we need to agree on the design before we can start coding.  1) I've attempted some diagrams on the wiki  https://wiki.hyperledger.org/display/fabric/Raw+Transaction+Design   To fully abstract this requires two things, go-sdk to support privately signed transactions, and a similar lightweight interposer similar in functionality to metamask, that performs fabric-signing on reciept of a normal send-transaction.  The design as proposed would allow local credentials and an less permissioned fab3 to exist on the remote server-side of a network.     2) There's an underlying duality for this particular implementation that I do not think is reasonable at this time.  For fabric to support ethereum identities (pub+priv keys) would require ethereum to do the same and support fabric identities (pub+priv keys). I don't think ethereum ever intends for this to be the case, but I am not up to date on pluggable encryption support in that domain. Contrarywise, fabric could in-theory support this case, by implementing an MSP that support ethereum identities. This would still tie back to some fabric identity that requires support in the go-sdk of offline signing. Alternatively to that would be to use the node-sdk to sign input formatted as required by the evmcc.     3)  > I could deploy, in fabric-chaincode-evm with my patch, an ERC20 contract with the account created in my metamask wallet and could send the token to another account. We can host existing ethereum dapps with very little change on this permissioned system controlled by fabric identities. Is there any drawbacks then your view?   Do these round-trip successfully? From this discussion, I would not expect GetTransactionByHash to work, along with many of the other functions. That is the technical issue. That would require to adjust some code that I would not think would need adjustment otherwise. I would need to see an integration test that demonstrates that we get valid values out after a raw transaction, and not only that the submission of a raw transaction works in isolation from everything else.           ></body> </Action>
<Action id="64140" issue="42433" author="conanoc" type="comment" created="2019-09-26 02:06:25.0" updateauthor="conanoc" updated="2019-09-26 02:06:25.0"> <body><! CDATA ??Do these round-trip successfully? From this discussion, I would not expect GetTransactionByHash to work, along with many of the other functions. That is the technical issue. That would require to adjust some code that I would not think would need adjustment otherwise. I would need to see an integration test that demonstrates that we get valid values out after a raw transaction, and not only that the submission of a raw transaction works in isolation from everything else.??  Yes. It does. As you mentioned, we need to modify GetTrasactionByHash and I  did it| https://gerrit.hyperledger.org/r/gitweb?p=fabric-chaincode-evm.git;a=blob;f=fab3/ethservice.go;h=bf0726999ccb6e43ba4929f97b41aa52de0f5a79;hb=462ad9debb99b6cf4a5db95969a19895df07064c#l702   already. I'll resubmit the patch, with some bug fix, to github soon for your test. You will be able to deploy any contracts with remix+metamask to fabric-evm without any console works described in  https://github.com/hyperledger/fabric-chaincode-evm/blob/master/examples/EVM_Smart_Contracts.md#deploying-a-smart-contract      I have a question in your design document. In (d), it requires "The transaction must be fabric-signed before reaching fab3". Why is that? The transaction is an ethereum transaction, and it's already eth-signed which will be guaranteed not to be changed until it's passed to evmcc.     I'm struggling to find a way to explain this. Fabric is providing a platform for companies to build any application on this permissioned blockchain system. EVM is one of the applications. Fabric don't have to be changed to support EVM and fabric don't have to even think about the existence of the EVM. EVM as an application will implement several functions, to support Dapps, such as Ethereum JSON-RPC, signing, vm execution. These are all you've implemented in fabric-chaincode-evm. And I'm just adding a function to Ethereum JSON-RPC. Why fabric application developers are worrying about the fabric identities? We just need one fabric user to run one fab3 instance. If we'd like to dedicate each eth-dapp-services to it's own fab3 nodes, we could create more fabric accounts for fab3. EVM accounts have nothing to do with these fabric accounts. Does this make sense?  ></body> </Action>
<Action id="64201" issue="42433" author="conanoc" type="comment" created="2019-09-30 09:18:01.0" updateauthor="conanoc" updated="2019-09-30 09:18:01.0"> <body><! CDATA I've read  CA User's Guide| https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html   to understand the fabric identity model more. I didn't know that CA server supports ldap which could be a convenient tool to manage corporate user accounts. It gave me an idea that we could think of two types of service model. B2B service model where the users are employees of the companies and B2C service model where the users are the customers of the companies.  It was B2C service model what I had in my mind and I insisted that fabric-chaincode-evm should support that model. And it seems to be B2B service model what you ( ~swetharepakula  and  ~MHBauer ) had in your minds. Actually, I've thought about the B2B service model as this: A client app is shared among all employees and the app is mapped to a single fabric identity. Employees sign in to the app with their user id and pwd, and do their jobs using the app. The app will authenticate the user account using ldap or any legacy authentication system. This didn't seem to work well with the one eth-account on one fabric-account model. But, I can think of different B2B service model as this: A client app is shared among all employees but the app is not mapped to a single fabric identity. The app requires fabric user certificate instead of id/pwd on sign in. This will work well with the one eth-account on one fabric-account model.  In B2C service model, the one eth-account on one fabric-account model can not be applied. We will not be able to create a fabric account when a game user signs up with their facebook account. A clone of cryptokitties could not run on this one-to-one model.  Considering the two types of service model, we could introduce an option in the evmcc to allow raw transaction and then specify the option when instantiating the evmcc in the channel. What do you think?  ></body> </Action>
<Action id="64509" issue="42433" author="swetharepakula" type="comment" created="2019-10-09 18:35:52.0" updateauthor="swetharepakula" updated="2019-10-09 18:35:52.0"> <body><! CDATA  ~conanoc  I think it is reasonable to expect that if a user wants to interact with a Fabric network they will need to create a fabric account. Fabric is not intended to be a public network that anyone can access. One must be invited into the network and currently the organizations' MSPs control that. With how identity is managed, everyone on the network will be known regardless of the organization they come from. Regardless of a B2B model or a B2C model, the users interacting with the network should be known and should be tied to a Fabric Identity.  I want to reiterate that I do agree that implementing raw transactions will open the door to more applications. However I disagree that its support should be using Ethereum identities. Essentially, I believe regardless of how a transaction is submitted "sendTransaction" versus "sendRawTransaction" they need to be treated the same in the evmcc. And the current pull request introduces that issue. The other concern I have is that with this approach, fab3 can never become identity less as it will always need a write enabled Fabric identity to submit transactions to the evmcc.   This leads me to ask what is the goal/outcome we are looking to gain? Is it to adopt ethereum identities or is it to make fab3 identity less? I believe the latter is what we should be focused on and I think adopting ethereum identities makes the latter not possible. If we continue with Fabric identities, then I believe there is a possibility to make fab3 identity less.  If adopting ethereum identities is the goal, then I think fab3 stays a one to one relationship with the user (because of the required write access), but once inside the evmcc the account is tied to the ethereum public cert. But with this approach a larger refactor is necessary so that all transactions follow this format, not just sendRawTransaction. I don't think this is a wrong approach but this is not the path/design we went with.  ></body> </Action>
